
# AUTO-GENERATED file from IFMapApiGenerator. Do Not Edit!

import copy
import vnc_api.gen.resource_common
import vnc_api.gen.resource_xsd
try:
    from cfgm_common.exceptions import NoIdError
except ImportError:
    from vnc_api.exceptions import NoIdError


class ServiceEndpoint(vnc_api.gen.resource_common.ServiceEndpoint):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, *args, **kwargs):
        pending_fields = ['fq_name']

        self._server_conn = None

        if len(args) > 0 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 1 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 2 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 3 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(ServiceEndpoint, self).__init__(name, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = ServiceEndpoint(**props_dict)
        else:
            obj = ServiceEndpoint(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.service_connection_module_refs = kwargs[u'service_connection_module_refs']
        except KeyError:
            pass
        try:
            obj.physical_router_refs = kwargs[u'physical_router_refs']
        except KeyError:
            pass
        try:
            obj.service_object_refs = kwargs[u'service_object_refs']
        except KeyError:
            pass
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.virtual_machine_interface_back_refs = kwargs[u'virtual_machine_interface_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.ServiceEndpoint.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.ServiceEndpoint.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for service-endpoint.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.ServiceEndpoint.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for service-endpoint.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.ServiceEndpoint.annotations.setter
    def annotations(self, annotations):
        """Set annotations for service-endpoint.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.ServiceEndpoint.display_name.setter
    def display_name(self, display_name):
        """Set display-name for service-endpoint.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for service-endpoint.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for service-endpoint.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_service_connection_module(self, *args, **kwargs):
        """Set service-connection-module for service-endpoint.
        
        :param ref_obj: ServiceConnectionModule object
        
        """
        self._pending_field_updates.add('service_connection_module_refs')
        self._pending_ref_updates.discard('service_connection_module_refs')
        super(ServiceEndpoint, self).set_service_connection_module(*args, **kwargs)

    # end set_service_connection_module

    def add_service_connection_module(self, *args, **kwargs):
        """Add service-connection-module to service-endpoint.
        
        :param ref_obj: ServiceConnectionModule object
        
        """
        if 'service_connection_module_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('service_connection_module_refs')
            self._original_service_connection_module_refs = copy.deepcopy(self.get_service_connection_module_refs() or [])
        super(ServiceEndpoint, self).add_service_connection_module(*args, **kwargs)
    # end add_service_connection_module

    def del_service_connection_module(self, *args, **kwargs):
        if 'service_connection_module_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('service_connection_module_refs')
            self._original_service_connection_module_refs = copy.deepcopy(self.get_service_connection_module_refs() or [])
        super(ServiceEndpoint, self).del_service_connection_module(*args, **kwargs)
    # end del_service_connection_module

    def set_service_connection_module_list(self, *args, **kwargs):
        """Set service-connection-module list for service-endpoint.
        
        :param ref_obj_list: list of ServiceConnectionModule object
        
        """
        self._pending_field_updates.add('service_connection_module_refs')
        self._pending_ref_updates.discard('service_connection_module_refs')
        super(ServiceEndpoint, self).set_service_connection_module_list(*args, **kwargs)
    # end set_service_connection_module_list

    def set_physical_router(self, *args, **kwargs):
        """Set physical-router for service-endpoint.
        
        :param ref_obj: PhysicalRouter object
        
        """
        self._pending_field_updates.add('physical_router_refs')
        self._pending_ref_updates.discard('physical_router_refs')
        super(ServiceEndpoint, self).set_physical_router(*args, **kwargs)

    # end set_physical_router

    def add_physical_router(self, *args, **kwargs):
        """Add physical-router to service-endpoint.
        
        :param ref_obj: PhysicalRouter object
        
        """
        if 'physical_router_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('physical_router_refs')
            self._original_physical_router_refs = copy.deepcopy(self.get_physical_router_refs() or [])
        super(ServiceEndpoint, self).add_physical_router(*args, **kwargs)
    # end add_physical_router

    def del_physical_router(self, *args, **kwargs):
        if 'physical_router_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('physical_router_refs')
            self._original_physical_router_refs = copy.deepcopy(self.get_physical_router_refs() or [])
        super(ServiceEndpoint, self).del_physical_router(*args, **kwargs)
    # end del_physical_router

    def set_physical_router_list(self, *args, **kwargs):
        """Set physical-router list for service-endpoint.
        
        :param ref_obj_list: list of PhysicalRouter object
        
        """
        self._pending_field_updates.add('physical_router_refs')
        self._pending_ref_updates.discard('physical_router_refs')
        super(ServiceEndpoint, self).set_physical_router_list(*args, **kwargs)
    # end set_physical_router_list

    def set_service_object(self, *args, **kwargs):
        """Set service-object for service-endpoint.
        
        :param ref_obj: ServiceObject object
        
        """
        self._pending_field_updates.add('service_object_refs')
        self._pending_ref_updates.discard('service_object_refs')
        super(ServiceEndpoint, self).set_service_object(*args, **kwargs)

    # end set_service_object

    def add_service_object(self, *args, **kwargs):
        """Add service-object to service-endpoint.
        
        :param ref_obj: ServiceObject object
        
        """
        if 'service_object_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('service_object_refs')
            self._original_service_object_refs = copy.deepcopy(self.get_service_object_refs() or [])
        super(ServiceEndpoint, self).add_service_object(*args, **kwargs)
    # end add_service_object

    def del_service_object(self, *args, **kwargs):
        if 'service_object_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('service_object_refs')
            self._original_service_object_refs = copy.deepcopy(self.get_service_object_refs() or [])
        super(ServiceEndpoint, self).del_service_object(*args, **kwargs)
    # end del_service_object

    def set_service_object_list(self, *args, **kwargs):
        """Set service-object list for service-endpoint.
        
        :param ref_obj_list: list of ServiceObject object
        
        """
        self._pending_field_updates.add('service_object_refs')
        self._pending_ref_updates.discard('service_object_refs')
        super(ServiceEndpoint, self).set_service_object_list(*args, **kwargs)
    # end set_service_object_list

    def set_tag(self, *args, **kwargs):
        """Set tag for service-endpoint.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(ServiceEndpoint, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to service-endpoint.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(ServiceEndpoint, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(ServiceEndpoint, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for service-endpoint.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(ServiceEndpoint, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


    def get_virtual_machine_interface_back_refs(self):
        """Return list of all virtual-machine-interfaces using this service-endpoint"""
        if hasattr(self, 'virtual_machine_interface_back_refs'):
            return self.virtual_machine_interface_back_refs

        if hasattr(super(ServiceEndpoint, self), 'virtual_machine_interface_back_refs'):
            return super(ServiceEndpoint, self).get_virtual_machine_interface_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.service_endpoint_read(id = self.uuid, fields = ['virtual_machine_interface_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'virtual_machine_interface_back_refs', None)
        if not back_refs:
            return None
        self.virtual_machine_interface_back_refs = back_refs

        return back_refs
    # end get_virtual_machine_interface_back_refs

# end class ServiceEndpoint

class InstanceIp(vnc_api.gen.resource_common.InstanceIp):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, *args, **kwargs):
        pending_fields = ['fq_name']

        self._server_conn = None

        if len(args) > 0 or 'instance_ip_address' in kwargs:
            pending_fields.append('instance_ip_address')
        if len(args) > 1 or 'instance_ip_family' in kwargs:
            pending_fields.append('instance_ip_family')
        if len(args) > 2 or 'instance_ip_mode' in kwargs:
            pending_fields.append('instance_ip_mode')
        if len(args) > 3 or 'secondary_ip_tracking_ip' in kwargs:
            pending_fields.append('secondary_ip_tracking_ip')
        if len(args) > 4 or 'subnet_uuid' in kwargs:
            pending_fields.append('subnet_uuid')
        if len(args) > 5 or 'instance_ip_subscriber_tag' in kwargs:
            pending_fields.append('instance_ip_subscriber_tag')
        if len(args) > 6 or 'instance_ip_secondary' in kwargs:
            pending_fields.append('instance_ip_secondary')
        if len(args) > 7 or 'instance_ip_local_ip' in kwargs:
            pending_fields.append('instance_ip_local_ip')
        if len(args) > 8 or 'service_instance_ip' in kwargs:
            pending_fields.append('service_instance_ip')
        if len(args) > 9 or 'service_health_check_ip' in kwargs:
            pending_fields.append('service_health_check_ip')
        if len(args) > 10 or 'instance_ip_subnet' in kwargs:
            pending_fields.append('instance_ip_subnet')
        if len(args) > 11 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 12 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 13 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 14 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(InstanceIp, self).__init__(name, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            props_dict['instance_ip_address'] = kwargs[u'instance_ip_address']
        except KeyError:
            pass

        try:
            props_dict['instance_ip_family'] = kwargs[u'instance_ip_family']
        except KeyError:
            pass

        try:
            props_dict['instance_ip_mode'] = kwargs[u'instance_ip_mode']
        except KeyError:
            pass

        try:
            if kwargs['secondary_ip_tracking_ip'] is None:
                props_dict['secondary_ip_tracking_ip'] = None
            else:
                props_dict['secondary_ip_tracking_ip'] = vnc_api.gen.resource_xsd.SubnetType(params_dict=kwargs[u'secondary_ip_tracking_ip'])
        except KeyError:
            pass

        try:
            props_dict['subnet_uuid'] = kwargs[u'subnet_uuid']
        except KeyError:
            pass

        try:
            props_dict['instance_ip_subscriber_tag'] = kwargs[u'instance_ip_subscriber_tag']
        except KeyError:
            pass

        try:
            props_dict['instance_ip_secondary'] = kwargs[u'instance_ip_secondary']
        except KeyError:
            pass

        try:
            props_dict['instance_ip_local_ip'] = kwargs[u'instance_ip_local_ip']
        except KeyError:
            pass

        try:
            props_dict['service_instance_ip'] = kwargs[u'service_instance_ip']
        except KeyError:
            pass

        try:
            props_dict['service_health_check_ip'] = kwargs[u'service_health_check_ip']
        except KeyError:
            pass

        try:
            if kwargs['instance_ip_subnet'] is None:
                props_dict['instance_ip_subnet'] = None
            else:
                props_dict['instance_ip_subnet'] = vnc_api.gen.resource_xsd.SubnetType(params_dict=kwargs[u'instance_ip_subnet'])
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = InstanceIp(**props_dict)
        else:
            obj = InstanceIp(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...
        try:
            obj.floating_ips = kwargs[u'floating_ips']
        except KeyError:
            pass

        # add any specified references...
        try:
            obj.virtual_network_refs = kwargs[u'virtual_network_refs']
        except KeyError:
            pass
        try:
            obj.network_ipam_refs = kwargs[u'network_ipam_refs']
        except KeyError:
            pass
        try:
            obj.virtual_machine_interface_refs = kwargs[u'virtual_machine_interface_refs']
        except KeyError:
            pass
        try:
            obj.physical_router_refs = kwargs[u'physical_router_refs']
        except KeyError:
            pass
        try:
            obj.virtual_router_refs = kwargs[u'virtual_router_refs']
        except KeyError:
            pass
        try:
            obj.logical_interface_refs = kwargs[u'logical_interface_refs']
        except KeyError:
            pass
        try:
            obj.flow_node_refs = kwargs[u'flow_node_refs']
        except KeyError:
            pass
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.service_instance_back_refs = kwargs[u'service_instance_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.InstanceIp.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.InstanceIp.instance_ip_address.setter
    def instance_ip_address(self, instance_ip_address):
        """Set instance-ip-address for instance-ip.
        
        :param instance_ip_address: IpAddressType object
        
        """
        if 'instance_ip_address' not in self._pending_field_updates:
            self._pending_field_updates.add('instance_ip_address')

        self._instance_ip_address = instance_ip_address
    # end instance_ip_address

    def set_instance_ip_address(self, value):
        self.instance_ip_address = value
    # end set_instance_ip_address

    @vnc_api.gen.resource_common.InstanceIp.instance_ip_family.setter
    def instance_ip_family(self, instance_ip_family):
        """Set instance-ip-family for instance-ip.
        
        :param instance_ip_family: IpAddressFamilyType object
        
        """
        if 'instance_ip_family' not in self._pending_field_updates:
            self._pending_field_updates.add('instance_ip_family')

        self._instance_ip_family = instance_ip_family
    # end instance_ip_family

    def set_instance_ip_family(self, value):
        self.instance_ip_family = value
    # end set_instance_ip_family

    @vnc_api.gen.resource_common.InstanceIp.instance_ip_mode.setter
    def instance_ip_mode(self, instance_ip_mode):
        """Set instance-ip-mode for instance-ip.
        
        :param instance_ip_mode: AddressMode object
        
        """
        if 'instance_ip_mode' not in self._pending_field_updates:
            self._pending_field_updates.add('instance_ip_mode')

        self._instance_ip_mode = instance_ip_mode
    # end instance_ip_mode

    def set_instance_ip_mode(self, value):
        self.instance_ip_mode = value
    # end set_instance_ip_mode

    @vnc_api.gen.resource_common.InstanceIp.secondary_ip_tracking_ip.setter
    def secondary_ip_tracking_ip(self, secondary_ip_tracking_ip):
        """Set secondary-ip-tracking-ip for instance-ip.
        
        :param secondary_ip_tracking_ip: SubnetType object
        
        """
        if 'secondary_ip_tracking_ip' not in self._pending_field_updates:
            self._pending_field_updates.add('secondary_ip_tracking_ip')

        self._secondary_ip_tracking_ip = secondary_ip_tracking_ip
    # end secondary_ip_tracking_ip

    def set_secondary_ip_tracking_ip(self, value):
        self.secondary_ip_tracking_ip = value
    # end set_secondary_ip_tracking_ip

    @vnc_api.gen.resource_common.InstanceIp.subnet_uuid.setter
    def subnet_uuid(self, subnet_uuid):
        """Set subnet-uuid for instance-ip.
        
        :param subnet_uuid: xsd:string object
        
        """
        if 'subnet_uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('subnet_uuid')

        self._subnet_uuid = subnet_uuid
    # end subnet_uuid

    def set_subnet_uuid(self, value):
        self.subnet_uuid = value
    # end set_subnet_uuid

    @vnc_api.gen.resource_common.InstanceIp.instance_ip_subscriber_tag.setter
    def instance_ip_subscriber_tag(self, instance_ip_subscriber_tag):
        """Set instance-ip-subscriber-tag for instance-ip.
        
        :param instance_ip_subscriber_tag: xsd:string object
        
        """
        if 'instance_ip_subscriber_tag' not in self._pending_field_updates:
            self._pending_field_updates.add('instance_ip_subscriber_tag')

        self._instance_ip_subscriber_tag = instance_ip_subscriber_tag
    # end instance_ip_subscriber_tag

    def set_instance_ip_subscriber_tag(self, value):
        self.instance_ip_subscriber_tag = value
    # end set_instance_ip_subscriber_tag

    @vnc_api.gen.resource_common.InstanceIp.instance_ip_secondary.setter
    def instance_ip_secondary(self, instance_ip_secondary):
        """Set instance-ip-secondary for instance-ip.
        
        :param instance_ip_secondary: xsd:boolean object
        
        """
        if 'instance_ip_secondary' not in self._pending_field_updates:
            self._pending_field_updates.add('instance_ip_secondary')

        self._instance_ip_secondary = instance_ip_secondary
    # end instance_ip_secondary

    def set_instance_ip_secondary(self, value):
        self.instance_ip_secondary = value
    # end set_instance_ip_secondary

    @vnc_api.gen.resource_common.InstanceIp.instance_ip_local_ip.setter
    def instance_ip_local_ip(self, instance_ip_local_ip):
        """Set instance-ip-local-ip for instance-ip.
        
        :param instance_ip_local_ip: xsd:boolean object
        
        """
        if 'instance_ip_local_ip' not in self._pending_field_updates:
            self._pending_field_updates.add('instance_ip_local_ip')

        self._instance_ip_local_ip = instance_ip_local_ip
    # end instance_ip_local_ip

    def set_instance_ip_local_ip(self, value):
        self.instance_ip_local_ip = value
    # end set_instance_ip_local_ip

    @vnc_api.gen.resource_common.InstanceIp.service_instance_ip.setter
    def service_instance_ip(self, service_instance_ip):
        """Set service-instance-ip for instance-ip.
        
        :param service_instance_ip: xsd:boolean object
        
        """
        if 'service_instance_ip' not in self._pending_field_updates:
            self._pending_field_updates.add('service_instance_ip')

        self._service_instance_ip = service_instance_ip
    # end service_instance_ip

    def set_service_instance_ip(self, value):
        self.service_instance_ip = value
    # end set_service_instance_ip

    @vnc_api.gen.resource_common.InstanceIp.service_health_check_ip.setter
    def service_health_check_ip(self, service_health_check_ip):
        """Set service-health-check-ip for instance-ip.
        
        :param service_health_check_ip: xsd:boolean object
        
        """
        if 'service_health_check_ip' not in self._pending_field_updates:
            self._pending_field_updates.add('service_health_check_ip')

        self._service_health_check_ip = service_health_check_ip
    # end service_health_check_ip

    def set_service_health_check_ip(self, value):
        self.service_health_check_ip = value
    # end set_service_health_check_ip

    @vnc_api.gen.resource_common.InstanceIp.instance_ip_subnet.setter
    def instance_ip_subnet(self, instance_ip_subnet):
        """Set instance-ip-subnet for instance-ip.
        
        :param instance_ip_subnet: SubnetType object
        
        """
        if 'instance_ip_subnet' not in self._pending_field_updates:
            self._pending_field_updates.add('instance_ip_subnet')

        self._instance_ip_subnet = instance_ip_subnet
    # end instance_ip_subnet

    def set_instance_ip_subnet(self, value):
        self.instance_ip_subnet = value
    # end set_instance_ip_subnet

    @vnc_api.gen.resource_common.InstanceIp.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for instance-ip.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.InstanceIp.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for instance-ip.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.InstanceIp.annotations.setter
    def annotations(self, annotations):
        """Set annotations for instance-ip.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.InstanceIp.display_name.setter
    def display_name(self, display_name):
        """Set display-name for instance-ip.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for instance-ip.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for instance-ip.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_virtual_network(self, *args, **kwargs):
        """Set virtual-network for instance-ip.
        
        :param ref_obj: VirtualNetwork object
        
        """
        self._pending_field_updates.add('virtual_network_refs')
        self._pending_ref_updates.discard('virtual_network_refs')
        super(InstanceIp, self).set_virtual_network(*args, **kwargs)

    # end set_virtual_network

    def add_virtual_network(self, *args, **kwargs):
        """Add virtual-network to instance-ip.
        
        :param ref_obj: VirtualNetwork object
        
        """
        if 'virtual_network_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('virtual_network_refs')
            self._original_virtual_network_refs = copy.deepcopy(self.get_virtual_network_refs() or [])
        super(InstanceIp, self).add_virtual_network(*args, **kwargs)
    # end add_virtual_network

    def del_virtual_network(self, *args, **kwargs):
        if 'virtual_network_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('virtual_network_refs')
            self._original_virtual_network_refs = copy.deepcopy(self.get_virtual_network_refs() or [])
        super(InstanceIp, self).del_virtual_network(*args, **kwargs)
    # end del_virtual_network

    def set_virtual_network_list(self, *args, **kwargs):
        """Set virtual-network list for instance-ip.
        
        :param ref_obj_list: list of VirtualNetwork object
        
        """
        self._pending_field_updates.add('virtual_network_refs')
        self._pending_ref_updates.discard('virtual_network_refs')
        super(InstanceIp, self).set_virtual_network_list(*args, **kwargs)
    # end set_virtual_network_list

    def set_network_ipam(self, *args, **kwargs):
        """Set network-ipam for instance-ip.
        
        :param ref_obj: NetworkIpam object
        
        """
        self._pending_field_updates.add('network_ipam_refs')
        self._pending_ref_updates.discard('network_ipam_refs')
        super(InstanceIp, self).set_network_ipam(*args, **kwargs)

    # end set_network_ipam

    def add_network_ipam(self, *args, **kwargs):
        """Add network-ipam to instance-ip.
        
        :param ref_obj: NetworkIpam object
        
        """
        if 'network_ipam_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('network_ipam_refs')
            self._original_network_ipam_refs = copy.deepcopy(self.get_network_ipam_refs() or [])
        super(InstanceIp, self).add_network_ipam(*args, **kwargs)
    # end add_network_ipam

    def del_network_ipam(self, *args, **kwargs):
        if 'network_ipam_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('network_ipam_refs')
            self._original_network_ipam_refs = copy.deepcopy(self.get_network_ipam_refs() or [])
        super(InstanceIp, self).del_network_ipam(*args, **kwargs)
    # end del_network_ipam

    def set_network_ipam_list(self, *args, **kwargs):
        """Set network-ipam list for instance-ip.
        
        :param ref_obj_list: list of NetworkIpam object
        
        """
        self._pending_field_updates.add('network_ipam_refs')
        self._pending_ref_updates.discard('network_ipam_refs')
        super(InstanceIp, self).set_network_ipam_list(*args, **kwargs)
    # end set_network_ipam_list

    def set_virtual_machine_interface(self, *args, **kwargs):
        """Set virtual-machine-interface for instance-ip.
        
        :param ref_obj: VirtualMachineInterface object
        
        """
        self._pending_field_updates.add('virtual_machine_interface_refs')
        self._pending_ref_updates.discard('virtual_machine_interface_refs')
        super(InstanceIp, self).set_virtual_machine_interface(*args, **kwargs)

    # end set_virtual_machine_interface

    def add_virtual_machine_interface(self, *args, **kwargs):
        """Add virtual-machine-interface to instance-ip.
        
        :param ref_obj: VirtualMachineInterface object
        
        """
        if 'virtual_machine_interface_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('virtual_machine_interface_refs')
            self._original_virtual_machine_interface_refs = copy.deepcopy(self.get_virtual_machine_interface_refs() or [])
        super(InstanceIp, self).add_virtual_machine_interface(*args, **kwargs)
    # end add_virtual_machine_interface

    def del_virtual_machine_interface(self, *args, **kwargs):
        if 'virtual_machine_interface_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('virtual_machine_interface_refs')
            self._original_virtual_machine_interface_refs = copy.deepcopy(self.get_virtual_machine_interface_refs() or [])
        super(InstanceIp, self).del_virtual_machine_interface(*args, **kwargs)
    # end del_virtual_machine_interface

    def set_virtual_machine_interface_list(self, *args, **kwargs):
        """Set virtual-machine-interface list for instance-ip.
        
        :param ref_obj_list: list of VirtualMachineInterface object
        
        """
        self._pending_field_updates.add('virtual_machine_interface_refs')
        self._pending_ref_updates.discard('virtual_machine_interface_refs')
        super(InstanceIp, self).set_virtual_machine_interface_list(*args, **kwargs)
    # end set_virtual_machine_interface_list

    def set_physical_router(self, *args, **kwargs):
        """Set physical-router for instance-ip.
        
        :param ref_obj: PhysicalRouter object
        
        """
        self._pending_field_updates.add('physical_router_refs')
        self._pending_ref_updates.discard('physical_router_refs')
        super(InstanceIp, self).set_physical_router(*args, **kwargs)

    # end set_physical_router

    def add_physical_router(self, *args, **kwargs):
        """Add physical-router to instance-ip.
        
        :param ref_obj: PhysicalRouter object
        
        """
        if 'physical_router_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('physical_router_refs')
            self._original_physical_router_refs = copy.deepcopy(self.get_physical_router_refs() or [])
        super(InstanceIp, self).add_physical_router(*args, **kwargs)
    # end add_physical_router

    def del_physical_router(self, *args, **kwargs):
        if 'physical_router_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('physical_router_refs')
            self._original_physical_router_refs = copy.deepcopy(self.get_physical_router_refs() or [])
        super(InstanceIp, self).del_physical_router(*args, **kwargs)
    # end del_physical_router

    def set_physical_router_list(self, *args, **kwargs):
        """Set physical-router list for instance-ip.
        
        :param ref_obj_list: list of PhysicalRouter object
        
        """
        self._pending_field_updates.add('physical_router_refs')
        self._pending_ref_updates.discard('physical_router_refs')
        super(InstanceIp, self).set_physical_router_list(*args, **kwargs)
    # end set_physical_router_list

    def set_virtual_router(self, *args, **kwargs):
        """Set virtual-router for instance-ip.
        
        :param ref_obj: VirtualRouter object
        
        """
        self._pending_field_updates.add('virtual_router_refs')
        self._pending_ref_updates.discard('virtual_router_refs')
        super(InstanceIp, self).set_virtual_router(*args, **kwargs)

    # end set_virtual_router

    def add_virtual_router(self, *args, **kwargs):
        """Add virtual-router to instance-ip.
        
        :param ref_obj: VirtualRouter object
        
        """
        if 'virtual_router_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('virtual_router_refs')
            self._original_virtual_router_refs = copy.deepcopy(self.get_virtual_router_refs() or [])
        super(InstanceIp, self).add_virtual_router(*args, **kwargs)
    # end add_virtual_router

    def del_virtual_router(self, *args, **kwargs):
        if 'virtual_router_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('virtual_router_refs')
            self._original_virtual_router_refs = copy.deepcopy(self.get_virtual_router_refs() or [])
        super(InstanceIp, self).del_virtual_router(*args, **kwargs)
    # end del_virtual_router

    def set_virtual_router_list(self, *args, **kwargs):
        """Set virtual-router list for instance-ip.
        
        :param ref_obj_list: list of VirtualRouter object
        
        """
        self._pending_field_updates.add('virtual_router_refs')
        self._pending_ref_updates.discard('virtual_router_refs')
        super(InstanceIp, self).set_virtual_router_list(*args, **kwargs)
    # end set_virtual_router_list

    def set_logical_interface(self, *args, **kwargs):
        """Set logical-interface for instance-ip.
        
        :param ref_obj: LogicalInterface object
        
        """
        self._pending_field_updates.add('logical_interface_refs')
        self._pending_ref_updates.discard('logical_interface_refs')
        super(InstanceIp, self).set_logical_interface(*args, **kwargs)

    # end set_logical_interface

    def add_logical_interface(self, *args, **kwargs):
        """Add logical-interface to instance-ip.
        
        :param ref_obj: LogicalInterface object
        
        """
        if 'logical_interface_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('logical_interface_refs')
            self._original_logical_interface_refs = copy.deepcopy(self.get_logical_interface_refs() or [])
        super(InstanceIp, self).add_logical_interface(*args, **kwargs)
    # end add_logical_interface

    def del_logical_interface(self, *args, **kwargs):
        if 'logical_interface_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('logical_interface_refs')
            self._original_logical_interface_refs = copy.deepcopy(self.get_logical_interface_refs() or [])
        super(InstanceIp, self).del_logical_interface(*args, **kwargs)
    # end del_logical_interface

    def set_logical_interface_list(self, *args, **kwargs):
        """Set logical-interface list for instance-ip.
        
        :param ref_obj_list: list of LogicalInterface object
        
        """
        self._pending_field_updates.add('logical_interface_refs')
        self._pending_ref_updates.discard('logical_interface_refs')
        super(InstanceIp, self).set_logical_interface_list(*args, **kwargs)
    # end set_logical_interface_list

    def set_flow_node(self, *args, **kwargs):
        """Set flow-node for instance-ip.
        
        :param ref_obj: FlowNode object
        
        """
        self._pending_field_updates.add('flow_node_refs')
        self._pending_ref_updates.discard('flow_node_refs')
        super(InstanceIp, self).set_flow_node(*args, **kwargs)

    # end set_flow_node

    def add_flow_node(self, *args, **kwargs):
        """Add flow-node to instance-ip.
        
        :param ref_obj: FlowNode object
        
        """
        if 'flow_node_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('flow_node_refs')
            self._original_flow_node_refs = copy.deepcopy(self.get_flow_node_refs() or [])
        super(InstanceIp, self).add_flow_node(*args, **kwargs)
    # end add_flow_node

    def del_flow_node(self, *args, **kwargs):
        if 'flow_node_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('flow_node_refs')
            self._original_flow_node_refs = copy.deepcopy(self.get_flow_node_refs() or [])
        super(InstanceIp, self).del_flow_node(*args, **kwargs)
    # end del_flow_node

    def set_flow_node_list(self, *args, **kwargs):
        """Set flow-node list for instance-ip.
        
        :param ref_obj_list: list of FlowNode object
        
        """
        self._pending_field_updates.add('flow_node_refs')
        self._pending_ref_updates.discard('flow_node_refs')
        super(InstanceIp, self).set_flow_node_list(*args, **kwargs)
    # end set_flow_node_list

    def set_tag(self, *args, **kwargs):
        """Set tag for instance-ip.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(InstanceIp, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to instance-ip.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(InstanceIp, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(InstanceIp, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for instance-ip.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(InstanceIp, self).set_tag_list(*args, **kwargs)
    # end set_tag_list

    def get_floating_ips(self):
        if hasattr(self, 'floating_ips'):
            return self.floating_ips

        if hasattr(super(InstanceIp, self), 'floating_ips'):
            return super(InstanceIp, self).get_floating_ips()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.instance_ip_read(id = self.uuid, fields = ['floating_ips'])
        except NoIdError:
            return None
        children = getattr(obj, 'floating_ips', None)
        if not children:
            return None
        self.floating_ips = children

        return children
    # end get_floating_ips


    def get_service_instance_back_refs(self):
        """Return list of all service-instances using this instance-ip"""
        if hasattr(self, 'service_instance_back_refs'):
            return self.service_instance_back_refs

        if hasattr(super(InstanceIp, self), 'service_instance_back_refs'):
            return super(InstanceIp, self).get_service_instance_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.instance_ip_read(id = self.uuid, fields = ['service_instance_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'service_instance_back_refs', None)
        if not back_refs:
            return None
        self.service_instance_back_refs = back_refs

        return back_refs
    # end get_service_instance_back_refs

# end class InstanceIp

class ServiceApplianceSet(vnc_api.gen.resource_common.ServiceApplianceSet):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'service_appliance_set_virtualization_type' in kwargs:
            pending_fields.append('service_appliance_set_virtualization_type')
        if len(args) > 1 or 'service_appliance_set_properties' in kwargs:
            pending_fields.append('service_appliance_set_properties')
        if len(args) > 2 or 'service_appliance_driver' in kwargs:
            pending_fields.append('service_appliance_driver')
        if len(args) > 3 or 'service_appliance_ha_mode' in kwargs:
            pending_fields.append('service_appliance_ha_mode')
        if len(args) > 4 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 5 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 6 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 7 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(ServiceApplianceSet, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            props_dict['service_appliance_set_virtualization_type'] = kwargs[u'service_appliance_set_virtualization_type']
        except KeyError:
            pass

        try:
            if kwargs['service_appliance_set_properties'] is None:
                props_dict['service_appliance_set_properties'] = None
            else:
                props_dict['service_appliance_set_properties'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'service_appliance_set_properties'])
        except KeyError:
            pass

        try:
            props_dict['service_appliance_driver'] = kwargs[u'service_appliance_driver']
        except KeyError:
            pass

        try:
            props_dict['service_appliance_ha_mode'] = kwargs[u'service_appliance_ha_mode']
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = ServiceApplianceSet(**props_dict)
        else:
            obj = ServiceApplianceSet(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...
        try:
            obj.service_appliances = kwargs[u'service_appliances']
        except KeyError:
            pass

        # add any specified references...
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.service_template_back_refs = kwargs[u'service_template_back_refs']
        except KeyError:
            pass
        try:
            obj.loadbalancer_pool_back_refs = kwargs[u'loadbalancer_pool_back_refs']
        except KeyError:
            pass
        try:
            obj.loadbalancer_back_refs = kwargs[u'loadbalancer_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.ServiceApplianceSet.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.ServiceApplianceSet.service_appliance_set_virtualization_type.setter
    def service_appliance_set_virtualization_type(self, service_appliance_set_virtualization_type):
        """Set service-appliance-set-virtualization-type for service-appliance-set.
        
        :param service_appliance_set_virtualization_type: ServiceVirtualizationType object
        
        """
        if 'service_appliance_set_virtualization_type' not in self._pending_field_updates:
            self._pending_field_updates.add('service_appliance_set_virtualization_type')

        self._service_appliance_set_virtualization_type = service_appliance_set_virtualization_type
    # end service_appliance_set_virtualization_type

    def set_service_appliance_set_virtualization_type(self, value):
        self.service_appliance_set_virtualization_type = value
    # end set_service_appliance_set_virtualization_type

    @vnc_api.gen.resource_common.ServiceApplianceSet.service_appliance_set_properties.setter
    def service_appliance_set_properties(self, service_appliance_set_properties):
        """Set service-appliance-set-properties for service-appliance-set.
        
        :param service_appliance_set_properties: KeyValuePairs object
        
        """
        if 'service_appliance_set_properties' not in self._pending_field_updates:
            self._pending_field_updates.add('service_appliance_set_properties')

        self._service_appliance_set_properties = service_appliance_set_properties
    # end service_appliance_set_properties

    def set_service_appliance_set_properties(self, value):
        self.service_appliance_set_properties = value
    # end set_service_appliance_set_properties

    @vnc_api.gen.resource_common.ServiceApplianceSet.service_appliance_driver.setter
    def service_appliance_driver(self, service_appliance_driver):
        """Set service-appliance-driver for service-appliance-set.
        
        :param service_appliance_driver: xsd:string object
        
        """
        if 'service_appliance_driver' not in self._pending_field_updates:
            self._pending_field_updates.add('service_appliance_driver')

        self._service_appliance_driver = service_appliance_driver
    # end service_appliance_driver

    def set_service_appliance_driver(self, value):
        self.service_appliance_driver = value
    # end set_service_appliance_driver

    @vnc_api.gen.resource_common.ServiceApplianceSet.service_appliance_ha_mode.setter
    def service_appliance_ha_mode(self, service_appliance_ha_mode):
        """Set service-appliance-ha-mode for service-appliance-set.
        
        :param service_appliance_ha_mode: xsd:string object
        
        """
        if 'service_appliance_ha_mode' not in self._pending_field_updates:
            self._pending_field_updates.add('service_appliance_ha_mode')

        self._service_appliance_ha_mode = service_appliance_ha_mode
    # end service_appliance_ha_mode

    def set_service_appliance_ha_mode(self, value):
        self.service_appliance_ha_mode = value
    # end set_service_appliance_ha_mode

    @vnc_api.gen.resource_common.ServiceApplianceSet.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for service-appliance-set.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.ServiceApplianceSet.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for service-appliance-set.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.ServiceApplianceSet.annotations.setter
    def annotations(self, annotations):
        """Set annotations for service-appliance-set.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.ServiceApplianceSet.display_name.setter
    def display_name(self, display_name):
        """Set display-name for service-appliance-set.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for service-appliance-set.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for service-appliance-set.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_tag(self, *args, **kwargs):
        """Set tag for service-appliance-set.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(ServiceApplianceSet, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to service-appliance-set.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(ServiceApplianceSet, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(ServiceApplianceSet, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for service-appliance-set.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(ServiceApplianceSet, self).set_tag_list(*args, **kwargs)
    # end set_tag_list

    def get_service_appliances(self):
        if hasattr(self, 'service_appliances'):
            return self.service_appliances

        if hasattr(super(ServiceApplianceSet, self), 'service_appliances'):
            return super(ServiceApplianceSet, self).get_service_appliances()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.service_appliance_set_read(id = self.uuid, fields = ['service_appliances'])
        except NoIdError:
            return None
        children = getattr(obj, 'service_appliances', None)
        if not children:
            return None
        self.service_appliances = children

        return children
    # end get_service_appliances


    def get_service_template_back_refs(self):
        """Return list of all service-templates using this service-appliance-set"""
        if hasattr(self, 'service_template_back_refs'):
            return self.service_template_back_refs

        if hasattr(super(ServiceApplianceSet, self), 'service_template_back_refs'):
            return super(ServiceApplianceSet, self).get_service_template_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.service_appliance_set_read(id = self.uuid, fields = ['service_template_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'service_template_back_refs', None)
        if not back_refs:
            return None
        self.service_template_back_refs = back_refs

        return back_refs
    # end get_service_template_back_refs

    def get_loadbalancer_pool_back_refs(self):
        """Return list of all loadbalancer-pools using this service-appliance-set"""
        if hasattr(self, 'loadbalancer_pool_back_refs'):
            return self.loadbalancer_pool_back_refs

        if hasattr(super(ServiceApplianceSet, self), 'loadbalancer_pool_back_refs'):
            return super(ServiceApplianceSet, self).get_loadbalancer_pool_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.service_appliance_set_read(id = self.uuid, fields = ['loadbalancer_pool_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'loadbalancer_pool_back_refs', None)
        if not back_refs:
            return None
        self.loadbalancer_pool_back_refs = back_refs

        return back_refs
    # end get_loadbalancer_pool_back_refs

    def get_loadbalancer_back_refs(self):
        """Return list of all loadbalancers using this service-appliance-set"""
        if hasattr(self, 'loadbalancer_back_refs'):
            return self.loadbalancer_back_refs

        if hasattr(super(ServiceApplianceSet, self), 'loadbalancer_back_refs'):
            return super(ServiceApplianceSet, self).get_loadbalancer_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.service_appliance_set_read(id = self.uuid, fields = ['loadbalancer_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'loadbalancer_back_refs', None)
        if not back_refs:
            return None
        self.loadbalancer_back_refs = back_refs

        return back_refs
    # end get_loadbalancer_back_refs

# end class ServiceApplianceSet

class RouteTarget(vnc_api.gen.resource_common.RouteTarget):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, *args, **kwargs):
        pending_fields = ['fq_name']

        self._server_conn = None

        if len(args) > 0 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 1 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 2 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 3 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(RouteTarget, self).__init__(name, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = RouteTarget(**props_dict)
        else:
            obj = RouteTarget(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.logical_router_back_refs = kwargs[u'logical_router_back_refs']
        except KeyError:
            pass
        try:
            obj.routing_instance_back_refs = kwargs[u'routing_instance_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.RouteTarget.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.RouteTarget.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for route-target.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.RouteTarget.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for route-target.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.RouteTarget.annotations.setter
    def annotations(self, annotations):
        """Set annotations for route-target.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.RouteTarget.display_name.setter
    def display_name(self, display_name):
        """Set display-name for route-target.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for route-target.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for route-target.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_tag(self, *args, **kwargs):
        """Set tag for route-target.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(RouteTarget, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to route-target.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(RouteTarget, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(RouteTarget, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for route-target.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(RouteTarget, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


    def get_logical_router_back_refs(self):
        """Return list of all logical-routers using this route-target"""
        if hasattr(self, 'logical_router_back_refs'):
            return self.logical_router_back_refs

        if hasattr(super(RouteTarget, self), 'logical_router_back_refs'):
            return super(RouteTarget, self).get_logical_router_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.route_target_read(id = self.uuid, fields = ['logical_router_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'logical_router_back_refs', None)
        if not back_refs:
            return None
        self.logical_router_back_refs = back_refs

        return back_refs
    # end get_logical_router_back_refs

    def get_routing_instance_back_refs(self):
        """Return list of all routing-instances using this route-target"""
        if hasattr(self, 'routing_instance_back_refs'):
            return self.routing_instance_back_refs

        if hasattr(super(RouteTarget, self), 'routing_instance_back_refs'):
            return super(RouteTarget, self).get_routing_instance_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.route_target_read(id = self.uuid, fields = ['routing_instance_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'routing_instance_back_refs', None)
        if not back_refs:
            return None
        self.routing_instance_back_refs = back_refs

        return back_refs
    # end get_routing_instance_back_refs

# end class RouteTarget

class LoadbalancerListener(vnc_api.gen.resource_common.LoadbalancerListener):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'loadbalancer_listener_properties' in kwargs:
            pending_fields.append('loadbalancer_listener_properties')
        if len(args) > 1 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 2 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 3 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 4 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(LoadbalancerListener, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            if kwargs['loadbalancer_listener_properties'] is None:
                props_dict['loadbalancer_listener_properties'] = None
            else:
                props_dict['loadbalancer_listener_properties'] = vnc_api.gen.resource_xsd.LoadbalancerListenerType(params_dict=kwargs[u'loadbalancer_listener_properties'])
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = LoadbalancerListener(**props_dict)
        else:
            obj = LoadbalancerListener(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.loadbalancer_refs = kwargs[u'loadbalancer_refs']
        except KeyError:
            pass
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.loadbalancer_pool_back_refs = kwargs[u'loadbalancer_pool_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.LoadbalancerListener.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.LoadbalancerListener.loadbalancer_listener_properties.setter
    def loadbalancer_listener_properties(self, loadbalancer_listener_properties):
        """Set loadbalancer-listener-properties for loadbalancer-listener.
        
        :param loadbalancer_listener_properties: LoadbalancerListenerType object
        
        """
        if 'loadbalancer_listener_properties' not in self._pending_field_updates:
            self._pending_field_updates.add('loadbalancer_listener_properties')

        self._loadbalancer_listener_properties = loadbalancer_listener_properties
    # end loadbalancer_listener_properties

    def set_loadbalancer_listener_properties(self, value):
        self.loadbalancer_listener_properties = value
    # end set_loadbalancer_listener_properties

    @vnc_api.gen.resource_common.LoadbalancerListener.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for loadbalancer-listener.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.LoadbalancerListener.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for loadbalancer-listener.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.LoadbalancerListener.annotations.setter
    def annotations(self, annotations):
        """Set annotations for loadbalancer-listener.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.LoadbalancerListener.display_name.setter
    def display_name(self, display_name):
        """Set display-name for loadbalancer-listener.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for loadbalancer-listener.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for loadbalancer-listener.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_loadbalancer(self, *args, **kwargs):
        """Set loadbalancer for loadbalancer-listener.
        
        :param ref_obj: Loadbalancer object
        
        """
        self._pending_field_updates.add('loadbalancer_refs')
        self._pending_ref_updates.discard('loadbalancer_refs')
        super(LoadbalancerListener, self).set_loadbalancer(*args, **kwargs)

    # end set_loadbalancer

    def add_loadbalancer(self, *args, **kwargs):
        """Add loadbalancer to loadbalancer-listener.
        
        :param ref_obj: Loadbalancer object
        
        """
        if 'loadbalancer_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('loadbalancer_refs')
            self._original_loadbalancer_refs = copy.deepcopy(self.get_loadbalancer_refs() or [])
        super(LoadbalancerListener, self).add_loadbalancer(*args, **kwargs)
    # end add_loadbalancer

    def del_loadbalancer(self, *args, **kwargs):
        if 'loadbalancer_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('loadbalancer_refs')
            self._original_loadbalancer_refs = copy.deepcopy(self.get_loadbalancer_refs() or [])
        super(LoadbalancerListener, self).del_loadbalancer(*args, **kwargs)
    # end del_loadbalancer

    def set_loadbalancer_list(self, *args, **kwargs):
        """Set loadbalancer list for loadbalancer-listener.
        
        :param ref_obj_list: list of Loadbalancer object
        
        """
        self._pending_field_updates.add('loadbalancer_refs')
        self._pending_ref_updates.discard('loadbalancer_refs')
        super(LoadbalancerListener, self).set_loadbalancer_list(*args, **kwargs)
    # end set_loadbalancer_list

    def set_tag(self, *args, **kwargs):
        """Set tag for loadbalancer-listener.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(LoadbalancerListener, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to loadbalancer-listener.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(LoadbalancerListener, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(LoadbalancerListener, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for loadbalancer-listener.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(LoadbalancerListener, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


    def get_loadbalancer_pool_back_refs(self):
        """Return list of all loadbalancer-pools using this loadbalancer-listener"""
        if hasattr(self, 'loadbalancer_pool_back_refs'):
            return self.loadbalancer_pool_back_refs

        if hasattr(super(LoadbalancerListener, self), 'loadbalancer_pool_back_refs'):
            return super(LoadbalancerListener, self).get_loadbalancer_pool_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.loadbalancer_listener_read(id = self.uuid, fields = ['loadbalancer_pool_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'loadbalancer_pool_back_refs', None)
        if not back_refs:
            return None
        self.loadbalancer_pool_back_refs = back_refs

        return back_refs
    # end get_loadbalancer_pool_back_refs

# end class LoadbalancerListener

class FloatingIpPool(vnc_api.gen.resource_common.FloatingIpPool):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'floating_ip_pool_subnets' in kwargs:
            pending_fields.append('floating_ip_pool_subnets')
        if len(args) > 1 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 2 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 3 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 4 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(FloatingIpPool, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            if kwargs['floating_ip_pool_subnets'] is None:
                props_dict['floating_ip_pool_subnets'] = None
            else:
                props_dict['floating_ip_pool_subnets'] = vnc_api.gen.resource_xsd.FloatingIpPoolSubnetType(params_dict=kwargs[u'floating_ip_pool_subnets'])
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = FloatingIpPool(**props_dict)
        else:
            obj = FloatingIpPool(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...
        try:
            obj.floating_ips = kwargs[u'floating_ips']
        except KeyError:
            pass

        # add any specified references...
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.project_back_refs = kwargs[u'project_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.FloatingIpPool.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.FloatingIpPool.floating_ip_pool_subnets.setter
    def floating_ip_pool_subnets(self, floating_ip_pool_subnets):
        """Set floating-ip-pool-subnets for floating-ip-pool.
        
        :param floating_ip_pool_subnets: FloatingIpPoolSubnetType object
        
        """
        if 'floating_ip_pool_subnets' not in self._pending_field_updates:
            self._pending_field_updates.add('floating_ip_pool_subnets')

        self._floating_ip_pool_subnets = floating_ip_pool_subnets
    # end floating_ip_pool_subnets

    def set_floating_ip_pool_subnets(self, value):
        self.floating_ip_pool_subnets = value
    # end set_floating_ip_pool_subnets

    @vnc_api.gen.resource_common.FloatingIpPool.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for floating-ip-pool.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.FloatingIpPool.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for floating-ip-pool.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.FloatingIpPool.annotations.setter
    def annotations(self, annotations):
        """Set annotations for floating-ip-pool.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.FloatingIpPool.display_name.setter
    def display_name(self, display_name):
        """Set display-name for floating-ip-pool.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for floating-ip-pool.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for floating-ip-pool.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_tag(self, *args, **kwargs):
        """Set tag for floating-ip-pool.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(FloatingIpPool, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to floating-ip-pool.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(FloatingIpPool, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(FloatingIpPool, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for floating-ip-pool.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(FloatingIpPool, self).set_tag_list(*args, **kwargs)
    # end set_tag_list

    def get_floating_ips(self):
        if hasattr(self, 'floating_ips'):
            return self.floating_ips

        if hasattr(super(FloatingIpPool, self), 'floating_ips'):
            return super(FloatingIpPool, self).get_floating_ips()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.floating_ip_pool_read(id = self.uuid, fields = ['floating_ips'])
        except NoIdError:
            return None
        children = getattr(obj, 'floating_ips', None)
        if not children:
            return None
        self.floating_ips = children

        return children
    # end get_floating_ips


    def get_project_back_refs(self):
        """Return list of all projects using this floating-ip-pool"""
        if hasattr(self, 'project_back_refs'):
            return self.project_back_refs

        if hasattr(super(FloatingIpPool, self), 'project_back_refs'):
            return super(FloatingIpPool, self).get_project_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.floating_ip_pool_read(id = self.uuid, fields = ['project_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'project_back_refs', None)
        if not back_refs:
            return None
        self.project_back_refs = back_refs

        return back_refs
    # end get_project_back_refs

# end class FloatingIpPool

class PhysicalRouter(vnc_api.gen.resource_common.PhysicalRouter):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'physical_router_junos_service_ports' in kwargs:
            pending_fields.append('physical_router_junos_service_ports')
        if len(args) > 1 or 'telemetry_info' in kwargs:
            pending_fields.append('telemetry_info')
        if len(args) > 2 or 'physical_router_device_family' in kwargs:
            pending_fields.append('physical_router_device_family')
        if len(args) > 3 or 'physical_router_os_version' in kwargs:
            pending_fields.append('physical_router_os_version')
        if len(args) > 4 or 'physical_router_hostname' in kwargs:
            pending_fields.append('physical_router_hostname')
        if len(args) > 5 or 'physical_router_management_ip' in kwargs:
            pending_fields.append('physical_router_management_ip')
        if len(args) > 6 or 'physical_router_management_mac' in kwargs:
            pending_fields.append('physical_router_management_mac')
        if len(args) > 7 or 'physical_router_dataplane_ip' in kwargs:
            pending_fields.append('physical_router_dataplane_ip')
        if len(args) > 8 or 'physical_router_loopback_ip' in kwargs:
            pending_fields.append('physical_router_loopback_ip')
        if len(args) > 9 or 'physical_router_replicator_loopback_ip' in kwargs:
            pending_fields.append('physical_router_replicator_loopback_ip')
        if len(args) > 10 or 'physical_router_vendor_name' in kwargs:
            pending_fields.append('physical_router_vendor_name')
        if len(args) > 11 or 'physical_router_product_name' in kwargs:
            pending_fields.append('physical_router_product_name')
        if len(args) > 12 or 'physical_router_serial_number' in kwargs:
            pending_fields.append('physical_router_serial_number')
        if len(args) > 13 or 'physical_router_vnc_managed' in kwargs:
            pending_fields.append('physical_router_vnc_managed')
        if len(args) > 14 or 'physical_router_underlay_managed' in kwargs:
            pending_fields.append('physical_router_underlay_managed')
        if len(args) > 15 or 'physical_router_role' in kwargs:
            pending_fields.append('physical_router_role')
        if len(args) > 16 or 'routing_bridging_roles' in kwargs:
            pending_fields.append('routing_bridging_roles')
        if len(args) > 17 or 'physical_router_snmp' in kwargs:
            pending_fields.append('physical_router_snmp')
        if len(args) > 18 or 'physical_router_lldp' in kwargs:
            pending_fields.append('physical_router_lldp')
        if len(args) > 19 or 'physical_router_user_credentials' in kwargs:
            pending_fields.append('physical_router_user_credentials')
        if len(args) > 20 or 'physical_router_encryption_type' in kwargs:
            pending_fields.append('physical_router_encryption_type')
        if len(args) > 21 or 'physical_router_snmp_credentials' in kwargs:
            pending_fields.append('physical_router_snmp_credentials')
        if len(args) > 22 or 'physical_router_dhcp_parameters' in kwargs:
            pending_fields.append('physical_router_dhcp_parameters')
        if len(args) > 23 or 'physical_router_cli_commit_state' in kwargs:
            pending_fields.append('physical_router_cli_commit_state')
        if len(args) > 24 or 'physical_router_managed_state' in kwargs:
            pending_fields.append('physical_router_managed_state')
        if len(args) > 25 or 'physical_router_underlay_config' in kwargs:
            pending_fields.append('physical_router_underlay_config')
        if len(args) > 26 or 'physical_router_supplemental_config' in kwargs:
            pending_fields.append('physical_router_supplemental_config')
        if len(args) > 27 or 'physical_router_autonomous_system' in kwargs:
            pending_fields.append('physical_router_autonomous_system')
        if len(args) > 28 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 29 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 30 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 31 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(PhysicalRouter, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            if kwargs['physical_router_junos_service_ports'] is None:
                props_dict['physical_router_junos_service_ports'] = None
            else:
                props_dict['physical_router_junos_service_ports'] = vnc_api.gen.resource_xsd.JunosServicePorts(params_dict=kwargs[u'physical_router_junos_service_ports'])
        except KeyError:
            pass

        try:
            if kwargs['telemetry_info'] is None:
                props_dict['telemetry_info'] = None
            else:
                props_dict['telemetry_info'] = vnc_api.gen.resource_xsd.TelemetryStateInfo(params_dict=kwargs[u'telemetry_info'])
        except KeyError:
            pass

        try:
            props_dict['physical_router_device_family'] = kwargs[u'physical_router_device_family']
        except KeyError:
            pass

        try:
            props_dict['physical_router_os_version'] = kwargs[u'physical_router_os_version']
        except KeyError:
            pass

        try:
            props_dict['physical_router_hostname'] = kwargs[u'physical_router_hostname']
        except KeyError:
            pass

        try:
            props_dict['physical_router_management_ip'] = kwargs[u'physical_router_management_ip']
        except KeyError:
            pass

        try:
            props_dict['physical_router_management_mac'] = kwargs[u'physical_router_management_mac']
        except KeyError:
            pass

        try:
            props_dict['physical_router_dataplane_ip'] = kwargs[u'physical_router_dataplane_ip']
        except KeyError:
            pass

        try:
            props_dict['physical_router_loopback_ip'] = kwargs[u'physical_router_loopback_ip']
        except KeyError:
            pass

        try:
            props_dict['physical_router_replicator_loopback_ip'] = kwargs[u'physical_router_replicator_loopback_ip']
        except KeyError:
            pass

        try:
            props_dict['physical_router_vendor_name'] = kwargs[u'physical_router_vendor_name']
        except KeyError:
            pass

        try:
            props_dict['physical_router_product_name'] = kwargs[u'physical_router_product_name']
        except KeyError:
            pass

        try:
            props_dict['physical_router_serial_number'] = kwargs[u'physical_router_serial_number']
        except KeyError:
            pass

        try:
            props_dict['physical_router_vnc_managed'] = kwargs[u'physical_router_vnc_managed']
        except KeyError:
            pass

        try:
            props_dict['physical_router_underlay_managed'] = kwargs[u'physical_router_underlay_managed']
        except KeyError:
            pass

        try:
            props_dict['physical_router_role'] = kwargs[u'physical_router_role']
        except KeyError:
            pass

        try:
            if kwargs['routing_bridging_roles'] is None:
                props_dict['routing_bridging_roles'] = None
            else:
                props_dict['routing_bridging_roles'] = vnc_api.gen.resource_xsd.RoutingBridgingRolesType(params_dict=kwargs[u'routing_bridging_roles'])
        except KeyError:
            pass

        try:
            props_dict['physical_router_snmp'] = kwargs[u'physical_router_snmp']
        except KeyError:
            pass

        try:
            props_dict['physical_router_lldp'] = kwargs[u'physical_router_lldp']
        except KeyError:
            pass

        try:
            if kwargs['physical_router_user_credentials'] is None:
                props_dict['physical_router_user_credentials'] = None
            else:
                props_dict['physical_router_user_credentials'] = vnc_api.gen.resource_xsd.UserCredentials(params_dict=kwargs[u'physical_router_user_credentials'])
        except KeyError:
            pass

        try:
            props_dict['physical_router_encryption_type'] = kwargs[u'physical_router_encryption_type']
        except KeyError:
            pass

        try:
            if kwargs['physical_router_snmp_credentials'] is None:
                props_dict['physical_router_snmp_credentials'] = None
            else:
                props_dict['physical_router_snmp_credentials'] = vnc_api.gen.resource_xsd.SNMPCredentials(params_dict=kwargs[u'physical_router_snmp_credentials'])
        except KeyError:
            pass

        try:
            if kwargs['physical_router_dhcp_parameters'] is None:
                props_dict['physical_router_dhcp_parameters'] = None
            else:
                props_dict['physical_router_dhcp_parameters'] = vnc_api.gen.resource_xsd.DnsmasqLeaseParameters(params_dict=kwargs[u'physical_router_dhcp_parameters'])
        except KeyError:
            pass

        try:
            props_dict['physical_router_cli_commit_state'] = kwargs[u'physical_router_cli_commit_state']
        except KeyError:
            pass

        try:
            props_dict['physical_router_managed_state'] = kwargs[u'physical_router_managed_state']
        except KeyError:
            pass

        try:
            props_dict['physical_router_underlay_config'] = kwargs[u'physical_router_underlay_config']
        except KeyError:
            pass

        try:
            props_dict['physical_router_supplemental_config'] = kwargs[u'physical_router_supplemental_config']
        except KeyError:
            pass

        try:
            if kwargs['physical_router_autonomous_system'] is None:
                props_dict['physical_router_autonomous_system'] = None
            else:
                props_dict['physical_router_autonomous_system'] = vnc_api.gen.resource_xsd.AutonomousSystemsType(params_dict=kwargs[u'physical_router_autonomous_system'])
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = PhysicalRouter(**props_dict)
        else:
            obj = PhysicalRouter(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...
        try:
            obj.link_aggregation_groups = kwargs[u'link_aggregation_groups']
        except KeyError:
            pass
        try:
            obj.hardware_inventorys = kwargs[u'hardware_inventorys']
        except KeyError:
            pass
        try:
            obj.cli_configs = kwargs[u'cli_configs']
        except KeyError:
            pass
        try:
            obj.physical_interfaces = kwargs[u'physical_interfaces']
        except KeyError:
            pass
        try:
            obj.logical_interfaces = kwargs[u'logical_interfaces']
        except KeyError:
            pass

        # add any specified references...
        try:
            obj.virtual_router_refs = kwargs[u'virtual_router_refs']
        except KeyError:
            pass
        try:
            obj.bgp_router_refs = kwargs[u'bgp_router_refs']
        except KeyError:
            pass
        try:
            obj.virtual_network_refs = kwargs[u'virtual_network_refs']
        except KeyError:
            pass
        try:
            obj.intent_map_refs = kwargs[u'intent_map_refs']
        except KeyError:
            pass
        try:
            obj.fabric_refs = kwargs[u'fabric_refs']
        except KeyError:
            pass
        try:
            obj.node_profile_refs = kwargs[u'node_profile_refs']
        except KeyError:
            pass
        try:
            obj.device_functional_group_refs = kwargs[u'device_functional_group_refs']
        except KeyError:
            pass
        try:
            obj.device_chassis_refs = kwargs[u'device_chassis_refs']
        except KeyError:
            pass
        try:
            obj.device_image_refs = kwargs[u'device_image_refs']
        except KeyError:
            pass
        try:
            obj.physical_role_refs = kwargs[u'physical_role_refs']
        except KeyError:
            pass
        try:
            obj.overlay_role_refs = kwargs[u'overlay_role_refs']
        except KeyError:
            pass
        try:
            obj.telemetry_profile_refs = kwargs[u'telemetry_profile_refs']
        except KeyError:
            pass
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.instance_ip_back_refs = kwargs[u'instance_ip_back_refs']
        except KeyError:
            pass
        try:
            obj.logical_router_back_refs = kwargs[u'logical_router_back_refs']
        except KeyError:
            pass
        try:
            obj.service_endpoint_back_refs = kwargs[u'service_endpoint_back_refs']
        except KeyError:
            pass
        try:
            obj.network_device_config_back_refs = kwargs[u'network_device_config_back_refs']
        except KeyError:
            pass
        try:
            obj.e2_service_provider_back_refs = kwargs[u'e2_service_provider_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.PhysicalRouter.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.PhysicalRouter.physical_router_junos_service_ports.setter
    def physical_router_junos_service_ports(self, physical_router_junos_service_ports):
        """Set physical-router-junos-service-ports for physical-router.
        
        :param physical_router_junos_service_ports: JunosServicePorts object
        
        """
        if 'physical_router_junos_service_ports' not in self._pending_field_updates:
            self._pending_field_updates.add('physical_router_junos_service_ports')

        self._physical_router_junos_service_ports = physical_router_junos_service_ports
    # end physical_router_junos_service_ports

    def set_physical_router_junos_service_ports(self, value):
        self.physical_router_junos_service_ports = value
    # end set_physical_router_junos_service_ports

    @vnc_api.gen.resource_common.PhysicalRouter.telemetry_info.setter
    def telemetry_info(self, telemetry_info):
        """Set telemetry-info for physical-router.
        
        :param telemetry_info: TelemetryStateInfo object
        
        """
        if 'telemetry_info' not in self._pending_field_updates:
            self._pending_field_updates.add('telemetry_info')

        self._telemetry_info = telemetry_info
    # end telemetry_info

    def set_telemetry_info(self, value):
        self.telemetry_info = value
    # end set_telemetry_info

    @vnc_api.gen.resource_common.PhysicalRouter.physical_router_device_family.setter
    def physical_router_device_family(self, physical_router_device_family):
        """Set physical-router-device-family for physical-router.
        
        :param physical_router_device_family: xsd:string object
        
        """
        if 'physical_router_device_family' not in self._pending_field_updates:
            self._pending_field_updates.add('physical_router_device_family')

        self._physical_router_device_family = physical_router_device_family
    # end physical_router_device_family

    def set_physical_router_device_family(self, value):
        self.physical_router_device_family = value
    # end set_physical_router_device_family

    @vnc_api.gen.resource_common.PhysicalRouter.physical_router_os_version.setter
    def physical_router_os_version(self, physical_router_os_version):
        """Set physical-router-os-version for physical-router.
        
        :param physical_router_os_version: xsd:string object
        
        """
        if 'physical_router_os_version' not in self._pending_field_updates:
            self._pending_field_updates.add('physical_router_os_version')

        self._physical_router_os_version = physical_router_os_version
    # end physical_router_os_version

    def set_physical_router_os_version(self, value):
        self.physical_router_os_version = value
    # end set_physical_router_os_version

    @vnc_api.gen.resource_common.PhysicalRouter.physical_router_hostname.setter
    def physical_router_hostname(self, physical_router_hostname):
        """Set physical-router-hostname for physical-router.
        
        :param physical_router_hostname: xsd:string object
        
        """
        if 'physical_router_hostname' not in self._pending_field_updates:
            self._pending_field_updates.add('physical_router_hostname')

        self._physical_router_hostname = physical_router_hostname
    # end physical_router_hostname

    def set_physical_router_hostname(self, value):
        self.physical_router_hostname = value
    # end set_physical_router_hostname

    @vnc_api.gen.resource_common.PhysicalRouter.physical_router_management_ip.setter
    def physical_router_management_ip(self, physical_router_management_ip):
        """Set physical-router-management-ip for physical-router.
        
        :param physical_router_management_ip: IpAddress object
        
        """
        if 'physical_router_management_ip' not in self._pending_field_updates:
            self._pending_field_updates.add('physical_router_management_ip')

        self._physical_router_management_ip = physical_router_management_ip
    # end physical_router_management_ip

    def set_physical_router_management_ip(self, value):
        self.physical_router_management_ip = value
    # end set_physical_router_management_ip

    @vnc_api.gen.resource_common.PhysicalRouter.physical_router_management_mac.setter
    def physical_router_management_mac(self, physical_router_management_mac):
        """Set physical-router-management-mac for physical-router.
        
        :param physical_router_management_mac: xsd:string object
        
        """
        if 'physical_router_management_mac' not in self._pending_field_updates:
            self._pending_field_updates.add('physical_router_management_mac')

        self._physical_router_management_mac = physical_router_management_mac
    # end physical_router_management_mac

    def set_physical_router_management_mac(self, value):
        self.physical_router_management_mac = value
    # end set_physical_router_management_mac

    @vnc_api.gen.resource_common.PhysicalRouter.physical_router_dataplane_ip.setter
    def physical_router_dataplane_ip(self, physical_router_dataplane_ip):
        """Set physical-router-dataplane-ip for physical-router.
        
        :param physical_router_dataplane_ip: IpAddress object
        
        """
        if 'physical_router_dataplane_ip' not in self._pending_field_updates:
            self._pending_field_updates.add('physical_router_dataplane_ip')

        self._physical_router_dataplane_ip = physical_router_dataplane_ip
    # end physical_router_dataplane_ip

    def set_physical_router_dataplane_ip(self, value):
        self.physical_router_dataplane_ip = value
    # end set_physical_router_dataplane_ip

    @vnc_api.gen.resource_common.PhysicalRouter.physical_router_loopback_ip.setter
    def physical_router_loopback_ip(self, physical_router_loopback_ip):
        """Set physical-router-loopback-ip for physical-router.
        
        :param physical_router_loopback_ip: IpAddress object
        
        """
        if 'physical_router_loopback_ip' not in self._pending_field_updates:
            self._pending_field_updates.add('physical_router_loopback_ip')

        self._physical_router_loopback_ip = physical_router_loopback_ip
    # end physical_router_loopback_ip

    def set_physical_router_loopback_ip(self, value):
        self.physical_router_loopback_ip = value
    # end set_physical_router_loopback_ip

    @vnc_api.gen.resource_common.PhysicalRouter.physical_router_replicator_loopback_ip.setter
    def physical_router_replicator_loopback_ip(self, physical_router_replicator_loopback_ip):
        """Set physical-router-replicator-loopback-ip for physical-router.
        
        :param physical_router_replicator_loopback_ip: IpAddress object
        
        """
        if 'physical_router_replicator_loopback_ip' not in self._pending_field_updates:
            self._pending_field_updates.add('physical_router_replicator_loopback_ip')

        self._physical_router_replicator_loopback_ip = physical_router_replicator_loopback_ip
    # end physical_router_replicator_loopback_ip

    def set_physical_router_replicator_loopback_ip(self, value):
        self.physical_router_replicator_loopback_ip = value
    # end set_physical_router_replicator_loopback_ip

    @vnc_api.gen.resource_common.PhysicalRouter.physical_router_vendor_name.setter
    def physical_router_vendor_name(self, physical_router_vendor_name):
        """Set physical-router-vendor-name for physical-router.
        
        :param physical_router_vendor_name: xsd:string object
        
        """
        if 'physical_router_vendor_name' not in self._pending_field_updates:
            self._pending_field_updates.add('physical_router_vendor_name')

        self._physical_router_vendor_name = physical_router_vendor_name
    # end physical_router_vendor_name

    def set_physical_router_vendor_name(self, value):
        self.physical_router_vendor_name = value
    # end set_physical_router_vendor_name

    @vnc_api.gen.resource_common.PhysicalRouter.physical_router_product_name.setter
    def physical_router_product_name(self, physical_router_product_name):
        """Set physical-router-product-name for physical-router.
        
        :param physical_router_product_name: xsd:string object
        
        """
        if 'physical_router_product_name' not in self._pending_field_updates:
            self._pending_field_updates.add('physical_router_product_name')

        self._physical_router_product_name = physical_router_product_name
    # end physical_router_product_name

    def set_physical_router_product_name(self, value):
        self.physical_router_product_name = value
    # end set_physical_router_product_name

    @vnc_api.gen.resource_common.PhysicalRouter.physical_router_serial_number.setter
    def physical_router_serial_number(self, physical_router_serial_number):
        """Set physical-router-serial-number for physical-router.
        
        :param physical_router_serial_number: xsd:string object
        
        """
        if 'physical_router_serial_number' not in self._pending_field_updates:
            self._pending_field_updates.add('physical_router_serial_number')

        self._physical_router_serial_number = physical_router_serial_number
    # end physical_router_serial_number

    def set_physical_router_serial_number(self, value):
        self.physical_router_serial_number = value
    # end set_physical_router_serial_number

    @vnc_api.gen.resource_common.PhysicalRouter.physical_router_vnc_managed.setter
    def physical_router_vnc_managed(self, physical_router_vnc_managed):
        """Set physical-router-vnc-managed for physical-router.
        
        :param physical_router_vnc_managed: xsd:boolean object
        
        """
        if 'physical_router_vnc_managed' not in self._pending_field_updates:
            self._pending_field_updates.add('physical_router_vnc_managed')

        self._physical_router_vnc_managed = physical_router_vnc_managed
    # end physical_router_vnc_managed

    def set_physical_router_vnc_managed(self, value):
        self.physical_router_vnc_managed = value
    # end set_physical_router_vnc_managed

    @vnc_api.gen.resource_common.PhysicalRouter.physical_router_underlay_managed.setter
    def physical_router_underlay_managed(self, physical_router_underlay_managed):
        """Set physical-router-underlay-managed for physical-router.
        
        :param physical_router_underlay_managed: xsd:boolean object
        
        """
        if 'physical_router_underlay_managed' not in self._pending_field_updates:
            self._pending_field_updates.add('physical_router_underlay_managed')

        self._physical_router_underlay_managed = physical_router_underlay_managed
    # end physical_router_underlay_managed

    def set_physical_router_underlay_managed(self, value):
        self.physical_router_underlay_managed = value
    # end set_physical_router_underlay_managed

    @vnc_api.gen.resource_common.PhysicalRouter.physical_router_role.setter
    def physical_router_role(self, physical_router_role):
        """Set physical-router-role for physical-router.
        
        :param physical_router_role: PhysicalRouterRole object
        
        """
        if 'physical_router_role' not in self._pending_field_updates:
            self._pending_field_updates.add('physical_router_role')

        self._physical_router_role = physical_router_role
    # end physical_router_role

    def set_physical_router_role(self, value):
        self.physical_router_role = value
    # end set_physical_router_role

    @vnc_api.gen.resource_common.PhysicalRouter.routing_bridging_roles.setter
    def routing_bridging_roles(self, routing_bridging_roles):
        """Set routing-bridging-roles for physical-router.
        
        :param routing_bridging_roles: RoutingBridgingRolesType object
        
        """
        if 'routing_bridging_roles' not in self._pending_field_updates:
            self._pending_field_updates.add('routing_bridging_roles')

        self._routing_bridging_roles = routing_bridging_roles
    # end routing_bridging_roles

    def set_routing_bridging_roles(self, value):
        self.routing_bridging_roles = value
    # end set_routing_bridging_roles

    @vnc_api.gen.resource_common.PhysicalRouter.physical_router_snmp.setter
    def physical_router_snmp(self, physical_router_snmp):
        """Set physical-router-snmp for physical-router.
        
        :param physical_router_snmp: xsd:boolean object
        
        """
        if 'physical_router_snmp' not in self._pending_field_updates:
            self._pending_field_updates.add('physical_router_snmp')

        self._physical_router_snmp = physical_router_snmp
    # end physical_router_snmp

    def set_physical_router_snmp(self, value):
        self.physical_router_snmp = value
    # end set_physical_router_snmp

    @vnc_api.gen.resource_common.PhysicalRouter.physical_router_lldp.setter
    def physical_router_lldp(self, physical_router_lldp):
        """Set physical-router-lldp for physical-router.
        
        :param physical_router_lldp: xsd:boolean object
        
        """
        if 'physical_router_lldp' not in self._pending_field_updates:
            self._pending_field_updates.add('physical_router_lldp')

        self._physical_router_lldp = physical_router_lldp
    # end physical_router_lldp

    def set_physical_router_lldp(self, value):
        self.physical_router_lldp = value
    # end set_physical_router_lldp

    @vnc_api.gen.resource_common.PhysicalRouter.physical_router_user_credentials.setter
    def physical_router_user_credentials(self, physical_router_user_credentials):
        """Set physical-router-user-credentials for physical-router.
        
        :param physical_router_user_credentials: UserCredentials object
        
        """
        if 'physical_router_user_credentials' not in self._pending_field_updates:
            self._pending_field_updates.add('physical_router_user_credentials')

        self._physical_router_user_credentials = physical_router_user_credentials
    # end physical_router_user_credentials

    def set_physical_router_user_credentials(self, value):
        self.physical_router_user_credentials = value
    # end set_physical_router_user_credentials

    @vnc_api.gen.resource_common.PhysicalRouter.physical_router_encryption_type.setter
    def physical_router_encryption_type(self, physical_router_encryption_type):
        """Set physical-router-encryption-type for physical-router.
        
        :param physical_router_encryption_type: CredentialEncryptionType object
        
        """
        if 'physical_router_encryption_type' not in self._pending_field_updates:
            self._pending_field_updates.add('physical_router_encryption_type')

        self._physical_router_encryption_type = physical_router_encryption_type
    # end physical_router_encryption_type

    def set_physical_router_encryption_type(self, value):
        self.physical_router_encryption_type = value
    # end set_physical_router_encryption_type

    @vnc_api.gen.resource_common.PhysicalRouter.physical_router_snmp_credentials.setter
    def physical_router_snmp_credentials(self, physical_router_snmp_credentials):
        """Set physical-router-snmp-credentials for physical-router.
        
        :param physical_router_snmp_credentials: SNMPCredentials object
        
        """
        if 'physical_router_snmp_credentials' not in self._pending_field_updates:
            self._pending_field_updates.add('physical_router_snmp_credentials')

        self._physical_router_snmp_credentials = physical_router_snmp_credentials
    # end physical_router_snmp_credentials

    def set_physical_router_snmp_credentials(self, value):
        self.physical_router_snmp_credentials = value
    # end set_physical_router_snmp_credentials

    @vnc_api.gen.resource_common.PhysicalRouter.physical_router_dhcp_parameters.setter
    def physical_router_dhcp_parameters(self, physical_router_dhcp_parameters):
        """Set physical-router-dhcp-parameters for physical-router.
        
        :param physical_router_dhcp_parameters: DnsmasqLeaseParameters object
        
        """
        if 'physical_router_dhcp_parameters' not in self._pending_field_updates:
            self._pending_field_updates.add('physical_router_dhcp_parameters')

        self._physical_router_dhcp_parameters = physical_router_dhcp_parameters
    # end physical_router_dhcp_parameters

    def set_physical_router_dhcp_parameters(self, value):
        self.physical_router_dhcp_parameters = value
    # end set_physical_router_dhcp_parameters

    @vnc_api.gen.resource_common.PhysicalRouter.physical_router_cli_commit_state.setter
    def physical_router_cli_commit_state(self, physical_router_cli_commit_state):
        """Set physical-router-cli-commit-state for physical-router.
        
        :param physical_router_cli_commit_state: CommitStateType object
        
        """
        if 'physical_router_cli_commit_state' not in self._pending_field_updates:
            self._pending_field_updates.add('physical_router_cli_commit_state')

        self._physical_router_cli_commit_state = physical_router_cli_commit_state
    # end physical_router_cli_commit_state

    def set_physical_router_cli_commit_state(self, value):
        self.physical_router_cli_commit_state = value
    # end set_physical_router_cli_commit_state

    @vnc_api.gen.resource_common.PhysicalRouter.physical_router_managed_state.setter
    def physical_router_managed_state(self, physical_router_managed_state):
        """Set physical-router-managed-state for physical-router.
        
        :param physical_router_managed_state: ManagedStateType object
        
        """
        if 'physical_router_managed_state' not in self._pending_field_updates:
            self._pending_field_updates.add('physical_router_managed_state')

        self._physical_router_managed_state = physical_router_managed_state
    # end physical_router_managed_state

    def set_physical_router_managed_state(self, value):
        self.physical_router_managed_state = value
    # end set_physical_router_managed_state

    @vnc_api.gen.resource_common.PhysicalRouter.physical_router_underlay_config.setter
    def physical_router_underlay_config(self, physical_router_underlay_config):
        """Set physical-router-underlay-config for physical-router.
        
        :param physical_router_underlay_config: xsd:string object
        
        """
        if 'physical_router_underlay_config' not in self._pending_field_updates:
            self._pending_field_updates.add('physical_router_underlay_config')

        self._physical_router_underlay_config = physical_router_underlay_config
    # end physical_router_underlay_config

    def set_physical_router_underlay_config(self, value):
        self.physical_router_underlay_config = value
    # end set_physical_router_underlay_config

    @vnc_api.gen.resource_common.PhysicalRouter.physical_router_supplemental_config.setter
    def physical_router_supplemental_config(self, physical_router_supplemental_config):
        """Set physical-router-supplemental-config for physical-router.
        
        :param physical_router_supplemental_config: xsd:string object
        
        """
        if 'physical_router_supplemental_config' not in self._pending_field_updates:
            self._pending_field_updates.add('physical_router_supplemental_config')

        self._physical_router_supplemental_config = physical_router_supplemental_config
    # end physical_router_supplemental_config

    def set_physical_router_supplemental_config(self, value):
        self.physical_router_supplemental_config = value
    # end set_physical_router_supplemental_config

    @vnc_api.gen.resource_common.PhysicalRouter.physical_router_autonomous_system.setter
    def physical_router_autonomous_system(self, physical_router_autonomous_system):
        """Set physical-router-autonomous-system for physical-router.
        
        :param physical_router_autonomous_system: AutonomousSystemsType object
        
        """
        if 'physical_router_autonomous_system' not in self._pending_field_updates:
            self._pending_field_updates.add('physical_router_autonomous_system')

        self._physical_router_autonomous_system = physical_router_autonomous_system
    # end physical_router_autonomous_system

    def set_physical_router_autonomous_system(self, value):
        self.physical_router_autonomous_system = value
    # end set_physical_router_autonomous_system

    @vnc_api.gen.resource_common.PhysicalRouter.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for physical-router.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.PhysicalRouter.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for physical-router.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.PhysicalRouter.annotations.setter
    def annotations(self, annotations):
        """Set annotations for physical-router.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.PhysicalRouter.display_name.setter
    def display_name(self, display_name):
        """Set display-name for physical-router.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for physical-router.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for physical-router.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_virtual_router(self, *args, **kwargs):
        """Set virtual-router for physical-router.
        
        :param ref_obj: VirtualRouter object
        
        """
        self._pending_field_updates.add('virtual_router_refs')
        self._pending_ref_updates.discard('virtual_router_refs')
        super(PhysicalRouter, self).set_virtual_router(*args, **kwargs)

    # end set_virtual_router

    def add_virtual_router(self, *args, **kwargs):
        """Add virtual-router to physical-router.
        
        :param ref_obj: VirtualRouter object
        
        """
        if 'virtual_router_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('virtual_router_refs')
            self._original_virtual_router_refs = copy.deepcopy(self.get_virtual_router_refs() or [])
        super(PhysicalRouter, self).add_virtual_router(*args, **kwargs)
    # end add_virtual_router

    def del_virtual_router(self, *args, **kwargs):
        if 'virtual_router_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('virtual_router_refs')
            self._original_virtual_router_refs = copy.deepcopy(self.get_virtual_router_refs() or [])
        super(PhysicalRouter, self).del_virtual_router(*args, **kwargs)
    # end del_virtual_router

    def set_virtual_router_list(self, *args, **kwargs):
        """Set virtual-router list for physical-router.
        
        :param ref_obj_list: list of VirtualRouter object
        
        """
        self._pending_field_updates.add('virtual_router_refs')
        self._pending_ref_updates.discard('virtual_router_refs')
        super(PhysicalRouter, self).set_virtual_router_list(*args, **kwargs)
    # end set_virtual_router_list

    def set_bgp_router(self, *args, **kwargs):
        """Set bgp-router for physical-router.
        
        :param ref_obj: BgpRouter object
        
        """
        self._pending_field_updates.add('bgp_router_refs')
        self._pending_ref_updates.discard('bgp_router_refs')
        super(PhysicalRouter, self).set_bgp_router(*args, **kwargs)

    # end set_bgp_router

    def add_bgp_router(self, *args, **kwargs):
        """Add bgp-router to physical-router.
        
        :param ref_obj: BgpRouter object
        
        """
        if 'bgp_router_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('bgp_router_refs')
            self._original_bgp_router_refs = copy.deepcopy(self.get_bgp_router_refs() or [])
        super(PhysicalRouter, self).add_bgp_router(*args, **kwargs)
    # end add_bgp_router

    def del_bgp_router(self, *args, **kwargs):
        if 'bgp_router_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('bgp_router_refs')
            self._original_bgp_router_refs = copy.deepcopy(self.get_bgp_router_refs() or [])
        super(PhysicalRouter, self).del_bgp_router(*args, **kwargs)
    # end del_bgp_router

    def set_bgp_router_list(self, *args, **kwargs):
        """Set bgp-router list for physical-router.
        
        :param ref_obj_list: list of BgpRouter object
        
        """
        self._pending_field_updates.add('bgp_router_refs')
        self._pending_ref_updates.discard('bgp_router_refs')
        super(PhysicalRouter, self).set_bgp_router_list(*args, **kwargs)
    # end set_bgp_router_list

    def set_virtual_network(self, *args, **kwargs):
        """Set virtual-network for physical-router.
        
        :param ref_obj: VirtualNetwork object
        
        """
        self._pending_field_updates.add('virtual_network_refs')
        self._pending_ref_updates.discard('virtual_network_refs')
        super(PhysicalRouter, self).set_virtual_network(*args, **kwargs)

    # end set_virtual_network

    def add_virtual_network(self, *args, **kwargs):
        """Add virtual-network to physical-router.
        
        :param ref_obj: VirtualNetwork object
        
        """
        if 'virtual_network_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('virtual_network_refs')
            self._original_virtual_network_refs = copy.deepcopy(self.get_virtual_network_refs() or [])
        super(PhysicalRouter, self).add_virtual_network(*args, **kwargs)
    # end add_virtual_network

    def del_virtual_network(self, *args, **kwargs):
        if 'virtual_network_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('virtual_network_refs')
            self._original_virtual_network_refs = copy.deepcopy(self.get_virtual_network_refs() or [])
        super(PhysicalRouter, self).del_virtual_network(*args, **kwargs)
    # end del_virtual_network

    def set_virtual_network_list(self, *args, **kwargs):
        """Set virtual-network list for physical-router.
        
        :param ref_obj_list: list of VirtualNetwork object
        
        """
        self._pending_field_updates.add('virtual_network_refs')
        self._pending_ref_updates.discard('virtual_network_refs')
        super(PhysicalRouter, self).set_virtual_network_list(*args, **kwargs)
    # end set_virtual_network_list

    def set_intent_map(self, *args, **kwargs):
        """Set intent-map for physical-router.
        
        :param ref_obj: IntentMap object
        
        """
        self._pending_field_updates.add('intent_map_refs')
        self._pending_ref_updates.discard('intent_map_refs')
        super(PhysicalRouter, self).set_intent_map(*args, **kwargs)

    # end set_intent_map

    def add_intent_map(self, *args, **kwargs):
        """Add intent-map to physical-router.
        
        :param ref_obj: IntentMap object
        
        """
        if 'intent_map_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('intent_map_refs')
            self._original_intent_map_refs = copy.deepcopy(self.get_intent_map_refs() or [])
        super(PhysicalRouter, self).add_intent_map(*args, **kwargs)
    # end add_intent_map

    def del_intent_map(self, *args, **kwargs):
        if 'intent_map_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('intent_map_refs')
            self._original_intent_map_refs = copy.deepcopy(self.get_intent_map_refs() or [])
        super(PhysicalRouter, self).del_intent_map(*args, **kwargs)
    # end del_intent_map

    def set_intent_map_list(self, *args, **kwargs):
        """Set intent-map list for physical-router.
        
        :param ref_obj_list: list of IntentMap object
        
        """
        self._pending_field_updates.add('intent_map_refs')
        self._pending_ref_updates.discard('intent_map_refs')
        super(PhysicalRouter, self).set_intent_map_list(*args, **kwargs)
    # end set_intent_map_list

    def set_fabric(self, *args, **kwargs):
        """Set fabric for physical-router.
        
        :param ref_obj: Fabric object
        
        """
        self._pending_field_updates.add('fabric_refs')
        self._pending_ref_updates.discard('fabric_refs')
        super(PhysicalRouter, self).set_fabric(*args, **kwargs)

    # end set_fabric

    def add_fabric(self, *args, **kwargs):
        """Add fabric to physical-router.
        
        :param ref_obj: Fabric object
        
        """
        if 'fabric_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('fabric_refs')
            self._original_fabric_refs = copy.deepcopy(self.get_fabric_refs() or [])
        super(PhysicalRouter, self).add_fabric(*args, **kwargs)
    # end add_fabric

    def del_fabric(self, *args, **kwargs):
        if 'fabric_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('fabric_refs')
            self._original_fabric_refs = copy.deepcopy(self.get_fabric_refs() or [])
        super(PhysicalRouter, self).del_fabric(*args, **kwargs)
    # end del_fabric

    def set_fabric_list(self, *args, **kwargs):
        """Set fabric list for physical-router.
        
        :param ref_obj_list: list of Fabric object
        
        """
        self._pending_field_updates.add('fabric_refs')
        self._pending_ref_updates.discard('fabric_refs')
        super(PhysicalRouter, self).set_fabric_list(*args, **kwargs)
    # end set_fabric_list

    def set_node_profile(self, *args, **kwargs):
        """Set node-profile for physical-router.
        
        :param ref_obj: NodeProfile object
        
        """
        self._pending_field_updates.add('node_profile_refs')
        self._pending_ref_updates.discard('node_profile_refs')
        super(PhysicalRouter, self).set_node_profile(*args, **kwargs)

    # end set_node_profile

    def add_node_profile(self, *args, **kwargs):
        """Add node-profile to physical-router.
        
        :param ref_obj: NodeProfile object
        
        """
        if 'node_profile_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('node_profile_refs')
            self._original_node_profile_refs = copy.deepcopy(self.get_node_profile_refs() or [])
        super(PhysicalRouter, self).add_node_profile(*args, **kwargs)
    # end add_node_profile

    def del_node_profile(self, *args, **kwargs):
        if 'node_profile_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('node_profile_refs')
            self._original_node_profile_refs = copy.deepcopy(self.get_node_profile_refs() or [])
        super(PhysicalRouter, self).del_node_profile(*args, **kwargs)
    # end del_node_profile

    def set_node_profile_list(self, *args, **kwargs):
        """Set node-profile list for physical-router.
        
        :param ref_obj_list: list of NodeProfile object
        
        """
        self._pending_field_updates.add('node_profile_refs')
        self._pending_ref_updates.discard('node_profile_refs')
        super(PhysicalRouter, self).set_node_profile_list(*args, **kwargs)
    # end set_node_profile_list

    def set_device_functional_group(self, *args, **kwargs):
        """Set device-functional-group for physical-router.
        
        :param ref_obj: DeviceFunctionalGroup object
        
        """
        self._pending_field_updates.add('device_functional_group_refs')
        self._pending_ref_updates.discard('device_functional_group_refs')
        super(PhysicalRouter, self).set_device_functional_group(*args, **kwargs)

    # end set_device_functional_group

    def add_device_functional_group(self, *args, **kwargs):
        """Add device-functional-group to physical-router.
        
        :param ref_obj: DeviceFunctionalGroup object
        
        """
        if 'device_functional_group_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('device_functional_group_refs')
            self._original_device_functional_group_refs = copy.deepcopy(self.get_device_functional_group_refs() or [])
        super(PhysicalRouter, self).add_device_functional_group(*args, **kwargs)
    # end add_device_functional_group

    def del_device_functional_group(self, *args, **kwargs):
        if 'device_functional_group_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('device_functional_group_refs')
            self._original_device_functional_group_refs = copy.deepcopy(self.get_device_functional_group_refs() or [])
        super(PhysicalRouter, self).del_device_functional_group(*args, **kwargs)
    # end del_device_functional_group

    def set_device_functional_group_list(self, *args, **kwargs):
        """Set device-functional-group list for physical-router.
        
        :param ref_obj_list: list of DeviceFunctionalGroup object
        
        """
        self._pending_field_updates.add('device_functional_group_refs')
        self._pending_ref_updates.discard('device_functional_group_refs')
        super(PhysicalRouter, self).set_device_functional_group_list(*args, **kwargs)
    # end set_device_functional_group_list

    def set_device_chassis(self, *args, **kwargs):
        """Set device-chassis for physical-router.
        
        :param ref_obj: DeviceChassis object
        
        """
        self._pending_field_updates.add('device_chassis_refs')
        self._pending_ref_updates.discard('device_chassis_refs')
        super(PhysicalRouter, self).set_device_chassis(*args, **kwargs)

    # end set_device_chassis

    def add_device_chassis(self, *args, **kwargs):
        """Add device-chassis to physical-router.
        
        :param ref_obj: DeviceChassis object
        
        """
        if 'device_chassis_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('device_chassis_refs')
            self._original_device_chassis_refs = copy.deepcopy(self.get_device_chassis_refs() or [])
        super(PhysicalRouter, self).add_device_chassis(*args, **kwargs)
    # end add_device_chassis

    def del_device_chassis(self, *args, **kwargs):
        if 'device_chassis_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('device_chassis_refs')
            self._original_device_chassis_refs = copy.deepcopy(self.get_device_chassis_refs() or [])
        super(PhysicalRouter, self).del_device_chassis(*args, **kwargs)
    # end del_device_chassis

    def set_device_chassis_list(self, *args, **kwargs):
        """Set device-chassis list for physical-router.
        
        :param ref_obj_list: list of DeviceChassis object
        
        """
        self._pending_field_updates.add('device_chassis_refs')
        self._pending_ref_updates.discard('device_chassis_refs')
        super(PhysicalRouter, self).set_device_chassis_list(*args, **kwargs)
    # end set_device_chassis_list

    def set_device_image(self, *args, **kwargs):
        """Set device-image for physical-router.
        
        :param ref_obj: DeviceImage object
        
        """
        self._pending_field_updates.add('device_image_refs')
        self._pending_ref_updates.discard('device_image_refs')
        super(PhysicalRouter, self).set_device_image(*args, **kwargs)

    # end set_device_image

    def add_device_image(self, *args, **kwargs):
        """Add device-image to physical-router.
        
        :param ref_obj: DeviceImage object
        
        """
        if 'device_image_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('device_image_refs')
            self._original_device_image_refs = copy.deepcopy(self.get_device_image_refs() or [])
        super(PhysicalRouter, self).add_device_image(*args, **kwargs)
    # end add_device_image

    def del_device_image(self, *args, **kwargs):
        if 'device_image_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('device_image_refs')
            self._original_device_image_refs = copy.deepcopy(self.get_device_image_refs() or [])
        super(PhysicalRouter, self).del_device_image(*args, **kwargs)
    # end del_device_image

    def set_device_image_list(self, *args, **kwargs):
        """Set device-image list for physical-router.
        
        :param ref_obj_list: list of DeviceImage object
        
        """
        self._pending_field_updates.add('device_image_refs')
        self._pending_ref_updates.discard('device_image_refs')
        super(PhysicalRouter, self).set_device_image_list(*args, **kwargs)
    # end set_device_image_list

    def set_physical_role(self, *args, **kwargs):
        """Set physical-role for physical-router.
        
        :param ref_obj: PhysicalRole object
        
        """
        self._pending_field_updates.add('physical_role_refs')
        self._pending_ref_updates.discard('physical_role_refs')
        super(PhysicalRouter, self).set_physical_role(*args, **kwargs)

    # end set_physical_role

    def add_physical_role(self, *args, **kwargs):
        """Add physical-role to physical-router.
        
        :param ref_obj: PhysicalRole object
        
        """
        if 'physical_role_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('physical_role_refs')
            self._original_physical_role_refs = copy.deepcopy(self.get_physical_role_refs() or [])
        super(PhysicalRouter, self).add_physical_role(*args, **kwargs)
    # end add_physical_role

    def del_physical_role(self, *args, **kwargs):
        if 'physical_role_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('physical_role_refs')
            self._original_physical_role_refs = copy.deepcopy(self.get_physical_role_refs() or [])
        super(PhysicalRouter, self).del_physical_role(*args, **kwargs)
    # end del_physical_role

    def set_physical_role_list(self, *args, **kwargs):
        """Set physical-role list for physical-router.
        
        :param ref_obj_list: list of PhysicalRole object
        
        """
        self._pending_field_updates.add('physical_role_refs')
        self._pending_ref_updates.discard('physical_role_refs')
        super(PhysicalRouter, self).set_physical_role_list(*args, **kwargs)
    # end set_physical_role_list

    def set_overlay_role(self, *args, **kwargs):
        """Set overlay-role for physical-router.
        
        :param ref_obj: OverlayRole object
        
        """
        self._pending_field_updates.add('overlay_role_refs')
        self._pending_ref_updates.discard('overlay_role_refs')
        super(PhysicalRouter, self).set_overlay_role(*args, **kwargs)

    # end set_overlay_role

    def add_overlay_role(self, *args, **kwargs):
        """Add overlay-role to physical-router.
        
        :param ref_obj: OverlayRole object
        
        """
        if 'overlay_role_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('overlay_role_refs')
            self._original_overlay_role_refs = copy.deepcopy(self.get_overlay_role_refs() or [])
        super(PhysicalRouter, self).add_overlay_role(*args, **kwargs)
    # end add_overlay_role

    def del_overlay_role(self, *args, **kwargs):
        if 'overlay_role_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('overlay_role_refs')
            self._original_overlay_role_refs = copy.deepcopy(self.get_overlay_role_refs() or [])
        super(PhysicalRouter, self).del_overlay_role(*args, **kwargs)
    # end del_overlay_role

    def set_overlay_role_list(self, *args, **kwargs):
        """Set overlay-role list for physical-router.
        
        :param ref_obj_list: list of OverlayRole object
        
        """
        self._pending_field_updates.add('overlay_role_refs')
        self._pending_ref_updates.discard('overlay_role_refs')
        super(PhysicalRouter, self).set_overlay_role_list(*args, **kwargs)
    # end set_overlay_role_list

    def set_telemetry_profile(self, *args, **kwargs):
        """Set telemetry-profile for physical-router.
        
        :param ref_obj: TelemetryProfile object
        
        """
        self._pending_field_updates.add('telemetry_profile_refs')
        self._pending_ref_updates.discard('telemetry_profile_refs')
        super(PhysicalRouter, self).set_telemetry_profile(*args, **kwargs)

    # end set_telemetry_profile

    def add_telemetry_profile(self, *args, **kwargs):
        """Add telemetry-profile to physical-router.
        
        :param ref_obj: TelemetryProfile object
        
        """
        if 'telemetry_profile_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('telemetry_profile_refs')
            self._original_telemetry_profile_refs = copy.deepcopy(self.get_telemetry_profile_refs() or [])
        super(PhysicalRouter, self).add_telemetry_profile(*args, **kwargs)
    # end add_telemetry_profile

    def del_telemetry_profile(self, *args, **kwargs):
        if 'telemetry_profile_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('telemetry_profile_refs')
            self._original_telemetry_profile_refs = copy.deepcopy(self.get_telemetry_profile_refs() or [])
        super(PhysicalRouter, self).del_telemetry_profile(*args, **kwargs)
    # end del_telemetry_profile

    def set_telemetry_profile_list(self, *args, **kwargs):
        """Set telemetry-profile list for physical-router.
        
        :param ref_obj_list: list of TelemetryProfile object
        
        """
        self._pending_field_updates.add('telemetry_profile_refs')
        self._pending_ref_updates.discard('telemetry_profile_refs')
        super(PhysicalRouter, self).set_telemetry_profile_list(*args, **kwargs)
    # end set_telemetry_profile_list

    def set_tag(self, *args, **kwargs):
        """Set tag for physical-router.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(PhysicalRouter, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to physical-router.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(PhysicalRouter, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(PhysicalRouter, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for physical-router.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(PhysicalRouter, self).set_tag_list(*args, **kwargs)
    # end set_tag_list

    def get_link_aggregation_groups(self):
        if hasattr(self, 'link_aggregation_groups'):
            return self.link_aggregation_groups

        if hasattr(super(PhysicalRouter, self), 'link_aggregation_groups'):
            return super(PhysicalRouter, self).get_link_aggregation_groups()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.physical_router_read(id = self.uuid, fields = ['link_aggregation_groups'])
        except NoIdError:
            return None
        children = getattr(obj, 'link_aggregation_groups', None)
        if not children:
            return None
        self.link_aggregation_groups = children

        return children
    # end get_link_aggregation_groups

    def get_hardware_inventorys(self):
        if hasattr(self, 'hardware_inventorys'):
            return self.hardware_inventorys

        if hasattr(super(PhysicalRouter, self), 'hardware_inventorys'):
            return super(PhysicalRouter, self).get_hardware_inventorys()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.physical_router_read(id = self.uuid, fields = ['hardware_inventorys'])
        except NoIdError:
            return None
        children = getattr(obj, 'hardware_inventorys', None)
        if not children:
            return None
        self.hardware_inventorys = children

        return children
    # end get_hardware_inventorys

    def get_cli_configs(self):
        if hasattr(self, 'cli_configs'):
            return self.cli_configs

        if hasattr(super(PhysicalRouter, self), 'cli_configs'):
            return super(PhysicalRouter, self).get_cli_configs()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.physical_router_read(id = self.uuid, fields = ['cli_configs'])
        except NoIdError:
            return None
        children = getattr(obj, 'cli_configs', None)
        if not children:
            return None
        self.cli_configs = children

        return children
    # end get_cli_configs

    def get_physical_interfaces(self):
        if hasattr(self, 'physical_interfaces'):
            return self.physical_interfaces

        if hasattr(super(PhysicalRouter, self), 'physical_interfaces'):
            return super(PhysicalRouter, self).get_physical_interfaces()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.physical_router_read(id = self.uuid, fields = ['physical_interfaces'])
        except NoIdError:
            return None
        children = getattr(obj, 'physical_interfaces', None)
        if not children:
            return None
        self.physical_interfaces = children

        return children
    # end get_physical_interfaces

    def get_logical_interfaces(self):
        if hasattr(self, 'logical_interfaces'):
            return self.logical_interfaces

        if hasattr(super(PhysicalRouter, self), 'logical_interfaces'):
            return super(PhysicalRouter, self).get_logical_interfaces()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.physical_router_read(id = self.uuid, fields = ['logical_interfaces'])
        except NoIdError:
            return None
        children = getattr(obj, 'logical_interfaces', None)
        if not children:
            return None
        self.logical_interfaces = children

        return children
    # end get_logical_interfaces


    def get_instance_ip_back_refs(self):
        """Return list of all instance-ips using this physical-router"""
        if hasattr(self, 'instance_ip_back_refs'):
            return self.instance_ip_back_refs

        if hasattr(super(PhysicalRouter, self), 'instance_ip_back_refs'):
            return super(PhysicalRouter, self).get_instance_ip_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.physical_router_read(id = self.uuid, fields = ['instance_ip_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'instance_ip_back_refs', None)
        if not back_refs:
            return None
        self.instance_ip_back_refs = back_refs

        return back_refs
    # end get_instance_ip_back_refs

    def get_logical_router_back_refs(self):
        """Return list of all logical-routers using this physical-router"""
        if hasattr(self, 'logical_router_back_refs'):
            return self.logical_router_back_refs

        if hasattr(super(PhysicalRouter, self), 'logical_router_back_refs'):
            return super(PhysicalRouter, self).get_logical_router_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.physical_router_read(id = self.uuid, fields = ['logical_router_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'logical_router_back_refs', None)
        if not back_refs:
            return None
        self.logical_router_back_refs = back_refs

        return back_refs
    # end get_logical_router_back_refs

    def get_service_endpoint_back_refs(self):
        """Return list of all service-endpoints using this physical-router"""
        if hasattr(self, 'service_endpoint_back_refs'):
            return self.service_endpoint_back_refs

        if hasattr(super(PhysicalRouter, self), 'service_endpoint_back_refs'):
            return super(PhysicalRouter, self).get_service_endpoint_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.physical_router_read(id = self.uuid, fields = ['service_endpoint_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'service_endpoint_back_refs', None)
        if not back_refs:
            return None
        self.service_endpoint_back_refs = back_refs

        return back_refs
    # end get_service_endpoint_back_refs

    def get_network_device_config_back_refs(self):
        """Return list of all network-device-configs using this physical-router"""
        if hasattr(self, 'network_device_config_back_refs'):
            return self.network_device_config_back_refs

        if hasattr(super(PhysicalRouter, self), 'network_device_config_back_refs'):
            return super(PhysicalRouter, self).get_network_device_config_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.physical_router_read(id = self.uuid, fields = ['network_device_config_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'network_device_config_back_refs', None)
        if not back_refs:
            return None
        self.network_device_config_back_refs = back_refs

        return back_refs
    # end get_network_device_config_back_refs

    def get_e2_service_provider_back_refs(self):
        """Return list of all e2-service-providers using this physical-router"""
        if hasattr(self, 'e2_service_provider_back_refs'):
            return self.e2_service_provider_back_refs

        if hasattr(super(PhysicalRouter, self), 'e2_service_provider_back_refs'):
            return super(PhysicalRouter, self).get_e2_service_provider_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.physical_router_read(id = self.uuid, fields = ['e2_service_provider_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'e2_service_provider_back_refs', None)
        if not back_refs:
            return None
        self.e2_service_provider_back_refs = back_refs

        return back_refs
    # end get_e2_service_provider_back_refs

# end class PhysicalRouter

class ConfigRoot(vnc_api.gen.resource_common.ConfigRoot):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, *args, **kwargs):
        pending_fields = ['fq_name']

        self._server_conn = None

        if len(args) > 0 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 1 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 2 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 3 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(ConfigRoot, self).__init__(name, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = ConfigRoot(**props_dict)
        else:
            obj = ConfigRoot(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...
        try:
            obj.global_system_configs = kwargs[u'global_system_configs']
        except KeyError:
            pass
        try:
            obj.domains = kwargs[u'domains']
        except KeyError:
            pass
        try:
            obj.policy_managements = kwargs[u'policy_managements']
        except KeyError:
            pass
        try:
            obj.tags = kwargs[u'tags']
        except KeyError:
            pass

        # add any specified references...
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.ConfigRoot.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.ConfigRoot.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for config-root.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.ConfigRoot.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for config-root.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.ConfigRoot.annotations.setter
    def annotations(self, annotations):
        """Set annotations for config-root.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.ConfigRoot.display_name.setter
    def display_name(self, display_name):
        """Set display-name for config-root.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for config-root.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for config-root.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_tag(self, *args, **kwargs):
        """Set tag for config-root.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(ConfigRoot, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to config-root.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(ConfigRoot, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(ConfigRoot, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for config-root.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(ConfigRoot, self).set_tag_list(*args, **kwargs)
    # end set_tag_list

    def get_global_system_configs(self):
        if hasattr(self, 'global_system_configs'):
            return self.global_system_configs

        if hasattr(super(ConfigRoot, self), 'global_system_configs'):
            return super(ConfigRoot, self).get_global_system_configs()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.config_root_read(id = self.uuid, fields = ['global_system_configs'])
        except NoIdError:
            return None
        children = getattr(obj, 'global_system_configs', None)
        if not children:
            return None
        self.global_system_configs = children

        return children
    # end get_global_system_configs

    def get_domains(self):
        if hasattr(self, 'domains'):
            return self.domains

        if hasattr(super(ConfigRoot, self), 'domains'):
            return super(ConfigRoot, self).get_domains()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.config_root_read(id = self.uuid, fields = ['domains'])
        except NoIdError:
            return None
        children = getattr(obj, 'domains', None)
        if not children:
            return None
        self.domains = children

        return children
    # end get_domains

    def get_policy_managements(self):
        if hasattr(self, 'policy_managements'):
            return self.policy_managements

        if hasattr(super(ConfigRoot, self), 'policy_managements'):
            return super(ConfigRoot, self).get_policy_managements()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.config_root_read(id = self.uuid, fields = ['policy_managements'])
        except NoIdError:
            return None
        children = getattr(obj, 'policy_managements', None)
        if not children:
            return None
        self.policy_managements = children

        return children
    # end get_policy_managements

    def get_tags(self):
        if hasattr(self, 'tags'):
            return self.tags

        if hasattr(super(ConfigRoot, self), 'tags'):
            return super(ConfigRoot, self).get_tags()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.config_root_read(id = self.uuid, fields = ['tags'])
        except NoIdError:
            return None
        children = getattr(obj, 'tags', None)
        if not children:
            return None
        self.tags = children

        return children
    # end get_tags


# end class ConfigRoot

class ServiceTemplate(vnc_api.gen.resource_common.ServiceTemplate):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'service_template_properties' in kwargs:
            pending_fields.append('service_template_properties')
        if len(args) > 1 or 'service_config_managed' in kwargs:
            pending_fields.append('service_config_managed')
        if len(args) > 2 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 3 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 4 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 5 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(ServiceTemplate, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            if kwargs['service_template_properties'] is None:
                props_dict['service_template_properties'] = None
            else:
                props_dict['service_template_properties'] = vnc_api.gen.resource_xsd.ServiceTemplateType(params_dict=kwargs[u'service_template_properties'])
        except KeyError:
            pass

        try:
            props_dict['service_config_managed'] = kwargs[u'service_config_managed']
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = ServiceTemplate(**props_dict)
        else:
            obj = ServiceTemplate(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.service_appliance_set_refs = kwargs[u'service_appliance_set_refs']
        except KeyError:
            pass
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.service_instance_back_refs = kwargs[u'service_instance_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.ServiceTemplate.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.ServiceTemplate.service_template_properties.setter
    def service_template_properties(self, service_template_properties):
        """Set service-template-properties for service-template.
        
        :param service_template_properties: ServiceTemplateType object
        
        """
        if 'service_template_properties' not in self._pending_field_updates:
            self._pending_field_updates.add('service_template_properties')

        self._service_template_properties = service_template_properties
    # end service_template_properties

    def set_service_template_properties(self, value):
        self.service_template_properties = value
    # end set_service_template_properties

    @vnc_api.gen.resource_common.ServiceTemplate.service_config_managed.setter
    def service_config_managed(self, service_config_managed):
        """Set service-config-managed for service-template.
        
        :param service_config_managed: xsd:boolean object
        
        """
        if 'service_config_managed' not in self._pending_field_updates:
            self._pending_field_updates.add('service_config_managed')

        self._service_config_managed = service_config_managed
    # end service_config_managed

    def set_service_config_managed(self, value):
        self.service_config_managed = value
    # end set_service_config_managed

    @vnc_api.gen.resource_common.ServiceTemplate.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for service-template.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.ServiceTemplate.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for service-template.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.ServiceTemplate.annotations.setter
    def annotations(self, annotations):
        """Set annotations for service-template.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.ServiceTemplate.display_name.setter
    def display_name(self, display_name):
        """Set display-name for service-template.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for service-template.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for service-template.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_service_appliance_set(self, *args, **kwargs):
        """Set service-appliance-set for service-template.
        
        :param ref_obj: ServiceApplianceSet object
        
        """
        self._pending_field_updates.add('service_appliance_set_refs')
        self._pending_ref_updates.discard('service_appliance_set_refs')
        super(ServiceTemplate, self).set_service_appliance_set(*args, **kwargs)

    # end set_service_appliance_set

    def add_service_appliance_set(self, *args, **kwargs):
        """Add service-appliance-set to service-template.
        
        :param ref_obj: ServiceApplianceSet object
        
        """
        if 'service_appliance_set_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('service_appliance_set_refs')
            self._original_service_appliance_set_refs = copy.deepcopy(self.get_service_appliance_set_refs() or [])
        super(ServiceTemplate, self).add_service_appliance_set(*args, **kwargs)
    # end add_service_appliance_set

    def del_service_appliance_set(self, *args, **kwargs):
        if 'service_appliance_set_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('service_appliance_set_refs')
            self._original_service_appliance_set_refs = copy.deepcopy(self.get_service_appliance_set_refs() or [])
        super(ServiceTemplate, self).del_service_appliance_set(*args, **kwargs)
    # end del_service_appliance_set

    def set_service_appliance_set_list(self, *args, **kwargs):
        """Set service-appliance-set list for service-template.
        
        :param ref_obj_list: list of ServiceApplianceSet object
        
        """
        self._pending_field_updates.add('service_appliance_set_refs')
        self._pending_ref_updates.discard('service_appliance_set_refs')
        super(ServiceTemplate, self).set_service_appliance_set_list(*args, **kwargs)
    # end set_service_appliance_set_list

    def set_tag(self, *args, **kwargs):
        """Set tag for service-template.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(ServiceTemplate, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to service-template.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(ServiceTemplate, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(ServiceTemplate, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for service-template.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(ServiceTemplate, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


    def get_service_instance_back_refs(self):
        """Return list of all service-instances using this service-template"""
        if hasattr(self, 'service_instance_back_refs'):
            return self.service_instance_back_refs

        if hasattr(super(ServiceTemplate, self), 'service_instance_back_refs'):
            return super(ServiceTemplate, self).get_service_instance_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.service_template_read(id = self.uuid, fields = ['service_instance_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'service_instance_back_refs', None)
        if not back_refs:
            return None
        self.service_instance_back_refs = back_refs

        return back_refs
    # end get_service_instance_back_refs

# end class ServiceTemplate

class HardwareInventory(vnc_api.gen.resource_common.HardwareInventory):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'hardware_inventory_inventory_info' in kwargs:
            pending_fields.append('hardware_inventory_inventory_info')
        if len(args) > 1 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 2 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 3 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 4 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(HardwareInventory, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            props_dict['hardware_inventory_inventory_info'] = kwargs[u'hardware_inventory_inventory_info']
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = HardwareInventory(**props_dict)
        else:
            obj = HardwareInventory(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.HardwareInventory.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.HardwareInventory.hardware_inventory_inventory_info.setter
    def hardware_inventory_inventory_info(self, hardware_inventory_inventory_info):
        """Set hardware-inventory-inventory-info for hardware-inventory.
        
        :param hardware_inventory_inventory_info: xsd:string object
        
        """
        if 'hardware_inventory_inventory_info' not in self._pending_field_updates:
            self._pending_field_updates.add('hardware_inventory_inventory_info')

        self._hardware_inventory_inventory_info = hardware_inventory_inventory_info
    # end hardware_inventory_inventory_info

    def set_hardware_inventory_inventory_info(self, value):
        self.hardware_inventory_inventory_info = value
    # end set_hardware_inventory_inventory_info

    @vnc_api.gen.resource_common.HardwareInventory.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for hardware-inventory.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.HardwareInventory.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for hardware-inventory.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.HardwareInventory.annotations.setter
    def annotations(self, annotations):
        """Set annotations for hardware-inventory.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.HardwareInventory.display_name.setter
    def display_name(self, display_name):
        """Set display-name for hardware-inventory.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for hardware-inventory.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for hardware-inventory.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_tag(self, *args, **kwargs):
        """Set tag for hardware-inventory.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(HardwareInventory, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to hardware-inventory.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(HardwareInventory, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(HardwareInventory, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for hardware-inventory.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(HardwareInventory, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


# end class HardwareInventory

class FirewallPolicy(vnc_api.gen.resource_common.FirewallPolicy):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'draft_mode_state' in kwargs:
            pending_fields.append('draft_mode_state')
        if len(args) > 1 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 2 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 3 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 4 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(FirewallPolicy, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            props_dict['draft_mode_state'] = kwargs[u'draft_mode_state']
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = FirewallPolicy(**props_dict)
        else:
            obj = FirewallPolicy(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.firewall_rule_refs = kwargs[u'firewall_rule_refs']
            for ref in obj.firewall_rule_refs:
                ref['attr'] = vnc_api.gen.resource_xsd.FirewallSequence(params_dict=ref[u'attr'])
        except KeyError:
            pass
        try:
            obj.security_logging_object_refs = kwargs[u'security_logging_object_refs']
            for ref in obj.security_logging_object_refs:
                ref['attr'] = vnc_api.gen.resource_xsd.SloRateType(params_dict=ref[u'attr'])
        except KeyError:
            pass
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.application_policy_set_back_refs = kwargs[u'application_policy_set_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.FirewallPolicy.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.FirewallPolicy.draft_mode_state.setter
    def draft_mode_state(self, draft_mode_state):
        """Set draft-mode-state for firewall-policy.
        
        :param draft_mode_state: DraftModeState object
        
        """
        if 'draft_mode_state' not in self._pending_field_updates:
            self._pending_field_updates.add('draft_mode_state')

        self._draft_mode_state = draft_mode_state
    # end draft_mode_state

    def set_draft_mode_state(self, value):
        self.draft_mode_state = value
    # end set_draft_mode_state

    @vnc_api.gen.resource_common.FirewallPolicy.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for firewall-policy.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.FirewallPolicy.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for firewall-policy.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.FirewallPolicy.annotations.setter
    def annotations(self, annotations):
        """Set annotations for firewall-policy.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.FirewallPolicy.display_name.setter
    def display_name(self, display_name):
        """Set display-name for firewall-policy.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for firewall-policy.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for firewall-policy.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_firewall_rule(self, *args, **kwargs):
        """Set firewall-rule for firewall-policy.
        
        :param ref_obj: FirewallRule object
        :param ref_data: FirewallSequence object
        
        """
        self._pending_field_updates.add('firewall_rule_refs')
        self._pending_ref_updates.discard('firewall_rule_refs')
        super(FirewallPolicy, self).set_firewall_rule(*args, **kwargs)

    # end set_firewall_rule

    def add_firewall_rule(self, *args, **kwargs):
        """Add firewall-rule to firewall-policy.
        
        :param ref_obj: FirewallRule object
        :param ref_data: FirewallSequence object
        
        """
        if 'firewall_rule_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('firewall_rule_refs')
            self._original_firewall_rule_refs = copy.deepcopy(self.get_firewall_rule_refs() or [])
        super(FirewallPolicy, self).add_firewall_rule(*args, **kwargs)
    # end add_firewall_rule

    def del_firewall_rule(self, *args, **kwargs):
        if 'firewall_rule_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('firewall_rule_refs')
            self._original_firewall_rule_refs = copy.deepcopy(self.get_firewall_rule_refs() or [])
        super(FirewallPolicy, self).del_firewall_rule(*args, **kwargs)
    # end del_firewall_rule

    def set_firewall_rule_list(self, *args, **kwargs):
        """Set firewall-rule list for firewall-policy.
        
        :param ref_obj_list: list of FirewallRule object
        :param ref_data_list: list of FirewallSequence summary
        
        """
        self._pending_field_updates.add('firewall_rule_refs')
        self._pending_ref_updates.discard('firewall_rule_refs')
        super(FirewallPolicy, self).set_firewall_rule_list(*args, **kwargs)
    # end set_firewall_rule_list

    def set_security_logging_object(self, *args, **kwargs):
        """Set security-logging-object for firewall-policy.
        
        :param ref_obj: SecurityLoggingObject object
        :param ref_data: SloRateType object
        
        """
        self._pending_field_updates.add('security_logging_object_refs')
        self._pending_ref_updates.discard('security_logging_object_refs')
        super(FirewallPolicy, self).set_security_logging_object(*args, **kwargs)

    # end set_security_logging_object

    def add_security_logging_object(self, *args, **kwargs):
        """Add security-logging-object to firewall-policy.
        
        :param ref_obj: SecurityLoggingObject object
        :param ref_data: SloRateType object
        
        """
        if 'security_logging_object_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('security_logging_object_refs')
            self._original_security_logging_object_refs = copy.deepcopy(self.get_security_logging_object_refs() or [])
        super(FirewallPolicy, self).add_security_logging_object(*args, **kwargs)
    # end add_security_logging_object

    def del_security_logging_object(self, *args, **kwargs):
        if 'security_logging_object_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('security_logging_object_refs')
            self._original_security_logging_object_refs = copy.deepcopy(self.get_security_logging_object_refs() or [])
        super(FirewallPolicy, self).del_security_logging_object(*args, **kwargs)
    # end del_security_logging_object

    def set_security_logging_object_list(self, *args, **kwargs):
        """Set security-logging-object list for firewall-policy.
        
        :param ref_obj_list: list of SecurityLoggingObject object
        :param ref_data_list: list of SloRateType summary
        
        """
        self._pending_field_updates.add('security_logging_object_refs')
        self._pending_ref_updates.discard('security_logging_object_refs')
        super(FirewallPolicy, self).set_security_logging_object_list(*args, **kwargs)
    # end set_security_logging_object_list

    def set_tag(self, *args, **kwargs):
        """Set tag for firewall-policy.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(FirewallPolicy, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to firewall-policy.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(FirewallPolicy, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(FirewallPolicy, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for firewall-policy.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(FirewallPolicy, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


    def get_application_policy_set_back_refs(self):
        """Return list of all application-policy-sets using this firewall-policy"""
        if hasattr(self, 'application_policy_set_back_refs'):
            return self.application_policy_set_back_refs

        if hasattr(super(FirewallPolicy, self), 'application_policy_set_back_refs'):
            return super(FirewallPolicy, self).get_application_policy_set_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.firewall_policy_read(id = self.uuid, fields = ['application_policy_set_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'application_policy_set_back_refs', None)
        if not back_refs:
            return None
        self.application_policy_set_back_refs = back_refs

        return back_refs
    # end get_application_policy_set_back_refs

# end class FirewallPolicy

class RouteTable(vnc_api.gen.resource_common.RouteTable):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'routes' in kwargs:
            pending_fields.append('routes')
        if len(args) > 1 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 2 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 3 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 4 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(RouteTable, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            if kwargs['routes'] is None:
                props_dict['routes'] = None
            else:
                props_dict['routes'] = vnc_api.gen.resource_xsd.RouteTableType(params_dict=kwargs[u'routes'])
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = RouteTable(**props_dict)
        else:
            obj = RouteTable(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.virtual_network_back_refs = kwargs[u'virtual_network_back_refs']
        except KeyError:
            pass
        try:
            obj.logical_router_back_refs = kwargs[u'logical_router_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.RouteTable.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.RouteTable.routes.setter
    def routes(self, routes):
        """Set routes for route-table.
        
        :param routes: RouteTableType object
        
        """
        if 'routes' not in self._pending_field_updates:
            self._pending_field_updates.add('routes')

        self._routes = routes
    # end routes

    def set_routes(self, value):
        self.routes = value
    # end set_routes

    @vnc_api.gen.resource_common.RouteTable.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for route-table.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.RouteTable.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for route-table.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.RouteTable.annotations.setter
    def annotations(self, annotations):
        """Set annotations for route-table.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.RouteTable.display_name.setter
    def display_name(self, display_name):
        """Set display-name for route-table.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for route-table.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for route-table.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_tag(self, *args, **kwargs):
        """Set tag for route-table.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(RouteTable, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to route-table.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(RouteTable, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(RouteTable, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for route-table.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(RouteTable, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


    def get_virtual_network_back_refs(self):
        """Return list of all virtual-networks using this route-table"""
        if hasattr(self, 'virtual_network_back_refs'):
            return self.virtual_network_back_refs

        if hasattr(super(RouteTable, self), 'virtual_network_back_refs'):
            return super(RouteTable, self).get_virtual_network_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.route_table_read(id = self.uuid, fields = ['virtual_network_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'virtual_network_back_refs', None)
        if not back_refs:
            return None
        self.virtual_network_back_refs = back_refs

        return back_refs
    # end get_virtual_network_back_refs

    def get_logical_router_back_refs(self):
        """Return list of all logical-routers using this route-table"""
        if hasattr(self, 'logical_router_back_refs'):
            return self.logical_router_back_refs

        if hasattr(super(RouteTable, self), 'logical_router_back_refs'):
            return super(RouteTable, self).get_logical_router_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.route_table_read(id = self.uuid, fields = ['logical_router_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'logical_router_back_refs', None)
        if not back_refs:
            return None
        self.logical_router_back_refs = back_refs

        return back_refs
    # end get_logical_router_back_refs

# end class RouteTable

class ProviderAttachment(vnc_api.gen.resource_common.ProviderAttachment):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, *args, **kwargs):
        pending_fields = ['fq_name']

        self._server_conn = None

        if len(args) > 0 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 1 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 2 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 3 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(ProviderAttachment, self).__init__(name, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = ProviderAttachment(**props_dict)
        else:
            obj = ProviderAttachment(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.virtual_router_refs = kwargs[u'virtual_router_refs']
        except KeyError:
            pass
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.ProviderAttachment.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.ProviderAttachment.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for provider-attachment.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.ProviderAttachment.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for provider-attachment.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.ProviderAttachment.annotations.setter
    def annotations(self, annotations):
        """Set annotations for provider-attachment.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.ProviderAttachment.display_name.setter
    def display_name(self, display_name):
        """Set display-name for provider-attachment.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for provider-attachment.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for provider-attachment.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_virtual_router(self, *args, **kwargs):
        """Set virtual-router for provider-attachment.
        
        :param ref_obj: VirtualRouter object
        
        """
        self._pending_field_updates.add('virtual_router_refs')
        self._pending_ref_updates.discard('virtual_router_refs')
        super(ProviderAttachment, self).set_virtual_router(*args, **kwargs)

    # end set_virtual_router

    def add_virtual_router(self, *args, **kwargs):
        """Add virtual-router to provider-attachment.
        
        :param ref_obj: VirtualRouter object
        
        """
        if 'virtual_router_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('virtual_router_refs')
            self._original_virtual_router_refs = copy.deepcopy(self.get_virtual_router_refs() or [])
        super(ProviderAttachment, self).add_virtual_router(*args, **kwargs)
    # end add_virtual_router

    def del_virtual_router(self, *args, **kwargs):
        if 'virtual_router_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('virtual_router_refs')
            self._original_virtual_router_refs = copy.deepcopy(self.get_virtual_router_refs() or [])
        super(ProviderAttachment, self).del_virtual_router(*args, **kwargs)
    # end del_virtual_router

    def set_virtual_router_list(self, *args, **kwargs):
        """Set virtual-router list for provider-attachment.
        
        :param ref_obj_list: list of VirtualRouter object
        
        """
        self._pending_field_updates.add('virtual_router_refs')
        self._pending_ref_updates.discard('virtual_router_refs')
        super(ProviderAttachment, self).set_virtual_router_list(*args, **kwargs)
    # end set_virtual_router_list

    def set_tag(self, *args, **kwargs):
        """Set tag for provider-attachment.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(ProviderAttachment, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to provider-attachment.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(ProviderAttachment, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(ProviderAttachment, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for provider-attachment.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(ProviderAttachment, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


# end class ProviderAttachment

class OverlayRole(vnc_api.gen.resource_common.OverlayRole):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 1 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 2 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 3 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(OverlayRole, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = OverlayRole(**props_dict)
        else:
            obj = OverlayRole(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.physical_router_back_refs = kwargs[u'physical_router_back_refs']
        except KeyError:
            pass
        try:
            obj.role_definition_back_refs = kwargs[u'role_definition_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.OverlayRole.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.OverlayRole.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for overlay-role.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.OverlayRole.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for overlay-role.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.OverlayRole.annotations.setter
    def annotations(self, annotations):
        """Set annotations for overlay-role.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.OverlayRole.display_name.setter
    def display_name(self, display_name):
        """Set display-name for overlay-role.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for overlay-role.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for overlay-role.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_tag(self, *args, **kwargs):
        """Set tag for overlay-role.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(OverlayRole, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to overlay-role.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(OverlayRole, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(OverlayRole, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for overlay-role.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(OverlayRole, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


    def get_physical_router_back_refs(self):
        """Return list of all physical-routers using this overlay-role"""
        if hasattr(self, 'physical_router_back_refs'):
            return self.physical_router_back_refs

        if hasattr(super(OverlayRole, self), 'physical_router_back_refs'):
            return super(OverlayRole, self).get_physical_router_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.overlay_role_read(id = self.uuid, fields = ['physical_router_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'physical_router_back_refs', None)
        if not back_refs:
            return None
        self.physical_router_back_refs = back_refs

        return back_refs
    # end get_physical_router_back_refs

    def get_role_definition_back_refs(self):
        """Return list of all role-definitions using this overlay-role"""
        if hasattr(self, 'role_definition_back_refs'):
            return self.role_definition_back_refs

        if hasattr(super(OverlayRole, self), 'role_definition_back_refs'):
            return super(OverlayRole, self).get_role_definition_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.overlay_role_read(id = self.uuid, fields = ['role_definition_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'role_definition_back_refs', None)
        if not back_refs:
            return None
        self.role_definition_back_refs = back_refs

        return back_refs
    # end get_role_definition_back_refs

# end class OverlayRole

class MulticastPolicy(vnc_api.gen.resource_common.MulticastPolicy):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'multicast_source_groups' in kwargs:
            pending_fields.append('multicast_source_groups')
        if len(args) > 1 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 2 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 3 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 4 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(MulticastPolicy, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            if kwargs['multicast_source_groups'] is None:
                props_dict['multicast_source_groups'] = None
            else:
                props_dict['multicast_source_groups'] = vnc_api.gen.resource_xsd.MulticastSourceGroups(params_dict=kwargs[u'multicast_source_groups'])
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = MulticastPolicy(**props_dict)
        else:
            obj = MulticastPolicy(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.virtual_network_back_refs = kwargs[u'virtual_network_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.MulticastPolicy.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.MulticastPolicy.multicast_source_groups.setter
    def multicast_source_groups(self, multicast_source_groups):
        """Set multicast-source-groups for multicast-policy.
        
        :param multicast_source_groups: MulticastSourceGroups object
        
        """
        if 'multicast_source_groups' not in self._pending_field_updates:
            self._pending_field_updates.add('multicast_source_groups')

        if 'multicast_source_groups' in self._pending_field_list_updates:
            # set clobbers earlier add/del on prop list elements
            del self._pending_field_list_updates['multicast_source_groups']

        self._multicast_source_groups = multicast_source_groups
    # end multicast_source_groups

    def set_multicast_source_groups(self, value):
        self.multicast_source_groups = value
    # end set_multicast_source_groups

    @vnc_api.gen.resource_common.MulticastPolicy.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for multicast-policy.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.MulticastPolicy.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for multicast-policy.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.MulticastPolicy.annotations.setter
    def annotations(self, annotations):
        """Set annotations for multicast-policy.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.MulticastPolicy.display_name.setter
    def display_name(self, display_name):
        """Set display-name for multicast-policy.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_multicast_source_groups(self, elem_value, elem_position=None):
        """Add element to multicast-source-groups for multicast-policy.
        
        :param elem_value: xsd:string object
        :param elem_position: optional string order-key
        
        """
        if 'multicast_source_groups' not in self._pending_field_list_updates:
            self._pending_field_list_updates['multicast_source_groups'] = [
                ('add', elem_value, elem_position)]
        else:
            self._pending_field_list_updates['multicast_source_groups'].append(
                ('add', elem_value, elem_position))
    # end add_multicast_source_groups

    def del_multicast_source_groups(self, elem_position):
        """Delete element from multicast-source-groups for multicast-policy.
        
        :param elem_position: string indicating order-key
        
        """
        if 'multicast_source_groups' not in self._pending_field_list_updates:
            self._pending_field_list_updates['multicast_source_groups'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_list_updates['multicast_source_groups'].append(
                ('delete', None, elem_position))
    # end del_multicast_source_groups
    def add_annotations(self, elem):
        """Add element to annotations for multicast-policy.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for multicast-policy.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_tag(self, *args, **kwargs):
        """Set tag for multicast-policy.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(MulticastPolicy, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to multicast-policy.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(MulticastPolicy, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(MulticastPolicy, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for multicast-policy.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(MulticastPolicy, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


    def get_virtual_network_back_refs(self):
        """Return list of all virtual-networks using this multicast-policy"""
        if hasattr(self, 'virtual_network_back_refs'):
            return self.virtual_network_back_refs

        if hasattr(super(MulticastPolicy, self), 'virtual_network_back_refs'):
            return super(MulticastPolicy, self).get_virtual_network_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.multicast_policy_read(id = self.uuid, fields = ['virtual_network_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'virtual_network_back_refs', None)
        if not back_refs:
            return None
        self.virtual_network_back_refs = back_refs

        return back_refs
    # end get_virtual_network_back_refs

# end class MulticastPolicy

class NetworkDeviceConfig(vnc_api.gen.resource_common.NetworkDeviceConfig):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, *args, **kwargs):
        pending_fields = ['fq_name']

        self._server_conn = None

        if len(args) > 0 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 1 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 2 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 3 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(NetworkDeviceConfig, self).__init__(name, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = NetworkDeviceConfig(**props_dict)
        else:
            obj = NetworkDeviceConfig(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.physical_router_refs = kwargs[u'physical_router_refs']
        except KeyError:
            pass
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.NetworkDeviceConfig.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.NetworkDeviceConfig.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for network-device-config.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.NetworkDeviceConfig.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for network-device-config.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.NetworkDeviceConfig.annotations.setter
    def annotations(self, annotations):
        """Set annotations for network-device-config.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.NetworkDeviceConfig.display_name.setter
    def display_name(self, display_name):
        """Set display-name for network-device-config.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for network-device-config.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for network-device-config.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_physical_router(self, *args, **kwargs):
        """Set physical-router for network-device-config.
        
        :param ref_obj: PhysicalRouter object
        
        """
        self._pending_field_updates.add('physical_router_refs')
        self._pending_ref_updates.discard('physical_router_refs')
        super(NetworkDeviceConfig, self).set_physical_router(*args, **kwargs)

    # end set_physical_router

    def add_physical_router(self, *args, **kwargs):
        """Add physical-router to network-device-config.
        
        :param ref_obj: PhysicalRouter object
        
        """
        if 'physical_router_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('physical_router_refs')
            self._original_physical_router_refs = copy.deepcopy(self.get_physical_router_refs() or [])
        super(NetworkDeviceConfig, self).add_physical_router(*args, **kwargs)
    # end add_physical_router

    def del_physical_router(self, *args, **kwargs):
        if 'physical_router_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('physical_router_refs')
            self._original_physical_router_refs = copy.deepcopy(self.get_physical_router_refs() or [])
        super(NetworkDeviceConfig, self).del_physical_router(*args, **kwargs)
    # end del_physical_router

    def set_physical_router_list(self, *args, **kwargs):
        """Set physical-router list for network-device-config.
        
        :param ref_obj_list: list of PhysicalRouter object
        
        """
        self._pending_field_updates.add('physical_router_refs')
        self._pending_ref_updates.discard('physical_router_refs')
        super(NetworkDeviceConfig, self).set_physical_router_list(*args, **kwargs)
    # end set_physical_router_list

    def set_tag(self, *args, **kwargs):
        """Set tag for network-device-config.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(NetworkDeviceConfig, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to network-device-config.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(NetworkDeviceConfig, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(NetworkDeviceConfig, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for network-device-config.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(NetworkDeviceConfig, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


# end class NetworkDeviceConfig

class VirtualDnsRecord(vnc_api.gen.resource_common.VirtualDnsRecord):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'virtual_DNS_record_data' in kwargs:
            pending_fields.append('virtual_DNS_record_data')
        if len(args) > 1 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 2 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 3 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 4 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(VirtualDnsRecord, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            if kwargs['virtual_DNS_record_data'] is None:
                props_dict['virtual_DNS_record_data'] = None
            else:
                props_dict['virtual_DNS_record_data'] = vnc_api.gen.resource_xsd.VirtualDnsRecordType(params_dict=kwargs[u'virtual_DNS_record_data'])
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = VirtualDnsRecord(**props_dict)
        else:
            obj = VirtualDnsRecord(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.VirtualDnsRecord.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.VirtualDnsRecord.virtual_DNS_record_data.setter
    def virtual_DNS_record_data(self, virtual_DNS_record_data):
        """Set virtual-DNS-record-data for virtual-DNS-record.
        
        :param virtual_DNS_record_data: VirtualDnsRecordType object
        
        """
        if 'virtual_DNS_record_data' not in self._pending_field_updates:
            self._pending_field_updates.add('virtual_DNS_record_data')

        self._virtual_DNS_record_data = virtual_DNS_record_data
    # end virtual_DNS_record_data

    def set_virtual_DNS_record_data(self, value):
        self.virtual_DNS_record_data = value
    # end set_virtual_DNS_record_data

    @vnc_api.gen.resource_common.VirtualDnsRecord.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for virtual-DNS-record.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.VirtualDnsRecord.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for virtual-DNS-record.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.VirtualDnsRecord.annotations.setter
    def annotations(self, annotations):
        """Set annotations for virtual-DNS-record.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.VirtualDnsRecord.display_name.setter
    def display_name(self, display_name):
        """Set display-name for virtual-DNS-record.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for virtual-DNS-record.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for virtual-DNS-record.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_tag(self, *args, **kwargs):
        """Set tag for virtual-DNS-record.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(VirtualDnsRecord, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to virtual-DNS-record.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(VirtualDnsRecord, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(VirtualDnsRecord, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for virtual-DNS-record.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(VirtualDnsRecord, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


# end class VirtualDnsRecord

class ControlNodeZone(vnc_api.gen.resource_common.ControlNodeZone):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 1 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 2 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 3 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(ControlNodeZone, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = ControlNodeZone(**props_dict)
        else:
            obj = ControlNodeZone(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.bgp_as_a_service_back_refs = kwargs[u'bgp_as_a_service_back_refs']
        except KeyError:
            pass
        try:
            obj.bgp_router_back_refs = kwargs[u'bgp_router_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.ControlNodeZone.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.ControlNodeZone.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for control-node-zone.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.ControlNodeZone.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for control-node-zone.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.ControlNodeZone.annotations.setter
    def annotations(self, annotations):
        """Set annotations for control-node-zone.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.ControlNodeZone.display_name.setter
    def display_name(self, display_name):
        """Set display-name for control-node-zone.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for control-node-zone.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for control-node-zone.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_tag(self, *args, **kwargs):
        """Set tag for control-node-zone.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(ControlNodeZone, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to control-node-zone.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(ControlNodeZone, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(ControlNodeZone, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for control-node-zone.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(ControlNodeZone, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


    def get_bgp_as_a_service_back_refs(self):
        """Return list of all bgp-as-a-services using this control-node-zone"""
        if hasattr(self, 'bgp_as_a_service_back_refs'):
            return self.bgp_as_a_service_back_refs

        if hasattr(super(ControlNodeZone, self), 'bgp_as_a_service_back_refs'):
            return super(ControlNodeZone, self).get_bgp_as_a_service_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.control_node_zone_read(id = self.uuid, fields = ['bgp_as_a_service_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'bgp_as_a_service_back_refs', None)
        if not back_refs:
            return None
        self.bgp_as_a_service_back_refs = back_refs

        return back_refs
    # end get_bgp_as_a_service_back_refs

    def get_bgp_router_back_refs(self):
        """Return list of all bgp-routers using this control-node-zone"""
        if hasattr(self, 'bgp_router_back_refs'):
            return self.bgp_router_back_refs

        if hasattr(super(ControlNodeZone, self), 'bgp_router_back_refs'):
            return super(ControlNodeZone, self).get_bgp_router_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.control_node_zone_read(id = self.uuid, fields = ['bgp_router_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'bgp_router_back_refs', None)
        if not back_refs:
            return None
        self.bgp_router_back_refs = back_refs

        return back_refs
    # end get_bgp_router_back_refs

# end class ControlNodeZone

class DsaRule(vnc_api.gen.resource_common.DsaRule):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'dsa_rule_entry' in kwargs:
            pending_fields.append('dsa_rule_entry')
        if len(args) > 1 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 2 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 3 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 4 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(DsaRule, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            if kwargs['dsa_rule_entry'] is None:
                props_dict['dsa_rule_entry'] = None
            else:
                props_dict['dsa_rule_entry'] = vnc_api.gen.resource_xsd.DiscoveryServiceAssignmentType(params_dict=kwargs[u'dsa_rule_entry'])
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = DsaRule(**props_dict)
        else:
            obj = DsaRule(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.DsaRule.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.DsaRule.dsa_rule_entry.setter
    def dsa_rule_entry(self, dsa_rule_entry):
        """Set dsa-rule-entry for dsa-rule.
        
        :param dsa_rule_entry: DiscoveryServiceAssignmentType object
        
        """
        if 'dsa_rule_entry' not in self._pending_field_updates:
            self._pending_field_updates.add('dsa_rule_entry')

        self._dsa_rule_entry = dsa_rule_entry
    # end dsa_rule_entry

    def set_dsa_rule_entry(self, value):
        self.dsa_rule_entry = value
    # end set_dsa_rule_entry

    @vnc_api.gen.resource_common.DsaRule.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for dsa-rule.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.DsaRule.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for dsa-rule.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.DsaRule.annotations.setter
    def annotations(self, annotations):
        """Set annotations for dsa-rule.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.DsaRule.display_name.setter
    def display_name(self, display_name):
        """Set display-name for dsa-rule.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for dsa-rule.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for dsa-rule.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_tag(self, *args, **kwargs):
        """Set tag for dsa-rule.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(DsaRule, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to dsa-rule.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(DsaRule, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(DsaRule, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for dsa-rule.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(DsaRule, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


# end class DsaRule

class StructuredSyslogConfig(vnc_api.gen.resource_common.StructuredSyslogConfig):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 1 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 2 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 3 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(StructuredSyslogConfig, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = StructuredSyslogConfig(**props_dict)
        else:
            obj = StructuredSyslogConfig(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...
        try:
            obj.structured_syslog_messages = kwargs[u'structured_syslog_messages']
        except KeyError:
            pass
        try:
            obj.structured_syslog_hostname_records = kwargs[u'structured_syslog_hostname_records']
        except KeyError:
            pass
        try:
            obj.structured_syslog_application_records = kwargs[u'structured_syslog_application_records']
        except KeyError:
            pass
        try:
            obj.structured_syslog_sla_profiles = kwargs[u'structured_syslog_sla_profiles']
        except KeyError:
            pass

        # add any specified references...
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.StructuredSyslogConfig.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.StructuredSyslogConfig.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for structured-syslog-config.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.StructuredSyslogConfig.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for structured-syslog-config.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.StructuredSyslogConfig.annotations.setter
    def annotations(self, annotations):
        """Set annotations for structured-syslog-config.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.StructuredSyslogConfig.display_name.setter
    def display_name(self, display_name):
        """Set display-name for structured-syslog-config.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for structured-syslog-config.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for structured-syslog-config.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_tag(self, *args, **kwargs):
        """Set tag for structured-syslog-config.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(StructuredSyslogConfig, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to structured-syslog-config.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(StructuredSyslogConfig, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(StructuredSyslogConfig, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for structured-syslog-config.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(StructuredSyslogConfig, self).set_tag_list(*args, **kwargs)
    # end set_tag_list

    def get_structured_syslog_messages(self):
        if hasattr(self, 'structured_syslog_messages'):
            return self.structured_syslog_messages

        if hasattr(super(StructuredSyslogConfig, self), 'structured_syslog_messages'):
            return super(StructuredSyslogConfig, self).get_structured_syslog_messages()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.structured_syslog_config_read(id = self.uuid, fields = ['structured_syslog_messages'])
        except NoIdError:
            return None
        children = getattr(obj, 'structured_syslog_messages', None)
        if not children:
            return None
        self.structured_syslog_messages = children

        return children
    # end get_structured_syslog_messages

    def get_structured_syslog_hostname_records(self):
        if hasattr(self, 'structured_syslog_hostname_records'):
            return self.structured_syslog_hostname_records

        if hasattr(super(StructuredSyslogConfig, self), 'structured_syslog_hostname_records'):
            return super(StructuredSyslogConfig, self).get_structured_syslog_hostname_records()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.structured_syslog_config_read(id = self.uuid, fields = ['structured_syslog_hostname_records'])
        except NoIdError:
            return None
        children = getattr(obj, 'structured_syslog_hostname_records', None)
        if not children:
            return None
        self.structured_syslog_hostname_records = children

        return children
    # end get_structured_syslog_hostname_records

    def get_structured_syslog_application_records(self):
        if hasattr(self, 'structured_syslog_application_records'):
            return self.structured_syslog_application_records

        if hasattr(super(StructuredSyslogConfig, self), 'structured_syslog_application_records'):
            return super(StructuredSyslogConfig, self).get_structured_syslog_application_records()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.structured_syslog_config_read(id = self.uuid, fields = ['structured_syslog_application_records'])
        except NoIdError:
            return None
        children = getattr(obj, 'structured_syslog_application_records', None)
        if not children:
            return None
        self.structured_syslog_application_records = children

        return children
    # end get_structured_syslog_application_records

    def get_structured_syslog_sla_profiles(self):
        if hasattr(self, 'structured_syslog_sla_profiles'):
            return self.structured_syslog_sla_profiles

        if hasattr(super(StructuredSyslogConfig, self), 'structured_syslog_sla_profiles'):
            return super(StructuredSyslogConfig, self).get_structured_syslog_sla_profiles()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.structured_syslog_config_read(id = self.uuid, fields = ['structured_syslog_sla_profiles'])
        except NoIdError:
            return None
        children = getattr(obj, 'structured_syslog_sla_profiles', None)
        if not children:
            return None
        self.structured_syslog_sla_profiles = children

        return children
    # end get_structured_syslog_sla_profiles


# end class StructuredSyslogConfig

class DiscoveryServiceAssignment(vnc_api.gen.resource_common.DiscoveryServiceAssignment):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, *args, **kwargs):
        pending_fields = ['fq_name']

        self._server_conn = None

        if len(args) > 0 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 1 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 2 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 3 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(DiscoveryServiceAssignment, self).__init__(name, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = DiscoveryServiceAssignment(**props_dict)
        else:
            obj = DiscoveryServiceAssignment(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...
        try:
            obj.dsa_rules = kwargs[u'dsa_rules']
        except KeyError:
            pass

        # add any specified references...
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.DiscoveryServiceAssignment.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.DiscoveryServiceAssignment.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for discovery-service-assignment.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.DiscoveryServiceAssignment.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for discovery-service-assignment.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.DiscoveryServiceAssignment.annotations.setter
    def annotations(self, annotations):
        """Set annotations for discovery-service-assignment.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.DiscoveryServiceAssignment.display_name.setter
    def display_name(self, display_name):
        """Set display-name for discovery-service-assignment.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for discovery-service-assignment.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for discovery-service-assignment.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_tag(self, *args, **kwargs):
        """Set tag for discovery-service-assignment.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(DiscoveryServiceAssignment, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to discovery-service-assignment.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(DiscoveryServiceAssignment, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(DiscoveryServiceAssignment, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for discovery-service-assignment.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(DiscoveryServiceAssignment, self).set_tag_list(*args, **kwargs)
    # end set_tag_list

    def get_dsa_rules(self):
        if hasattr(self, 'dsa_rules'):
            return self.dsa_rules

        if hasattr(super(DiscoveryServiceAssignment, self), 'dsa_rules'):
            return super(DiscoveryServiceAssignment, self).get_dsa_rules()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.discovery_service_assignment_read(id = self.uuid, fields = ['dsa_rules'])
        except NoIdError:
            return None
        children = getattr(obj, 'dsa_rules', None)
        if not children:
            return None
        self.dsa_rules = children

        return children
    # end get_dsa_rules


# end class DiscoveryServiceAssignment

class LogicalInterface(vnc_api.gen.resource_common.LogicalInterface):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'logical_interface_vlan_tag' in kwargs:
            pending_fields.append('logical_interface_vlan_tag')
        if len(args) > 1 or 'logical_interface_type' in kwargs:
            pending_fields.append('logical_interface_type')
        if len(args) > 2 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 3 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 4 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 5 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(LogicalInterface, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            props_dict['logical_interface_vlan_tag'] = kwargs[u'logical_interface_vlan_tag']
        except KeyError:
            pass

        try:
            props_dict['logical_interface_type'] = kwargs[u'logical_interface_type']
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = LogicalInterface(**props_dict)
        else:
            obj = LogicalInterface(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.virtual_machine_interface_refs = kwargs[u'virtual_machine_interface_refs']
        except KeyError:
            pass
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.instance_ip_back_refs = kwargs[u'instance_ip_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.LogicalInterface.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.LogicalInterface.logical_interface_vlan_tag.setter
    def logical_interface_vlan_tag(self, logical_interface_vlan_tag):
        """Set logical-interface-vlan-tag for logical-interface.
        
        :param logical_interface_vlan_tag: xsd:integer object
        
        """
        if 'logical_interface_vlan_tag' not in self._pending_field_updates:
            self._pending_field_updates.add('logical_interface_vlan_tag')

        self._logical_interface_vlan_tag = logical_interface_vlan_tag
    # end logical_interface_vlan_tag

    def set_logical_interface_vlan_tag(self, value):
        self.logical_interface_vlan_tag = value
    # end set_logical_interface_vlan_tag

    @vnc_api.gen.resource_common.LogicalInterface.logical_interface_type.setter
    def logical_interface_type(self, logical_interface_type):
        """Set logical-interface-type for logical-interface.
        
        :param logical_interface_type: LogicalInterfaceType object
        
        """
        if 'logical_interface_type' not in self._pending_field_updates:
            self._pending_field_updates.add('logical_interface_type')

        self._logical_interface_type = logical_interface_type
    # end logical_interface_type

    def set_logical_interface_type(self, value):
        self.logical_interface_type = value
    # end set_logical_interface_type

    @vnc_api.gen.resource_common.LogicalInterface.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for logical-interface.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.LogicalInterface.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for logical-interface.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.LogicalInterface.annotations.setter
    def annotations(self, annotations):
        """Set annotations for logical-interface.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.LogicalInterface.display_name.setter
    def display_name(self, display_name):
        """Set display-name for logical-interface.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for logical-interface.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for logical-interface.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_virtual_machine_interface(self, *args, **kwargs):
        """Set virtual-machine-interface for logical-interface.
        
        :param ref_obj: VirtualMachineInterface object
        
        """
        self._pending_field_updates.add('virtual_machine_interface_refs')
        self._pending_ref_updates.discard('virtual_machine_interface_refs')
        super(LogicalInterface, self).set_virtual_machine_interface(*args, **kwargs)

    # end set_virtual_machine_interface

    def add_virtual_machine_interface(self, *args, **kwargs):
        """Add virtual-machine-interface to logical-interface.
        
        :param ref_obj: VirtualMachineInterface object
        
        """
        if 'virtual_machine_interface_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('virtual_machine_interface_refs')
            self._original_virtual_machine_interface_refs = copy.deepcopy(self.get_virtual_machine_interface_refs() or [])
        super(LogicalInterface, self).add_virtual_machine_interface(*args, **kwargs)
    # end add_virtual_machine_interface

    def del_virtual_machine_interface(self, *args, **kwargs):
        if 'virtual_machine_interface_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('virtual_machine_interface_refs')
            self._original_virtual_machine_interface_refs = copy.deepcopy(self.get_virtual_machine_interface_refs() or [])
        super(LogicalInterface, self).del_virtual_machine_interface(*args, **kwargs)
    # end del_virtual_machine_interface

    def set_virtual_machine_interface_list(self, *args, **kwargs):
        """Set virtual-machine-interface list for logical-interface.
        
        :param ref_obj_list: list of VirtualMachineInterface object
        
        """
        self._pending_field_updates.add('virtual_machine_interface_refs')
        self._pending_ref_updates.discard('virtual_machine_interface_refs')
        super(LogicalInterface, self).set_virtual_machine_interface_list(*args, **kwargs)
    # end set_virtual_machine_interface_list

    def set_tag(self, *args, **kwargs):
        """Set tag for logical-interface.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(LogicalInterface, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to logical-interface.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(LogicalInterface, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(LogicalInterface, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for logical-interface.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(LogicalInterface, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


    def get_instance_ip_back_refs(self):
        """Return list of all instance-ips using this logical-interface"""
        if hasattr(self, 'instance_ip_back_refs'):
            return self.instance_ip_back_refs

        if hasattr(super(LogicalInterface, self), 'instance_ip_back_refs'):
            return super(LogicalInterface, self).get_instance_ip_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.logical_interface_read(id = self.uuid, fields = ['instance_ip_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'instance_ip_back_refs', None)
        if not back_refs:
            return None
        self.instance_ip_back_refs = back_refs

        return back_refs
    # end get_instance_ip_back_refs

# end class LogicalInterface

class FlowNode(vnc_api.gen.resource_common.FlowNode):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'flow_node_ip_address' in kwargs:
            pending_fields.append('flow_node_ip_address')
        if len(args) > 1 or 'flow_node_load_balancer_ip' in kwargs:
            pending_fields.append('flow_node_load_balancer_ip')
        if len(args) > 2 or 'flow_node_inband_interface' in kwargs:
            pending_fields.append('flow_node_inband_interface')
        if len(args) > 3 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 4 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 5 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 6 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(FlowNode, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            props_dict['flow_node_ip_address'] = kwargs[u'flow_node_ip_address']
        except KeyError:
            pass

        try:
            props_dict['flow_node_load_balancer_ip'] = kwargs[u'flow_node_load_balancer_ip']
        except KeyError:
            pass

        try:
            props_dict['flow_node_inband_interface'] = kwargs[u'flow_node_inband_interface']
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = FlowNode(**props_dict)
        else:
            obj = FlowNode(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.virtual_network_refs = kwargs[u'virtual_network_refs']
        except KeyError:
            pass
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.instance_ip_back_refs = kwargs[u'instance_ip_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.FlowNode.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.FlowNode.flow_node_ip_address.setter
    def flow_node_ip_address(self, flow_node_ip_address):
        """Set flow-node-ip-address for flow-node.
        
        :param flow_node_ip_address: IpAddressType object
        
        """
        if 'flow_node_ip_address' not in self._pending_field_updates:
            self._pending_field_updates.add('flow_node_ip_address')

        self._flow_node_ip_address = flow_node_ip_address
    # end flow_node_ip_address

    def set_flow_node_ip_address(self, value):
        self.flow_node_ip_address = value
    # end set_flow_node_ip_address

    @vnc_api.gen.resource_common.FlowNode.flow_node_load_balancer_ip.setter
    def flow_node_load_balancer_ip(self, flow_node_load_balancer_ip):
        """Set flow-node-load-balancer-ip for flow-node.
        
        :param flow_node_load_balancer_ip: IpAddressType object
        
        """
        if 'flow_node_load_balancer_ip' not in self._pending_field_updates:
            self._pending_field_updates.add('flow_node_load_balancer_ip')

        self._flow_node_load_balancer_ip = flow_node_load_balancer_ip
    # end flow_node_load_balancer_ip

    def set_flow_node_load_balancer_ip(self, value):
        self.flow_node_load_balancer_ip = value
    # end set_flow_node_load_balancer_ip

    @vnc_api.gen.resource_common.FlowNode.flow_node_inband_interface.setter
    def flow_node_inband_interface(self, flow_node_inband_interface):
        """Set flow-node-inband-interface for flow-node.
        
        :param flow_node_inband_interface: xsd:string object
        
        """
        if 'flow_node_inband_interface' not in self._pending_field_updates:
            self._pending_field_updates.add('flow_node_inband_interface')

        self._flow_node_inband_interface = flow_node_inband_interface
    # end flow_node_inband_interface

    def set_flow_node_inband_interface(self, value):
        self.flow_node_inband_interface = value
    # end set_flow_node_inband_interface

    @vnc_api.gen.resource_common.FlowNode.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for flow-node.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.FlowNode.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for flow-node.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.FlowNode.annotations.setter
    def annotations(self, annotations):
        """Set annotations for flow-node.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.FlowNode.display_name.setter
    def display_name(self, display_name):
        """Set display-name for flow-node.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for flow-node.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for flow-node.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_virtual_network(self, *args, **kwargs):
        """Set virtual-network for flow-node.
        
        :param ref_obj: VirtualNetwork object
        
        """
        self._pending_field_updates.add('virtual_network_refs')
        self._pending_ref_updates.discard('virtual_network_refs')
        super(FlowNode, self).set_virtual_network(*args, **kwargs)

    # end set_virtual_network

    def add_virtual_network(self, *args, **kwargs):
        """Add virtual-network to flow-node.
        
        :param ref_obj: VirtualNetwork object
        
        """
        if 'virtual_network_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('virtual_network_refs')
            self._original_virtual_network_refs = copy.deepcopy(self.get_virtual_network_refs() or [])
        super(FlowNode, self).add_virtual_network(*args, **kwargs)
    # end add_virtual_network

    def del_virtual_network(self, *args, **kwargs):
        if 'virtual_network_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('virtual_network_refs')
            self._original_virtual_network_refs = copy.deepcopy(self.get_virtual_network_refs() or [])
        super(FlowNode, self).del_virtual_network(*args, **kwargs)
    # end del_virtual_network

    def set_virtual_network_list(self, *args, **kwargs):
        """Set virtual-network list for flow-node.
        
        :param ref_obj_list: list of VirtualNetwork object
        
        """
        self._pending_field_updates.add('virtual_network_refs')
        self._pending_ref_updates.discard('virtual_network_refs')
        super(FlowNode, self).set_virtual_network_list(*args, **kwargs)
    # end set_virtual_network_list

    def set_tag(self, *args, **kwargs):
        """Set tag for flow-node.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(FlowNode, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to flow-node.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(FlowNode, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(FlowNode, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for flow-node.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(FlowNode, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


    def get_instance_ip_back_refs(self):
        """Return list of all instance-ips using this flow-node"""
        if hasattr(self, 'instance_ip_back_refs'):
            return self.instance_ip_back_refs

        if hasattr(super(FlowNode, self), 'instance_ip_back_refs'):
            return super(FlowNode, self).get_instance_ip_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.flow_node_read(id = self.uuid, fields = ['instance_ip_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'instance_ip_back_refs', None)
        if not back_refs:
            return None
        self.instance_ip_back_refs = back_refs

        return back_refs
    # end get_instance_ip_back_refs

# end class FlowNode

class PortGroup(vnc_api.gen.resource_common.PortGroup):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'bms_port_group_info' in kwargs:
            pending_fields.append('bms_port_group_info')
        if len(args) > 1 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 2 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 3 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 4 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(PortGroup, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            if kwargs['bms_port_group_info'] is None:
                props_dict['bms_port_group_info'] = None
            else:
                props_dict['bms_port_group_info'] = vnc_api.gen.resource_xsd.BaremetalPortGroupInfo(params_dict=kwargs[u'bms_port_group_info'])
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = PortGroup(**props_dict)
        else:
            obj = PortGroup(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.port_refs = kwargs[u'port_refs']
        except KeyError:
            pass
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.PortGroup.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.PortGroup.bms_port_group_info.setter
    def bms_port_group_info(self, bms_port_group_info):
        """Set bms-port-group-info for port-group.
        
        :param bms_port_group_info: BaremetalPortGroupInfo object
        
        """
        if 'bms_port_group_info' not in self._pending_field_updates:
            self._pending_field_updates.add('bms_port_group_info')

        self._bms_port_group_info = bms_port_group_info
    # end bms_port_group_info

    def set_bms_port_group_info(self, value):
        self.bms_port_group_info = value
    # end set_bms_port_group_info

    @vnc_api.gen.resource_common.PortGroup.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for port-group.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.PortGroup.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for port-group.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.PortGroup.annotations.setter
    def annotations(self, annotations):
        """Set annotations for port-group.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.PortGroup.display_name.setter
    def display_name(self, display_name):
        """Set display-name for port-group.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for port-group.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for port-group.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_port(self, *args, **kwargs):
        """Set port for port-group.
        
        :param ref_obj: Port object
        
        """
        self._pending_field_updates.add('port_refs')
        self._pending_ref_updates.discard('port_refs')
        super(PortGroup, self).set_port(*args, **kwargs)

    # end set_port

    def add_port(self, *args, **kwargs):
        """Add port to port-group.
        
        :param ref_obj: Port object
        
        """
        if 'port_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('port_refs')
            self._original_port_refs = copy.deepcopy(self.get_port_refs() or [])
        super(PortGroup, self).add_port(*args, **kwargs)
    # end add_port

    def del_port(self, *args, **kwargs):
        if 'port_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('port_refs')
            self._original_port_refs = copy.deepcopy(self.get_port_refs() or [])
        super(PortGroup, self).del_port(*args, **kwargs)
    # end del_port

    def set_port_list(self, *args, **kwargs):
        """Set port list for port-group.
        
        :param ref_obj_list: list of Port object
        
        """
        self._pending_field_updates.add('port_refs')
        self._pending_ref_updates.discard('port_refs')
        super(PortGroup, self).set_port_list(*args, **kwargs)
    # end set_port_list

    def set_tag(self, *args, **kwargs):
        """Set tag for port-group.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(PortGroup, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to port-group.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(PortGroup, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(PortGroup, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for port-group.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(PortGroup, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


# end class PortGroup

class RouteAggregate(vnc_api.gen.resource_common.RouteAggregate):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'aggregate_route_entries' in kwargs:
            pending_fields.append('aggregate_route_entries')
        if len(args) > 1 or 'aggregate_route_nexthop' in kwargs:
            pending_fields.append('aggregate_route_nexthop')
        if len(args) > 2 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 3 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 4 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 5 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(RouteAggregate, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            if kwargs['aggregate_route_entries'] is None:
                props_dict['aggregate_route_entries'] = None
            else:
                props_dict['aggregate_route_entries'] = vnc_api.gen.resource_xsd.RouteListType(params_dict=kwargs[u'aggregate_route_entries'])
        except KeyError:
            pass

        try:
            props_dict['aggregate_route_nexthop'] = kwargs[u'aggregate_route_nexthop']
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = RouteAggregate(**props_dict)
        else:
            obj = RouteAggregate(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.service_instance_refs = kwargs[u'service_instance_refs']
            for ref in obj.service_instance_refs:
                ref['attr'] = vnc_api.gen.resource_xsd.ServiceInterfaceTag(params_dict=ref[u'attr'])
        except KeyError:
            pass
        try:
            obj.routing_instance_refs = kwargs[u'routing_instance_refs']
        except KeyError:
            pass
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.RouteAggregate.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.RouteAggregate.aggregate_route_entries.setter
    def aggregate_route_entries(self, aggregate_route_entries):
        """Set aggregate-route-entries for route-aggregate.
        
        :param aggregate_route_entries: RouteListType object
        
        """
        if 'aggregate_route_entries' not in self._pending_field_updates:
            self._pending_field_updates.add('aggregate_route_entries')

        self._aggregate_route_entries = aggregate_route_entries
    # end aggregate_route_entries

    def set_aggregate_route_entries(self, value):
        self.aggregate_route_entries = value
    # end set_aggregate_route_entries

    @vnc_api.gen.resource_common.RouteAggregate.aggregate_route_nexthop.setter
    def aggregate_route_nexthop(self, aggregate_route_nexthop):
        """Set aggregate-route-nexthop for route-aggregate.
        
        :param aggregate_route_nexthop: xsd:string object
        
        """
        if 'aggregate_route_nexthop' not in self._pending_field_updates:
            self._pending_field_updates.add('aggregate_route_nexthop')

        self._aggregate_route_nexthop = aggregate_route_nexthop
    # end aggregate_route_nexthop

    def set_aggregate_route_nexthop(self, value):
        self.aggregate_route_nexthop = value
    # end set_aggregate_route_nexthop

    @vnc_api.gen.resource_common.RouteAggregate.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for route-aggregate.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.RouteAggregate.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for route-aggregate.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.RouteAggregate.annotations.setter
    def annotations(self, annotations):
        """Set annotations for route-aggregate.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.RouteAggregate.display_name.setter
    def display_name(self, display_name):
        """Set display-name for route-aggregate.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for route-aggregate.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for route-aggregate.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_service_instance(self, *args, **kwargs):
        """Set service-instance for route-aggregate.
        
        :param ref_obj: ServiceInstance object
        :param ref_data: ServiceInterfaceTag object
        
        """
        self._pending_field_updates.add('service_instance_refs')
        self._pending_ref_updates.discard('service_instance_refs')
        super(RouteAggregate, self).set_service_instance(*args, **kwargs)

    # end set_service_instance

    def add_service_instance(self, *args, **kwargs):
        """Add service-instance to route-aggregate.
        
        :param ref_obj: ServiceInstance object
        :param ref_data: ServiceInterfaceTag object
        
        """
        if 'service_instance_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('service_instance_refs')
            self._original_service_instance_refs = copy.deepcopy(self.get_service_instance_refs() or [])
        super(RouteAggregate, self).add_service_instance(*args, **kwargs)
    # end add_service_instance

    def del_service_instance(self, *args, **kwargs):
        if 'service_instance_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('service_instance_refs')
            self._original_service_instance_refs = copy.deepcopy(self.get_service_instance_refs() or [])
        super(RouteAggregate, self).del_service_instance(*args, **kwargs)
    # end del_service_instance

    def set_service_instance_list(self, *args, **kwargs):
        """Set service-instance list for route-aggregate.
        
        :param ref_obj_list: list of ServiceInstance object
        :param ref_data_list: list of ServiceInterfaceTag summary
        
        """
        self._pending_field_updates.add('service_instance_refs')
        self._pending_ref_updates.discard('service_instance_refs')
        super(RouteAggregate, self).set_service_instance_list(*args, **kwargs)
    # end set_service_instance_list

    def set_routing_instance(self, *args, **kwargs):
        """Set routing-instance for route-aggregate.
        
        :param ref_obj: RoutingInstance object
        
        """
        self._pending_field_updates.add('routing_instance_refs')
        self._pending_ref_updates.discard('routing_instance_refs')
        super(RouteAggregate, self).set_routing_instance(*args, **kwargs)

    # end set_routing_instance

    def add_routing_instance(self, *args, **kwargs):
        """Add routing-instance to route-aggregate.
        
        :param ref_obj: RoutingInstance object
        
        """
        if 'routing_instance_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('routing_instance_refs')
            self._original_routing_instance_refs = copy.deepcopy(self.get_routing_instance_refs() or [])
        super(RouteAggregate, self).add_routing_instance(*args, **kwargs)
    # end add_routing_instance

    def del_routing_instance(self, *args, **kwargs):
        if 'routing_instance_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('routing_instance_refs')
            self._original_routing_instance_refs = copy.deepcopy(self.get_routing_instance_refs() or [])
        super(RouteAggregate, self).del_routing_instance(*args, **kwargs)
    # end del_routing_instance

    def set_routing_instance_list(self, *args, **kwargs):
        """Set routing-instance list for route-aggregate.
        
        :param ref_obj_list: list of RoutingInstance object
        
        """
        self._pending_field_updates.add('routing_instance_refs')
        self._pending_ref_updates.discard('routing_instance_refs')
        super(RouteAggregate, self).set_routing_instance_list(*args, **kwargs)
    # end set_routing_instance_list

    def set_tag(self, *args, **kwargs):
        """Set tag for route-aggregate.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(RouteAggregate, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to route-aggregate.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(RouteAggregate, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(RouteAggregate, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for route-aggregate.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(RouteAggregate, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


# end class RouteAggregate

class LogicalRouter(vnc_api.gen.resource_common.LogicalRouter):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'configured_route_target_list' in kwargs:
            pending_fields.append('configured_route_target_list')
        if len(args) > 1 or 'vxlan_network_identifier' in kwargs:
            pending_fields.append('vxlan_network_identifier')
        if len(args) > 2 or 'logical_router_dhcp_relay_server' in kwargs:
            pending_fields.append('logical_router_dhcp_relay_server')
        if len(args) > 3 or 'logical_router_gateway_external' in kwargs:
            pending_fields.append('logical_router_gateway_external')
        if len(args) > 4 or 'logical_router_type' in kwargs:
            pending_fields.append('logical_router_type')
        if len(args) > 5 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 6 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 7 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 8 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(LogicalRouter, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            if kwargs['configured_route_target_list'] is None:
                props_dict['configured_route_target_list'] = None
            else:
                props_dict['configured_route_target_list'] = vnc_api.gen.resource_xsd.RouteTargetList(params_dict=kwargs[u'configured_route_target_list'])
        except KeyError:
            pass

        try:
            props_dict['vxlan_network_identifier'] = kwargs[u'vxlan_network_identifier']
        except KeyError:
            pass

        try:
            if kwargs['logical_router_dhcp_relay_server'] is None:
                props_dict['logical_router_dhcp_relay_server'] = None
            else:
                props_dict['logical_router_dhcp_relay_server'] = vnc_api.gen.resource_xsd.IpAddressesType(params_dict=kwargs[u'logical_router_dhcp_relay_server'])
        except KeyError:
            pass

        try:
            props_dict['logical_router_gateway_external'] = kwargs[u'logical_router_gateway_external']
        except KeyError:
            pass

        try:
            props_dict['logical_router_type'] = kwargs[u'logical_router_type']
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = LogicalRouter(**props_dict)
        else:
            obj = LogicalRouter(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.virtual_machine_interface_refs = kwargs[u'virtual_machine_interface_refs']
        except KeyError:
            pass
        try:
            obj.route_target_refs = kwargs[u'route_target_refs']
        except KeyError:
            pass
        try:
            obj.route_table_refs = kwargs[u'route_table_refs']
        except KeyError:
            pass
        try:
            obj.virtual_network_refs = kwargs[u'virtual_network_refs']
            for ref in obj.virtual_network_refs:
                ref['attr'] = vnc_api.gen.resource_xsd.LogicalRouterVirtualNetworkType(params_dict=ref[u'attr'])
        except KeyError:
            pass
        try:
            obj.service_instance_refs = kwargs[u'service_instance_refs']
        except KeyError:
            pass
        try:
            obj.physical_router_refs = kwargs[u'physical_router_refs']
        except KeyError:
            pass
        try:
            obj.bgpvpn_refs = kwargs[u'bgpvpn_refs']
        except KeyError:
            pass
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.port_tuple_back_refs = kwargs[u'port_tuple_back_refs']
        except KeyError:
            pass
        try:
            obj.data_center_interconnect_back_refs = kwargs[u'data_center_interconnect_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.LogicalRouter.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.LogicalRouter.configured_route_target_list.setter
    def configured_route_target_list(self, configured_route_target_list):
        """Set configured-route-target-list for logical-router.
        
        :param configured_route_target_list: RouteTargetList object
        
        """
        if 'configured_route_target_list' not in self._pending_field_updates:
            self._pending_field_updates.add('configured_route_target_list')

        self._configured_route_target_list = configured_route_target_list
    # end configured_route_target_list

    def set_configured_route_target_list(self, value):
        self.configured_route_target_list = value
    # end set_configured_route_target_list

    @vnc_api.gen.resource_common.LogicalRouter.vxlan_network_identifier.setter
    def vxlan_network_identifier(self, vxlan_network_identifier):
        """Set vxlan-network-identifier for logical-router.
        
        :param vxlan_network_identifier: xsd:string object
        
        """
        if 'vxlan_network_identifier' not in self._pending_field_updates:
            self._pending_field_updates.add('vxlan_network_identifier')

        self._vxlan_network_identifier = vxlan_network_identifier
    # end vxlan_network_identifier

    def set_vxlan_network_identifier(self, value):
        self.vxlan_network_identifier = value
    # end set_vxlan_network_identifier

    @vnc_api.gen.resource_common.LogicalRouter.logical_router_dhcp_relay_server.setter
    def logical_router_dhcp_relay_server(self, logical_router_dhcp_relay_server):
        """Set logical-router-dhcp-relay-server for logical-router.
        
        :param logical_router_dhcp_relay_server: IpAddressesType object
        
        """
        if 'logical_router_dhcp_relay_server' not in self._pending_field_updates:
            self._pending_field_updates.add('logical_router_dhcp_relay_server')

        self._logical_router_dhcp_relay_server = logical_router_dhcp_relay_server
    # end logical_router_dhcp_relay_server

    def set_logical_router_dhcp_relay_server(self, value):
        self.logical_router_dhcp_relay_server = value
    # end set_logical_router_dhcp_relay_server

    @vnc_api.gen.resource_common.LogicalRouter.logical_router_gateway_external.setter
    def logical_router_gateway_external(self, logical_router_gateway_external):
        """Set logical-router-gateway-external for logical-router.
        
        :param logical_router_gateway_external: xsd:boolean object
        
        """
        if 'logical_router_gateway_external' not in self._pending_field_updates:
            self._pending_field_updates.add('logical_router_gateway_external')

        self._logical_router_gateway_external = logical_router_gateway_external
    # end logical_router_gateway_external

    def set_logical_router_gateway_external(self, value):
        self.logical_router_gateway_external = value
    # end set_logical_router_gateway_external

    @vnc_api.gen.resource_common.LogicalRouter.logical_router_type.setter
    def logical_router_type(self, logical_router_type):
        """Set logical-router-type for logical-router.
        
        :param logical_router_type: LogicalRouterType object
        
        """
        if 'logical_router_type' not in self._pending_field_updates:
            self._pending_field_updates.add('logical_router_type')

        self._logical_router_type = logical_router_type
    # end logical_router_type

    def set_logical_router_type(self, value):
        self.logical_router_type = value
    # end set_logical_router_type

    @vnc_api.gen.resource_common.LogicalRouter.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for logical-router.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.LogicalRouter.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for logical-router.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.LogicalRouter.annotations.setter
    def annotations(self, annotations):
        """Set annotations for logical-router.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.LogicalRouter.display_name.setter
    def display_name(self, display_name):
        """Set display-name for logical-router.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for logical-router.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for logical-router.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_virtual_machine_interface(self, *args, **kwargs):
        """Set virtual-machine-interface for logical-router.
        
        :param ref_obj: VirtualMachineInterface object
        
        """
        self._pending_field_updates.add('virtual_machine_interface_refs')
        self._pending_ref_updates.discard('virtual_machine_interface_refs')
        super(LogicalRouter, self).set_virtual_machine_interface(*args, **kwargs)

    # end set_virtual_machine_interface

    def add_virtual_machine_interface(self, *args, **kwargs):
        """Add virtual-machine-interface to logical-router.
        
        :param ref_obj: VirtualMachineInterface object
        
        """
        if 'virtual_machine_interface_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('virtual_machine_interface_refs')
            self._original_virtual_machine_interface_refs = copy.deepcopy(self.get_virtual_machine_interface_refs() or [])
        super(LogicalRouter, self).add_virtual_machine_interface(*args, **kwargs)
    # end add_virtual_machine_interface

    def del_virtual_machine_interface(self, *args, **kwargs):
        if 'virtual_machine_interface_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('virtual_machine_interface_refs')
            self._original_virtual_machine_interface_refs = copy.deepcopy(self.get_virtual_machine_interface_refs() or [])
        super(LogicalRouter, self).del_virtual_machine_interface(*args, **kwargs)
    # end del_virtual_machine_interface

    def set_virtual_machine_interface_list(self, *args, **kwargs):
        """Set virtual-machine-interface list for logical-router.
        
        :param ref_obj_list: list of VirtualMachineInterface object
        
        """
        self._pending_field_updates.add('virtual_machine_interface_refs')
        self._pending_ref_updates.discard('virtual_machine_interface_refs')
        super(LogicalRouter, self).set_virtual_machine_interface_list(*args, **kwargs)
    # end set_virtual_machine_interface_list

    def set_route_target(self, *args, **kwargs):
        """Set route-target for logical-router.
        
        :param ref_obj: RouteTarget object
        
        """
        self._pending_field_updates.add('route_target_refs')
        self._pending_ref_updates.discard('route_target_refs')
        super(LogicalRouter, self).set_route_target(*args, **kwargs)

    # end set_route_target

    def add_route_target(self, *args, **kwargs):
        """Add route-target to logical-router.
        
        :param ref_obj: RouteTarget object
        
        """
        if 'route_target_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('route_target_refs')
            self._original_route_target_refs = copy.deepcopy(self.get_route_target_refs() or [])
        super(LogicalRouter, self).add_route_target(*args, **kwargs)
    # end add_route_target

    def del_route_target(self, *args, **kwargs):
        if 'route_target_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('route_target_refs')
            self._original_route_target_refs = copy.deepcopy(self.get_route_target_refs() or [])
        super(LogicalRouter, self).del_route_target(*args, **kwargs)
    # end del_route_target

    def set_route_target_list(self, *args, **kwargs):
        """Set route-target list for logical-router.
        
        :param ref_obj_list: list of RouteTarget object
        
        """
        self._pending_field_updates.add('route_target_refs')
        self._pending_ref_updates.discard('route_target_refs')
        super(LogicalRouter, self).set_route_target_list(*args, **kwargs)
    # end set_route_target_list

    def set_route_table(self, *args, **kwargs):
        """Set route-table for logical-router.
        
        :param ref_obj: RouteTable object
        
        """
        self._pending_field_updates.add('route_table_refs')
        self._pending_ref_updates.discard('route_table_refs')
        super(LogicalRouter, self).set_route_table(*args, **kwargs)

    # end set_route_table

    def add_route_table(self, *args, **kwargs):
        """Add route-table to logical-router.
        
        :param ref_obj: RouteTable object
        
        """
        if 'route_table_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('route_table_refs')
            self._original_route_table_refs = copy.deepcopy(self.get_route_table_refs() or [])
        super(LogicalRouter, self).add_route_table(*args, **kwargs)
    # end add_route_table

    def del_route_table(self, *args, **kwargs):
        if 'route_table_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('route_table_refs')
            self._original_route_table_refs = copy.deepcopy(self.get_route_table_refs() or [])
        super(LogicalRouter, self).del_route_table(*args, **kwargs)
    # end del_route_table

    def set_route_table_list(self, *args, **kwargs):
        """Set route-table list for logical-router.
        
        :param ref_obj_list: list of RouteTable object
        
        """
        self._pending_field_updates.add('route_table_refs')
        self._pending_ref_updates.discard('route_table_refs')
        super(LogicalRouter, self).set_route_table_list(*args, **kwargs)
    # end set_route_table_list

    def set_virtual_network(self, *args, **kwargs):
        """Set virtual-network for logical-router.
        
        :param ref_obj: VirtualNetwork object
        :param ref_data: LogicalRouterVirtualNetworkType object
        
        """
        self._pending_field_updates.add('virtual_network_refs')
        self._pending_ref_updates.discard('virtual_network_refs')
        super(LogicalRouter, self).set_virtual_network(*args, **kwargs)

    # end set_virtual_network

    def add_virtual_network(self, *args, **kwargs):
        """Add virtual-network to logical-router.
        
        :param ref_obj: VirtualNetwork object
        :param ref_data: LogicalRouterVirtualNetworkType object
        
        """
        if 'virtual_network_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('virtual_network_refs')
            self._original_virtual_network_refs = copy.deepcopy(self.get_virtual_network_refs() or [])
        super(LogicalRouter, self).add_virtual_network(*args, **kwargs)
    # end add_virtual_network

    def del_virtual_network(self, *args, **kwargs):
        if 'virtual_network_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('virtual_network_refs')
            self._original_virtual_network_refs = copy.deepcopy(self.get_virtual_network_refs() or [])
        super(LogicalRouter, self).del_virtual_network(*args, **kwargs)
    # end del_virtual_network

    def set_virtual_network_list(self, *args, **kwargs):
        """Set virtual-network list for logical-router.
        
        :param ref_obj_list: list of VirtualNetwork object
        :param ref_data_list: list of LogicalRouterVirtualNetworkType summary
        
        """
        self._pending_field_updates.add('virtual_network_refs')
        self._pending_ref_updates.discard('virtual_network_refs')
        super(LogicalRouter, self).set_virtual_network_list(*args, **kwargs)
    # end set_virtual_network_list

    def set_service_instance(self, *args, **kwargs):
        """Set service-instance for logical-router.
        
        :param ref_obj: ServiceInstance object
        
        """
        self._pending_field_updates.add('service_instance_refs')
        self._pending_ref_updates.discard('service_instance_refs')
        super(LogicalRouter, self).set_service_instance(*args, **kwargs)

    # end set_service_instance

    def add_service_instance(self, *args, **kwargs):
        """Add service-instance to logical-router.
        
        :param ref_obj: ServiceInstance object
        
        """
        if 'service_instance_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('service_instance_refs')
            self._original_service_instance_refs = copy.deepcopy(self.get_service_instance_refs() or [])
        super(LogicalRouter, self).add_service_instance(*args, **kwargs)
    # end add_service_instance

    def del_service_instance(self, *args, **kwargs):
        if 'service_instance_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('service_instance_refs')
            self._original_service_instance_refs = copy.deepcopy(self.get_service_instance_refs() or [])
        super(LogicalRouter, self).del_service_instance(*args, **kwargs)
    # end del_service_instance

    def set_service_instance_list(self, *args, **kwargs):
        """Set service-instance list for logical-router.
        
        :param ref_obj_list: list of ServiceInstance object
        
        """
        self._pending_field_updates.add('service_instance_refs')
        self._pending_ref_updates.discard('service_instance_refs')
        super(LogicalRouter, self).set_service_instance_list(*args, **kwargs)
    # end set_service_instance_list

    def set_physical_router(self, *args, **kwargs):
        """Set physical-router for logical-router.
        
        :param ref_obj: PhysicalRouter object
        
        """
        self._pending_field_updates.add('physical_router_refs')
        self._pending_ref_updates.discard('physical_router_refs')
        super(LogicalRouter, self).set_physical_router(*args, **kwargs)

    # end set_physical_router

    def add_physical_router(self, *args, **kwargs):
        """Add physical-router to logical-router.
        
        :param ref_obj: PhysicalRouter object
        
        """
        if 'physical_router_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('physical_router_refs')
            self._original_physical_router_refs = copy.deepcopy(self.get_physical_router_refs() or [])
        super(LogicalRouter, self).add_physical_router(*args, **kwargs)
    # end add_physical_router

    def del_physical_router(self, *args, **kwargs):
        if 'physical_router_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('physical_router_refs')
            self._original_physical_router_refs = copy.deepcopy(self.get_physical_router_refs() or [])
        super(LogicalRouter, self).del_physical_router(*args, **kwargs)
    # end del_physical_router

    def set_physical_router_list(self, *args, **kwargs):
        """Set physical-router list for logical-router.
        
        :param ref_obj_list: list of PhysicalRouter object
        
        """
        self._pending_field_updates.add('physical_router_refs')
        self._pending_ref_updates.discard('physical_router_refs')
        super(LogicalRouter, self).set_physical_router_list(*args, **kwargs)
    # end set_physical_router_list

    def set_bgpvpn(self, *args, **kwargs):
        """Set bgpvpn for logical-router.
        
        :param ref_obj: Bgpvpn object
        
        """
        self._pending_field_updates.add('bgpvpn_refs')
        self._pending_ref_updates.discard('bgpvpn_refs')
        super(LogicalRouter, self).set_bgpvpn(*args, **kwargs)

    # end set_bgpvpn

    def add_bgpvpn(self, *args, **kwargs):
        """Add bgpvpn to logical-router.
        
        :param ref_obj: Bgpvpn object
        
        """
        if 'bgpvpn_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('bgpvpn_refs')
            self._original_bgpvpn_refs = copy.deepcopy(self.get_bgpvpn_refs() or [])
        super(LogicalRouter, self).add_bgpvpn(*args, **kwargs)
    # end add_bgpvpn

    def del_bgpvpn(self, *args, **kwargs):
        if 'bgpvpn_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('bgpvpn_refs')
            self._original_bgpvpn_refs = copy.deepcopy(self.get_bgpvpn_refs() or [])
        super(LogicalRouter, self).del_bgpvpn(*args, **kwargs)
    # end del_bgpvpn

    def set_bgpvpn_list(self, *args, **kwargs):
        """Set bgpvpn list for logical-router.
        
        :param ref_obj_list: list of Bgpvpn object
        
        """
        self._pending_field_updates.add('bgpvpn_refs')
        self._pending_ref_updates.discard('bgpvpn_refs')
        super(LogicalRouter, self).set_bgpvpn_list(*args, **kwargs)
    # end set_bgpvpn_list

    def set_tag(self, *args, **kwargs):
        """Set tag for logical-router.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(LogicalRouter, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to logical-router.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(LogicalRouter, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(LogicalRouter, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for logical-router.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(LogicalRouter, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


    def get_port_tuple_back_refs(self):
        """Return list of all port-tuples using this logical-router"""
        if hasattr(self, 'port_tuple_back_refs'):
            return self.port_tuple_back_refs

        if hasattr(super(LogicalRouter, self), 'port_tuple_back_refs'):
            return super(LogicalRouter, self).get_port_tuple_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.logical_router_read(id = self.uuid, fields = ['port_tuple_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'port_tuple_back_refs', None)
        if not back_refs:
            return None
        self.port_tuple_back_refs = back_refs

        return back_refs
    # end get_port_tuple_back_refs

    def get_data_center_interconnect_back_refs(self):
        """Return list of all data-center-interconnects using this logical-router"""
        if hasattr(self, 'data_center_interconnect_back_refs'):
            return self.data_center_interconnect_back_refs

        if hasattr(super(LogicalRouter, self), 'data_center_interconnect_back_refs'):
            return super(LogicalRouter, self).get_data_center_interconnect_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.logical_router_read(id = self.uuid, fields = ['data_center_interconnect_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'data_center_interconnect_back_refs', None)
        if not back_refs:
            return None
        self.data_center_interconnect_back_refs = back_refs

        return back_refs
    # end get_data_center_interconnect_back_refs

# end class LogicalRouter

class Domain(vnc_api.gen.resource_common.Domain):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'domain_limits' in kwargs:
            pending_fields.append('domain_limits')
        if len(args) > 1 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 2 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 3 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 4 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(Domain, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            if kwargs['domain_limits'] is None:
                props_dict['domain_limits'] = None
            else:
                props_dict['domain_limits'] = vnc_api.gen.resource_xsd.DomainLimitsType(params_dict=kwargs[u'domain_limits'])
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = Domain(**props_dict)
        else:
            obj = Domain(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...
        try:
            obj.projects = kwargs[u'projects']
        except KeyError:
            pass
        try:
            obj.namespaces = kwargs[u'namespaces']
        except KeyError:
            pass
        try:
            obj.service_templates = kwargs[u'service_templates']
        except KeyError:
            pass
        try:
            obj.virtual_DNSs = kwargs[u'virtual_DNSs']
        except KeyError:
            pass
        try:
            obj.api_access_lists = kwargs[u'api_access_lists']
        except KeyError:
            pass

        # add any specified references...
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.Domain.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.Domain.domain_limits.setter
    def domain_limits(self, domain_limits):
        """Set domain-limits for domain.
        
        :param domain_limits: DomainLimitsType object
        
        """
        if 'domain_limits' not in self._pending_field_updates:
            self._pending_field_updates.add('domain_limits')

        self._domain_limits = domain_limits
    # end domain_limits

    def set_domain_limits(self, value):
        self.domain_limits = value
    # end set_domain_limits

    @vnc_api.gen.resource_common.Domain.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for domain.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.Domain.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for domain.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.Domain.annotations.setter
    def annotations(self, annotations):
        """Set annotations for domain.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.Domain.display_name.setter
    def display_name(self, display_name):
        """Set display-name for domain.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for domain.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for domain.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_tag(self, *args, **kwargs):
        """Set tag for domain.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(Domain, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to domain.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(Domain, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(Domain, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for domain.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(Domain, self).set_tag_list(*args, **kwargs)
    # end set_tag_list

    def get_projects(self):
        if hasattr(self, 'projects'):
            return self.projects

        if hasattr(super(Domain, self), 'projects'):
            return super(Domain, self).get_projects()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.domain_read(id = self.uuid, fields = ['projects'])
        except NoIdError:
            return None
        children = getattr(obj, 'projects', None)
        if not children:
            return None
        self.projects = children

        return children
    # end get_projects

    def get_namespaces(self):
        if hasattr(self, 'namespaces'):
            return self.namespaces

        if hasattr(super(Domain, self), 'namespaces'):
            return super(Domain, self).get_namespaces()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.domain_read(id = self.uuid, fields = ['namespaces'])
        except NoIdError:
            return None
        children = getattr(obj, 'namespaces', None)
        if not children:
            return None
        self.namespaces = children

        return children
    # end get_namespaces

    def get_service_templates(self):
        if hasattr(self, 'service_templates'):
            return self.service_templates

        if hasattr(super(Domain, self), 'service_templates'):
            return super(Domain, self).get_service_templates()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.domain_read(id = self.uuid, fields = ['service_templates'])
        except NoIdError:
            return None
        children = getattr(obj, 'service_templates', None)
        if not children:
            return None
        self.service_templates = children

        return children
    # end get_service_templates

    def get_virtual_DNSs(self):
        if hasattr(self, 'virtual_DNSs'):
            return self.virtual_DNSs

        if hasattr(super(Domain, self), 'virtual_DNSs'):
            return super(Domain, self).get_virtual_DNSs()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.domain_read(id = self.uuid, fields = ['virtual_DNSs'])
        except NoIdError:
            return None
        children = getattr(obj, 'virtual_DNSs', None)
        if not children:
            return None
        self.virtual_DNSs = children

        return children
    # end get_virtual_DNSs

    def get_api_access_lists(self):
        if hasattr(self, 'api_access_lists'):
            return self.api_access_lists

        if hasattr(super(Domain, self), 'api_access_lists'):
            return super(Domain, self).get_api_access_lists()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.domain_read(id = self.uuid, fields = ['api_access_lists'])
        except NoIdError:
            return None
        children = getattr(obj, 'api_access_lists', None)
        if not children:
            return None
        self.api_access_lists = children

        return children
    # end get_api_access_lists


# end class Domain

class StructuredSyslogHostnameRecord(vnc_api.gen.resource_common.StructuredSyslogHostnameRecord):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'structured_syslog_hostaddr' in kwargs:
            pending_fields.append('structured_syslog_hostaddr')
        if len(args) > 1 or 'structured_syslog_tenant' in kwargs:
            pending_fields.append('structured_syslog_tenant')
        if len(args) > 2 or 'structured_syslog_location' in kwargs:
            pending_fields.append('structured_syslog_location')
        if len(args) > 3 or 'structured_syslog_device' in kwargs:
            pending_fields.append('structured_syslog_device')
        if len(args) > 4 or 'structured_syslog_hostname_tags' in kwargs:
            pending_fields.append('structured_syslog_hostname_tags')
        if len(args) > 5 or 'structured_syslog_linkmap' in kwargs:
            pending_fields.append('structured_syslog_linkmap')
        if len(args) > 6 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 7 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 8 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 9 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(StructuredSyslogHostnameRecord, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            props_dict['structured_syslog_hostaddr'] = kwargs[u'structured_syslog_hostaddr']
        except KeyError:
            pass

        try:
            props_dict['structured_syslog_tenant'] = kwargs[u'structured_syslog_tenant']
        except KeyError:
            pass

        try:
            props_dict['structured_syslog_location'] = kwargs[u'structured_syslog_location']
        except KeyError:
            pass

        try:
            props_dict['structured_syslog_device'] = kwargs[u'structured_syslog_device']
        except KeyError:
            pass

        try:
            props_dict['structured_syslog_hostname_tags'] = kwargs[u'structured_syslog_hostname_tags']
        except KeyError:
            pass

        try:
            if kwargs['structured_syslog_linkmap'] is None:
                props_dict['structured_syslog_linkmap'] = None
            else:
                props_dict['structured_syslog_linkmap'] = vnc_api.gen.resource_xsd.StructuredSyslogLinkmap(params_dict=kwargs[u'structured_syslog_linkmap'])
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = StructuredSyslogHostnameRecord(**props_dict)
        else:
            obj = StructuredSyslogHostnameRecord(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.StructuredSyslogHostnameRecord.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.StructuredSyslogHostnameRecord.structured_syslog_hostaddr.setter
    def structured_syslog_hostaddr(self, structured_syslog_hostaddr):
        """Set structured-syslog-hostaddr for structured-syslog-hostname-record.
        
        :param structured_syslog_hostaddr: xsd:string object
        
        """
        if 'structured_syslog_hostaddr' not in self._pending_field_updates:
            self._pending_field_updates.add('structured_syslog_hostaddr')

        self._structured_syslog_hostaddr = structured_syslog_hostaddr
    # end structured_syslog_hostaddr

    def set_structured_syslog_hostaddr(self, value):
        self.structured_syslog_hostaddr = value
    # end set_structured_syslog_hostaddr

    @vnc_api.gen.resource_common.StructuredSyslogHostnameRecord.structured_syslog_tenant.setter
    def structured_syslog_tenant(self, structured_syslog_tenant):
        """Set structured-syslog-tenant for structured-syslog-hostname-record.
        
        :param structured_syslog_tenant: xsd:string object
        
        """
        if 'structured_syslog_tenant' not in self._pending_field_updates:
            self._pending_field_updates.add('structured_syslog_tenant')

        self._structured_syslog_tenant = structured_syslog_tenant
    # end structured_syslog_tenant

    def set_structured_syslog_tenant(self, value):
        self.structured_syslog_tenant = value
    # end set_structured_syslog_tenant

    @vnc_api.gen.resource_common.StructuredSyslogHostnameRecord.structured_syslog_location.setter
    def structured_syslog_location(self, structured_syslog_location):
        """Set structured-syslog-location for structured-syslog-hostname-record.
        
        :param structured_syslog_location: xsd:string object
        
        """
        if 'structured_syslog_location' not in self._pending_field_updates:
            self._pending_field_updates.add('structured_syslog_location')

        self._structured_syslog_location = structured_syslog_location
    # end structured_syslog_location

    def set_structured_syslog_location(self, value):
        self.structured_syslog_location = value
    # end set_structured_syslog_location

    @vnc_api.gen.resource_common.StructuredSyslogHostnameRecord.structured_syslog_device.setter
    def structured_syslog_device(self, structured_syslog_device):
        """Set structured-syslog-device for structured-syslog-hostname-record.
        
        :param structured_syslog_device: xsd:string object
        
        """
        if 'structured_syslog_device' not in self._pending_field_updates:
            self._pending_field_updates.add('structured_syslog_device')

        self._structured_syslog_device = structured_syslog_device
    # end structured_syslog_device

    def set_structured_syslog_device(self, value):
        self.structured_syslog_device = value
    # end set_structured_syslog_device

    @vnc_api.gen.resource_common.StructuredSyslogHostnameRecord.structured_syslog_hostname_tags.setter
    def structured_syslog_hostname_tags(self, structured_syslog_hostname_tags):
        """Set structured-syslog-hostname-tags for structured-syslog-hostname-record.
        
        :param structured_syslog_hostname_tags: xsd:string object
        
        """
        if 'structured_syslog_hostname_tags' not in self._pending_field_updates:
            self._pending_field_updates.add('structured_syslog_hostname_tags')

        self._structured_syslog_hostname_tags = structured_syslog_hostname_tags
    # end structured_syslog_hostname_tags

    def set_structured_syslog_hostname_tags(self, value):
        self.structured_syslog_hostname_tags = value
    # end set_structured_syslog_hostname_tags

    @vnc_api.gen.resource_common.StructuredSyslogHostnameRecord.structured_syslog_linkmap.setter
    def structured_syslog_linkmap(self, structured_syslog_linkmap):
        """Set structured-syslog-linkmap for structured-syslog-hostname-record.
        
        :param structured_syslog_linkmap: StructuredSyslogLinkmap object
        
        """
        if 'structured_syslog_linkmap' not in self._pending_field_updates:
            self._pending_field_updates.add('structured_syslog_linkmap')

        self._structured_syslog_linkmap = structured_syslog_linkmap
    # end structured_syslog_linkmap

    def set_structured_syslog_linkmap(self, value):
        self.structured_syslog_linkmap = value
    # end set_structured_syslog_linkmap

    @vnc_api.gen.resource_common.StructuredSyslogHostnameRecord.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for structured-syslog-hostname-record.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.StructuredSyslogHostnameRecord.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for structured-syslog-hostname-record.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.StructuredSyslogHostnameRecord.annotations.setter
    def annotations(self, annotations):
        """Set annotations for structured-syslog-hostname-record.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.StructuredSyslogHostnameRecord.display_name.setter
    def display_name(self, display_name):
        """Set display-name for structured-syslog-hostname-record.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for structured-syslog-hostname-record.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for structured-syslog-hostname-record.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_tag(self, *args, **kwargs):
        """Set tag for structured-syslog-hostname-record.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(StructuredSyslogHostnameRecord, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to structured-syslog-hostname-record.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(StructuredSyslogHostnameRecord, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(StructuredSyslogHostnameRecord, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for structured-syslog-hostname-record.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(StructuredSyslogHostnameRecord, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


# end class StructuredSyslogHostnameRecord

class ServiceInstance(vnc_api.gen.resource_common.ServiceInstance):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'service_instance_properties' in kwargs:
            pending_fields.append('service_instance_properties')
        if len(args) > 1 or 'service_instance_bindings' in kwargs:
            pending_fields.append('service_instance_bindings')
        if len(args) > 2 or 'service_instance_bgp_enabled' in kwargs:
            pending_fields.append('service_instance_bgp_enabled')
        if len(args) > 3 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 4 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 5 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 6 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(ServiceInstance, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            if kwargs['service_instance_properties'] is None:
                props_dict['service_instance_properties'] = None
            else:
                props_dict['service_instance_properties'] = vnc_api.gen.resource_xsd.ServiceInstanceType(params_dict=kwargs[u'service_instance_properties'])
        except KeyError:
            pass

        try:
            if kwargs['service_instance_bindings'] is None:
                props_dict['service_instance_bindings'] = None
            else:
                props_dict['service_instance_bindings'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'service_instance_bindings'])
        except KeyError:
            pass

        try:
            props_dict['service_instance_bgp_enabled'] = kwargs[u'service_instance_bgp_enabled']
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = ServiceInstance(**props_dict)
        else:
            obj = ServiceInstance(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...
        try:
            obj.port_tuples = kwargs[u'port_tuples']
        except KeyError:
            pass

        # add any specified references...
        try:
            obj.service_template_refs = kwargs[u'service_template_refs']
        except KeyError:
            pass
        try:
            obj.instance_ip_refs = kwargs[u'instance_ip_refs']
            for ref in obj.instance_ip_refs:
                ref['attr'] = vnc_api.gen.resource_xsd.ServiceInterfaceTag(params_dict=ref[u'attr'])
        except KeyError:
            pass
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.virtual_machine_back_refs = kwargs[u'virtual_machine_back_refs']
        except KeyError:
            pass
        try:
            obj.service_health_check_back_refs = kwargs[u'service_health_check_back_refs']
        except KeyError:
            pass
        try:
            obj.interface_route_table_back_refs = kwargs[u'interface_route_table_back_refs']
        except KeyError:
            pass
        try:
            obj.routing_policy_back_refs = kwargs[u'routing_policy_back_refs']
        except KeyError:
            pass
        try:
            obj.route_aggregate_back_refs = kwargs[u'route_aggregate_back_refs']
        except KeyError:
            pass
        try:
            obj.logical_router_back_refs = kwargs[u'logical_router_back_refs']
        except KeyError:
            pass
        try:
            obj.loadbalancer_pool_back_refs = kwargs[u'loadbalancer_pool_back_refs']
        except KeyError:
            pass
        try:
            obj.loadbalancer_back_refs = kwargs[u'loadbalancer_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.ServiceInstance.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.ServiceInstance.service_instance_properties.setter
    def service_instance_properties(self, service_instance_properties):
        """Set service-instance-properties for service-instance.
        
        :param service_instance_properties: ServiceInstanceType object
        
        """
        if 'service_instance_properties' not in self._pending_field_updates:
            self._pending_field_updates.add('service_instance_properties')

        self._service_instance_properties = service_instance_properties
    # end service_instance_properties

    def set_service_instance_properties(self, value):
        self.service_instance_properties = value
    # end set_service_instance_properties

    @vnc_api.gen.resource_common.ServiceInstance.service_instance_bindings.setter
    def service_instance_bindings(self, service_instance_bindings):
        """Set service-instance-bindings for service-instance.
        
        :param service_instance_bindings: KeyValuePairs object
        
        """
        if 'service_instance_bindings' not in self._pending_field_updates:
            self._pending_field_updates.add('service_instance_bindings')

        if 'service_instance_bindings' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['service_instance_bindings']

        self._service_instance_bindings = service_instance_bindings
    # end service_instance_bindings

    def set_service_instance_bindings(self, value):
        self.service_instance_bindings = value
    # end set_service_instance_bindings

    @vnc_api.gen.resource_common.ServiceInstance.service_instance_bgp_enabled.setter
    def service_instance_bgp_enabled(self, service_instance_bgp_enabled):
        """Set service-instance-bgp-enabled for service-instance.
        
        :param service_instance_bgp_enabled: xsd:boolean object
        
        """
        if 'service_instance_bgp_enabled' not in self._pending_field_updates:
            self._pending_field_updates.add('service_instance_bgp_enabled')

        self._service_instance_bgp_enabled = service_instance_bgp_enabled
    # end service_instance_bgp_enabled

    def set_service_instance_bgp_enabled(self, value):
        self.service_instance_bgp_enabled = value
    # end set_service_instance_bgp_enabled

    @vnc_api.gen.resource_common.ServiceInstance.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for service-instance.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.ServiceInstance.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for service-instance.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.ServiceInstance.annotations.setter
    def annotations(self, annotations):
        """Set annotations for service-instance.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.ServiceInstance.display_name.setter
    def display_name(self, display_name):
        """Set display-name for service-instance.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_service_instance_bindings(self, elem):
        """Add element to service-instance-bindings for service-instance.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'service_instance_bindings' not in self._pending_field_map_updates:
            self._pending_field_map_updates['service_instance_bindings'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['service_instance_bindings'].append(
                ('set', elem, elem_position))
    # end set_service_instance_bindings

    def del_service_instance_bindings(self, elem_position):
        """Delete element from service-instance-bindings for service-instance.
        
        :param elem_position: string indicating map-key
        
        """
        if 'service_instance_bindings' not in self._pending_field_map_updates:
            self._pending_field_map_updates['service_instance_bindings'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['service_instance_bindings'].append(
                ('delete', None, elem_position))
    # end del_service_instance_bindings
    def add_annotations(self, elem):
        """Add element to annotations for service-instance.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for service-instance.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_service_template(self, *args, **kwargs):
        """Set service-template for service-instance.
        
        :param ref_obj: ServiceTemplate object
        
        """
        self._pending_field_updates.add('service_template_refs')
        self._pending_ref_updates.discard('service_template_refs')
        super(ServiceInstance, self).set_service_template(*args, **kwargs)

    # end set_service_template

    def add_service_template(self, *args, **kwargs):
        """Add service-template to service-instance.
        
        :param ref_obj: ServiceTemplate object
        
        """
        if 'service_template_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('service_template_refs')
            self._original_service_template_refs = copy.deepcopy(self.get_service_template_refs() or [])
        super(ServiceInstance, self).add_service_template(*args, **kwargs)
    # end add_service_template

    def del_service_template(self, *args, **kwargs):
        if 'service_template_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('service_template_refs')
            self._original_service_template_refs = copy.deepcopy(self.get_service_template_refs() or [])
        super(ServiceInstance, self).del_service_template(*args, **kwargs)
    # end del_service_template

    def set_service_template_list(self, *args, **kwargs):
        """Set service-template list for service-instance.
        
        :param ref_obj_list: list of ServiceTemplate object
        
        """
        self._pending_field_updates.add('service_template_refs')
        self._pending_ref_updates.discard('service_template_refs')
        super(ServiceInstance, self).set_service_template_list(*args, **kwargs)
    # end set_service_template_list

    def set_instance_ip(self, *args, **kwargs):
        """Set instance-ip for service-instance.
        
        :param ref_obj: InstanceIp object
        :param ref_data: ServiceInterfaceTag object
        
        """
        self._pending_field_updates.add('instance_ip_refs')
        self._pending_ref_updates.discard('instance_ip_refs')
        super(ServiceInstance, self).set_instance_ip(*args, **kwargs)

    # end set_instance_ip

    def add_instance_ip(self, *args, **kwargs):
        """Add instance-ip to service-instance.
        
        :param ref_obj: InstanceIp object
        :param ref_data: ServiceInterfaceTag object
        
        """
        if 'instance_ip_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('instance_ip_refs')
            self._original_instance_ip_refs = copy.deepcopy(self.get_instance_ip_refs() or [])
        super(ServiceInstance, self).add_instance_ip(*args, **kwargs)
    # end add_instance_ip

    def del_instance_ip(self, *args, **kwargs):
        if 'instance_ip_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('instance_ip_refs')
            self._original_instance_ip_refs = copy.deepcopy(self.get_instance_ip_refs() or [])
        super(ServiceInstance, self).del_instance_ip(*args, **kwargs)
    # end del_instance_ip

    def set_instance_ip_list(self, *args, **kwargs):
        """Set instance-ip list for service-instance.
        
        :param ref_obj_list: list of InstanceIp object
        :param ref_data_list: list of ServiceInterfaceTag summary
        
        """
        self._pending_field_updates.add('instance_ip_refs')
        self._pending_ref_updates.discard('instance_ip_refs')
        super(ServiceInstance, self).set_instance_ip_list(*args, **kwargs)
    # end set_instance_ip_list

    def set_tag(self, *args, **kwargs):
        """Set tag for service-instance.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(ServiceInstance, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to service-instance.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(ServiceInstance, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(ServiceInstance, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for service-instance.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(ServiceInstance, self).set_tag_list(*args, **kwargs)
    # end set_tag_list

    def get_port_tuples(self):
        if hasattr(self, 'port_tuples'):
            return self.port_tuples

        if hasattr(super(ServiceInstance, self), 'port_tuples'):
            return super(ServiceInstance, self).get_port_tuples()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.service_instance_read(id = self.uuid, fields = ['port_tuples'])
        except NoIdError:
            return None
        children = getattr(obj, 'port_tuples', None)
        if not children:
            return None
        self.port_tuples = children

        return children
    # end get_port_tuples


    def get_virtual_machine_back_refs(self):
        """Return list of all virtual-machines using this service-instance"""
        if hasattr(self, 'virtual_machine_back_refs'):
            return self.virtual_machine_back_refs

        if hasattr(super(ServiceInstance, self), 'virtual_machine_back_refs'):
            return super(ServiceInstance, self).get_virtual_machine_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.service_instance_read(id = self.uuid, fields = ['virtual_machine_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'virtual_machine_back_refs', None)
        if not back_refs:
            return None
        self.virtual_machine_back_refs = back_refs

        return back_refs
    # end get_virtual_machine_back_refs

    def get_service_health_check_back_refs(self):
        """Return list of all service-health-checks using this service-instance"""
        if hasattr(self, 'service_health_check_back_refs'):
            return self.service_health_check_back_refs

        if hasattr(super(ServiceInstance, self), 'service_health_check_back_refs'):
            return super(ServiceInstance, self).get_service_health_check_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.service_instance_read(id = self.uuid, fields = ['service_health_check_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'service_health_check_back_refs', None)
        if not back_refs:
            return None
        self.service_health_check_back_refs = back_refs

        return back_refs
    # end get_service_health_check_back_refs

    def get_interface_route_table_back_refs(self):
        """Return list of all interface-route-tables using this service-instance"""
        if hasattr(self, 'interface_route_table_back_refs'):
            return self.interface_route_table_back_refs

        if hasattr(super(ServiceInstance, self), 'interface_route_table_back_refs'):
            return super(ServiceInstance, self).get_interface_route_table_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.service_instance_read(id = self.uuid, fields = ['interface_route_table_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'interface_route_table_back_refs', None)
        if not back_refs:
            return None
        self.interface_route_table_back_refs = back_refs

        return back_refs
    # end get_interface_route_table_back_refs

    def get_routing_policy_back_refs(self):
        """Return list of all routing-policys using this service-instance"""
        if hasattr(self, 'routing_policy_back_refs'):
            return self.routing_policy_back_refs

        if hasattr(super(ServiceInstance, self), 'routing_policy_back_refs'):
            return super(ServiceInstance, self).get_routing_policy_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.service_instance_read(id = self.uuid, fields = ['routing_policy_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'routing_policy_back_refs', None)
        if not back_refs:
            return None
        self.routing_policy_back_refs = back_refs

        return back_refs
    # end get_routing_policy_back_refs

    def get_route_aggregate_back_refs(self):
        """Return list of all route-aggregates using this service-instance"""
        if hasattr(self, 'route_aggregate_back_refs'):
            return self.route_aggregate_back_refs

        if hasattr(super(ServiceInstance, self), 'route_aggregate_back_refs'):
            return super(ServiceInstance, self).get_route_aggregate_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.service_instance_read(id = self.uuid, fields = ['route_aggregate_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'route_aggregate_back_refs', None)
        if not back_refs:
            return None
        self.route_aggregate_back_refs = back_refs

        return back_refs
    # end get_route_aggregate_back_refs

    def get_logical_router_back_refs(self):
        """Return list of all logical-routers using this service-instance"""
        if hasattr(self, 'logical_router_back_refs'):
            return self.logical_router_back_refs

        if hasattr(super(ServiceInstance, self), 'logical_router_back_refs'):
            return super(ServiceInstance, self).get_logical_router_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.service_instance_read(id = self.uuid, fields = ['logical_router_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'logical_router_back_refs', None)
        if not back_refs:
            return None
        self.logical_router_back_refs = back_refs

        return back_refs
    # end get_logical_router_back_refs

    def get_loadbalancer_pool_back_refs(self):
        """Return list of all loadbalancer-pools using this service-instance"""
        if hasattr(self, 'loadbalancer_pool_back_refs'):
            return self.loadbalancer_pool_back_refs

        if hasattr(super(ServiceInstance, self), 'loadbalancer_pool_back_refs'):
            return super(ServiceInstance, self).get_loadbalancer_pool_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.service_instance_read(id = self.uuid, fields = ['loadbalancer_pool_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'loadbalancer_pool_back_refs', None)
        if not back_refs:
            return None
        self.loadbalancer_pool_back_refs = back_refs

        return back_refs
    # end get_loadbalancer_pool_back_refs

    def get_loadbalancer_back_refs(self):
        """Return list of all loadbalancers using this service-instance"""
        if hasattr(self, 'loadbalancer_back_refs'):
            return self.loadbalancer_back_refs

        if hasattr(super(ServiceInstance, self), 'loadbalancer_back_refs'):
            return super(ServiceInstance, self).get_loadbalancer_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.service_instance_read(id = self.uuid, fields = ['loadbalancer_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'loadbalancer_back_refs', None)
        if not back_refs:
            return None
        self.loadbalancer_back_refs = back_refs

        return back_refs
    # end get_loadbalancer_back_refs

# end class ServiceInstance

class NodeProfile(vnc_api.gen.resource_common.NodeProfile):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'node_profile_type' in kwargs:
            pending_fields.append('node_profile_type')
        if len(args) > 1 or 'node_profile_vendor' in kwargs:
            pending_fields.append('node_profile_vendor')
        if len(args) > 2 or 'node_profile_device_family' in kwargs:
            pending_fields.append('node_profile_device_family')
        if len(args) > 3 or 'node_profile_hitless_upgrade' in kwargs:
            pending_fields.append('node_profile_hitless_upgrade')
        if len(args) > 4 or 'node_profile_roles' in kwargs:
            pending_fields.append('node_profile_roles')
        if len(args) > 5 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 6 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 7 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 8 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(NodeProfile, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            props_dict['node_profile_type'] = kwargs[u'node_profile_type']
        except KeyError:
            pass

        try:
            props_dict['node_profile_vendor'] = kwargs[u'node_profile_vendor']
        except KeyError:
            pass

        try:
            props_dict['node_profile_device_family'] = kwargs[u'node_profile_device_family']
        except KeyError:
            pass

        try:
            props_dict['node_profile_hitless_upgrade'] = kwargs[u'node_profile_hitless_upgrade']
        except KeyError:
            pass

        try:
            if kwargs['node_profile_roles'] is None:
                props_dict['node_profile_roles'] = None
            else:
                props_dict['node_profile_roles'] = vnc_api.gen.resource_xsd.NodeProfileRolesType(params_dict=kwargs[u'node_profile_roles'])
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = NodeProfile(**props_dict)
        else:
            obj = NodeProfile(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...
        try:
            obj.role_configs = kwargs[u'role_configs']
        except KeyError:
            pass

        # add any specified references...
        try:
            obj.job_template_refs = kwargs[u'job_template_refs']
        except KeyError:
            pass
        try:
            obj.hardware_refs = kwargs[u'hardware_refs']
        except KeyError:
            pass
        try:
            obj.role_definition_refs = kwargs[u'role_definition_refs']
        except KeyError:
            pass
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.fabric_back_refs = kwargs[u'fabric_back_refs']
        except KeyError:
            pass
        try:
            obj.physical_router_back_refs = kwargs[u'physical_router_back_refs']
        except KeyError:
            pass
        try:
            obj.node_back_refs = kwargs[u'node_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.NodeProfile.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.NodeProfile.node_profile_type.setter
    def node_profile_type(self, node_profile_type):
        """Set node-profile-type for node-profile.
        
        :param node_profile_type: NodeProfileType object
        
        """
        if 'node_profile_type' not in self._pending_field_updates:
            self._pending_field_updates.add('node_profile_type')

        self._node_profile_type = node_profile_type
    # end node_profile_type

    def set_node_profile_type(self, value):
        self.node_profile_type = value
    # end set_node_profile_type

    @vnc_api.gen.resource_common.NodeProfile.node_profile_vendor.setter
    def node_profile_vendor(self, node_profile_vendor):
        """Set node-profile-vendor for node-profile.
        
        :param node_profile_vendor: xsd:string object
        
        """
        if 'node_profile_vendor' not in self._pending_field_updates:
            self._pending_field_updates.add('node_profile_vendor')

        self._node_profile_vendor = node_profile_vendor
    # end node_profile_vendor

    def set_node_profile_vendor(self, value):
        self.node_profile_vendor = value
    # end set_node_profile_vendor

    @vnc_api.gen.resource_common.NodeProfile.node_profile_device_family.setter
    def node_profile_device_family(self, node_profile_device_family):
        """Set node-profile-device-family for node-profile.
        
        :param node_profile_device_family: xsd:string object
        
        """
        if 'node_profile_device_family' not in self._pending_field_updates:
            self._pending_field_updates.add('node_profile_device_family')

        self._node_profile_device_family = node_profile_device_family
    # end node_profile_device_family

    def set_node_profile_device_family(self, value):
        self.node_profile_device_family = value
    # end set_node_profile_device_family

    @vnc_api.gen.resource_common.NodeProfile.node_profile_hitless_upgrade.setter
    def node_profile_hitless_upgrade(self, node_profile_hitless_upgrade):
        """Set node-profile-hitless-upgrade for node-profile.
        
        :param node_profile_hitless_upgrade: xsd:boolean object
        
        """
        if 'node_profile_hitless_upgrade' not in self._pending_field_updates:
            self._pending_field_updates.add('node_profile_hitless_upgrade')

        self._node_profile_hitless_upgrade = node_profile_hitless_upgrade
    # end node_profile_hitless_upgrade

    def set_node_profile_hitless_upgrade(self, value):
        self.node_profile_hitless_upgrade = value
    # end set_node_profile_hitless_upgrade

    @vnc_api.gen.resource_common.NodeProfile.node_profile_roles.setter
    def node_profile_roles(self, node_profile_roles):
        """Set node-profile-roles for node-profile.
        
        :param node_profile_roles: NodeProfileRolesType object
        
        """
        if 'node_profile_roles' not in self._pending_field_updates:
            self._pending_field_updates.add('node_profile_roles')

        self._node_profile_roles = node_profile_roles
    # end node_profile_roles

    def set_node_profile_roles(self, value):
        self.node_profile_roles = value
    # end set_node_profile_roles

    @vnc_api.gen.resource_common.NodeProfile.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for node-profile.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.NodeProfile.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for node-profile.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.NodeProfile.annotations.setter
    def annotations(self, annotations):
        """Set annotations for node-profile.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.NodeProfile.display_name.setter
    def display_name(self, display_name):
        """Set display-name for node-profile.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for node-profile.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for node-profile.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_job_template(self, *args, **kwargs):
        """Set job-template for node-profile.
        
        :param ref_obj: JobTemplate object
        
        """
        self._pending_field_updates.add('job_template_refs')
        self._pending_ref_updates.discard('job_template_refs')
        super(NodeProfile, self).set_job_template(*args, **kwargs)

    # end set_job_template

    def add_job_template(self, *args, **kwargs):
        """Add job-template to node-profile.
        
        :param ref_obj: JobTemplate object
        
        """
        if 'job_template_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('job_template_refs')
            self._original_job_template_refs = copy.deepcopy(self.get_job_template_refs() or [])
        super(NodeProfile, self).add_job_template(*args, **kwargs)
    # end add_job_template

    def del_job_template(self, *args, **kwargs):
        if 'job_template_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('job_template_refs')
            self._original_job_template_refs = copy.deepcopy(self.get_job_template_refs() or [])
        super(NodeProfile, self).del_job_template(*args, **kwargs)
    # end del_job_template

    def set_job_template_list(self, *args, **kwargs):
        """Set job-template list for node-profile.
        
        :param ref_obj_list: list of JobTemplate object
        
        """
        self._pending_field_updates.add('job_template_refs')
        self._pending_ref_updates.discard('job_template_refs')
        super(NodeProfile, self).set_job_template_list(*args, **kwargs)
    # end set_job_template_list

    def set_hardware(self, *args, **kwargs):
        """Set hardware for node-profile.
        
        :param ref_obj: Hardware object
        
        """
        self._pending_field_updates.add('hardware_refs')
        self._pending_ref_updates.discard('hardware_refs')
        super(NodeProfile, self).set_hardware(*args, **kwargs)

    # end set_hardware

    def add_hardware(self, *args, **kwargs):
        """Add hardware to node-profile.
        
        :param ref_obj: Hardware object
        
        """
        if 'hardware_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('hardware_refs')
            self._original_hardware_refs = copy.deepcopy(self.get_hardware_refs() or [])
        super(NodeProfile, self).add_hardware(*args, **kwargs)
    # end add_hardware

    def del_hardware(self, *args, **kwargs):
        if 'hardware_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('hardware_refs')
            self._original_hardware_refs = copy.deepcopy(self.get_hardware_refs() or [])
        super(NodeProfile, self).del_hardware(*args, **kwargs)
    # end del_hardware

    def set_hardware_list(self, *args, **kwargs):
        """Set hardware list for node-profile.
        
        :param ref_obj_list: list of Hardware object
        
        """
        self._pending_field_updates.add('hardware_refs')
        self._pending_ref_updates.discard('hardware_refs')
        super(NodeProfile, self).set_hardware_list(*args, **kwargs)
    # end set_hardware_list

    def set_role_definition(self, *args, **kwargs):
        """Set role-definition for node-profile.
        
        :param ref_obj: RoleDefinition object
        
        """
        self._pending_field_updates.add('role_definition_refs')
        self._pending_ref_updates.discard('role_definition_refs')
        super(NodeProfile, self).set_role_definition(*args, **kwargs)

    # end set_role_definition

    def add_role_definition(self, *args, **kwargs):
        """Add role-definition to node-profile.
        
        :param ref_obj: RoleDefinition object
        
        """
        if 'role_definition_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('role_definition_refs')
            self._original_role_definition_refs = copy.deepcopy(self.get_role_definition_refs() or [])
        super(NodeProfile, self).add_role_definition(*args, **kwargs)
    # end add_role_definition

    def del_role_definition(self, *args, **kwargs):
        if 'role_definition_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('role_definition_refs')
            self._original_role_definition_refs = copy.deepcopy(self.get_role_definition_refs() or [])
        super(NodeProfile, self).del_role_definition(*args, **kwargs)
    # end del_role_definition

    def set_role_definition_list(self, *args, **kwargs):
        """Set role-definition list for node-profile.
        
        :param ref_obj_list: list of RoleDefinition object
        
        """
        self._pending_field_updates.add('role_definition_refs')
        self._pending_ref_updates.discard('role_definition_refs')
        super(NodeProfile, self).set_role_definition_list(*args, **kwargs)
    # end set_role_definition_list

    def set_tag(self, *args, **kwargs):
        """Set tag for node-profile.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(NodeProfile, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to node-profile.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(NodeProfile, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(NodeProfile, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for node-profile.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(NodeProfile, self).set_tag_list(*args, **kwargs)
    # end set_tag_list

    def get_role_configs(self):
        if hasattr(self, 'role_configs'):
            return self.role_configs

        if hasattr(super(NodeProfile, self), 'role_configs'):
            return super(NodeProfile, self).get_role_configs()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.node_profile_read(id = self.uuid, fields = ['role_configs'])
        except NoIdError:
            return None
        children = getattr(obj, 'role_configs', None)
        if not children:
            return None
        self.role_configs = children

        return children
    # end get_role_configs


    def get_fabric_back_refs(self):
        """Return list of all fabrics using this node-profile"""
        if hasattr(self, 'fabric_back_refs'):
            return self.fabric_back_refs

        if hasattr(super(NodeProfile, self), 'fabric_back_refs'):
            return super(NodeProfile, self).get_fabric_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.node_profile_read(id = self.uuid, fields = ['fabric_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'fabric_back_refs', None)
        if not back_refs:
            return None
        self.fabric_back_refs = back_refs

        return back_refs
    # end get_fabric_back_refs

    def get_physical_router_back_refs(self):
        """Return list of all physical-routers using this node-profile"""
        if hasattr(self, 'physical_router_back_refs'):
            return self.physical_router_back_refs

        if hasattr(super(NodeProfile, self), 'physical_router_back_refs'):
            return super(NodeProfile, self).get_physical_router_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.node_profile_read(id = self.uuid, fields = ['physical_router_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'physical_router_back_refs', None)
        if not back_refs:
            return None
        self.physical_router_back_refs = back_refs

        return back_refs
    # end get_physical_router_back_refs

    def get_node_back_refs(self):
        """Return list of all nodes using this node-profile"""
        if hasattr(self, 'node_back_refs'):
            return self.node_back_refs

        if hasattr(super(NodeProfile, self), 'node_back_refs'):
            return super(NodeProfile, self).get_node_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.node_profile_read(id = self.uuid, fields = ['node_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'node_back_refs', None)
        if not back_refs:
            return None
        self.node_back_refs = back_refs

        return back_refs
    # end get_node_back_refs

# end class NodeProfile

class BridgeDomain(vnc_api.gen.resource_common.BridgeDomain):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'mac_learning_enabled' in kwargs:
            pending_fields.append('mac_learning_enabled')
        if len(args) > 1 or 'mac_limit_control' in kwargs:
            pending_fields.append('mac_limit_control')
        if len(args) > 2 or 'mac_move_control' in kwargs:
            pending_fields.append('mac_move_control')
        if len(args) > 3 or 'mac_aging_time' in kwargs:
            pending_fields.append('mac_aging_time')
        if len(args) > 4 or 'isid' in kwargs:
            pending_fields.append('isid')
        if len(args) > 5 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 6 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 7 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 8 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(BridgeDomain, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            props_dict['mac_learning_enabled'] = kwargs[u'mac_learning_enabled']
        except KeyError:
            pass

        try:
            if kwargs['mac_limit_control'] is None:
                props_dict['mac_limit_control'] = None
            else:
                props_dict['mac_limit_control'] = vnc_api.gen.resource_xsd.MACLimitControlType(params_dict=kwargs[u'mac_limit_control'])
        except KeyError:
            pass

        try:
            if kwargs['mac_move_control'] is None:
                props_dict['mac_move_control'] = None
            else:
                props_dict['mac_move_control'] = vnc_api.gen.resource_xsd.MACMoveLimitControlType(params_dict=kwargs[u'mac_move_control'])
        except KeyError:
            pass

        try:
            props_dict['mac_aging_time'] = kwargs[u'mac_aging_time']
        except KeyError:
            pass

        try:
            props_dict['isid'] = kwargs[u'isid']
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = BridgeDomain(**props_dict)
        else:
            obj = BridgeDomain(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.virtual_machine_interface_back_refs = kwargs[u'virtual_machine_interface_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.BridgeDomain.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.BridgeDomain.mac_learning_enabled.setter
    def mac_learning_enabled(self, mac_learning_enabled):
        """Set mac-learning-enabled for bridge-domain.
        
        :param mac_learning_enabled: xsd:boolean object
        
        """
        if 'mac_learning_enabled' not in self._pending_field_updates:
            self._pending_field_updates.add('mac_learning_enabled')

        self._mac_learning_enabled = mac_learning_enabled
    # end mac_learning_enabled

    def set_mac_learning_enabled(self, value):
        self.mac_learning_enabled = value
    # end set_mac_learning_enabled

    @vnc_api.gen.resource_common.BridgeDomain.mac_limit_control.setter
    def mac_limit_control(self, mac_limit_control):
        """Set mac-limit-control for bridge-domain.
        
        :param mac_limit_control: MACLimitControlType object
        
        """
        if 'mac_limit_control' not in self._pending_field_updates:
            self._pending_field_updates.add('mac_limit_control')

        self._mac_limit_control = mac_limit_control
    # end mac_limit_control

    def set_mac_limit_control(self, value):
        self.mac_limit_control = value
    # end set_mac_limit_control

    @vnc_api.gen.resource_common.BridgeDomain.mac_move_control.setter
    def mac_move_control(self, mac_move_control):
        """Set mac-move-control for bridge-domain.
        
        :param mac_move_control: MACMoveLimitControlType object
        
        """
        if 'mac_move_control' not in self._pending_field_updates:
            self._pending_field_updates.add('mac_move_control')

        self._mac_move_control = mac_move_control
    # end mac_move_control

    def set_mac_move_control(self, value):
        self.mac_move_control = value
    # end set_mac_move_control

    @vnc_api.gen.resource_common.BridgeDomain.mac_aging_time.setter
    def mac_aging_time(self, mac_aging_time):
        """Set mac-aging-time for bridge-domain.
        
        :param mac_aging_time: MACAgingTime object
        
        """
        if 'mac_aging_time' not in self._pending_field_updates:
            self._pending_field_updates.add('mac_aging_time')

        self._mac_aging_time = mac_aging_time
    # end mac_aging_time

    def set_mac_aging_time(self, value):
        self.mac_aging_time = value
    # end set_mac_aging_time

    @vnc_api.gen.resource_common.BridgeDomain.isid.setter
    def isid(self, isid):
        """Set isid for bridge-domain.
        
        :param isid: IsidType object
        
        """
        if 'isid' not in self._pending_field_updates:
            self._pending_field_updates.add('isid')

        self._isid = isid
    # end isid

    def set_isid(self, value):
        self.isid = value
    # end set_isid

    @vnc_api.gen.resource_common.BridgeDomain.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for bridge-domain.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.BridgeDomain.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for bridge-domain.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.BridgeDomain.annotations.setter
    def annotations(self, annotations):
        """Set annotations for bridge-domain.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.BridgeDomain.display_name.setter
    def display_name(self, display_name):
        """Set display-name for bridge-domain.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for bridge-domain.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for bridge-domain.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_tag(self, *args, **kwargs):
        """Set tag for bridge-domain.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(BridgeDomain, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to bridge-domain.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(BridgeDomain, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(BridgeDomain, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for bridge-domain.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(BridgeDomain, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


    def get_virtual_machine_interface_back_refs(self):
        """Return list of all virtual-machine-interfaces using this bridge-domain"""
        if hasattr(self, 'virtual_machine_interface_back_refs'):
            return self.virtual_machine_interface_back_refs

        if hasattr(super(BridgeDomain, self), 'virtual_machine_interface_back_refs'):
            return super(BridgeDomain, self).get_virtual_machine_interface_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.bridge_domain_read(id = self.uuid, fields = ['virtual_machine_interface_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'virtual_machine_interface_back_refs', None)
        if not back_refs:
            return None
        self.virtual_machine_interface_back_refs = back_refs

        return back_refs
    # end get_virtual_machine_interface_back_refs

# end class BridgeDomain

class AliasIp(vnc_api.gen.resource_common.AliasIp):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'alias_ip_address' in kwargs:
            pending_fields.append('alias_ip_address')
        if len(args) > 1 or 'alias_ip_address_family' in kwargs:
            pending_fields.append('alias_ip_address_family')
        if len(args) > 2 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 3 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 4 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 5 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(AliasIp, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            props_dict['alias_ip_address'] = kwargs[u'alias_ip_address']
        except KeyError:
            pass

        try:
            props_dict['alias_ip_address_family'] = kwargs[u'alias_ip_address_family']
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = AliasIp(**props_dict)
        else:
            obj = AliasIp(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.project_refs = kwargs[u'project_refs']
        except KeyError:
            pass
        try:
            obj.virtual_machine_interface_refs = kwargs[u'virtual_machine_interface_refs']
        except KeyError:
            pass
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.AliasIp.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.AliasIp.alias_ip_address.setter
    def alias_ip_address(self, alias_ip_address):
        """Set alias-ip-address for alias-ip.
        
        :param alias_ip_address: IpAddressType object
        
        """
        if 'alias_ip_address' not in self._pending_field_updates:
            self._pending_field_updates.add('alias_ip_address')

        self._alias_ip_address = alias_ip_address
    # end alias_ip_address

    def set_alias_ip_address(self, value):
        self.alias_ip_address = value
    # end set_alias_ip_address

    @vnc_api.gen.resource_common.AliasIp.alias_ip_address_family.setter
    def alias_ip_address_family(self, alias_ip_address_family):
        """Set alias-ip-address-family for alias-ip.
        
        :param alias_ip_address_family: IpAddressFamilyType object
        
        """
        if 'alias_ip_address_family' not in self._pending_field_updates:
            self._pending_field_updates.add('alias_ip_address_family')

        self._alias_ip_address_family = alias_ip_address_family
    # end alias_ip_address_family

    def set_alias_ip_address_family(self, value):
        self.alias_ip_address_family = value
    # end set_alias_ip_address_family

    @vnc_api.gen.resource_common.AliasIp.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for alias-ip.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.AliasIp.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for alias-ip.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.AliasIp.annotations.setter
    def annotations(self, annotations):
        """Set annotations for alias-ip.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.AliasIp.display_name.setter
    def display_name(self, display_name):
        """Set display-name for alias-ip.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for alias-ip.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for alias-ip.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_project(self, *args, **kwargs):
        """Set project for alias-ip.
        
        :param ref_obj: Project object
        
        """
        self._pending_field_updates.add('project_refs')
        self._pending_ref_updates.discard('project_refs')
        super(AliasIp, self).set_project(*args, **kwargs)

    # end set_project

    def add_project(self, *args, **kwargs):
        """Add project to alias-ip.
        
        :param ref_obj: Project object
        
        """
        if 'project_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('project_refs')
            self._original_project_refs = copy.deepcopy(self.get_project_refs() or [])
        super(AliasIp, self).add_project(*args, **kwargs)
    # end add_project

    def del_project(self, *args, **kwargs):
        if 'project_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('project_refs')
            self._original_project_refs = copy.deepcopy(self.get_project_refs() or [])
        super(AliasIp, self).del_project(*args, **kwargs)
    # end del_project

    def set_project_list(self, *args, **kwargs):
        """Set project list for alias-ip.
        
        :param ref_obj_list: list of Project object
        
        """
        self._pending_field_updates.add('project_refs')
        self._pending_ref_updates.discard('project_refs')
        super(AliasIp, self).set_project_list(*args, **kwargs)
    # end set_project_list

    def set_virtual_machine_interface(self, *args, **kwargs):
        """Set virtual-machine-interface for alias-ip.
        
        :param ref_obj: VirtualMachineInterface object
        
        """
        self._pending_field_updates.add('virtual_machine_interface_refs')
        self._pending_ref_updates.discard('virtual_machine_interface_refs')
        super(AliasIp, self).set_virtual_machine_interface(*args, **kwargs)

    # end set_virtual_machine_interface

    def add_virtual_machine_interface(self, *args, **kwargs):
        """Add virtual-machine-interface to alias-ip.
        
        :param ref_obj: VirtualMachineInterface object
        
        """
        if 'virtual_machine_interface_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('virtual_machine_interface_refs')
            self._original_virtual_machine_interface_refs = copy.deepcopy(self.get_virtual_machine_interface_refs() or [])
        super(AliasIp, self).add_virtual_machine_interface(*args, **kwargs)
    # end add_virtual_machine_interface

    def del_virtual_machine_interface(self, *args, **kwargs):
        if 'virtual_machine_interface_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('virtual_machine_interface_refs')
            self._original_virtual_machine_interface_refs = copy.deepcopy(self.get_virtual_machine_interface_refs() or [])
        super(AliasIp, self).del_virtual_machine_interface(*args, **kwargs)
    # end del_virtual_machine_interface

    def set_virtual_machine_interface_list(self, *args, **kwargs):
        """Set virtual-machine-interface list for alias-ip.
        
        :param ref_obj_list: list of VirtualMachineInterface object
        
        """
        self._pending_field_updates.add('virtual_machine_interface_refs')
        self._pending_ref_updates.discard('virtual_machine_interface_refs')
        super(AliasIp, self).set_virtual_machine_interface_list(*args, **kwargs)
    # end set_virtual_machine_interface_list

    def set_tag(self, *args, **kwargs):
        """Set tag for alias-ip.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(AliasIp, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to alias-ip.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(AliasIp, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(AliasIp, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for alias-ip.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(AliasIp, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


# end class AliasIp

class WebuiNode(vnc_api.gen.resource_common.WebuiNode):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'webui_node_ip_address' in kwargs:
            pending_fields.append('webui_node_ip_address')
        if len(args) > 1 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 2 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 3 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 4 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(WebuiNode, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            props_dict['webui_node_ip_address'] = kwargs[u'webui_node_ip_address']
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = WebuiNode(**props_dict)
        else:
            obj = WebuiNode(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.WebuiNode.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.WebuiNode.webui_node_ip_address.setter
    def webui_node_ip_address(self, webui_node_ip_address):
        """Set webui-node-ip-address for webui-node.
        
        :param webui_node_ip_address: IpAddressType object
        
        """
        if 'webui_node_ip_address' not in self._pending_field_updates:
            self._pending_field_updates.add('webui_node_ip_address')

        self._webui_node_ip_address = webui_node_ip_address
    # end webui_node_ip_address

    def set_webui_node_ip_address(self, value):
        self.webui_node_ip_address = value
    # end set_webui_node_ip_address

    @vnc_api.gen.resource_common.WebuiNode.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for webui-node.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.WebuiNode.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for webui-node.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.WebuiNode.annotations.setter
    def annotations(self, annotations):
        """Set annotations for webui-node.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.WebuiNode.display_name.setter
    def display_name(self, display_name):
        """Set display-name for webui-node.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for webui-node.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for webui-node.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_tag(self, *args, **kwargs):
        """Set tag for webui-node.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(WebuiNode, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to webui-node.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(WebuiNode, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(WebuiNode, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for webui-node.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(WebuiNode, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


# end class WebuiNode

class Port(vnc_api.gen.resource_common.Port):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'port_group_uuid' in kwargs:
            pending_fields.append('port_group_uuid')
        if len(args) > 1 or 'bms_port_info' in kwargs:
            pending_fields.append('bms_port_info')
        if len(args) > 2 or 'esxi_port_info' in kwargs:
            pending_fields.append('esxi_port_info')
        if len(args) > 3 or 'label' in kwargs:
            pending_fields.append('label')
        if len(args) > 4 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 5 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 6 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 7 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(Port, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            props_dict['port_group_uuid'] = kwargs[u'port_group_uuid']
        except KeyError:
            pass

        try:
            if kwargs['bms_port_info'] is None:
                props_dict['bms_port_info'] = None
            else:
                props_dict['bms_port_info'] = vnc_api.gen.resource_xsd.BaremetalPortInfo(params_dict=kwargs[u'bms_port_info'])
        except KeyError:
            pass

        try:
            if kwargs['esxi_port_info'] is None:
                props_dict['esxi_port_info'] = None
            else:
                props_dict['esxi_port_info'] = vnc_api.gen.resource_xsd.ESXIProperties(params_dict=kwargs[u'esxi_port_info'])
        except KeyError:
            pass

        try:
            props_dict['label'] = kwargs[u'label']
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = Port(**props_dict)
        else:
            obj = Port(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.port_group_back_refs = kwargs[u'port_group_back_refs']
        except KeyError:
            pass
        try:
            obj.physical_interface_back_refs = kwargs[u'physical_interface_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.Port.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.Port.port_group_uuid.setter
    def port_group_uuid(self, port_group_uuid):
        """Set port-group-uuid for port.
        
        :param port_group_uuid: xsd:string object
        
        """
        if 'port_group_uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('port_group_uuid')

        self._port_group_uuid = port_group_uuid
    # end port_group_uuid

    def set_port_group_uuid(self, value):
        self.port_group_uuid = value
    # end set_port_group_uuid

    @vnc_api.gen.resource_common.Port.bms_port_info.setter
    def bms_port_info(self, bms_port_info):
        """Set bms-port-info for port.
        
        :param bms_port_info: BaremetalPortInfo object
        
        """
        if 'bms_port_info' not in self._pending_field_updates:
            self._pending_field_updates.add('bms_port_info')

        self._bms_port_info = bms_port_info
    # end bms_port_info

    def set_bms_port_info(self, value):
        self.bms_port_info = value
    # end set_bms_port_info

    @vnc_api.gen.resource_common.Port.esxi_port_info.setter
    def esxi_port_info(self, esxi_port_info):
        """Set esxi-port-info for port.
        
        :param esxi_port_info: ESXIProperties object
        
        """
        if 'esxi_port_info' not in self._pending_field_updates:
            self._pending_field_updates.add('esxi_port_info')

        self._esxi_port_info = esxi_port_info
    # end esxi_port_info

    def set_esxi_port_info(self, value):
        self.esxi_port_info = value
    # end set_esxi_port_info

    @vnc_api.gen.resource_common.Port.label.setter
    def label(self, label):
        """Set label for port.
        
        :param label: xsd:string object
        
        """
        if 'label' not in self._pending_field_updates:
            self._pending_field_updates.add('label')

        self._label = label
    # end label

    def set_label(self, value):
        self.label = value
    # end set_label

    @vnc_api.gen.resource_common.Port.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for port.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.Port.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for port.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.Port.annotations.setter
    def annotations(self, annotations):
        """Set annotations for port.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.Port.display_name.setter
    def display_name(self, display_name):
        """Set display-name for port.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for port.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for port.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_tag(self, *args, **kwargs):
        """Set tag for port.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(Port, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to port.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(Port, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(Port, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for port.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(Port, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


    def get_port_group_back_refs(self):
        """Return list of all port-groups using this port"""
        if hasattr(self, 'port_group_back_refs'):
            return self.port_group_back_refs

        if hasattr(super(Port, self), 'port_group_back_refs'):
            return super(Port, self).get_port_group_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.port_read(id = self.uuid, fields = ['port_group_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'port_group_back_refs', None)
        if not back_refs:
            return None
        self.port_group_back_refs = back_refs

        return back_refs
    # end get_port_group_back_refs

    def get_physical_interface_back_refs(self):
        """Return list of all physical-interfaces using this port"""
        if hasattr(self, 'physical_interface_back_refs'):
            return self.physical_interface_back_refs

        if hasattr(super(Port, self), 'physical_interface_back_refs'):
            return super(Port, self).get_physical_interface_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.port_read(id = self.uuid, fields = ['physical_interface_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'physical_interface_back_refs', None)
        if not back_refs:
            return None
        self.physical_interface_back_refs = back_refs

        return back_refs
    # end get_physical_interface_back_refs

# end class Port

class BgpAsAService(vnc_api.gen.resource_common.BgpAsAService):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'autonomous_system' in kwargs:
            pending_fields.append('autonomous_system')
        if len(args) > 1 or 'bgpaas_shared' in kwargs:
            pending_fields.append('bgpaas_shared')
        if len(args) > 2 or 'bgpaas_ip_address' in kwargs:
            pending_fields.append('bgpaas_ip_address')
        if len(args) > 3 or 'bgpaas_session_attributes' in kwargs:
            pending_fields.append('bgpaas_session_attributes')
        if len(args) > 4 or 'bgpaas_ipv4_mapped_ipv6_nexthop' in kwargs:
            pending_fields.append('bgpaas_ipv4_mapped_ipv6_nexthop')
        if len(args) > 5 or 'bgpaas_suppress_route_advertisement' in kwargs:
            pending_fields.append('bgpaas_suppress_route_advertisement')
        if len(args) > 6 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 7 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 8 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 9 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(BgpAsAService, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            props_dict['autonomous_system'] = kwargs[u'autonomous_system']
        except KeyError:
            pass

        try:
            props_dict['bgpaas_shared'] = kwargs[u'bgpaas_shared']
        except KeyError:
            pass

        try:
            props_dict['bgpaas_ip_address'] = kwargs[u'bgpaas_ip_address']
        except KeyError:
            pass

        try:
            if kwargs['bgpaas_session_attributes'] is None:
                props_dict['bgpaas_session_attributes'] = None
            else:
                props_dict['bgpaas_session_attributes'] = vnc_api.gen.resource_xsd.BgpSessionAttributes(params_dict=kwargs[u'bgpaas_session_attributes'])
        except KeyError:
            pass

        try:
            props_dict['bgpaas_ipv4_mapped_ipv6_nexthop'] = kwargs[u'bgpaas_ipv4_mapped_ipv6_nexthop']
        except KeyError:
            pass

        try:
            props_dict['bgpaas_suppress_route_advertisement'] = kwargs[u'bgpaas_suppress_route_advertisement']
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = BgpAsAService(**props_dict)
        else:
            obj = BgpAsAService(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.control_node_zone_refs = kwargs[u'control_node_zone_refs']
            for ref in obj.control_node_zone_refs:
                ref['attr'] = vnc_api.gen.resource_xsd.BGPaaSControlNodeZoneAttributes(params_dict=ref[u'attr'])
        except KeyError:
            pass
        try:
            obj.virtual_machine_interface_refs = kwargs[u'virtual_machine_interface_refs']
        except KeyError:
            pass
        try:
            obj.service_health_check_refs = kwargs[u'service_health_check_refs']
        except KeyError:
            pass
        try:
            obj.bgp_router_refs = kwargs[u'bgp_router_refs']
        except KeyError:
            pass
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.BgpAsAService.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.BgpAsAService.autonomous_system.setter
    def autonomous_system(self, autonomous_system):
        """Set autonomous-system for bgp-as-a-service.
        
        :param autonomous_system: AutonomousSystemType object
        
        """
        if 'autonomous_system' not in self._pending_field_updates:
            self._pending_field_updates.add('autonomous_system')

        self._autonomous_system = autonomous_system
    # end autonomous_system

    def set_autonomous_system(self, value):
        self.autonomous_system = value
    # end set_autonomous_system

    @vnc_api.gen.resource_common.BgpAsAService.bgpaas_shared.setter
    def bgpaas_shared(self, bgpaas_shared):
        """Set bgpaas-shared for bgp-as-a-service.
        
        :param bgpaas_shared: xsd:boolean object
        
        """
        if 'bgpaas_shared' not in self._pending_field_updates:
            self._pending_field_updates.add('bgpaas_shared')

        self._bgpaas_shared = bgpaas_shared
    # end bgpaas_shared

    def set_bgpaas_shared(self, value):
        self.bgpaas_shared = value
    # end set_bgpaas_shared

    @vnc_api.gen.resource_common.BgpAsAService.bgpaas_ip_address.setter
    def bgpaas_ip_address(self, bgpaas_ip_address):
        """Set bgpaas-ip-address for bgp-as-a-service.
        
        :param bgpaas_ip_address: IpAddressType object
        
        """
        if 'bgpaas_ip_address' not in self._pending_field_updates:
            self._pending_field_updates.add('bgpaas_ip_address')

        self._bgpaas_ip_address = bgpaas_ip_address
    # end bgpaas_ip_address

    def set_bgpaas_ip_address(self, value):
        self.bgpaas_ip_address = value
    # end set_bgpaas_ip_address

    @vnc_api.gen.resource_common.BgpAsAService.bgpaas_session_attributes.setter
    def bgpaas_session_attributes(self, bgpaas_session_attributes):
        """Set bgpaas-session-attributes for bgp-as-a-service.
        
        :param bgpaas_session_attributes: BgpSessionAttributes object
        
        """
        if 'bgpaas_session_attributes' not in self._pending_field_updates:
            self._pending_field_updates.add('bgpaas_session_attributes')

        self._bgpaas_session_attributes = bgpaas_session_attributes
    # end bgpaas_session_attributes

    def set_bgpaas_session_attributes(self, value):
        self.bgpaas_session_attributes = value
    # end set_bgpaas_session_attributes

    @vnc_api.gen.resource_common.BgpAsAService.bgpaas_ipv4_mapped_ipv6_nexthop.setter
    def bgpaas_ipv4_mapped_ipv6_nexthop(self, bgpaas_ipv4_mapped_ipv6_nexthop):
        """Set bgpaas-ipv4-mapped-ipv6-nexthop for bgp-as-a-service.
        
        :param bgpaas_ipv4_mapped_ipv6_nexthop: xsd:boolean object
        
        """
        if 'bgpaas_ipv4_mapped_ipv6_nexthop' not in self._pending_field_updates:
            self._pending_field_updates.add('bgpaas_ipv4_mapped_ipv6_nexthop')

        self._bgpaas_ipv4_mapped_ipv6_nexthop = bgpaas_ipv4_mapped_ipv6_nexthop
    # end bgpaas_ipv4_mapped_ipv6_nexthop

    def set_bgpaas_ipv4_mapped_ipv6_nexthop(self, value):
        self.bgpaas_ipv4_mapped_ipv6_nexthop = value
    # end set_bgpaas_ipv4_mapped_ipv6_nexthop

    @vnc_api.gen.resource_common.BgpAsAService.bgpaas_suppress_route_advertisement.setter
    def bgpaas_suppress_route_advertisement(self, bgpaas_suppress_route_advertisement):
        """Set bgpaas-suppress-route-advertisement for bgp-as-a-service.
        
        :param bgpaas_suppress_route_advertisement: xsd:boolean object
        
        """
        if 'bgpaas_suppress_route_advertisement' not in self._pending_field_updates:
            self._pending_field_updates.add('bgpaas_suppress_route_advertisement')

        self._bgpaas_suppress_route_advertisement = bgpaas_suppress_route_advertisement
    # end bgpaas_suppress_route_advertisement

    def set_bgpaas_suppress_route_advertisement(self, value):
        self.bgpaas_suppress_route_advertisement = value
    # end set_bgpaas_suppress_route_advertisement

    @vnc_api.gen.resource_common.BgpAsAService.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for bgp-as-a-service.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.BgpAsAService.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for bgp-as-a-service.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.BgpAsAService.annotations.setter
    def annotations(self, annotations):
        """Set annotations for bgp-as-a-service.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.BgpAsAService.display_name.setter
    def display_name(self, display_name):
        """Set display-name for bgp-as-a-service.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for bgp-as-a-service.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for bgp-as-a-service.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_control_node_zone(self, *args, **kwargs):
        """Set control-node-zone for bgp-as-a-service.
        
        :param ref_obj: ControlNodeZone object
        :param ref_data: BGPaaSControlNodeZoneAttributes object
        
        """
        self._pending_field_updates.add('control_node_zone_refs')
        self._pending_ref_updates.discard('control_node_zone_refs')
        super(BgpAsAService, self).set_control_node_zone(*args, **kwargs)

    # end set_control_node_zone

    def add_control_node_zone(self, *args, **kwargs):
        """Add control-node-zone to bgp-as-a-service.
        
        :param ref_obj: ControlNodeZone object
        :param ref_data: BGPaaSControlNodeZoneAttributes object
        
        """
        if 'control_node_zone_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('control_node_zone_refs')
            self._original_control_node_zone_refs = copy.deepcopy(self.get_control_node_zone_refs() or [])
        super(BgpAsAService, self).add_control_node_zone(*args, **kwargs)
    # end add_control_node_zone

    def del_control_node_zone(self, *args, **kwargs):
        if 'control_node_zone_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('control_node_zone_refs')
            self._original_control_node_zone_refs = copy.deepcopy(self.get_control_node_zone_refs() or [])
        super(BgpAsAService, self).del_control_node_zone(*args, **kwargs)
    # end del_control_node_zone

    def set_control_node_zone_list(self, *args, **kwargs):
        """Set control-node-zone list for bgp-as-a-service.
        
        :param ref_obj_list: list of ControlNodeZone object
        :param ref_data_list: list of BGPaaSControlNodeZoneAttributes summary
        
        """
        self._pending_field_updates.add('control_node_zone_refs')
        self._pending_ref_updates.discard('control_node_zone_refs')
        super(BgpAsAService, self).set_control_node_zone_list(*args, **kwargs)
    # end set_control_node_zone_list

    def set_virtual_machine_interface(self, *args, **kwargs):
        """Set virtual-machine-interface for bgp-as-a-service.
        
        :param ref_obj: VirtualMachineInterface object
        
        """
        self._pending_field_updates.add('virtual_machine_interface_refs')
        self._pending_ref_updates.discard('virtual_machine_interface_refs')
        super(BgpAsAService, self).set_virtual_machine_interface(*args, **kwargs)

    # end set_virtual_machine_interface

    def add_virtual_machine_interface(self, *args, **kwargs):
        """Add virtual-machine-interface to bgp-as-a-service.
        
        :param ref_obj: VirtualMachineInterface object
        
        """
        if 'virtual_machine_interface_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('virtual_machine_interface_refs')
            self._original_virtual_machine_interface_refs = copy.deepcopy(self.get_virtual_machine_interface_refs() or [])
        super(BgpAsAService, self).add_virtual_machine_interface(*args, **kwargs)
    # end add_virtual_machine_interface

    def del_virtual_machine_interface(self, *args, **kwargs):
        if 'virtual_machine_interface_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('virtual_machine_interface_refs')
            self._original_virtual_machine_interface_refs = copy.deepcopy(self.get_virtual_machine_interface_refs() or [])
        super(BgpAsAService, self).del_virtual_machine_interface(*args, **kwargs)
    # end del_virtual_machine_interface

    def set_virtual_machine_interface_list(self, *args, **kwargs):
        """Set virtual-machine-interface list for bgp-as-a-service.
        
        :param ref_obj_list: list of VirtualMachineInterface object
        
        """
        self._pending_field_updates.add('virtual_machine_interface_refs')
        self._pending_ref_updates.discard('virtual_machine_interface_refs')
        super(BgpAsAService, self).set_virtual_machine_interface_list(*args, **kwargs)
    # end set_virtual_machine_interface_list

    def set_service_health_check(self, *args, **kwargs):
        """Set service-health-check for bgp-as-a-service.
        
        :param ref_obj: ServiceHealthCheck object
        
        """
        self._pending_field_updates.add('service_health_check_refs')
        self._pending_ref_updates.discard('service_health_check_refs')
        super(BgpAsAService, self).set_service_health_check(*args, **kwargs)

    # end set_service_health_check

    def add_service_health_check(self, *args, **kwargs):
        """Add service-health-check to bgp-as-a-service.
        
        :param ref_obj: ServiceHealthCheck object
        
        """
        if 'service_health_check_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('service_health_check_refs')
            self._original_service_health_check_refs = copy.deepcopy(self.get_service_health_check_refs() or [])
        super(BgpAsAService, self).add_service_health_check(*args, **kwargs)
    # end add_service_health_check

    def del_service_health_check(self, *args, **kwargs):
        if 'service_health_check_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('service_health_check_refs')
            self._original_service_health_check_refs = copy.deepcopy(self.get_service_health_check_refs() or [])
        super(BgpAsAService, self).del_service_health_check(*args, **kwargs)
    # end del_service_health_check

    def set_service_health_check_list(self, *args, **kwargs):
        """Set service-health-check list for bgp-as-a-service.
        
        :param ref_obj_list: list of ServiceHealthCheck object
        
        """
        self._pending_field_updates.add('service_health_check_refs')
        self._pending_ref_updates.discard('service_health_check_refs')
        super(BgpAsAService, self).set_service_health_check_list(*args, **kwargs)
    # end set_service_health_check_list

    def set_bgp_router(self, *args, **kwargs):
        """Set bgp-router for bgp-as-a-service.
        
        :param ref_obj: BgpRouter object
        
        """
        self._pending_field_updates.add('bgp_router_refs')
        self._pending_ref_updates.discard('bgp_router_refs')
        super(BgpAsAService, self).set_bgp_router(*args, **kwargs)

    # end set_bgp_router

    def add_bgp_router(self, *args, **kwargs):
        """Add bgp-router to bgp-as-a-service.
        
        :param ref_obj: BgpRouter object
        
        """
        if 'bgp_router_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('bgp_router_refs')
            self._original_bgp_router_refs = copy.deepcopy(self.get_bgp_router_refs() or [])
        super(BgpAsAService, self).add_bgp_router(*args, **kwargs)
    # end add_bgp_router

    def del_bgp_router(self, *args, **kwargs):
        if 'bgp_router_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('bgp_router_refs')
            self._original_bgp_router_refs = copy.deepcopy(self.get_bgp_router_refs() or [])
        super(BgpAsAService, self).del_bgp_router(*args, **kwargs)
    # end del_bgp_router

    def set_bgp_router_list(self, *args, **kwargs):
        """Set bgp-router list for bgp-as-a-service.
        
        :param ref_obj_list: list of BgpRouter object
        
        """
        self._pending_field_updates.add('bgp_router_refs')
        self._pending_ref_updates.discard('bgp_router_refs')
        super(BgpAsAService, self).set_bgp_router_list(*args, **kwargs)
    # end set_bgp_router_list

    def set_tag(self, *args, **kwargs):
        """Set tag for bgp-as-a-service.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(BgpAsAService, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to bgp-as-a-service.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(BgpAsAService, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(BgpAsAService, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for bgp-as-a-service.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(BgpAsAService, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


# end class BgpAsAService

class Subnet(vnc_api.gen.resource_common.Subnet):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, *args, **kwargs):
        pending_fields = ['fq_name']

        self._server_conn = None

        if len(args) > 0 or 'subnet_ip_prefix' in kwargs:
            pending_fields.append('subnet_ip_prefix')
        if len(args) > 1 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 2 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 3 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 4 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(Subnet, self).__init__(name, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            if kwargs['subnet_ip_prefix'] is None:
                props_dict['subnet_ip_prefix'] = None
            else:
                props_dict['subnet_ip_prefix'] = vnc_api.gen.resource_xsd.SubnetType(params_dict=kwargs[u'subnet_ip_prefix'])
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = Subnet(**props_dict)
        else:
            obj = Subnet(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.virtual_machine_interface_refs = kwargs[u'virtual_machine_interface_refs']
        except KeyError:
            pass
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.Subnet.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.Subnet.subnet_ip_prefix.setter
    def subnet_ip_prefix(self, subnet_ip_prefix):
        """Set subnet-ip-prefix for subnet.
        
        :param subnet_ip_prefix: SubnetType object
        
        """
        if 'subnet_ip_prefix' not in self._pending_field_updates:
            self._pending_field_updates.add('subnet_ip_prefix')

        self._subnet_ip_prefix = subnet_ip_prefix
    # end subnet_ip_prefix

    def set_subnet_ip_prefix(self, value):
        self.subnet_ip_prefix = value
    # end set_subnet_ip_prefix

    @vnc_api.gen.resource_common.Subnet.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for subnet.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.Subnet.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for subnet.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.Subnet.annotations.setter
    def annotations(self, annotations):
        """Set annotations for subnet.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.Subnet.display_name.setter
    def display_name(self, display_name):
        """Set display-name for subnet.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for subnet.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for subnet.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_virtual_machine_interface(self, *args, **kwargs):
        """Set virtual-machine-interface for subnet.
        
        :param ref_obj: VirtualMachineInterface object
        
        """
        self._pending_field_updates.add('virtual_machine_interface_refs')
        self._pending_ref_updates.discard('virtual_machine_interface_refs')
        super(Subnet, self).set_virtual_machine_interface(*args, **kwargs)

    # end set_virtual_machine_interface

    def add_virtual_machine_interface(self, *args, **kwargs):
        """Add virtual-machine-interface to subnet.
        
        :param ref_obj: VirtualMachineInterface object
        
        """
        if 'virtual_machine_interface_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('virtual_machine_interface_refs')
            self._original_virtual_machine_interface_refs = copy.deepcopy(self.get_virtual_machine_interface_refs() or [])
        super(Subnet, self).add_virtual_machine_interface(*args, **kwargs)
    # end add_virtual_machine_interface

    def del_virtual_machine_interface(self, *args, **kwargs):
        if 'virtual_machine_interface_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('virtual_machine_interface_refs')
            self._original_virtual_machine_interface_refs = copy.deepcopy(self.get_virtual_machine_interface_refs() or [])
        super(Subnet, self).del_virtual_machine_interface(*args, **kwargs)
    # end del_virtual_machine_interface

    def set_virtual_machine_interface_list(self, *args, **kwargs):
        """Set virtual-machine-interface list for subnet.
        
        :param ref_obj_list: list of VirtualMachineInterface object
        
        """
        self._pending_field_updates.add('virtual_machine_interface_refs')
        self._pending_ref_updates.discard('virtual_machine_interface_refs')
        super(Subnet, self).set_virtual_machine_interface_list(*args, **kwargs)
    # end set_virtual_machine_interface_list

    def set_tag(self, *args, **kwargs):
        """Set tag for subnet.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(Subnet, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to subnet.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(Subnet, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(Subnet, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for subnet.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(Subnet, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


# end class Subnet

class GlobalSystemConfig(vnc_api.gen.resource_common.GlobalSystemConfig):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'autonomous_system' in kwargs:
            pending_fields.append('autonomous_system')
        if len(args) > 1 or 'enable_4byte_as' in kwargs:
            pending_fields.append('enable_4byte_as')
        if len(args) > 2 or 'config_version' in kwargs:
            pending_fields.append('config_version')
        if len(args) > 3 or 'graceful_restart_parameters' in kwargs:
            pending_fields.append('graceful_restart_parameters')
        if len(args) > 4 or 'plugin_tuning' in kwargs:
            pending_fields.append('plugin_tuning')
        if len(args) > 5 or 'data_center_interconnect_loopback_namespace' in kwargs:
            pending_fields.append('data_center_interconnect_loopback_namespace')
        if len(args) > 6 or 'data_center_interconnect_asn_namespace' in kwargs:
            pending_fields.append('data_center_interconnect_asn_namespace')
        if len(args) > 7 or 'ibgp_auto_mesh' in kwargs:
            pending_fields.append('ibgp_auto_mesh')
        if len(args) > 8 or 'bgp_always_compare_med' in kwargs:
            pending_fields.append('bgp_always_compare_med')
        if len(args) > 9 or 'rd_cluster_seed' in kwargs:
            pending_fields.append('rd_cluster_seed')
        if len(args) > 10 or 'ip_fabric_subnets' in kwargs:
            pending_fields.append('ip_fabric_subnets')
        if len(args) > 11 or 'supported_device_families' in kwargs:
            pending_fields.append('supported_device_families')
        if len(args) > 12 or 'supported_vendor_hardwares' in kwargs:
            pending_fields.append('supported_vendor_hardwares')
        if len(args) > 13 or 'bgpaas_parameters' in kwargs:
            pending_fields.append('bgpaas_parameters')
        if len(args) > 14 or 'mac_limit_control' in kwargs:
            pending_fields.append('mac_limit_control')
        if len(args) > 15 or 'mac_move_control' in kwargs:
            pending_fields.append('mac_move_control')
        if len(args) > 16 or 'mac_aging_time' in kwargs:
            pending_fields.append('mac_aging_time')
        if len(args) > 17 or 'igmp_enable' in kwargs:
            pending_fields.append('igmp_enable')
        if len(args) > 18 or 'alarm_enable' in kwargs:
            pending_fields.append('alarm_enable')
        if len(args) > 19 or 'user_defined_log_statistics' in kwargs:
            pending_fields.append('user_defined_log_statistics')
        if len(args) > 20 or 'enable_security_policy_draft' in kwargs:
            pending_fields.append('enable_security_policy_draft')
        if len(args) > 21 or 'supported_fabric_annotations' in kwargs:
            pending_fields.append('supported_fabric_annotations')
        if len(args) > 22 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 23 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 24 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 25 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(GlobalSystemConfig, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            props_dict['autonomous_system'] = kwargs[u'autonomous_system']
        except KeyError:
            pass

        try:
            props_dict['enable_4byte_as'] = kwargs[u'enable_4byte_as']
        except KeyError:
            pass

        try:
            props_dict['config_version'] = kwargs[u'config_version']
        except KeyError:
            pass

        try:
            if kwargs['graceful_restart_parameters'] is None:
                props_dict['graceful_restart_parameters'] = None
            else:
                props_dict['graceful_restart_parameters'] = vnc_api.gen.resource_xsd.GracefulRestartParametersType(params_dict=kwargs[u'graceful_restart_parameters'])
        except KeyError:
            pass

        try:
            if kwargs['plugin_tuning'] is None:
                props_dict['plugin_tuning'] = None
            else:
                props_dict['plugin_tuning'] = vnc_api.gen.resource_xsd.PluginProperties(params_dict=kwargs[u'plugin_tuning'])
        except KeyError:
            pass

        try:
            if kwargs['data_center_interconnect_loopback_namespace'] is None:
                props_dict['data_center_interconnect_loopback_namespace'] = None
            else:
                props_dict['data_center_interconnect_loopback_namespace'] = vnc_api.gen.resource_xsd.SubnetListType(params_dict=kwargs[u'data_center_interconnect_loopback_namespace'])
        except KeyError:
            pass

        try:
            if kwargs['data_center_interconnect_asn_namespace'] is None:
                props_dict['data_center_interconnect_asn_namespace'] = None
            else:
                props_dict['data_center_interconnect_asn_namespace'] = vnc_api.gen.resource_xsd.AsnRangeType(params_dict=kwargs[u'data_center_interconnect_asn_namespace'])
        except KeyError:
            pass

        try:
            props_dict['ibgp_auto_mesh'] = kwargs[u'ibgp_auto_mesh']
        except KeyError:
            pass

        try:
            props_dict['bgp_always_compare_med'] = kwargs[u'bgp_always_compare_med']
        except KeyError:
            pass

        try:
            props_dict['rd_cluster_seed'] = kwargs[u'rd_cluster_seed']
        except KeyError:
            pass

        try:
            if kwargs['ip_fabric_subnets'] is None:
                props_dict['ip_fabric_subnets'] = None
            else:
                props_dict['ip_fabric_subnets'] = vnc_api.gen.resource_xsd.SubnetListType(params_dict=kwargs[u'ip_fabric_subnets'])
        except KeyError:
            pass

        try:
            if kwargs['supported_device_families'] is None:
                props_dict['supported_device_families'] = None
            else:
                props_dict['supported_device_families'] = vnc_api.gen.resource_xsd.DeviceFamilyListType(params_dict=kwargs[u'supported_device_families'])
        except KeyError:
            pass

        try:
            if kwargs['supported_vendor_hardwares'] is None:
                props_dict['supported_vendor_hardwares'] = None
            else:
                props_dict['supported_vendor_hardwares'] = vnc_api.gen.resource_xsd.VendorHardwaresType(params_dict=kwargs[u'supported_vendor_hardwares'])
        except KeyError:
            pass

        try:
            if kwargs['bgpaas_parameters'] is None:
                props_dict['bgpaas_parameters'] = None
            else:
                props_dict['bgpaas_parameters'] = vnc_api.gen.resource_xsd.BGPaaServiceParametersType(params_dict=kwargs[u'bgpaas_parameters'])
        except KeyError:
            pass

        try:
            if kwargs['mac_limit_control'] is None:
                props_dict['mac_limit_control'] = None
            else:
                props_dict['mac_limit_control'] = vnc_api.gen.resource_xsd.MACLimitControlType(params_dict=kwargs[u'mac_limit_control'])
        except KeyError:
            pass

        try:
            if kwargs['mac_move_control'] is None:
                props_dict['mac_move_control'] = None
            else:
                props_dict['mac_move_control'] = vnc_api.gen.resource_xsd.MACMoveLimitControlType(params_dict=kwargs[u'mac_move_control'])
        except KeyError:
            pass

        try:
            props_dict['mac_aging_time'] = kwargs[u'mac_aging_time']
        except KeyError:
            pass

        try:
            props_dict['igmp_enable'] = kwargs[u'igmp_enable']
        except KeyError:
            pass

        try:
            props_dict['alarm_enable'] = kwargs[u'alarm_enable']
        except KeyError:
            pass

        try:
            if kwargs['user_defined_log_statistics'] is None:
                props_dict['user_defined_log_statistics'] = None
            else:
                props_dict['user_defined_log_statistics'] = vnc_api.gen.resource_xsd.UserDefinedLogStatList(params_dict=kwargs[u'user_defined_log_statistics'])
        except KeyError:
            pass

        try:
            props_dict['enable_security_policy_draft'] = kwargs[u'enable_security_policy_draft']
        except KeyError:
            pass

        try:
            if kwargs['supported_fabric_annotations'] is None:
                props_dict['supported_fabric_annotations'] = None
            else:
                props_dict['supported_fabric_annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'supported_fabric_annotations'])
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = GlobalSystemConfig(**props_dict)
        else:
            obj = GlobalSystemConfig(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...
        try:
            obj.feature_flags = kwargs[u'feature_flags']
        except KeyError:
            pass
        try:
            obj.control_node_zones = kwargs[u'control_node_zones']
        except KeyError:
            pass
        try:
            obj.global_vrouter_configs = kwargs[u'global_vrouter_configs']
        except KeyError:
            pass
        try:
            obj.global_qos_configs = kwargs[u'global_qos_configs']
        except KeyError:
            pass
        try:
            obj.virtual_routers = kwargs[u'virtual_routers']
        except KeyError:
            pass
        try:
            obj.config_nodes = kwargs[u'config_nodes']
        except KeyError:
            pass
        try:
            obj.analytics_nodes = kwargs[u'analytics_nodes']
        except KeyError:
            pass
        try:
            obj.flow_nodes = kwargs[u'flow_nodes']
        except KeyError:
            pass
        try:
            obj.devicemgr_nodes = kwargs[u'devicemgr_nodes']
        except KeyError:
            pass
        try:
            obj.database_nodes = kwargs[u'database_nodes']
        except KeyError:
            pass
        try:
            obj.webui_nodes = kwargs[u'webui_nodes']
        except KeyError:
            pass
        try:
            obj.config_database_nodes = kwargs[u'config_database_nodes']
        except KeyError:
            pass
        try:
            obj.analytics_alarm_nodes = kwargs[u'analytics_alarm_nodes']
        except KeyError:
            pass
        try:
            obj.analytics_snmp_nodes = kwargs[u'analytics_snmp_nodes']
        except KeyError:
            pass
        try:
            obj.service_appliance_sets = kwargs[u'service_appliance_sets']
        except KeyError:
            pass
        try:
            obj.api_access_lists = kwargs[u'api_access_lists']
        except KeyError:
            pass
        try:
            obj.alarms = kwargs[u'alarms']
        except KeyError:
            pass
        try:
            obj.job_templates = kwargs[u'job_templates']
        except KeyError:
            pass
        try:
            obj.data_center_interconnects = kwargs[u'data_center_interconnects']
        except KeyError:
            pass
        try:
            obj.intent_maps = kwargs[u'intent_maps']
        except KeyError:
            pass
        try:
            obj.fabrics = kwargs[u'fabrics']
        except KeyError:
            pass
        try:
            obj.node_profiles = kwargs[u'node_profiles']
        except KeyError:
            pass
        try:
            obj.physical_routers = kwargs[u'physical_routers']
        except KeyError:
            pass
        try:
            obj.device_images = kwargs[u'device_images']
        except KeyError:
            pass
        try:
            obj.nodes = kwargs[u'nodes']
        except KeyError:
            pass
        try:
            obj.features = kwargs[u'features']
        except KeyError:
            pass
        try:
            obj.physical_roles = kwargs[u'physical_roles']
        except KeyError:
            pass
        try:
            obj.overlay_roles = kwargs[u'overlay_roles']
        except KeyError:
            pass
        try:
            obj.role_definitions = kwargs[u'role_definitions']
        except KeyError:
            pass
        try:
            obj.global_analytics_configs = kwargs[u'global_analytics_configs']
        except KeyError:
            pass

        # add any specified references...
        try:
            obj.bgp_router_refs = kwargs[u'bgp_router_refs']
        except KeyError:
            pass
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.qos_config_back_refs = kwargs[u'qos_config_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.GlobalSystemConfig.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.GlobalSystemConfig.autonomous_system.setter
    def autonomous_system(self, autonomous_system):
        """Set autonomous-system for global-system-config.
        
        :param autonomous_system: AutonomousSystemType object
        
        """
        if 'autonomous_system' not in self._pending_field_updates:
            self._pending_field_updates.add('autonomous_system')

        self._autonomous_system = autonomous_system
    # end autonomous_system

    def set_autonomous_system(self, value):
        self.autonomous_system = value
    # end set_autonomous_system

    @vnc_api.gen.resource_common.GlobalSystemConfig.enable_4byte_as.setter
    def enable_4byte_as(self, enable_4byte_as):
        """Set enable-4byte-as for global-system-config.
        
        :param enable_4byte_as: xsd:boolean object
        
        """
        if 'enable_4byte_as' not in self._pending_field_updates:
            self._pending_field_updates.add('enable_4byte_as')

        self._enable_4byte_as = enable_4byte_as
    # end enable_4byte_as

    def set_enable_4byte_as(self, value):
        self.enable_4byte_as = value
    # end set_enable_4byte_as

    @vnc_api.gen.resource_common.GlobalSystemConfig.config_version.setter
    def config_version(self, config_version):
        """Set config-version for global-system-config.
        
        :param config_version: xsd:string object
        
        """
        if 'config_version' not in self._pending_field_updates:
            self._pending_field_updates.add('config_version')

        self._config_version = config_version
    # end config_version

    def set_config_version(self, value):
        self.config_version = value
    # end set_config_version

    @vnc_api.gen.resource_common.GlobalSystemConfig.graceful_restart_parameters.setter
    def graceful_restart_parameters(self, graceful_restart_parameters):
        """Set graceful-restart-parameters for global-system-config.
        
        :param graceful_restart_parameters: GracefulRestartParametersType object
        
        """
        if 'graceful_restart_parameters' not in self._pending_field_updates:
            self._pending_field_updates.add('graceful_restart_parameters')

        self._graceful_restart_parameters = graceful_restart_parameters
    # end graceful_restart_parameters

    def set_graceful_restart_parameters(self, value):
        self.graceful_restart_parameters = value
    # end set_graceful_restart_parameters

    @vnc_api.gen.resource_common.GlobalSystemConfig.plugin_tuning.setter
    def plugin_tuning(self, plugin_tuning):
        """Set plugin-tuning for global-system-config.
        
        :param plugin_tuning: PluginProperties object
        
        """
        if 'plugin_tuning' not in self._pending_field_updates:
            self._pending_field_updates.add('plugin_tuning')

        self._plugin_tuning = plugin_tuning
    # end plugin_tuning

    def set_plugin_tuning(self, value):
        self.plugin_tuning = value
    # end set_plugin_tuning

    @vnc_api.gen.resource_common.GlobalSystemConfig.data_center_interconnect_loopback_namespace.setter
    def data_center_interconnect_loopback_namespace(self, data_center_interconnect_loopback_namespace):
        """Set data-center-interconnect-loopback-namespace for global-system-config.
        
        :param data_center_interconnect_loopback_namespace: SubnetListType object
        
        """
        if 'data_center_interconnect_loopback_namespace' not in self._pending_field_updates:
            self._pending_field_updates.add('data_center_interconnect_loopback_namespace')

        self._data_center_interconnect_loopback_namespace = data_center_interconnect_loopback_namespace
    # end data_center_interconnect_loopback_namespace

    def set_data_center_interconnect_loopback_namespace(self, value):
        self.data_center_interconnect_loopback_namespace = value
    # end set_data_center_interconnect_loopback_namespace

    @vnc_api.gen.resource_common.GlobalSystemConfig.data_center_interconnect_asn_namespace.setter
    def data_center_interconnect_asn_namespace(self, data_center_interconnect_asn_namespace):
        """Set data-center-interconnect-asn-namespace for global-system-config.
        
        :param data_center_interconnect_asn_namespace: AsnRangeType object
        
        """
        if 'data_center_interconnect_asn_namespace' not in self._pending_field_updates:
            self._pending_field_updates.add('data_center_interconnect_asn_namespace')

        self._data_center_interconnect_asn_namespace = data_center_interconnect_asn_namespace
    # end data_center_interconnect_asn_namespace

    def set_data_center_interconnect_asn_namespace(self, value):
        self.data_center_interconnect_asn_namespace = value
    # end set_data_center_interconnect_asn_namespace

    @vnc_api.gen.resource_common.GlobalSystemConfig.ibgp_auto_mesh.setter
    def ibgp_auto_mesh(self, ibgp_auto_mesh):
        """Set ibgp-auto-mesh for global-system-config.
        
        :param ibgp_auto_mesh: xsd:boolean object
        
        """
        if 'ibgp_auto_mesh' not in self._pending_field_updates:
            self._pending_field_updates.add('ibgp_auto_mesh')

        self._ibgp_auto_mesh = ibgp_auto_mesh
    # end ibgp_auto_mesh

    def set_ibgp_auto_mesh(self, value):
        self.ibgp_auto_mesh = value
    # end set_ibgp_auto_mesh

    @vnc_api.gen.resource_common.GlobalSystemConfig.bgp_always_compare_med.setter
    def bgp_always_compare_med(self, bgp_always_compare_med):
        """Set bgp-always-compare-med for global-system-config.
        
        :param bgp_always_compare_med: xsd:boolean object
        
        """
        if 'bgp_always_compare_med' not in self._pending_field_updates:
            self._pending_field_updates.add('bgp_always_compare_med')

        self._bgp_always_compare_med = bgp_always_compare_med
    # end bgp_always_compare_med

    def set_bgp_always_compare_med(self, value):
        self.bgp_always_compare_med = value
    # end set_bgp_always_compare_med

    @vnc_api.gen.resource_common.GlobalSystemConfig.rd_cluster_seed.setter
    def rd_cluster_seed(self, rd_cluster_seed):
        """Set rd-cluster-seed for global-system-config.
        
        :param rd_cluster_seed: RdClusterSeedType object
        
        """
        if 'rd_cluster_seed' not in self._pending_field_updates:
            self._pending_field_updates.add('rd_cluster_seed')

        self._rd_cluster_seed = rd_cluster_seed
    # end rd_cluster_seed

    def set_rd_cluster_seed(self, value):
        self.rd_cluster_seed = value
    # end set_rd_cluster_seed

    @vnc_api.gen.resource_common.GlobalSystemConfig.ip_fabric_subnets.setter
    def ip_fabric_subnets(self, ip_fabric_subnets):
        """Set ip-fabric-subnets for global-system-config.
        
        :param ip_fabric_subnets: SubnetListType object
        
        """
        if 'ip_fabric_subnets' not in self._pending_field_updates:
            self._pending_field_updates.add('ip_fabric_subnets')

        self._ip_fabric_subnets = ip_fabric_subnets
    # end ip_fabric_subnets

    def set_ip_fabric_subnets(self, value):
        self.ip_fabric_subnets = value
    # end set_ip_fabric_subnets

    @vnc_api.gen.resource_common.GlobalSystemConfig.supported_device_families.setter
    def supported_device_families(self, supported_device_families):
        """Set supported-device-families for global-system-config.
        
        :param supported_device_families: DeviceFamilyListType object
        
        """
        if 'supported_device_families' not in self._pending_field_updates:
            self._pending_field_updates.add('supported_device_families')

        self._supported_device_families = supported_device_families
    # end supported_device_families

    def set_supported_device_families(self, value):
        self.supported_device_families = value
    # end set_supported_device_families

    @vnc_api.gen.resource_common.GlobalSystemConfig.supported_vendor_hardwares.setter
    def supported_vendor_hardwares(self, supported_vendor_hardwares):
        """Set supported-vendor-hardwares for global-system-config.
        
        :param supported_vendor_hardwares: VendorHardwaresType object
        
        """
        if 'supported_vendor_hardwares' not in self._pending_field_updates:
            self._pending_field_updates.add('supported_vendor_hardwares')

        self._supported_vendor_hardwares = supported_vendor_hardwares
    # end supported_vendor_hardwares

    def set_supported_vendor_hardwares(self, value):
        self.supported_vendor_hardwares = value
    # end set_supported_vendor_hardwares

    @vnc_api.gen.resource_common.GlobalSystemConfig.bgpaas_parameters.setter
    def bgpaas_parameters(self, bgpaas_parameters):
        """Set bgpaas-parameters for global-system-config.
        
        :param bgpaas_parameters: BGPaaServiceParametersType object
        
        """
        if 'bgpaas_parameters' not in self._pending_field_updates:
            self._pending_field_updates.add('bgpaas_parameters')

        self._bgpaas_parameters = bgpaas_parameters
    # end bgpaas_parameters

    def set_bgpaas_parameters(self, value):
        self.bgpaas_parameters = value
    # end set_bgpaas_parameters

    @vnc_api.gen.resource_common.GlobalSystemConfig.mac_limit_control.setter
    def mac_limit_control(self, mac_limit_control):
        """Set mac-limit-control for global-system-config.
        
        :param mac_limit_control: MACLimitControlType object
        
        """
        if 'mac_limit_control' not in self._pending_field_updates:
            self._pending_field_updates.add('mac_limit_control')

        self._mac_limit_control = mac_limit_control
    # end mac_limit_control

    def set_mac_limit_control(self, value):
        self.mac_limit_control = value
    # end set_mac_limit_control

    @vnc_api.gen.resource_common.GlobalSystemConfig.mac_move_control.setter
    def mac_move_control(self, mac_move_control):
        """Set mac-move-control for global-system-config.
        
        :param mac_move_control: MACMoveLimitControlType object
        
        """
        if 'mac_move_control' not in self._pending_field_updates:
            self._pending_field_updates.add('mac_move_control')

        self._mac_move_control = mac_move_control
    # end mac_move_control

    def set_mac_move_control(self, value):
        self.mac_move_control = value
    # end set_mac_move_control

    @vnc_api.gen.resource_common.GlobalSystemConfig.mac_aging_time.setter
    def mac_aging_time(self, mac_aging_time):
        """Set mac-aging-time for global-system-config.
        
        :param mac_aging_time: MACAgingTime object
        
        """
        if 'mac_aging_time' not in self._pending_field_updates:
            self._pending_field_updates.add('mac_aging_time')

        self._mac_aging_time = mac_aging_time
    # end mac_aging_time

    def set_mac_aging_time(self, value):
        self.mac_aging_time = value
    # end set_mac_aging_time

    @vnc_api.gen.resource_common.GlobalSystemConfig.igmp_enable.setter
    def igmp_enable(self, igmp_enable):
        """Set igmp-enable for global-system-config.
        
        :param igmp_enable: xsd:boolean object
        
        """
        if 'igmp_enable' not in self._pending_field_updates:
            self._pending_field_updates.add('igmp_enable')

        self._igmp_enable = igmp_enable
    # end igmp_enable

    def set_igmp_enable(self, value):
        self.igmp_enable = value
    # end set_igmp_enable

    @vnc_api.gen.resource_common.GlobalSystemConfig.alarm_enable.setter
    def alarm_enable(self, alarm_enable):
        """Set alarm-enable for global-system-config.
        
        :param alarm_enable: xsd:boolean object
        
        """
        if 'alarm_enable' not in self._pending_field_updates:
            self._pending_field_updates.add('alarm_enable')

        self._alarm_enable = alarm_enable
    # end alarm_enable

    def set_alarm_enable(self, value):
        self.alarm_enable = value
    # end set_alarm_enable

    @vnc_api.gen.resource_common.GlobalSystemConfig.user_defined_log_statistics.setter
    def user_defined_log_statistics(self, user_defined_log_statistics):
        """Set user-defined-log-statistics for global-system-config.
        
        :param user_defined_log_statistics: UserDefinedLogStatList object
        
        """
        if 'user_defined_log_statistics' not in self._pending_field_updates:
            self._pending_field_updates.add('user_defined_log_statistics')

        if 'user_defined_log_statistics' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['user_defined_log_statistics']

        self._user_defined_log_statistics = user_defined_log_statistics
    # end user_defined_log_statistics

    def set_user_defined_log_statistics(self, value):
        self.user_defined_log_statistics = value
    # end set_user_defined_log_statistics

    @vnc_api.gen.resource_common.GlobalSystemConfig.enable_security_policy_draft.setter
    def enable_security_policy_draft(self, enable_security_policy_draft):
        """Set enable-security-policy-draft for global-system-config.
        
        :param enable_security_policy_draft: xsd:boolean object
        
        """
        if 'enable_security_policy_draft' not in self._pending_field_updates:
            self._pending_field_updates.add('enable_security_policy_draft')

        self._enable_security_policy_draft = enable_security_policy_draft
    # end enable_security_policy_draft

    def set_enable_security_policy_draft(self, value):
        self.enable_security_policy_draft = value
    # end set_enable_security_policy_draft

    @vnc_api.gen.resource_common.GlobalSystemConfig.supported_fabric_annotations.setter
    def supported_fabric_annotations(self, supported_fabric_annotations):
        """Set supported-fabric-annotations for global-system-config.
        
        :param supported_fabric_annotations: KeyValuePairs object
        
        """
        if 'supported_fabric_annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('supported_fabric_annotations')

        self._supported_fabric_annotations = supported_fabric_annotations
    # end supported_fabric_annotations

    def set_supported_fabric_annotations(self, value):
        self.supported_fabric_annotations = value
    # end set_supported_fabric_annotations

    @vnc_api.gen.resource_common.GlobalSystemConfig.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for global-system-config.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.GlobalSystemConfig.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for global-system-config.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.GlobalSystemConfig.annotations.setter
    def annotations(self, annotations):
        """Set annotations for global-system-config.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.GlobalSystemConfig.display_name.setter
    def display_name(self, display_name):
        """Set display-name for global-system-config.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_user_defined_log_statistics(self, elem):
        """Add element to user-defined-log-statistics for global-system-config.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'name')
        if 'user_defined_log_statistics' not in self._pending_field_map_updates:
            self._pending_field_map_updates['user_defined_log_statistics'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['user_defined_log_statistics'].append(
                ('set', elem, elem_position))
    # end set_user_defined_log_statistics

    def del_user_defined_log_statistics(self, elem_position):
        """Delete element from user-defined-log-statistics for global-system-config.
        
        :param elem_position: string indicating map-key
        
        """
        if 'user_defined_log_statistics' not in self._pending_field_map_updates:
            self._pending_field_map_updates['user_defined_log_statistics'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['user_defined_log_statistics'].append(
                ('delete', None, elem_position))
    # end del_user_defined_log_statistics
    def add_annotations(self, elem):
        """Add element to annotations for global-system-config.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for global-system-config.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_bgp_router(self, *args, **kwargs):
        """Set bgp-router for global-system-config.
        
        :param ref_obj: BgpRouter object
        
        """
        self._pending_field_updates.add('bgp_router_refs')
        self._pending_ref_updates.discard('bgp_router_refs')
        super(GlobalSystemConfig, self).set_bgp_router(*args, **kwargs)

    # end set_bgp_router

    def add_bgp_router(self, *args, **kwargs):
        """Add bgp-router to global-system-config.
        
        :param ref_obj: BgpRouter object
        
        """
        if 'bgp_router_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('bgp_router_refs')
            self._original_bgp_router_refs = copy.deepcopy(self.get_bgp_router_refs() or [])
        super(GlobalSystemConfig, self).add_bgp_router(*args, **kwargs)
    # end add_bgp_router

    def del_bgp_router(self, *args, **kwargs):
        if 'bgp_router_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('bgp_router_refs')
            self._original_bgp_router_refs = copy.deepcopy(self.get_bgp_router_refs() or [])
        super(GlobalSystemConfig, self).del_bgp_router(*args, **kwargs)
    # end del_bgp_router

    def set_bgp_router_list(self, *args, **kwargs):
        """Set bgp-router list for global-system-config.
        
        :param ref_obj_list: list of BgpRouter object
        
        """
        self._pending_field_updates.add('bgp_router_refs')
        self._pending_ref_updates.discard('bgp_router_refs')
        super(GlobalSystemConfig, self).set_bgp_router_list(*args, **kwargs)
    # end set_bgp_router_list

    def set_tag(self, *args, **kwargs):
        """Set tag for global-system-config.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(GlobalSystemConfig, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to global-system-config.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(GlobalSystemConfig, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(GlobalSystemConfig, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for global-system-config.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(GlobalSystemConfig, self).set_tag_list(*args, **kwargs)
    # end set_tag_list

    def get_feature_flags(self):
        if hasattr(self, 'feature_flags'):
            return self.feature_flags

        if hasattr(super(GlobalSystemConfig, self), 'feature_flags'):
            return super(GlobalSystemConfig, self).get_feature_flags()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.global_system_config_read(id = self.uuid, fields = ['feature_flags'])
        except NoIdError:
            return None
        children = getattr(obj, 'feature_flags', None)
        if not children:
            return None
        self.feature_flags = children

        return children
    # end get_feature_flags

    def get_control_node_zones(self):
        if hasattr(self, 'control_node_zones'):
            return self.control_node_zones

        if hasattr(super(GlobalSystemConfig, self), 'control_node_zones'):
            return super(GlobalSystemConfig, self).get_control_node_zones()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.global_system_config_read(id = self.uuid, fields = ['control_node_zones'])
        except NoIdError:
            return None
        children = getattr(obj, 'control_node_zones', None)
        if not children:
            return None
        self.control_node_zones = children

        return children
    # end get_control_node_zones

    def get_global_vrouter_configs(self):
        if hasattr(self, 'global_vrouter_configs'):
            return self.global_vrouter_configs

        if hasattr(super(GlobalSystemConfig, self), 'global_vrouter_configs'):
            return super(GlobalSystemConfig, self).get_global_vrouter_configs()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.global_system_config_read(id = self.uuid, fields = ['global_vrouter_configs'])
        except NoIdError:
            return None
        children = getattr(obj, 'global_vrouter_configs', None)
        if not children:
            return None
        self.global_vrouter_configs = children

        return children
    # end get_global_vrouter_configs

    def get_global_qos_configs(self):
        if hasattr(self, 'global_qos_configs'):
            return self.global_qos_configs

        if hasattr(super(GlobalSystemConfig, self), 'global_qos_configs'):
            return super(GlobalSystemConfig, self).get_global_qos_configs()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.global_system_config_read(id = self.uuid, fields = ['global_qos_configs'])
        except NoIdError:
            return None
        children = getattr(obj, 'global_qos_configs', None)
        if not children:
            return None
        self.global_qos_configs = children

        return children
    # end get_global_qos_configs

    def get_virtual_routers(self):
        if hasattr(self, 'virtual_routers'):
            return self.virtual_routers

        if hasattr(super(GlobalSystemConfig, self), 'virtual_routers'):
            return super(GlobalSystemConfig, self).get_virtual_routers()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.global_system_config_read(id = self.uuid, fields = ['virtual_routers'])
        except NoIdError:
            return None
        children = getattr(obj, 'virtual_routers', None)
        if not children:
            return None
        self.virtual_routers = children

        return children
    # end get_virtual_routers

    def get_config_nodes(self):
        if hasattr(self, 'config_nodes'):
            return self.config_nodes

        if hasattr(super(GlobalSystemConfig, self), 'config_nodes'):
            return super(GlobalSystemConfig, self).get_config_nodes()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.global_system_config_read(id = self.uuid, fields = ['config_nodes'])
        except NoIdError:
            return None
        children = getattr(obj, 'config_nodes', None)
        if not children:
            return None
        self.config_nodes = children

        return children
    # end get_config_nodes

    def get_analytics_nodes(self):
        if hasattr(self, 'analytics_nodes'):
            return self.analytics_nodes

        if hasattr(super(GlobalSystemConfig, self), 'analytics_nodes'):
            return super(GlobalSystemConfig, self).get_analytics_nodes()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.global_system_config_read(id = self.uuid, fields = ['analytics_nodes'])
        except NoIdError:
            return None
        children = getattr(obj, 'analytics_nodes', None)
        if not children:
            return None
        self.analytics_nodes = children

        return children
    # end get_analytics_nodes

    def get_flow_nodes(self):
        if hasattr(self, 'flow_nodes'):
            return self.flow_nodes

        if hasattr(super(GlobalSystemConfig, self), 'flow_nodes'):
            return super(GlobalSystemConfig, self).get_flow_nodes()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.global_system_config_read(id = self.uuid, fields = ['flow_nodes'])
        except NoIdError:
            return None
        children = getattr(obj, 'flow_nodes', None)
        if not children:
            return None
        self.flow_nodes = children

        return children
    # end get_flow_nodes

    def get_devicemgr_nodes(self):
        if hasattr(self, 'devicemgr_nodes'):
            return self.devicemgr_nodes

        if hasattr(super(GlobalSystemConfig, self), 'devicemgr_nodes'):
            return super(GlobalSystemConfig, self).get_devicemgr_nodes()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.global_system_config_read(id = self.uuid, fields = ['devicemgr_nodes'])
        except NoIdError:
            return None
        children = getattr(obj, 'devicemgr_nodes', None)
        if not children:
            return None
        self.devicemgr_nodes = children

        return children
    # end get_devicemgr_nodes

    def get_database_nodes(self):
        if hasattr(self, 'database_nodes'):
            return self.database_nodes

        if hasattr(super(GlobalSystemConfig, self), 'database_nodes'):
            return super(GlobalSystemConfig, self).get_database_nodes()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.global_system_config_read(id = self.uuid, fields = ['database_nodes'])
        except NoIdError:
            return None
        children = getattr(obj, 'database_nodes', None)
        if not children:
            return None
        self.database_nodes = children

        return children
    # end get_database_nodes

    def get_webui_nodes(self):
        if hasattr(self, 'webui_nodes'):
            return self.webui_nodes

        if hasattr(super(GlobalSystemConfig, self), 'webui_nodes'):
            return super(GlobalSystemConfig, self).get_webui_nodes()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.global_system_config_read(id = self.uuid, fields = ['webui_nodes'])
        except NoIdError:
            return None
        children = getattr(obj, 'webui_nodes', None)
        if not children:
            return None
        self.webui_nodes = children

        return children
    # end get_webui_nodes

    def get_config_database_nodes(self):
        if hasattr(self, 'config_database_nodes'):
            return self.config_database_nodes

        if hasattr(super(GlobalSystemConfig, self), 'config_database_nodes'):
            return super(GlobalSystemConfig, self).get_config_database_nodes()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.global_system_config_read(id = self.uuid, fields = ['config_database_nodes'])
        except NoIdError:
            return None
        children = getattr(obj, 'config_database_nodes', None)
        if not children:
            return None
        self.config_database_nodes = children

        return children
    # end get_config_database_nodes

    def get_analytics_alarm_nodes(self):
        if hasattr(self, 'analytics_alarm_nodes'):
            return self.analytics_alarm_nodes

        if hasattr(super(GlobalSystemConfig, self), 'analytics_alarm_nodes'):
            return super(GlobalSystemConfig, self).get_analytics_alarm_nodes()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.global_system_config_read(id = self.uuid, fields = ['analytics_alarm_nodes'])
        except NoIdError:
            return None
        children = getattr(obj, 'analytics_alarm_nodes', None)
        if not children:
            return None
        self.analytics_alarm_nodes = children

        return children
    # end get_analytics_alarm_nodes

    def get_analytics_snmp_nodes(self):
        if hasattr(self, 'analytics_snmp_nodes'):
            return self.analytics_snmp_nodes

        if hasattr(super(GlobalSystemConfig, self), 'analytics_snmp_nodes'):
            return super(GlobalSystemConfig, self).get_analytics_snmp_nodes()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.global_system_config_read(id = self.uuid, fields = ['analytics_snmp_nodes'])
        except NoIdError:
            return None
        children = getattr(obj, 'analytics_snmp_nodes', None)
        if not children:
            return None
        self.analytics_snmp_nodes = children

        return children
    # end get_analytics_snmp_nodes

    def get_service_appliance_sets(self):
        if hasattr(self, 'service_appliance_sets'):
            return self.service_appliance_sets

        if hasattr(super(GlobalSystemConfig, self), 'service_appliance_sets'):
            return super(GlobalSystemConfig, self).get_service_appliance_sets()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.global_system_config_read(id = self.uuid, fields = ['service_appliance_sets'])
        except NoIdError:
            return None
        children = getattr(obj, 'service_appliance_sets', None)
        if not children:
            return None
        self.service_appliance_sets = children

        return children
    # end get_service_appliance_sets

    def get_api_access_lists(self):
        if hasattr(self, 'api_access_lists'):
            return self.api_access_lists

        if hasattr(super(GlobalSystemConfig, self), 'api_access_lists'):
            return super(GlobalSystemConfig, self).get_api_access_lists()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.global_system_config_read(id = self.uuid, fields = ['api_access_lists'])
        except NoIdError:
            return None
        children = getattr(obj, 'api_access_lists', None)
        if not children:
            return None
        self.api_access_lists = children

        return children
    # end get_api_access_lists

    def get_alarms(self):
        if hasattr(self, 'alarms'):
            return self.alarms

        if hasattr(super(GlobalSystemConfig, self), 'alarms'):
            return super(GlobalSystemConfig, self).get_alarms()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.global_system_config_read(id = self.uuid, fields = ['alarms'])
        except NoIdError:
            return None
        children = getattr(obj, 'alarms', None)
        if not children:
            return None
        self.alarms = children

        return children
    # end get_alarms

    def get_job_templates(self):
        if hasattr(self, 'job_templates'):
            return self.job_templates

        if hasattr(super(GlobalSystemConfig, self), 'job_templates'):
            return super(GlobalSystemConfig, self).get_job_templates()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.global_system_config_read(id = self.uuid, fields = ['job_templates'])
        except NoIdError:
            return None
        children = getattr(obj, 'job_templates', None)
        if not children:
            return None
        self.job_templates = children

        return children
    # end get_job_templates

    def get_data_center_interconnects(self):
        if hasattr(self, 'data_center_interconnects'):
            return self.data_center_interconnects

        if hasattr(super(GlobalSystemConfig, self), 'data_center_interconnects'):
            return super(GlobalSystemConfig, self).get_data_center_interconnects()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.global_system_config_read(id = self.uuid, fields = ['data_center_interconnects'])
        except NoIdError:
            return None
        children = getattr(obj, 'data_center_interconnects', None)
        if not children:
            return None
        self.data_center_interconnects = children

        return children
    # end get_data_center_interconnects

    def get_intent_maps(self):
        if hasattr(self, 'intent_maps'):
            return self.intent_maps

        if hasattr(super(GlobalSystemConfig, self), 'intent_maps'):
            return super(GlobalSystemConfig, self).get_intent_maps()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.global_system_config_read(id = self.uuid, fields = ['intent_maps'])
        except NoIdError:
            return None
        children = getattr(obj, 'intent_maps', None)
        if not children:
            return None
        self.intent_maps = children

        return children
    # end get_intent_maps

    def get_fabrics(self):
        if hasattr(self, 'fabrics'):
            return self.fabrics

        if hasattr(super(GlobalSystemConfig, self), 'fabrics'):
            return super(GlobalSystemConfig, self).get_fabrics()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.global_system_config_read(id = self.uuid, fields = ['fabrics'])
        except NoIdError:
            return None
        children = getattr(obj, 'fabrics', None)
        if not children:
            return None
        self.fabrics = children

        return children
    # end get_fabrics

    def get_node_profiles(self):
        if hasattr(self, 'node_profiles'):
            return self.node_profiles

        if hasattr(super(GlobalSystemConfig, self), 'node_profiles'):
            return super(GlobalSystemConfig, self).get_node_profiles()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.global_system_config_read(id = self.uuid, fields = ['node_profiles'])
        except NoIdError:
            return None
        children = getattr(obj, 'node_profiles', None)
        if not children:
            return None
        self.node_profiles = children

        return children
    # end get_node_profiles

    def get_physical_routers(self):
        if hasattr(self, 'physical_routers'):
            return self.physical_routers

        if hasattr(super(GlobalSystemConfig, self), 'physical_routers'):
            return super(GlobalSystemConfig, self).get_physical_routers()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.global_system_config_read(id = self.uuid, fields = ['physical_routers'])
        except NoIdError:
            return None
        children = getattr(obj, 'physical_routers', None)
        if not children:
            return None
        self.physical_routers = children

        return children
    # end get_physical_routers

    def get_device_images(self):
        if hasattr(self, 'device_images'):
            return self.device_images

        if hasattr(super(GlobalSystemConfig, self), 'device_images'):
            return super(GlobalSystemConfig, self).get_device_images()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.global_system_config_read(id = self.uuid, fields = ['device_images'])
        except NoIdError:
            return None
        children = getattr(obj, 'device_images', None)
        if not children:
            return None
        self.device_images = children

        return children
    # end get_device_images

    def get_nodes(self):
        if hasattr(self, 'nodes'):
            return self.nodes

        if hasattr(super(GlobalSystemConfig, self), 'nodes'):
            return super(GlobalSystemConfig, self).get_nodes()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.global_system_config_read(id = self.uuid, fields = ['nodes'])
        except NoIdError:
            return None
        children = getattr(obj, 'nodes', None)
        if not children:
            return None
        self.nodes = children

        return children
    # end get_nodes

    def get_features(self):
        if hasattr(self, 'features'):
            return self.features

        if hasattr(super(GlobalSystemConfig, self), 'features'):
            return super(GlobalSystemConfig, self).get_features()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.global_system_config_read(id = self.uuid, fields = ['features'])
        except NoIdError:
            return None
        children = getattr(obj, 'features', None)
        if not children:
            return None
        self.features = children

        return children
    # end get_features

    def get_physical_roles(self):
        if hasattr(self, 'physical_roles'):
            return self.physical_roles

        if hasattr(super(GlobalSystemConfig, self), 'physical_roles'):
            return super(GlobalSystemConfig, self).get_physical_roles()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.global_system_config_read(id = self.uuid, fields = ['physical_roles'])
        except NoIdError:
            return None
        children = getattr(obj, 'physical_roles', None)
        if not children:
            return None
        self.physical_roles = children

        return children
    # end get_physical_roles

    def get_overlay_roles(self):
        if hasattr(self, 'overlay_roles'):
            return self.overlay_roles

        if hasattr(super(GlobalSystemConfig, self), 'overlay_roles'):
            return super(GlobalSystemConfig, self).get_overlay_roles()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.global_system_config_read(id = self.uuid, fields = ['overlay_roles'])
        except NoIdError:
            return None
        children = getattr(obj, 'overlay_roles', None)
        if not children:
            return None
        self.overlay_roles = children

        return children
    # end get_overlay_roles

    def get_role_definitions(self):
        if hasattr(self, 'role_definitions'):
            return self.role_definitions

        if hasattr(super(GlobalSystemConfig, self), 'role_definitions'):
            return super(GlobalSystemConfig, self).get_role_definitions()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.global_system_config_read(id = self.uuid, fields = ['role_definitions'])
        except NoIdError:
            return None
        children = getattr(obj, 'role_definitions', None)
        if not children:
            return None
        self.role_definitions = children

        return children
    # end get_role_definitions

    def get_global_analytics_configs(self):
        if hasattr(self, 'global_analytics_configs'):
            return self.global_analytics_configs

        if hasattr(super(GlobalSystemConfig, self), 'global_analytics_configs'):
            return super(GlobalSystemConfig, self).get_global_analytics_configs()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.global_system_config_read(id = self.uuid, fields = ['global_analytics_configs'])
        except NoIdError:
            return None
        children = getattr(obj, 'global_analytics_configs', None)
        if not children:
            return None
        self.global_analytics_configs = children

        return children
    # end get_global_analytics_configs


    def get_qos_config_back_refs(self):
        """Return list of all qos-configs using this global-system-config"""
        if hasattr(self, 'qos_config_back_refs'):
            return self.qos_config_back_refs

        if hasattr(super(GlobalSystemConfig, self), 'qos_config_back_refs'):
            return super(GlobalSystemConfig, self).get_qos_config_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.global_system_config_read(id = self.uuid, fields = ['qos_config_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'qos_config_back_refs', None)
        if not back_refs:
            return None
        self.qos_config_back_refs = back_refs

        return back_refs
    # end get_qos_config_back_refs

# end class GlobalSystemConfig

class SubCluster(vnc_api.gen.resource_common.SubCluster):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, *args, **kwargs):
        pending_fields = ['fq_name']

        self._server_conn = None

        if len(args) > 0 or 'sub_cluster_asn' in kwargs:
            pending_fields.append('sub_cluster_asn')
        if len(args) > 1 or 'sub_cluster_id' in kwargs:
            pending_fields.append('sub_cluster_id')
        if len(args) > 2 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 3 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 4 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 5 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(SubCluster, self).__init__(name, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            props_dict['sub_cluster_asn'] = kwargs[u'sub_cluster_asn']
        except KeyError:
            pass

        try:
            props_dict['sub_cluster_id'] = kwargs[u'sub_cluster_id']
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = SubCluster(**props_dict)
        else:
            obj = SubCluster(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.virtual_router_back_refs = kwargs[u'virtual_router_back_refs']
        except KeyError:
            pass
        try:
            obj.bgp_router_back_refs = kwargs[u'bgp_router_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.SubCluster.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.SubCluster.sub_cluster_asn.setter
    def sub_cluster_asn(self, sub_cluster_asn):
        """Set sub-cluster-asn for sub-cluster.
        
        :param sub_cluster_asn: AutonomousSystemType object
        
        """
        if 'sub_cluster_asn' not in self._pending_field_updates:
            self._pending_field_updates.add('sub_cluster_asn')

        self._sub_cluster_asn = sub_cluster_asn
    # end sub_cluster_asn

    def set_sub_cluster_asn(self, value):
        self.sub_cluster_asn = value
    # end set_sub_cluster_asn

    @vnc_api.gen.resource_common.SubCluster.sub_cluster_id.setter
    def sub_cluster_id(self, sub_cluster_id):
        """Set sub-cluster-id for sub-cluster.
        
        :param sub_cluster_id: SubClusterIdType object
        
        """
        if 'sub_cluster_id' not in self._pending_field_updates:
            self._pending_field_updates.add('sub_cluster_id')

        self._sub_cluster_id = sub_cluster_id
    # end sub_cluster_id

    def set_sub_cluster_id(self, value):
        self.sub_cluster_id = value
    # end set_sub_cluster_id

    @vnc_api.gen.resource_common.SubCluster.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for sub-cluster.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.SubCluster.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for sub-cluster.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.SubCluster.annotations.setter
    def annotations(self, annotations):
        """Set annotations for sub-cluster.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.SubCluster.display_name.setter
    def display_name(self, display_name):
        """Set display-name for sub-cluster.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for sub-cluster.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for sub-cluster.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_tag(self, *args, **kwargs):
        """Set tag for sub-cluster.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(SubCluster, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to sub-cluster.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(SubCluster, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(SubCluster, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for sub-cluster.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(SubCluster, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


    def get_virtual_router_back_refs(self):
        """Return list of all virtual-routers using this sub-cluster"""
        if hasattr(self, 'virtual_router_back_refs'):
            return self.virtual_router_back_refs

        if hasattr(super(SubCluster, self), 'virtual_router_back_refs'):
            return super(SubCluster, self).get_virtual_router_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.sub_cluster_read(id = self.uuid, fields = ['virtual_router_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'virtual_router_back_refs', None)
        if not back_refs:
            return None
        self.virtual_router_back_refs = back_refs

        return back_refs
    # end get_virtual_router_back_refs

    def get_bgp_router_back_refs(self):
        """Return list of all bgp-routers using this sub-cluster"""
        if hasattr(self, 'bgp_router_back_refs'):
            return self.bgp_router_back_refs

        if hasattr(super(SubCluster, self), 'bgp_router_back_refs'):
            return super(SubCluster, self).get_bgp_router_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.sub_cluster_read(id = self.uuid, fields = ['bgp_router_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'bgp_router_back_refs', None)
        if not back_refs:
            return None
        self.bgp_router_back_refs = back_refs

        return back_refs
    # end get_bgp_router_back_refs

# end class SubCluster

class ForwardingClass(vnc_api.gen.resource_common.ForwardingClass):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'forwarding_class_id' in kwargs:
            pending_fields.append('forwarding_class_id')
        if len(args) > 1 or 'forwarding_class_dscp' in kwargs:
            pending_fields.append('forwarding_class_dscp')
        if len(args) > 2 or 'forwarding_class_vlan_priority' in kwargs:
            pending_fields.append('forwarding_class_vlan_priority')
        if len(args) > 3 or 'forwarding_class_mpls_exp' in kwargs:
            pending_fields.append('forwarding_class_mpls_exp')
        if len(args) > 4 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 5 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 6 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 7 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(ForwardingClass, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            props_dict['forwarding_class_id'] = kwargs[u'forwarding_class_id']
        except KeyError:
            pass

        try:
            props_dict['forwarding_class_dscp'] = kwargs[u'forwarding_class_dscp']
        except KeyError:
            pass

        try:
            props_dict['forwarding_class_vlan_priority'] = kwargs[u'forwarding_class_vlan_priority']
        except KeyError:
            pass

        try:
            props_dict['forwarding_class_mpls_exp'] = kwargs[u'forwarding_class_mpls_exp']
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = ForwardingClass(**props_dict)
        else:
            obj = ForwardingClass(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.qos_queue_refs = kwargs[u'qos_queue_refs']
        except KeyError:
            pass
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.ForwardingClass.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.ForwardingClass.forwarding_class_id.setter
    def forwarding_class_id(self, forwarding_class_id):
        """Set forwarding-class-id for forwarding-class.
        
        :param forwarding_class_id: ForwardingClassId object
        
        """
        if 'forwarding_class_id' not in self._pending_field_updates:
            self._pending_field_updates.add('forwarding_class_id')

        self._forwarding_class_id = forwarding_class_id
    # end forwarding_class_id

    def set_forwarding_class_id(self, value):
        self.forwarding_class_id = value
    # end set_forwarding_class_id

    @vnc_api.gen.resource_common.ForwardingClass.forwarding_class_dscp.setter
    def forwarding_class_dscp(self, forwarding_class_dscp):
        """Set forwarding-class-dscp for forwarding-class.
        
        :param forwarding_class_dscp: DscpValueType object
        
        """
        if 'forwarding_class_dscp' not in self._pending_field_updates:
            self._pending_field_updates.add('forwarding_class_dscp')

        self._forwarding_class_dscp = forwarding_class_dscp
    # end forwarding_class_dscp

    def set_forwarding_class_dscp(self, value):
        self.forwarding_class_dscp = value
    # end set_forwarding_class_dscp

    @vnc_api.gen.resource_common.ForwardingClass.forwarding_class_vlan_priority.setter
    def forwarding_class_vlan_priority(self, forwarding_class_vlan_priority):
        """Set forwarding-class-vlan-priority for forwarding-class.
        
        :param forwarding_class_vlan_priority: VlanPriorityType object
        
        """
        if 'forwarding_class_vlan_priority' not in self._pending_field_updates:
            self._pending_field_updates.add('forwarding_class_vlan_priority')

        self._forwarding_class_vlan_priority = forwarding_class_vlan_priority
    # end forwarding_class_vlan_priority

    def set_forwarding_class_vlan_priority(self, value):
        self.forwarding_class_vlan_priority = value
    # end set_forwarding_class_vlan_priority

    @vnc_api.gen.resource_common.ForwardingClass.forwarding_class_mpls_exp.setter
    def forwarding_class_mpls_exp(self, forwarding_class_mpls_exp):
        """Set forwarding-class-mpls-exp for forwarding-class.
        
        :param forwarding_class_mpls_exp: MplsExpType object
        
        """
        if 'forwarding_class_mpls_exp' not in self._pending_field_updates:
            self._pending_field_updates.add('forwarding_class_mpls_exp')

        self._forwarding_class_mpls_exp = forwarding_class_mpls_exp
    # end forwarding_class_mpls_exp

    def set_forwarding_class_mpls_exp(self, value):
        self.forwarding_class_mpls_exp = value
    # end set_forwarding_class_mpls_exp

    @vnc_api.gen.resource_common.ForwardingClass.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for forwarding-class.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.ForwardingClass.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for forwarding-class.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.ForwardingClass.annotations.setter
    def annotations(self, annotations):
        """Set annotations for forwarding-class.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.ForwardingClass.display_name.setter
    def display_name(self, display_name):
        """Set display-name for forwarding-class.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for forwarding-class.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for forwarding-class.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_qos_queue(self, *args, **kwargs):
        """Set qos-queue for forwarding-class.
        
        :param ref_obj: QosQueue object
        
        """
        self._pending_field_updates.add('qos_queue_refs')
        self._pending_ref_updates.discard('qos_queue_refs')
        super(ForwardingClass, self).set_qos_queue(*args, **kwargs)

    # end set_qos_queue

    def add_qos_queue(self, *args, **kwargs):
        """Add qos-queue to forwarding-class.
        
        :param ref_obj: QosQueue object
        
        """
        if 'qos_queue_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('qos_queue_refs')
            self._original_qos_queue_refs = copy.deepcopy(self.get_qos_queue_refs() or [])
        super(ForwardingClass, self).add_qos_queue(*args, **kwargs)
    # end add_qos_queue

    def del_qos_queue(self, *args, **kwargs):
        if 'qos_queue_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('qos_queue_refs')
            self._original_qos_queue_refs = copy.deepcopy(self.get_qos_queue_refs() or [])
        super(ForwardingClass, self).del_qos_queue(*args, **kwargs)
    # end del_qos_queue

    def set_qos_queue_list(self, *args, **kwargs):
        """Set qos-queue list for forwarding-class.
        
        :param ref_obj_list: list of QosQueue object
        
        """
        self._pending_field_updates.add('qos_queue_refs')
        self._pending_ref_updates.discard('qos_queue_refs')
        super(ForwardingClass, self).set_qos_queue_list(*args, **kwargs)
    # end set_qos_queue_list

    def set_tag(self, *args, **kwargs):
        """Set tag for forwarding-class.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(ForwardingClass, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to forwarding-class.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(ForwardingClass, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(ForwardingClass, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for forwarding-class.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(ForwardingClass, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


# end class ForwardingClass

class ServiceGroup(vnc_api.gen.resource_common.ServiceGroup):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'draft_mode_state' in kwargs:
            pending_fields.append('draft_mode_state')
        if len(args) > 1 or 'service_group_firewall_service_list' in kwargs:
            pending_fields.append('service_group_firewall_service_list')
        if len(args) > 2 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 3 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 4 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 5 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(ServiceGroup, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            props_dict['draft_mode_state'] = kwargs[u'draft_mode_state']
        except KeyError:
            pass

        try:
            if kwargs['service_group_firewall_service_list'] is None:
                props_dict['service_group_firewall_service_list'] = None
            else:
                props_dict['service_group_firewall_service_list'] = vnc_api.gen.resource_xsd.FirewallServiceGroupType(params_dict=kwargs[u'service_group_firewall_service_list'])
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = ServiceGroup(**props_dict)
        else:
            obj = ServiceGroup(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.firewall_rule_back_refs = kwargs[u'firewall_rule_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.ServiceGroup.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.ServiceGroup.draft_mode_state.setter
    def draft_mode_state(self, draft_mode_state):
        """Set draft-mode-state for service-group.
        
        :param draft_mode_state: DraftModeState object
        
        """
        if 'draft_mode_state' not in self._pending_field_updates:
            self._pending_field_updates.add('draft_mode_state')

        self._draft_mode_state = draft_mode_state
    # end draft_mode_state

    def set_draft_mode_state(self, value):
        self.draft_mode_state = value
    # end set_draft_mode_state

    @vnc_api.gen.resource_common.ServiceGroup.service_group_firewall_service_list.setter
    def service_group_firewall_service_list(self, service_group_firewall_service_list):
        """Set service-group-firewall-service-list for service-group.
        
        :param service_group_firewall_service_list: FirewallServiceGroupType object
        
        """
        if 'service_group_firewall_service_list' not in self._pending_field_updates:
            self._pending_field_updates.add('service_group_firewall_service_list')

        if 'service_group_firewall_service_list' in self._pending_field_list_updates:
            # set clobbers earlier add/del on prop list elements
            del self._pending_field_list_updates['service_group_firewall_service_list']

        self._service_group_firewall_service_list = service_group_firewall_service_list
    # end service_group_firewall_service_list

    def set_service_group_firewall_service_list(self, value):
        self.service_group_firewall_service_list = value
    # end set_service_group_firewall_service_list

    @vnc_api.gen.resource_common.ServiceGroup.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for service-group.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.ServiceGroup.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for service-group.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.ServiceGroup.annotations.setter
    def annotations(self, annotations):
        """Set annotations for service-group.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.ServiceGroup.display_name.setter
    def display_name(self, display_name):
        """Set display-name for service-group.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_service_group_firewall_service_list(self, elem_value, elem_position=None):
        """Add element to service-group-firewall-service-list for service-group.
        
        :param elem_value: xsd:string object
        :param elem_position: optional string order-key
        
        """
        if 'service_group_firewall_service_list' not in self._pending_field_list_updates:
            self._pending_field_list_updates['service_group_firewall_service_list'] = [
                ('add', elem_value, elem_position)]
        else:
            self._pending_field_list_updates['service_group_firewall_service_list'].append(
                ('add', elem_value, elem_position))
    # end add_service_group_firewall_service_list

    def del_service_group_firewall_service_list(self, elem_position):
        """Delete element from service-group-firewall-service-list for service-group.
        
        :param elem_position: string indicating order-key
        
        """
        if 'service_group_firewall_service_list' not in self._pending_field_list_updates:
            self._pending_field_list_updates['service_group_firewall_service_list'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_list_updates['service_group_firewall_service_list'].append(
                ('delete', None, elem_position))
    # end del_service_group_firewall_service_list
    def add_annotations(self, elem):
        """Add element to annotations for service-group.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for service-group.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_tag(self, *args, **kwargs):
        """Set tag for service-group.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(ServiceGroup, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to service-group.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(ServiceGroup, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(ServiceGroup, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for service-group.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(ServiceGroup, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


    def get_firewall_rule_back_refs(self):
        """Return list of all firewall-rules using this service-group"""
        if hasattr(self, 'firewall_rule_back_refs'):
            return self.firewall_rule_back_refs

        if hasattr(super(ServiceGroup, self), 'firewall_rule_back_refs'):
            return super(ServiceGroup, self).get_firewall_rule_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.service_group_read(id = self.uuid, fields = ['firewall_rule_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'firewall_rule_back_refs', None)
        if not back_refs:
            return None
        self.firewall_rule_back_refs = back_refs

        return back_refs
    # end get_firewall_rule_back_refs

# end class ServiceGroup

class GlobalAnalyticsConfig(vnc_api.gen.resource_common.GlobalAnalyticsConfig):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 1 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 2 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 3 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(GlobalAnalyticsConfig, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = GlobalAnalyticsConfig(**props_dict)
        else:
            obj = GlobalAnalyticsConfig(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...
        try:
            obj.structured_syslog_configs = kwargs[u'structured_syslog_configs']
        except KeyError:
            pass

        # add any specified references...
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.GlobalAnalyticsConfig.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.GlobalAnalyticsConfig.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for global-analytics-config.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.GlobalAnalyticsConfig.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for global-analytics-config.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.GlobalAnalyticsConfig.annotations.setter
    def annotations(self, annotations):
        """Set annotations for global-analytics-config.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.GlobalAnalyticsConfig.display_name.setter
    def display_name(self, display_name):
        """Set display-name for global-analytics-config.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for global-analytics-config.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for global-analytics-config.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_tag(self, *args, **kwargs):
        """Set tag for global-analytics-config.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(GlobalAnalyticsConfig, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to global-analytics-config.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(GlobalAnalyticsConfig, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(GlobalAnalyticsConfig, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for global-analytics-config.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(GlobalAnalyticsConfig, self).set_tag_list(*args, **kwargs)
    # end set_tag_list

    def get_structured_syslog_configs(self):
        if hasattr(self, 'structured_syslog_configs'):
            return self.structured_syslog_configs

        if hasattr(super(GlobalAnalyticsConfig, self), 'structured_syslog_configs'):
            return super(GlobalAnalyticsConfig, self).get_structured_syslog_configs()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.global_analytics_config_read(id = self.uuid, fields = ['structured_syslog_configs'])
        except NoIdError:
            return None
        children = getattr(obj, 'structured_syslog_configs', None)
        if not children:
            return None
        self.structured_syslog_configs = children

        return children
    # end get_structured_syslog_configs


# end class GlobalAnalyticsConfig

class AddressGroup(vnc_api.gen.resource_common.AddressGroup):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'draft_mode_state' in kwargs:
            pending_fields.append('draft_mode_state')
        if len(args) > 1 or 'address_group_prefix' in kwargs:
            pending_fields.append('address_group_prefix')
        if len(args) > 2 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 3 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 4 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 5 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(AddressGroup, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            props_dict['draft_mode_state'] = kwargs[u'draft_mode_state']
        except KeyError:
            pass

        try:
            if kwargs['address_group_prefix'] is None:
                props_dict['address_group_prefix'] = None
            else:
                props_dict['address_group_prefix'] = vnc_api.gen.resource_xsd.SubnetListType(params_dict=kwargs[u'address_group_prefix'])
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = AddressGroup(**props_dict)
        else:
            obj = AddressGroup(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.firewall_rule_back_refs = kwargs[u'firewall_rule_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.AddressGroup.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.AddressGroup.draft_mode_state.setter
    def draft_mode_state(self, draft_mode_state):
        """Set draft-mode-state for address-group.
        
        :param draft_mode_state: DraftModeState object
        
        """
        if 'draft_mode_state' not in self._pending_field_updates:
            self._pending_field_updates.add('draft_mode_state')

        self._draft_mode_state = draft_mode_state
    # end draft_mode_state

    def set_draft_mode_state(self, value):
        self.draft_mode_state = value
    # end set_draft_mode_state

    @vnc_api.gen.resource_common.AddressGroup.address_group_prefix.setter
    def address_group_prefix(self, address_group_prefix):
        """Set address-group-prefix for address-group.
        
        :param address_group_prefix: SubnetListType object
        
        """
        if 'address_group_prefix' not in self._pending_field_updates:
            self._pending_field_updates.add('address_group_prefix')

        if 'address_group_prefix' in self._pending_field_list_updates:
            # set clobbers earlier add/del on prop list elements
            del self._pending_field_list_updates['address_group_prefix']

        self._address_group_prefix = address_group_prefix
    # end address_group_prefix

    def set_address_group_prefix(self, value):
        self.address_group_prefix = value
    # end set_address_group_prefix

    @vnc_api.gen.resource_common.AddressGroup.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for address-group.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.AddressGroup.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for address-group.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.AddressGroup.annotations.setter
    def annotations(self, annotations):
        """Set annotations for address-group.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.AddressGroup.display_name.setter
    def display_name(self, display_name):
        """Set display-name for address-group.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_address_group_prefix(self, elem_value, elem_position=None):
        """Add element to address-group-prefix for address-group.
        
        :param elem_value: xsd:string object
        :param elem_position: optional string order-key
        
        """
        if 'address_group_prefix' not in self._pending_field_list_updates:
            self._pending_field_list_updates['address_group_prefix'] = [
                ('add', elem_value, elem_position)]
        else:
            self._pending_field_list_updates['address_group_prefix'].append(
                ('add', elem_value, elem_position))
    # end add_address_group_prefix

    def del_address_group_prefix(self, elem_position):
        """Delete element from address-group-prefix for address-group.
        
        :param elem_position: string indicating order-key
        
        """
        if 'address_group_prefix' not in self._pending_field_list_updates:
            self._pending_field_list_updates['address_group_prefix'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_list_updates['address_group_prefix'].append(
                ('delete', None, elem_position))
    # end del_address_group_prefix
    def add_annotations(self, elem):
        """Add element to annotations for address-group.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for address-group.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_tag(self, *args, **kwargs):
        """Set tag for address-group.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(AddressGroup, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to address-group.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(AddressGroup, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(AddressGroup, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for address-group.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(AddressGroup, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


    def get_firewall_rule_back_refs(self):
        """Return list of all firewall-rules using this address-group"""
        if hasattr(self, 'firewall_rule_back_refs'):
            return self.firewall_rule_back_refs

        if hasattr(super(AddressGroup, self), 'firewall_rule_back_refs'):
            return super(AddressGroup, self).get_firewall_rule_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.address_group_read(id = self.uuid, fields = ['firewall_rule_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'firewall_rule_back_refs', None)
        if not back_refs:
            return None
        self.firewall_rule_back_refs = back_refs

        return back_refs
    # end get_firewall_rule_back_refs

# end class AddressGroup

class ApplicationPolicySet(vnc_api.gen.resource_common.ApplicationPolicySet):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'draft_mode_state' in kwargs:
            pending_fields.append('draft_mode_state')
        if len(args) > 1 or 'all_applications' in kwargs:
            pending_fields.append('all_applications')
        if len(args) > 2 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 3 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 4 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 5 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(ApplicationPolicySet, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            props_dict['draft_mode_state'] = kwargs[u'draft_mode_state']
        except KeyError:
            pass

        try:
            props_dict['all_applications'] = kwargs[u'all_applications']
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = ApplicationPolicySet(**props_dict)
        else:
            obj = ApplicationPolicySet(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.firewall_policy_refs = kwargs[u'firewall_policy_refs']
            for ref in obj.firewall_policy_refs:
                ref['attr'] = vnc_api.gen.resource_xsd.FirewallSequence(params_dict=ref[u'attr'])
        except KeyError:
            pass
        try:
            obj.global_vrouter_config_refs = kwargs[u'global_vrouter_config_refs']
        except KeyError:
            pass
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.project_back_refs = kwargs[u'project_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.ApplicationPolicySet.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.ApplicationPolicySet.draft_mode_state.setter
    def draft_mode_state(self, draft_mode_state):
        """Set draft-mode-state for application-policy-set.
        
        :param draft_mode_state: DraftModeState object
        
        """
        if 'draft_mode_state' not in self._pending_field_updates:
            self._pending_field_updates.add('draft_mode_state')

        self._draft_mode_state = draft_mode_state
    # end draft_mode_state

    def set_draft_mode_state(self, value):
        self.draft_mode_state = value
    # end set_draft_mode_state

    @vnc_api.gen.resource_common.ApplicationPolicySet.all_applications.setter
    def all_applications(self, all_applications):
        """Set all-applications for application-policy-set.
        
        :param all_applications: xsd:boolean object
        
        """
        if 'all_applications' not in self._pending_field_updates:
            self._pending_field_updates.add('all_applications')

        self._all_applications = all_applications
    # end all_applications

    def set_all_applications(self, value):
        self.all_applications = value
    # end set_all_applications

    @vnc_api.gen.resource_common.ApplicationPolicySet.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for application-policy-set.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.ApplicationPolicySet.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for application-policy-set.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.ApplicationPolicySet.annotations.setter
    def annotations(self, annotations):
        """Set annotations for application-policy-set.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.ApplicationPolicySet.display_name.setter
    def display_name(self, display_name):
        """Set display-name for application-policy-set.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for application-policy-set.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for application-policy-set.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_firewall_policy(self, *args, **kwargs):
        """Set firewall-policy for application-policy-set.
        
        :param ref_obj: FirewallPolicy object
        :param ref_data: FirewallSequence object
        
        """
        self._pending_field_updates.add('firewall_policy_refs')
        self._pending_ref_updates.discard('firewall_policy_refs')
        super(ApplicationPolicySet, self).set_firewall_policy(*args, **kwargs)

    # end set_firewall_policy

    def add_firewall_policy(self, *args, **kwargs):
        """Add firewall-policy to application-policy-set.
        
        :param ref_obj: FirewallPolicy object
        :param ref_data: FirewallSequence object
        
        """
        if 'firewall_policy_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('firewall_policy_refs')
            self._original_firewall_policy_refs = copy.deepcopy(self.get_firewall_policy_refs() or [])
        super(ApplicationPolicySet, self).add_firewall_policy(*args, **kwargs)
    # end add_firewall_policy

    def del_firewall_policy(self, *args, **kwargs):
        if 'firewall_policy_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('firewall_policy_refs')
            self._original_firewall_policy_refs = copy.deepcopy(self.get_firewall_policy_refs() or [])
        super(ApplicationPolicySet, self).del_firewall_policy(*args, **kwargs)
    # end del_firewall_policy

    def set_firewall_policy_list(self, *args, **kwargs):
        """Set firewall-policy list for application-policy-set.
        
        :param ref_obj_list: list of FirewallPolicy object
        :param ref_data_list: list of FirewallSequence summary
        
        """
        self._pending_field_updates.add('firewall_policy_refs')
        self._pending_ref_updates.discard('firewall_policy_refs')
        super(ApplicationPolicySet, self).set_firewall_policy_list(*args, **kwargs)
    # end set_firewall_policy_list

    def set_global_vrouter_config(self, *args, **kwargs):
        """Set global-vrouter-config for application-policy-set.
        
        :param ref_obj: GlobalVrouterConfig object
        
        """
        self._pending_field_updates.add('global_vrouter_config_refs')
        self._pending_ref_updates.discard('global_vrouter_config_refs')
        super(ApplicationPolicySet, self).set_global_vrouter_config(*args, **kwargs)

    # end set_global_vrouter_config

    def add_global_vrouter_config(self, *args, **kwargs):
        """Add global-vrouter-config to application-policy-set.
        
        :param ref_obj: GlobalVrouterConfig object
        
        """
        if 'global_vrouter_config_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('global_vrouter_config_refs')
            self._original_global_vrouter_config_refs = copy.deepcopy(self.get_global_vrouter_config_refs() or [])
        super(ApplicationPolicySet, self).add_global_vrouter_config(*args, **kwargs)
    # end add_global_vrouter_config

    def del_global_vrouter_config(self, *args, **kwargs):
        if 'global_vrouter_config_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('global_vrouter_config_refs')
            self._original_global_vrouter_config_refs = copy.deepcopy(self.get_global_vrouter_config_refs() or [])
        super(ApplicationPolicySet, self).del_global_vrouter_config(*args, **kwargs)
    # end del_global_vrouter_config

    def set_global_vrouter_config_list(self, *args, **kwargs):
        """Set global-vrouter-config list for application-policy-set.
        
        :param ref_obj_list: list of GlobalVrouterConfig object
        
        """
        self._pending_field_updates.add('global_vrouter_config_refs')
        self._pending_ref_updates.discard('global_vrouter_config_refs')
        super(ApplicationPolicySet, self).set_global_vrouter_config_list(*args, **kwargs)
    # end set_global_vrouter_config_list

    def set_tag(self, *args, **kwargs):
        """Set tag for application-policy-set.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(ApplicationPolicySet, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to application-policy-set.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(ApplicationPolicySet, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(ApplicationPolicySet, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for application-policy-set.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(ApplicationPolicySet, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


    def get_project_back_refs(self):
        """Return list of all projects using this application-policy-set"""
        if hasattr(self, 'project_back_refs'):
            return self.project_back_refs

        if hasattr(super(ApplicationPolicySet, self), 'project_back_refs'):
            return super(ApplicationPolicySet, self).get_project_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.application_policy_set_read(id = self.uuid, fields = ['project_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'project_back_refs', None)
        if not back_refs:
            return None
        self.project_back_refs = back_refs

        return back_refs
    # end get_project_back_refs

# end class ApplicationPolicySet

class VirtualIp(vnc_api.gen.resource_common.VirtualIp):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'virtual_ip_properties' in kwargs:
            pending_fields.append('virtual_ip_properties')
        if len(args) > 1 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 2 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 3 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 4 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(VirtualIp, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            if kwargs['virtual_ip_properties'] is None:
                props_dict['virtual_ip_properties'] = None
            else:
                props_dict['virtual_ip_properties'] = vnc_api.gen.resource_xsd.VirtualIpType(params_dict=kwargs[u'virtual_ip_properties'])
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = VirtualIp(**props_dict)
        else:
            obj = VirtualIp(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.loadbalancer_pool_refs = kwargs[u'loadbalancer_pool_refs']
        except KeyError:
            pass
        try:
            obj.virtual_machine_interface_refs = kwargs[u'virtual_machine_interface_refs']
        except KeyError:
            pass
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.VirtualIp.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.VirtualIp.virtual_ip_properties.setter
    def virtual_ip_properties(self, virtual_ip_properties):
        """Set virtual-ip-properties for virtual-ip.
        
        :param virtual_ip_properties: VirtualIpType object
        
        """
        if 'virtual_ip_properties' not in self._pending_field_updates:
            self._pending_field_updates.add('virtual_ip_properties')

        self._virtual_ip_properties = virtual_ip_properties
    # end virtual_ip_properties

    def set_virtual_ip_properties(self, value):
        self.virtual_ip_properties = value
    # end set_virtual_ip_properties

    @vnc_api.gen.resource_common.VirtualIp.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for virtual-ip.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.VirtualIp.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for virtual-ip.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.VirtualIp.annotations.setter
    def annotations(self, annotations):
        """Set annotations for virtual-ip.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.VirtualIp.display_name.setter
    def display_name(self, display_name):
        """Set display-name for virtual-ip.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for virtual-ip.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for virtual-ip.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_loadbalancer_pool(self, *args, **kwargs):
        """Set loadbalancer-pool for virtual-ip.
        
        :param ref_obj: LoadbalancerPool object
        
        """
        self._pending_field_updates.add('loadbalancer_pool_refs')
        self._pending_ref_updates.discard('loadbalancer_pool_refs')
        super(VirtualIp, self).set_loadbalancer_pool(*args, **kwargs)

    # end set_loadbalancer_pool

    def add_loadbalancer_pool(self, *args, **kwargs):
        """Add loadbalancer-pool to virtual-ip.
        
        :param ref_obj: LoadbalancerPool object
        
        """
        if 'loadbalancer_pool_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('loadbalancer_pool_refs')
            self._original_loadbalancer_pool_refs = copy.deepcopy(self.get_loadbalancer_pool_refs() or [])
        super(VirtualIp, self).add_loadbalancer_pool(*args, **kwargs)
    # end add_loadbalancer_pool

    def del_loadbalancer_pool(self, *args, **kwargs):
        if 'loadbalancer_pool_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('loadbalancer_pool_refs')
            self._original_loadbalancer_pool_refs = copy.deepcopy(self.get_loadbalancer_pool_refs() or [])
        super(VirtualIp, self).del_loadbalancer_pool(*args, **kwargs)
    # end del_loadbalancer_pool

    def set_loadbalancer_pool_list(self, *args, **kwargs):
        """Set loadbalancer-pool list for virtual-ip.
        
        :param ref_obj_list: list of LoadbalancerPool object
        
        """
        self._pending_field_updates.add('loadbalancer_pool_refs')
        self._pending_ref_updates.discard('loadbalancer_pool_refs')
        super(VirtualIp, self).set_loadbalancer_pool_list(*args, **kwargs)
    # end set_loadbalancer_pool_list

    def set_virtual_machine_interface(self, *args, **kwargs):
        """Set virtual-machine-interface for virtual-ip.
        
        :param ref_obj: VirtualMachineInterface object
        
        """
        self._pending_field_updates.add('virtual_machine_interface_refs')
        self._pending_ref_updates.discard('virtual_machine_interface_refs')
        super(VirtualIp, self).set_virtual_machine_interface(*args, **kwargs)

    # end set_virtual_machine_interface

    def add_virtual_machine_interface(self, *args, **kwargs):
        """Add virtual-machine-interface to virtual-ip.
        
        :param ref_obj: VirtualMachineInterface object
        
        """
        if 'virtual_machine_interface_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('virtual_machine_interface_refs')
            self._original_virtual_machine_interface_refs = copy.deepcopy(self.get_virtual_machine_interface_refs() or [])
        super(VirtualIp, self).add_virtual_machine_interface(*args, **kwargs)
    # end add_virtual_machine_interface

    def del_virtual_machine_interface(self, *args, **kwargs):
        if 'virtual_machine_interface_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('virtual_machine_interface_refs')
            self._original_virtual_machine_interface_refs = copy.deepcopy(self.get_virtual_machine_interface_refs() or [])
        super(VirtualIp, self).del_virtual_machine_interface(*args, **kwargs)
    # end del_virtual_machine_interface

    def set_virtual_machine_interface_list(self, *args, **kwargs):
        """Set virtual-machine-interface list for virtual-ip.
        
        :param ref_obj_list: list of VirtualMachineInterface object
        
        """
        self._pending_field_updates.add('virtual_machine_interface_refs')
        self._pending_ref_updates.discard('virtual_machine_interface_refs')
        super(VirtualIp, self).set_virtual_machine_interface_list(*args, **kwargs)
    # end set_virtual_machine_interface_list

    def set_tag(self, *args, **kwargs):
        """Set tag for virtual-ip.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(VirtualIp, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to virtual-ip.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(VirtualIp, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(VirtualIp, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for virtual-ip.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(VirtualIp, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


# end class VirtualIp

class IntentMap(vnc_api.gen.resource_common.IntentMap):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'intent_map_intent_type' in kwargs:
            pending_fields.append('intent_map_intent_type')
        if len(args) > 1 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 2 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 3 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 4 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(IntentMap, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            props_dict['intent_map_intent_type'] = kwargs[u'intent_map_intent_type']
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = IntentMap(**props_dict)
        else:
            obj = IntentMap(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.physical_router_back_refs = kwargs[u'physical_router_back_refs']
        except KeyError:
            pass
        try:
            obj.virtual_network_back_refs = kwargs[u'virtual_network_back_refs']
        except KeyError:
            pass
        try:
            obj.fabric_back_refs = kwargs[u'fabric_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.IntentMap.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.IntentMap.intent_map_intent_type.setter
    def intent_map_intent_type(self, intent_map_intent_type):
        """Set intent-map-intent-type for intent-map.
        
        :param intent_map_intent_type: IntentType object
        
        """
        if 'intent_map_intent_type' not in self._pending_field_updates:
            self._pending_field_updates.add('intent_map_intent_type')

        self._intent_map_intent_type = intent_map_intent_type
    # end intent_map_intent_type

    def set_intent_map_intent_type(self, value):
        self.intent_map_intent_type = value
    # end set_intent_map_intent_type

    @vnc_api.gen.resource_common.IntentMap.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for intent-map.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.IntentMap.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for intent-map.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.IntentMap.annotations.setter
    def annotations(self, annotations):
        """Set annotations for intent-map.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.IntentMap.display_name.setter
    def display_name(self, display_name):
        """Set display-name for intent-map.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for intent-map.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for intent-map.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_tag(self, *args, **kwargs):
        """Set tag for intent-map.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(IntentMap, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to intent-map.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(IntentMap, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(IntentMap, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for intent-map.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(IntentMap, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


    def get_physical_router_back_refs(self):
        """Return list of all physical-routers using this intent-map"""
        if hasattr(self, 'physical_router_back_refs'):
            return self.physical_router_back_refs

        if hasattr(super(IntentMap, self), 'physical_router_back_refs'):
            return super(IntentMap, self).get_physical_router_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.intent_map_read(id = self.uuid, fields = ['physical_router_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'physical_router_back_refs', None)
        if not back_refs:
            return None
        self.physical_router_back_refs = back_refs

        return back_refs
    # end get_physical_router_back_refs

    def get_virtual_network_back_refs(self):
        """Return list of all virtual-networks using this intent-map"""
        if hasattr(self, 'virtual_network_back_refs'):
            return self.virtual_network_back_refs

        if hasattr(super(IntentMap, self), 'virtual_network_back_refs'):
            return super(IntentMap, self).get_virtual_network_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.intent_map_read(id = self.uuid, fields = ['virtual_network_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'virtual_network_back_refs', None)
        if not back_refs:
            return None
        self.virtual_network_back_refs = back_refs

        return back_refs
    # end get_virtual_network_back_refs

    def get_fabric_back_refs(self):
        """Return list of all fabrics using this intent-map"""
        if hasattr(self, 'fabric_back_refs'):
            return self.fabric_back_refs

        if hasattr(super(IntentMap, self), 'fabric_back_refs'):
            return super(IntentMap, self).get_fabric_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.intent_map_read(id = self.uuid, fields = ['fabric_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'fabric_back_refs', None)
        if not back_refs:
            return None
        self.fabric_back_refs = back_refs

        return back_refs
    # end get_fabric_back_refs

# end class IntentMap

class PortTuple(vnc_api.gen.resource_common.PortTuple):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 1 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 2 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 3 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(PortTuple, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = PortTuple(**props_dict)
        else:
            obj = PortTuple(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.logical_router_refs = kwargs[u'logical_router_refs']
        except KeyError:
            pass
        try:
            obj.virtual_network_refs = kwargs[u'virtual_network_refs']
        except KeyError:
            pass
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.virtual_machine_interface_back_refs = kwargs[u'virtual_machine_interface_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.PortTuple.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.PortTuple.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for port-tuple.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.PortTuple.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for port-tuple.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.PortTuple.annotations.setter
    def annotations(self, annotations):
        """Set annotations for port-tuple.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.PortTuple.display_name.setter
    def display_name(self, display_name):
        """Set display-name for port-tuple.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for port-tuple.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for port-tuple.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_logical_router(self, *args, **kwargs):
        """Set logical-router for port-tuple.
        
        :param ref_obj: LogicalRouter object
        
        """
        self._pending_field_updates.add('logical_router_refs')
        self._pending_ref_updates.discard('logical_router_refs')
        super(PortTuple, self).set_logical_router(*args, **kwargs)

    # end set_logical_router

    def add_logical_router(self, *args, **kwargs):
        """Add logical-router to port-tuple.
        
        :param ref_obj: LogicalRouter object
        
        """
        if 'logical_router_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('logical_router_refs')
            self._original_logical_router_refs = copy.deepcopy(self.get_logical_router_refs() or [])
        super(PortTuple, self).add_logical_router(*args, **kwargs)
    # end add_logical_router

    def del_logical_router(self, *args, **kwargs):
        if 'logical_router_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('logical_router_refs')
            self._original_logical_router_refs = copy.deepcopy(self.get_logical_router_refs() or [])
        super(PortTuple, self).del_logical_router(*args, **kwargs)
    # end del_logical_router

    def set_logical_router_list(self, *args, **kwargs):
        """Set logical-router list for port-tuple.
        
        :param ref_obj_list: list of LogicalRouter object
        
        """
        self._pending_field_updates.add('logical_router_refs')
        self._pending_ref_updates.discard('logical_router_refs')
        super(PortTuple, self).set_logical_router_list(*args, **kwargs)
    # end set_logical_router_list

    def set_virtual_network(self, *args, **kwargs):
        """Set virtual-network for port-tuple.
        
        :param ref_obj: VirtualNetwork object
        
        """
        self._pending_field_updates.add('virtual_network_refs')
        self._pending_ref_updates.discard('virtual_network_refs')
        super(PortTuple, self).set_virtual_network(*args, **kwargs)

    # end set_virtual_network

    def add_virtual_network(self, *args, **kwargs):
        """Add virtual-network to port-tuple.
        
        :param ref_obj: VirtualNetwork object
        
        """
        if 'virtual_network_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('virtual_network_refs')
            self._original_virtual_network_refs = copy.deepcopy(self.get_virtual_network_refs() or [])
        super(PortTuple, self).add_virtual_network(*args, **kwargs)
    # end add_virtual_network

    def del_virtual_network(self, *args, **kwargs):
        if 'virtual_network_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('virtual_network_refs')
            self._original_virtual_network_refs = copy.deepcopy(self.get_virtual_network_refs() or [])
        super(PortTuple, self).del_virtual_network(*args, **kwargs)
    # end del_virtual_network

    def set_virtual_network_list(self, *args, **kwargs):
        """Set virtual-network list for port-tuple.
        
        :param ref_obj_list: list of VirtualNetwork object
        
        """
        self._pending_field_updates.add('virtual_network_refs')
        self._pending_ref_updates.discard('virtual_network_refs')
        super(PortTuple, self).set_virtual_network_list(*args, **kwargs)
    # end set_virtual_network_list

    def set_tag(self, *args, **kwargs):
        """Set tag for port-tuple.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(PortTuple, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to port-tuple.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(PortTuple, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(PortTuple, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for port-tuple.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(PortTuple, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


    def get_virtual_machine_interface_back_refs(self):
        """Return list of all virtual-machine-interfaces using this port-tuple"""
        if hasattr(self, 'virtual_machine_interface_back_refs'):
            return self.virtual_machine_interface_back_refs

        if hasattr(super(PortTuple, self), 'virtual_machine_interface_back_refs'):
            return super(PortTuple, self).get_virtual_machine_interface_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.port_tuple_read(id = self.uuid, fields = ['virtual_machine_interface_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'virtual_machine_interface_back_refs', None)
        if not back_refs:
            return None
        self.virtual_machine_interface_back_refs = back_refs

        return back_refs
    # end get_virtual_machine_interface_back_refs

# end class PortTuple

class AnalyticsAlarmNode(vnc_api.gen.resource_common.AnalyticsAlarmNode):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'analytics_alarm_node_ip_address' in kwargs:
            pending_fields.append('analytics_alarm_node_ip_address')
        if len(args) > 1 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 2 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 3 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 4 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(AnalyticsAlarmNode, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            props_dict['analytics_alarm_node_ip_address'] = kwargs[u'analytics_alarm_node_ip_address']
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = AnalyticsAlarmNode(**props_dict)
        else:
            obj = AnalyticsAlarmNode(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.AnalyticsAlarmNode.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.AnalyticsAlarmNode.analytics_alarm_node_ip_address.setter
    def analytics_alarm_node_ip_address(self, analytics_alarm_node_ip_address):
        """Set analytics-alarm-node-ip-address for analytics-alarm-node.
        
        :param analytics_alarm_node_ip_address: IpAddressType object
        
        """
        if 'analytics_alarm_node_ip_address' not in self._pending_field_updates:
            self._pending_field_updates.add('analytics_alarm_node_ip_address')

        self._analytics_alarm_node_ip_address = analytics_alarm_node_ip_address
    # end analytics_alarm_node_ip_address

    def set_analytics_alarm_node_ip_address(self, value):
        self.analytics_alarm_node_ip_address = value
    # end set_analytics_alarm_node_ip_address

    @vnc_api.gen.resource_common.AnalyticsAlarmNode.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for analytics-alarm-node.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.AnalyticsAlarmNode.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for analytics-alarm-node.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.AnalyticsAlarmNode.annotations.setter
    def annotations(self, annotations):
        """Set annotations for analytics-alarm-node.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.AnalyticsAlarmNode.display_name.setter
    def display_name(self, display_name):
        """Set display-name for analytics-alarm-node.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for analytics-alarm-node.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for analytics-alarm-node.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_tag(self, *args, **kwargs):
        """Set tag for analytics-alarm-node.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(AnalyticsAlarmNode, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to analytics-alarm-node.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(AnalyticsAlarmNode, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(AnalyticsAlarmNode, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for analytics-alarm-node.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(AnalyticsAlarmNode, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


# end class AnalyticsAlarmNode

class QosQueue(vnc_api.gen.resource_common.QosQueue):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'min_bandwidth' in kwargs:
            pending_fields.append('min_bandwidth')
        if len(args) > 1 or 'max_bandwidth' in kwargs:
            pending_fields.append('max_bandwidth')
        if len(args) > 2 or 'qos_queue_identifier' in kwargs:
            pending_fields.append('qos_queue_identifier')
        if len(args) > 3 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 4 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 5 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 6 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(QosQueue, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            props_dict['min_bandwidth'] = kwargs[u'min_bandwidth']
        except KeyError:
            pass

        try:
            props_dict['max_bandwidth'] = kwargs[u'max_bandwidth']
        except KeyError:
            pass

        try:
            props_dict['qos_queue_identifier'] = kwargs[u'qos_queue_identifier']
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = QosQueue(**props_dict)
        else:
            obj = QosQueue(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.forwarding_class_back_refs = kwargs[u'forwarding_class_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.QosQueue.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.QosQueue.min_bandwidth.setter
    def min_bandwidth(self, min_bandwidth):
        """Set min-bandwidth for qos-queue.
        
        :param min_bandwidth: xsd:integer object
        
        """
        if 'min_bandwidth' not in self._pending_field_updates:
            self._pending_field_updates.add('min_bandwidth')

        self._min_bandwidth = min_bandwidth
    # end min_bandwidth

    def set_min_bandwidth(self, value):
        self.min_bandwidth = value
    # end set_min_bandwidth

    @vnc_api.gen.resource_common.QosQueue.max_bandwidth.setter
    def max_bandwidth(self, max_bandwidth):
        """Set max-bandwidth for qos-queue.
        
        :param max_bandwidth: xsd:integer object
        
        """
        if 'max_bandwidth' not in self._pending_field_updates:
            self._pending_field_updates.add('max_bandwidth')

        self._max_bandwidth = max_bandwidth
    # end max_bandwidth

    def set_max_bandwidth(self, value):
        self.max_bandwidth = value
    # end set_max_bandwidth

    @vnc_api.gen.resource_common.QosQueue.qos_queue_identifier.setter
    def qos_queue_identifier(self, qos_queue_identifier):
        """Set qos-queue-identifier for qos-queue.
        
        :param qos_queue_identifier: xsd:integer object
        
        """
        if 'qos_queue_identifier' not in self._pending_field_updates:
            self._pending_field_updates.add('qos_queue_identifier')

        self._qos_queue_identifier = qos_queue_identifier
    # end qos_queue_identifier

    def set_qos_queue_identifier(self, value):
        self.qos_queue_identifier = value
    # end set_qos_queue_identifier

    @vnc_api.gen.resource_common.QosQueue.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for qos-queue.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.QosQueue.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for qos-queue.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.QosQueue.annotations.setter
    def annotations(self, annotations):
        """Set annotations for qos-queue.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.QosQueue.display_name.setter
    def display_name(self, display_name):
        """Set display-name for qos-queue.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for qos-queue.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for qos-queue.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_tag(self, *args, **kwargs):
        """Set tag for qos-queue.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(QosQueue, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to qos-queue.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(QosQueue, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(QosQueue, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for qos-queue.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(QosQueue, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


    def get_forwarding_class_back_refs(self):
        """Return list of all forwarding-classs using this qos-queue"""
        if hasattr(self, 'forwarding_class_back_refs'):
            return self.forwarding_class_back_refs

        if hasattr(super(QosQueue, self), 'forwarding_class_back_refs'):
            return super(QosQueue, self).get_forwarding_class_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.qos_queue_read(id = self.uuid, fields = ['forwarding_class_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'forwarding_class_back_refs', None)
        if not back_refs:
            return None
        self.forwarding_class_back_refs = back_refs

        return back_refs
    # end get_forwarding_class_back_refs

# end class QosQueue

class PhysicalRole(vnc_api.gen.resource_common.PhysicalRole):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 1 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 2 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 3 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(PhysicalRole, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = PhysicalRole(**props_dict)
        else:
            obj = PhysicalRole(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.device_functional_group_back_refs = kwargs[u'device_functional_group_back_refs']
        except KeyError:
            pass
        try:
            obj.physical_router_back_refs = kwargs[u'physical_router_back_refs']
        except KeyError:
            pass
        try:
            obj.role_definition_back_refs = kwargs[u'role_definition_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.PhysicalRole.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.PhysicalRole.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for physical-role.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.PhysicalRole.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for physical-role.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.PhysicalRole.annotations.setter
    def annotations(self, annotations):
        """Set annotations for physical-role.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.PhysicalRole.display_name.setter
    def display_name(self, display_name):
        """Set display-name for physical-role.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for physical-role.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for physical-role.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_tag(self, *args, **kwargs):
        """Set tag for physical-role.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(PhysicalRole, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to physical-role.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(PhysicalRole, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(PhysicalRole, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for physical-role.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(PhysicalRole, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


    def get_device_functional_group_back_refs(self):
        """Return list of all device-functional-groups using this physical-role"""
        if hasattr(self, 'device_functional_group_back_refs'):
            return self.device_functional_group_back_refs

        if hasattr(super(PhysicalRole, self), 'device_functional_group_back_refs'):
            return super(PhysicalRole, self).get_device_functional_group_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.physical_role_read(id = self.uuid, fields = ['device_functional_group_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'device_functional_group_back_refs', None)
        if not back_refs:
            return None
        self.device_functional_group_back_refs = back_refs

        return back_refs
    # end get_device_functional_group_back_refs

    def get_physical_router_back_refs(self):
        """Return list of all physical-routers using this physical-role"""
        if hasattr(self, 'physical_router_back_refs'):
            return self.physical_router_back_refs

        if hasattr(super(PhysicalRole, self), 'physical_router_back_refs'):
            return super(PhysicalRole, self).get_physical_router_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.physical_role_read(id = self.uuid, fields = ['physical_router_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'physical_router_back_refs', None)
        if not back_refs:
            return None
        self.physical_router_back_refs = back_refs

        return back_refs
    # end get_physical_router_back_refs

    def get_role_definition_back_refs(self):
        """Return list of all role-definitions using this physical-role"""
        if hasattr(self, 'role_definition_back_refs'):
            return self.role_definition_back_refs

        if hasattr(super(PhysicalRole, self), 'role_definition_back_refs'):
            return super(PhysicalRole, self).get_role_definition_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.physical_role_read(id = self.uuid, fields = ['role_definition_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'role_definition_back_refs', None)
        if not back_refs:
            return None
        self.role_definition_back_refs = back_refs

        return back_refs
    # end get_role_definition_back_refs

# end class PhysicalRole

class Card(vnc_api.gen.resource_common.Card):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, *args, **kwargs):
        pending_fields = ['fq_name']

        self._server_conn = None

        if len(args) > 0 or 'interface_map' in kwargs:
            pending_fields.append('interface_map')
        if len(args) > 1 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 2 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 3 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 4 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(Card, self).__init__(name, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            if kwargs['interface_map'] is None:
                props_dict['interface_map'] = None
            else:
                props_dict['interface_map'] = vnc_api.gen.resource_xsd.InterfaceMapType(params_dict=kwargs[u'interface_map'])
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = Card(**props_dict)
        else:
            obj = Card(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.hardware_back_refs = kwargs[u'hardware_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.Card.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.Card.interface_map.setter
    def interface_map(self, interface_map):
        """Set interface-map for card.
        
        :param interface_map: InterfaceMapType object
        
        """
        if 'interface_map' not in self._pending_field_updates:
            self._pending_field_updates.add('interface_map')

        self._interface_map = interface_map
    # end interface_map

    def set_interface_map(self, value):
        self.interface_map = value
    # end set_interface_map

    @vnc_api.gen.resource_common.Card.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for card.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.Card.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for card.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.Card.annotations.setter
    def annotations(self, annotations):
        """Set annotations for card.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.Card.display_name.setter
    def display_name(self, display_name):
        """Set display-name for card.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for card.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for card.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_tag(self, *args, **kwargs):
        """Set tag for card.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(Card, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to card.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(Card, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(Card, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for card.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(Card, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


    def get_hardware_back_refs(self):
        """Return list of all hardwares using this card"""
        if hasattr(self, 'hardware_back_refs'):
            return self.hardware_back_refs

        if hasattr(super(Card, self), 'hardware_back_refs'):
            return super(Card, self).get_hardware_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.card_read(id = self.uuid, fields = ['hardware_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'hardware_back_refs', None)
        if not back_refs:
            return None
        self.hardware_back_refs = back_refs

        return back_refs
    # end get_hardware_back_refs

# end class Card

class SecurityLoggingObject(vnc_api.gen.resource_common.SecurityLoggingObject):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'security_logging_object_rules' in kwargs:
            pending_fields.append('security_logging_object_rules')
        if len(args) > 1 or 'security_logging_object_rate' in kwargs:
            pending_fields.append('security_logging_object_rate')
        if len(args) > 2 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 3 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 4 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 5 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(SecurityLoggingObject, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            if kwargs['security_logging_object_rules'] is None:
                props_dict['security_logging_object_rules'] = None
            else:
                props_dict['security_logging_object_rules'] = vnc_api.gen.resource_xsd.SecurityLoggingObjectRuleListType(params_dict=kwargs[u'security_logging_object_rules'])
        except KeyError:
            pass

        try:
            props_dict['security_logging_object_rate'] = kwargs[u'security_logging_object_rate']
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = SecurityLoggingObject(**props_dict)
        else:
            obj = SecurityLoggingObject(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.network_policy_refs = kwargs[u'network_policy_refs']
            for ref in obj.network_policy_refs:
                ref['attr'] = vnc_api.gen.resource_xsd.SecurityLoggingObjectRuleListType(params_dict=ref[u'attr'])
        except KeyError:
            pass
        try:
            obj.security_group_refs = kwargs[u'security_group_refs']
            for ref in obj.security_group_refs:
                ref['attr'] = vnc_api.gen.resource_xsd.SecurityLoggingObjectRuleListType(params_dict=ref[u'attr'])
        except KeyError:
            pass
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.virtual_network_back_refs = kwargs[u'virtual_network_back_refs']
        except KeyError:
            pass
        try:
            obj.virtual_machine_interface_back_refs = kwargs[u'virtual_machine_interface_back_refs']
        except KeyError:
            pass
        try:
            obj.firewall_policy_back_refs = kwargs[u'firewall_policy_back_refs']
        except KeyError:
            pass
        try:
            obj.firewall_rule_back_refs = kwargs[u'firewall_rule_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.SecurityLoggingObject.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.SecurityLoggingObject.security_logging_object_rules.setter
    def security_logging_object_rules(self, security_logging_object_rules):
        """Set security-logging-object-rules for security-logging-object.
        
        :param security_logging_object_rules: SecurityLoggingObjectRuleListType object
        
        """
        if 'security_logging_object_rules' not in self._pending_field_updates:
            self._pending_field_updates.add('security_logging_object_rules')

        self._security_logging_object_rules = security_logging_object_rules
    # end security_logging_object_rules

    def set_security_logging_object_rules(self, value):
        self.security_logging_object_rules = value
    # end set_security_logging_object_rules

    @vnc_api.gen.resource_common.SecurityLoggingObject.security_logging_object_rate.setter
    def security_logging_object_rate(self, security_logging_object_rate):
        """Set security-logging-object-rate for security-logging-object.
        
        :param security_logging_object_rate: xsd:integer object
        
        """
        if 'security_logging_object_rate' not in self._pending_field_updates:
            self._pending_field_updates.add('security_logging_object_rate')

        self._security_logging_object_rate = security_logging_object_rate
    # end security_logging_object_rate

    def set_security_logging_object_rate(self, value):
        self.security_logging_object_rate = value
    # end set_security_logging_object_rate

    @vnc_api.gen.resource_common.SecurityLoggingObject.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for security-logging-object.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.SecurityLoggingObject.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for security-logging-object.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.SecurityLoggingObject.annotations.setter
    def annotations(self, annotations):
        """Set annotations for security-logging-object.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.SecurityLoggingObject.display_name.setter
    def display_name(self, display_name):
        """Set display-name for security-logging-object.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for security-logging-object.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for security-logging-object.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_network_policy(self, *args, **kwargs):
        """Set network-policy for security-logging-object.
        
        :param ref_obj: NetworkPolicy object
        :param ref_data: SecurityLoggingObjectRuleListType object
        
        """
        self._pending_field_updates.add('network_policy_refs')
        self._pending_ref_updates.discard('network_policy_refs')
        super(SecurityLoggingObject, self).set_network_policy(*args, **kwargs)

    # end set_network_policy

    def add_network_policy(self, *args, **kwargs):
        """Add network-policy to security-logging-object.
        
        :param ref_obj: NetworkPolicy object
        :param ref_data: SecurityLoggingObjectRuleListType object
        
        """
        if 'network_policy_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('network_policy_refs')
            self._original_network_policy_refs = copy.deepcopy(self.get_network_policy_refs() or [])
        super(SecurityLoggingObject, self).add_network_policy(*args, **kwargs)
    # end add_network_policy

    def del_network_policy(self, *args, **kwargs):
        if 'network_policy_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('network_policy_refs')
            self._original_network_policy_refs = copy.deepcopy(self.get_network_policy_refs() or [])
        super(SecurityLoggingObject, self).del_network_policy(*args, **kwargs)
    # end del_network_policy

    def set_network_policy_list(self, *args, **kwargs):
        """Set network-policy list for security-logging-object.
        
        :param ref_obj_list: list of NetworkPolicy object
        :param ref_data_list: list of SecurityLoggingObjectRuleListType summary
        
        """
        self._pending_field_updates.add('network_policy_refs')
        self._pending_ref_updates.discard('network_policy_refs')
        super(SecurityLoggingObject, self).set_network_policy_list(*args, **kwargs)
    # end set_network_policy_list

    def set_security_group(self, *args, **kwargs):
        """Set security-group for security-logging-object.
        
        :param ref_obj: SecurityGroup object
        :param ref_data: SecurityLoggingObjectRuleListType object
        
        """
        self._pending_field_updates.add('security_group_refs')
        self._pending_ref_updates.discard('security_group_refs')
        super(SecurityLoggingObject, self).set_security_group(*args, **kwargs)

    # end set_security_group

    def add_security_group(self, *args, **kwargs):
        """Add security-group to security-logging-object.
        
        :param ref_obj: SecurityGroup object
        :param ref_data: SecurityLoggingObjectRuleListType object
        
        """
        if 'security_group_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('security_group_refs')
            self._original_security_group_refs = copy.deepcopy(self.get_security_group_refs() or [])
        super(SecurityLoggingObject, self).add_security_group(*args, **kwargs)
    # end add_security_group

    def del_security_group(self, *args, **kwargs):
        if 'security_group_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('security_group_refs')
            self._original_security_group_refs = copy.deepcopy(self.get_security_group_refs() or [])
        super(SecurityLoggingObject, self).del_security_group(*args, **kwargs)
    # end del_security_group

    def set_security_group_list(self, *args, **kwargs):
        """Set security-group list for security-logging-object.
        
        :param ref_obj_list: list of SecurityGroup object
        :param ref_data_list: list of SecurityLoggingObjectRuleListType summary
        
        """
        self._pending_field_updates.add('security_group_refs')
        self._pending_ref_updates.discard('security_group_refs')
        super(SecurityLoggingObject, self).set_security_group_list(*args, **kwargs)
    # end set_security_group_list

    def set_tag(self, *args, **kwargs):
        """Set tag for security-logging-object.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(SecurityLoggingObject, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to security-logging-object.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(SecurityLoggingObject, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(SecurityLoggingObject, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for security-logging-object.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(SecurityLoggingObject, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


    def get_virtual_network_back_refs(self):
        """Return list of all virtual-networks using this security-logging-object"""
        if hasattr(self, 'virtual_network_back_refs'):
            return self.virtual_network_back_refs

        if hasattr(super(SecurityLoggingObject, self), 'virtual_network_back_refs'):
            return super(SecurityLoggingObject, self).get_virtual_network_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.security_logging_object_read(id = self.uuid, fields = ['virtual_network_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'virtual_network_back_refs', None)
        if not back_refs:
            return None
        self.virtual_network_back_refs = back_refs

        return back_refs
    # end get_virtual_network_back_refs

    def get_virtual_machine_interface_back_refs(self):
        """Return list of all virtual-machine-interfaces using this security-logging-object"""
        if hasattr(self, 'virtual_machine_interface_back_refs'):
            return self.virtual_machine_interface_back_refs

        if hasattr(super(SecurityLoggingObject, self), 'virtual_machine_interface_back_refs'):
            return super(SecurityLoggingObject, self).get_virtual_machine_interface_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.security_logging_object_read(id = self.uuid, fields = ['virtual_machine_interface_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'virtual_machine_interface_back_refs', None)
        if not back_refs:
            return None
        self.virtual_machine_interface_back_refs = back_refs

        return back_refs
    # end get_virtual_machine_interface_back_refs

    def get_firewall_policy_back_refs(self):
        """Return list of all firewall-policys using this security-logging-object"""
        if hasattr(self, 'firewall_policy_back_refs'):
            return self.firewall_policy_back_refs

        if hasattr(super(SecurityLoggingObject, self), 'firewall_policy_back_refs'):
            return super(SecurityLoggingObject, self).get_firewall_policy_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.security_logging_object_read(id = self.uuid, fields = ['firewall_policy_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'firewall_policy_back_refs', None)
        if not back_refs:
            return None
        self.firewall_policy_back_refs = back_refs

        return back_refs
    # end get_firewall_policy_back_refs

    def get_firewall_rule_back_refs(self):
        """Return list of all firewall-rules using this security-logging-object"""
        if hasattr(self, 'firewall_rule_back_refs'):
            return self.firewall_rule_back_refs

        if hasattr(super(SecurityLoggingObject, self), 'firewall_rule_back_refs'):
            return super(SecurityLoggingObject, self).get_firewall_rule_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.security_logging_object_read(id = self.uuid, fields = ['firewall_rule_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'firewall_rule_back_refs', None)
        if not back_refs:
            return None
        self.firewall_rule_back_refs = back_refs

        return back_refs
    # end get_firewall_rule_back_refs

# end class SecurityLoggingObject

class QosConfig(vnc_api.gen.resource_common.QosConfig):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'qos_config_type' in kwargs:
            pending_fields.append('qos_config_type')
        if len(args) > 1 or 'dscp_entries' in kwargs:
            pending_fields.append('dscp_entries')
        if len(args) > 2 or 'vlan_priority_entries' in kwargs:
            pending_fields.append('vlan_priority_entries')
        if len(args) > 3 or 'mpls_exp_entries' in kwargs:
            pending_fields.append('mpls_exp_entries')
        if len(args) > 4 or 'default_forwarding_class_id' in kwargs:
            pending_fields.append('default_forwarding_class_id')
        if len(args) > 5 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 6 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 7 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 8 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(QosConfig, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            props_dict['qos_config_type'] = kwargs[u'qos_config_type']
        except KeyError:
            pass

        try:
            if kwargs['dscp_entries'] is None:
                props_dict['dscp_entries'] = None
            else:
                props_dict['dscp_entries'] = vnc_api.gen.resource_xsd.QosIdForwardingClassPairs(params_dict=kwargs[u'dscp_entries'])
        except KeyError:
            pass

        try:
            if kwargs['vlan_priority_entries'] is None:
                props_dict['vlan_priority_entries'] = None
            else:
                props_dict['vlan_priority_entries'] = vnc_api.gen.resource_xsd.QosIdForwardingClassPairs(params_dict=kwargs[u'vlan_priority_entries'])
        except KeyError:
            pass

        try:
            if kwargs['mpls_exp_entries'] is None:
                props_dict['mpls_exp_entries'] = None
            else:
                props_dict['mpls_exp_entries'] = vnc_api.gen.resource_xsd.QosIdForwardingClassPairs(params_dict=kwargs[u'mpls_exp_entries'])
        except KeyError:
            pass

        try:
            props_dict['default_forwarding_class_id'] = kwargs[u'default_forwarding_class_id']
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = QosConfig(**props_dict)
        else:
            obj = QosConfig(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.global_system_config_refs = kwargs[u'global_system_config_refs']
        except KeyError:
            pass
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.virtual_network_back_refs = kwargs[u'virtual_network_back_refs']
        except KeyError:
            pass
        try:
            obj.virtual_machine_interface_back_refs = kwargs[u'virtual_machine_interface_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.QosConfig.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.QosConfig.qos_config_type.setter
    def qos_config_type(self, qos_config_type):
        """Set qos-config-type for qos-config.
        
        :param qos_config_type: QosConfigType object
        
        """
        if 'qos_config_type' not in self._pending_field_updates:
            self._pending_field_updates.add('qos_config_type')

        self._qos_config_type = qos_config_type
    # end qos_config_type

    def set_qos_config_type(self, value):
        self.qos_config_type = value
    # end set_qos_config_type

    @vnc_api.gen.resource_common.QosConfig.dscp_entries.setter
    def dscp_entries(self, dscp_entries):
        """Set dscp-entries for qos-config.
        
        :param dscp_entries: QosIdForwardingClassPairs object
        
        """
        if 'dscp_entries' not in self._pending_field_updates:
            self._pending_field_updates.add('dscp_entries')

        if 'dscp_entries' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['dscp_entries']

        self._dscp_entries = dscp_entries
    # end dscp_entries

    def set_dscp_entries(self, value):
        self.dscp_entries = value
    # end set_dscp_entries

    @vnc_api.gen.resource_common.QosConfig.vlan_priority_entries.setter
    def vlan_priority_entries(self, vlan_priority_entries):
        """Set vlan-priority-entries for qos-config.
        
        :param vlan_priority_entries: QosIdForwardingClassPairs object
        
        """
        if 'vlan_priority_entries' not in self._pending_field_updates:
            self._pending_field_updates.add('vlan_priority_entries')

        if 'vlan_priority_entries' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['vlan_priority_entries']

        self._vlan_priority_entries = vlan_priority_entries
    # end vlan_priority_entries

    def set_vlan_priority_entries(self, value):
        self.vlan_priority_entries = value
    # end set_vlan_priority_entries

    @vnc_api.gen.resource_common.QosConfig.mpls_exp_entries.setter
    def mpls_exp_entries(self, mpls_exp_entries):
        """Set mpls-exp-entries for qos-config.
        
        :param mpls_exp_entries: QosIdForwardingClassPairs object
        
        """
        if 'mpls_exp_entries' not in self._pending_field_updates:
            self._pending_field_updates.add('mpls_exp_entries')

        if 'mpls_exp_entries' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['mpls_exp_entries']

        self._mpls_exp_entries = mpls_exp_entries
    # end mpls_exp_entries

    def set_mpls_exp_entries(self, value):
        self.mpls_exp_entries = value
    # end set_mpls_exp_entries

    @vnc_api.gen.resource_common.QosConfig.default_forwarding_class_id.setter
    def default_forwarding_class_id(self, default_forwarding_class_id):
        """Set default-forwarding-class-id for qos-config.
        
        :param default_forwarding_class_id: ForwardingClassId object
        
        """
        if 'default_forwarding_class_id' not in self._pending_field_updates:
            self._pending_field_updates.add('default_forwarding_class_id')

        self._default_forwarding_class_id = default_forwarding_class_id
    # end default_forwarding_class_id

    def set_default_forwarding_class_id(self, value):
        self.default_forwarding_class_id = value
    # end set_default_forwarding_class_id

    @vnc_api.gen.resource_common.QosConfig.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for qos-config.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.QosConfig.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for qos-config.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.QosConfig.annotations.setter
    def annotations(self, annotations):
        """Set annotations for qos-config.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.QosConfig.display_name.setter
    def display_name(self, display_name):
        """Set display-name for qos-config.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_dscp_entries(self, elem):
        """Add element to dscp-entries for qos-config.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'dscp_entries' not in self._pending_field_map_updates:
            self._pending_field_map_updates['dscp_entries'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['dscp_entries'].append(
                ('set', elem, elem_position))
    # end set_dscp_entries

    def del_dscp_entries(self, elem_position):
        """Delete element from dscp-entries for qos-config.
        
        :param elem_position: string indicating map-key
        
        """
        if 'dscp_entries' not in self._pending_field_map_updates:
            self._pending_field_map_updates['dscp_entries'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['dscp_entries'].append(
                ('delete', None, elem_position))
    # end del_dscp_entries
    def add_vlan_priority_entries(self, elem):
        """Add element to vlan-priority-entries for qos-config.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'vlan_priority_entries' not in self._pending_field_map_updates:
            self._pending_field_map_updates['vlan_priority_entries'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['vlan_priority_entries'].append(
                ('set', elem, elem_position))
    # end set_vlan_priority_entries

    def del_vlan_priority_entries(self, elem_position):
        """Delete element from vlan-priority-entries for qos-config.
        
        :param elem_position: string indicating map-key
        
        """
        if 'vlan_priority_entries' not in self._pending_field_map_updates:
            self._pending_field_map_updates['vlan_priority_entries'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['vlan_priority_entries'].append(
                ('delete', None, elem_position))
    # end del_vlan_priority_entries
    def add_mpls_exp_entries(self, elem):
        """Add element to mpls-exp-entries for qos-config.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'mpls_exp_entries' not in self._pending_field_map_updates:
            self._pending_field_map_updates['mpls_exp_entries'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['mpls_exp_entries'].append(
                ('set', elem, elem_position))
    # end set_mpls_exp_entries

    def del_mpls_exp_entries(self, elem_position):
        """Delete element from mpls-exp-entries for qos-config.
        
        :param elem_position: string indicating map-key
        
        """
        if 'mpls_exp_entries' not in self._pending_field_map_updates:
            self._pending_field_map_updates['mpls_exp_entries'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['mpls_exp_entries'].append(
                ('delete', None, elem_position))
    # end del_mpls_exp_entries
    def add_annotations(self, elem):
        """Add element to annotations for qos-config.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for qos-config.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_global_system_config(self, *args, **kwargs):
        """Set global-system-config for qos-config.
        
        :param ref_obj: GlobalSystemConfig object
        
        """
        self._pending_field_updates.add('global_system_config_refs')
        self._pending_ref_updates.discard('global_system_config_refs')
        super(QosConfig, self).set_global_system_config(*args, **kwargs)

    # end set_global_system_config

    def add_global_system_config(self, *args, **kwargs):
        """Add global-system-config to qos-config.
        
        :param ref_obj: GlobalSystemConfig object
        
        """
        if 'global_system_config_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('global_system_config_refs')
            self._original_global_system_config_refs = copy.deepcopy(self.get_global_system_config_refs() or [])
        super(QosConfig, self).add_global_system_config(*args, **kwargs)
    # end add_global_system_config

    def del_global_system_config(self, *args, **kwargs):
        if 'global_system_config_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('global_system_config_refs')
            self._original_global_system_config_refs = copy.deepcopy(self.get_global_system_config_refs() or [])
        super(QosConfig, self).del_global_system_config(*args, **kwargs)
    # end del_global_system_config

    def set_global_system_config_list(self, *args, **kwargs):
        """Set global-system-config list for qos-config.
        
        :param ref_obj_list: list of GlobalSystemConfig object
        
        """
        self._pending_field_updates.add('global_system_config_refs')
        self._pending_ref_updates.discard('global_system_config_refs')
        super(QosConfig, self).set_global_system_config_list(*args, **kwargs)
    # end set_global_system_config_list

    def set_tag(self, *args, **kwargs):
        """Set tag for qos-config.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(QosConfig, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to qos-config.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(QosConfig, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(QosConfig, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for qos-config.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(QosConfig, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


    def get_virtual_network_back_refs(self):
        """Return list of all virtual-networks using this qos-config"""
        if hasattr(self, 'virtual_network_back_refs'):
            return self.virtual_network_back_refs

        if hasattr(super(QosConfig, self), 'virtual_network_back_refs'):
            return super(QosConfig, self).get_virtual_network_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.qos_config_read(id = self.uuid, fields = ['virtual_network_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'virtual_network_back_refs', None)
        if not back_refs:
            return None
        self.virtual_network_back_refs = back_refs

        return back_refs
    # end get_virtual_network_back_refs

    def get_virtual_machine_interface_back_refs(self):
        """Return list of all virtual-machine-interfaces using this qos-config"""
        if hasattr(self, 'virtual_machine_interface_back_refs'):
            return self.virtual_machine_interface_back_refs

        if hasattr(super(QosConfig, self), 'virtual_machine_interface_back_refs'):
            return super(QosConfig, self).get_virtual_machine_interface_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.qos_config_read(id = self.uuid, fields = ['virtual_machine_interface_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'virtual_machine_interface_back_refs', None)
        if not back_refs:
            return None
        self.virtual_machine_interface_back_refs = back_refs

        return back_refs
    # end get_virtual_machine_interface_back_refs

# end class QosConfig

class AnalyticsSnmpNode(vnc_api.gen.resource_common.AnalyticsSnmpNode):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'analytics_snmp_node_ip_address' in kwargs:
            pending_fields.append('analytics_snmp_node_ip_address')
        if len(args) > 1 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 2 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 3 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 4 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(AnalyticsSnmpNode, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            props_dict['analytics_snmp_node_ip_address'] = kwargs[u'analytics_snmp_node_ip_address']
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = AnalyticsSnmpNode(**props_dict)
        else:
            obj = AnalyticsSnmpNode(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.AnalyticsSnmpNode.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.AnalyticsSnmpNode.analytics_snmp_node_ip_address.setter
    def analytics_snmp_node_ip_address(self, analytics_snmp_node_ip_address):
        """Set analytics-snmp-node-ip-address for analytics-snmp-node.
        
        :param analytics_snmp_node_ip_address: IpAddressType object
        
        """
        if 'analytics_snmp_node_ip_address' not in self._pending_field_updates:
            self._pending_field_updates.add('analytics_snmp_node_ip_address')

        self._analytics_snmp_node_ip_address = analytics_snmp_node_ip_address
    # end analytics_snmp_node_ip_address

    def set_analytics_snmp_node_ip_address(self, value):
        self.analytics_snmp_node_ip_address = value
    # end set_analytics_snmp_node_ip_address

    @vnc_api.gen.resource_common.AnalyticsSnmpNode.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for analytics-snmp-node.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.AnalyticsSnmpNode.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for analytics-snmp-node.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.AnalyticsSnmpNode.annotations.setter
    def annotations(self, annotations):
        """Set annotations for analytics-snmp-node.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.AnalyticsSnmpNode.display_name.setter
    def display_name(self, display_name):
        """Set display-name for analytics-snmp-node.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for analytics-snmp-node.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for analytics-snmp-node.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_tag(self, *args, **kwargs):
        """Set tag for analytics-snmp-node.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(AnalyticsSnmpNode, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to analytics-snmp-node.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(AnalyticsSnmpNode, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(AnalyticsSnmpNode, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for analytics-snmp-node.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(AnalyticsSnmpNode, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


# end class AnalyticsSnmpNode

class VirtualMachineInterface(vnc_api.gen.resource_common.VirtualMachineInterface):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'ecmp_hashing_include_fields' in kwargs:
            pending_fields.append('ecmp_hashing_include_fields')
        if len(args) > 1 or 'port_security_enabled' in kwargs:
            pending_fields.append('port_security_enabled')
        if len(args) > 2 or 'virtual_machine_interface_mac_addresses' in kwargs:
            pending_fields.append('virtual_machine_interface_mac_addresses')
        if len(args) > 3 or 'virtual_machine_interface_dhcp_option_list' in kwargs:
            pending_fields.append('virtual_machine_interface_dhcp_option_list')
        if len(args) > 4 or 'virtual_machine_interface_host_routes' in kwargs:
            pending_fields.append('virtual_machine_interface_host_routes')
        if len(args) > 5 or 'virtual_machine_interface_allowed_address_pairs' in kwargs:
            pending_fields.append('virtual_machine_interface_allowed_address_pairs')
        if len(args) > 6 or 'vrf_assign_table' in kwargs:
            pending_fields.append('vrf_assign_table')
        if len(args) > 7 or 'virtual_machine_interface_device_owner' in kwargs:
            pending_fields.append('virtual_machine_interface_device_owner')
        if len(args) > 8 or 'virtual_machine_interface_disable_policy' in kwargs:
            pending_fields.append('virtual_machine_interface_disable_policy')
        if len(args) > 9 or 'virtual_machine_interface_properties' in kwargs:
            pending_fields.append('virtual_machine_interface_properties')
        if len(args) > 10 or 'virtual_machine_interface_bindings' in kwargs:
            pending_fields.append('virtual_machine_interface_bindings')
        if len(args) > 11 or 'virtual_machine_interface_fat_flow_protocols' in kwargs:
            pending_fields.append('virtual_machine_interface_fat_flow_protocols')
        if len(args) > 12 or 'vlan_tag_based_bridge_domain' in kwargs:
            pending_fields.append('vlan_tag_based_bridge_domain')
        if len(args) > 13 or 'igmp_enable' in kwargs:
            pending_fields.append('igmp_enable')
        if len(args) > 14 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 15 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 16 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 17 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(VirtualMachineInterface, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            if kwargs['ecmp_hashing_include_fields'] is None:
                props_dict['ecmp_hashing_include_fields'] = None
            else:
                props_dict['ecmp_hashing_include_fields'] = vnc_api.gen.resource_xsd.EcmpHashingIncludeFields(params_dict=kwargs[u'ecmp_hashing_include_fields'])
        except KeyError:
            pass

        try:
            props_dict['port_security_enabled'] = kwargs[u'port_security_enabled']
        except KeyError:
            pass

        try:
            if kwargs['virtual_machine_interface_mac_addresses'] is None:
                props_dict['virtual_machine_interface_mac_addresses'] = None
            else:
                props_dict['virtual_machine_interface_mac_addresses'] = vnc_api.gen.resource_xsd.MacAddressesType(params_dict=kwargs[u'virtual_machine_interface_mac_addresses'])
        except KeyError:
            pass

        try:
            if kwargs['virtual_machine_interface_dhcp_option_list'] is None:
                props_dict['virtual_machine_interface_dhcp_option_list'] = None
            else:
                props_dict['virtual_machine_interface_dhcp_option_list'] = vnc_api.gen.resource_xsd.DhcpOptionsListType(params_dict=kwargs[u'virtual_machine_interface_dhcp_option_list'])
        except KeyError:
            pass

        try:
            if kwargs['virtual_machine_interface_host_routes'] is None:
                props_dict['virtual_machine_interface_host_routes'] = None
            else:
                props_dict['virtual_machine_interface_host_routes'] = vnc_api.gen.resource_xsd.RouteTableType(params_dict=kwargs[u'virtual_machine_interface_host_routes'])
        except KeyError:
            pass

        try:
            if kwargs['virtual_machine_interface_allowed_address_pairs'] is None:
                props_dict['virtual_machine_interface_allowed_address_pairs'] = None
            else:
                props_dict['virtual_machine_interface_allowed_address_pairs'] = vnc_api.gen.resource_xsd.AllowedAddressPairs(params_dict=kwargs[u'virtual_machine_interface_allowed_address_pairs'])
        except KeyError:
            pass

        try:
            if kwargs['vrf_assign_table'] is None:
                props_dict['vrf_assign_table'] = None
            else:
                props_dict['vrf_assign_table'] = vnc_api.gen.resource_xsd.VrfAssignTableType(params_dict=kwargs[u'vrf_assign_table'])
        except KeyError:
            pass

        try:
            props_dict['virtual_machine_interface_device_owner'] = kwargs[u'virtual_machine_interface_device_owner']
        except KeyError:
            pass

        try:
            props_dict['virtual_machine_interface_disable_policy'] = kwargs[u'virtual_machine_interface_disable_policy']
        except KeyError:
            pass

        try:
            if kwargs['virtual_machine_interface_properties'] is None:
                props_dict['virtual_machine_interface_properties'] = None
            else:
                props_dict['virtual_machine_interface_properties'] = vnc_api.gen.resource_xsd.VirtualMachineInterfacePropertiesType(params_dict=kwargs[u'virtual_machine_interface_properties'])
        except KeyError:
            pass

        try:
            if kwargs['virtual_machine_interface_bindings'] is None:
                props_dict['virtual_machine_interface_bindings'] = None
            else:
                props_dict['virtual_machine_interface_bindings'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'virtual_machine_interface_bindings'])
        except KeyError:
            pass

        try:
            if kwargs['virtual_machine_interface_fat_flow_protocols'] is None:
                props_dict['virtual_machine_interface_fat_flow_protocols'] = None
            else:
                props_dict['virtual_machine_interface_fat_flow_protocols'] = vnc_api.gen.resource_xsd.FatFlowProtocols(params_dict=kwargs[u'virtual_machine_interface_fat_flow_protocols'])
        except KeyError:
            pass

        try:
            props_dict['vlan_tag_based_bridge_domain'] = kwargs[u'vlan_tag_based_bridge_domain']
        except KeyError:
            pass

        try:
            props_dict['igmp_enable'] = kwargs[u'igmp_enable']
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = VirtualMachineInterface(**props_dict)
        else:
            obj = VirtualMachineInterface(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.security_logging_object_refs = kwargs[u'security_logging_object_refs']
        except KeyError:
            pass
        try:
            obj.qos_config_refs = kwargs[u'qos_config_refs']
        except KeyError:
            pass
        try:
            obj.security_group_refs = kwargs[u'security_group_refs']
        except KeyError:
            pass
        try:
            obj.virtual_machine_interface_refs = kwargs[u'virtual_machine_interface_refs']
        except KeyError:
            pass
        try:
            obj.virtual_machine_refs = kwargs[u'virtual_machine_refs']
        except KeyError:
            pass
        try:
            obj.virtual_network_refs = kwargs[u'virtual_network_refs']
        except KeyError:
            pass
        try:
            obj.routing_instance_refs = kwargs[u'routing_instance_refs']
            for ref in obj.routing_instance_refs:
                ref['attr'] = vnc_api.gen.resource_xsd.PolicyBasedForwardingRuleType(params_dict=ref[u'attr'])
        except KeyError:
            pass
        try:
            obj.bgp_router_refs = kwargs[u'bgp_router_refs']
        except KeyError:
            pass
        try:
            obj.port_tuple_refs = kwargs[u'port_tuple_refs']
        except KeyError:
            pass
        try:
            obj.service_health_check_refs = kwargs[u'service_health_check_refs']
        except KeyError:
            pass
        try:
            obj.interface_route_table_refs = kwargs[u'interface_route_table_refs']
        except KeyError:
            pass
        try:
            obj.physical_interface_refs = kwargs[u'physical_interface_refs']
        except KeyError:
            pass
        try:
            obj.bridge_domain_refs = kwargs[u'bridge_domain_refs']
            for ref in obj.bridge_domain_refs:
                ref['attr'] = vnc_api.gen.resource_xsd.BridgeDomainMembershipType(params_dict=ref[u'attr'])
        except KeyError:
            pass
        try:
            obj.service_endpoint_refs = kwargs[u'service_endpoint_refs']
        except KeyError:
            pass
        try:
            obj.port_profile_refs = kwargs[u'port_profile_refs']
        except KeyError:
            pass
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.virtual_machine_interface_back_refs = kwargs[u'virtual_machine_interface_back_refs']
        except KeyError:
            pass
        try:
            obj.instance_ip_back_refs = kwargs[u'instance_ip_back_refs']
        except KeyError:
            pass
        try:
            obj.subnet_back_refs = kwargs[u'subnet_back_refs']
        except KeyError:
            pass
        try:
            obj.floating_ip_back_refs = kwargs[u'floating_ip_back_refs']
        except KeyError:
            pass
        try:
            obj.alias_ip_back_refs = kwargs[u'alias_ip_back_refs']
        except KeyError:
            pass
        try:
            obj.logical_interface_back_refs = kwargs[u'logical_interface_back_refs']
        except KeyError:
            pass
        try:
            obj.bgp_as_a_service_back_refs = kwargs[u'bgp_as_a_service_back_refs']
        except KeyError:
            pass
        try:
            obj.customer_attachment_back_refs = kwargs[u'customer_attachment_back_refs']
        except KeyError:
            pass
        try:
            obj.logical_router_back_refs = kwargs[u'logical_router_back_refs']
        except KeyError:
            pass
        try:
            obj.loadbalancer_pool_back_refs = kwargs[u'loadbalancer_pool_back_refs']
        except KeyError:
            pass
        try:
            obj.virtual_ip_back_refs = kwargs[u'virtual_ip_back_refs']
        except KeyError:
            pass
        try:
            obj.loadbalancer_back_refs = kwargs[u'loadbalancer_back_refs']
        except KeyError:
            pass
        try:
            obj.virtual_port_group_back_refs = kwargs[u'virtual_port_group_back_refs']
        except KeyError:
            pass
        try:
            obj.link_aggregation_group_back_refs = kwargs[u'link_aggregation_group_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.VirtualMachineInterface.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.VirtualMachineInterface.ecmp_hashing_include_fields.setter
    def ecmp_hashing_include_fields(self, ecmp_hashing_include_fields):
        """Set ecmp-hashing-include-fields for virtual-machine-interface.
        
        :param ecmp_hashing_include_fields: EcmpHashingIncludeFields object
        
        """
        if 'ecmp_hashing_include_fields' not in self._pending_field_updates:
            self._pending_field_updates.add('ecmp_hashing_include_fields')

        self._ecmp_hashing_include_fields = ecmp_hashing_include_fields
    # end ecmp_hashing_include_fields

    def set_ecmp_hashing_include_fields(self, value):
        self.ecmp_hashing_include_fields = value
    # end set_ecmp_hashing_include_fields

    @vnc_api.gen.resource_common.VirtualMachineInterface.port_security_enabled.setter
    def port_security_enabled(self, port_security_enabled):
        """Set port-security-enabled for virtual-machine-interface.
        
        :param port_security_enabled: xsd:boolean object
        
        """
        if 'port_security_enabled' not in self._pending_field_updates:
            self._pending_field_updates.add('port_security_enabled')

        self._port_security_enabled = port_security_enabled
    # end port_security_enabled

    def set_port_security_enabled(self, value):
        self.port_security_enabled = value
    # end set_port_security_enabled

    @vnc_api.gen.resource_common.VirtualMachineInterface.virtual_machine_interface_mac_addresses.setter
    def virtual_machine_interface_mac_addresses(self, virtual_machine_interface_mac_addresses):
        """Set virtual-machine-interface-mac-addresses for virtual-machine-interface.
        
        :param virtual_machine_interface_mac_addresses: MacAddressesType object
        
        """
        if 'virtual_machine_interface_mac_addresses' not in self._pending_field_updates:
            self._pending_field_updates.add('virtual_machine_interface_mac_addresses')

        self._virtual_machine_interface_mac_addresses = virtual_machine_interface_mac_addresses
    # end virtual_machine_interface_mac_addresses

    def set_virtual_machine_interface_mac_addresses(self, value):
        self.virtual_machine_interface_mac_addresses = value
    # end set_virtual_machine_interface_mac_addresses

    @vnc_api.gen.resource_common.VirtualMachineInterface.virtual_machine_interface_dhcp_option_list.setter
    def virtual_machine_interface_dhcp_option_list(self, virtual_machine_interface_dhcp_option_list):
        """Set virtual-machine-interface-dhcp-option-list for virtual-machine-interface.
        
        :param virtual_machine_interface_dhcp_option_list: DhcpOptionsListType object
        
        """
        if 'virtual_machine_interface_dhcp_option_list' not in self._pending_field_updates:
            self._pending_field_updates.add('virtual_machine_interface_dhcp_option_list')

        self._virtual_machine_interface_dhcp_option_list = virtual_machine_interface_dhcp_option_list
    # end virtual_machine_interface_dhcp_option_list

    def set_virtual_machine_interface_dhcp_option_list(self, value):
        self.virtual_machine_interface_dhcp_option_list = value
    # end set_virtual_machine_interface_dhcp_option_list

    @vnc_api.gen.resource_common.VirtualMachineInterface.virtual_machine_interface_host_routes.setter
    def virtual_machine_interface_host_routes(self, virtual_machine_interface_host_routes):
        """Set virtual-machine-interface-host-routes for virtual-machine-interface.
        
        :param virtual_machine_interface_host_routes: RouteTableType object
        
        """
        if 'virtual_machine_interface_host_routes' not in self._pending_field_updates:
            self._pending_field_updates.add('virtual_machine_interface_host_routes')

        self._virtual_machine_interface_host_routes = virtual_machine_interface_host_routes
    # end virtual_machine_interface_host_routes

    def set_virtual_machine_interface_host_routes(self, value):
        self.virtual_machine_interface_host_routes = value
    # end set_virtual_machine_interface_host_routes

    @vnc_api.gen.resource_common.VirtualMachineInterface.virtual_machine_interface_allowed_address_pairs.setter
    def virtual_machine_interface_allowed_address_pairs(self, virtual_machine_interface_allowed_address_pairs):
        """Set virtual-machine-interface-allowed-address-pairs for virtual-machine-interface.
        
        :param virtual_machine_interface_allowed_address_pairs: AllowedAddressPairs object
        
        """
        if 'virtual_machine_interface_allowed_address_pairs' not in self._pending_field_updates:
            self._pending_field_updates.add('virtual_machine_interface_allowed_address_pairs')

        self._virtual_machine_interface_allowed_address_pairs = virtual_machine_interface_allowed_address_pairs
    # end virtual_machine_interface_allowed_address_pairs

    def set_virtual_machine_interface_allowed_address_pairs(self, value):
        self.virtual_machine_interface_allowed_address_pairs = value
    # end set_virtual_machine_interface_allowed_address_pairs

    @vnc_api.gen.resource_common.VirtualMachineInterface.vrf_assign_table.setter
    def vrf_assign_table(self, vrf_assign_table):
        """Set vrf-assign-table for virtual-machine-interface.
        
        :param vrf_assign_table: VrfAssignTableType object
        
        """
        if 'vrf_assign_table' not in self._pending_field_updates:
            self._pending_field_updates.add('vrf_assign_table')

        self._vrf_assign_table = vrf_assign_table
    # end vrf_assign_table

    def set_vrf_assign_table(self, value):
        self.vrf_assign_table = value
    # end set_vrf_assign_table

    @vnc_api.gen.resource_common.VirtualMachineInterface.virtual_machine_interface_device_owner.setter
    def virtual_machine_interface_device_owner(self, virtual_machine_interface_device_owner):
        """Set virtual-machine-interface-device-owner for virtual-machine-interface.
        
        :param virtual_machine_interface_device_owner: xsd:string object
        
        """
        if 'virtual_machine_interface_device_owner' not in self._pending_field_updates:
            self._pending_field_updates.add('virtual_machine_interface_device_owner')

        self._virtual_machine_interface_device_owner = virtual_machine_interface_device_owner
    # end virtual_machine_interface_device_owner

    def set_virtual_machine_interface_device_owner(self, value):
        self.virtual_machine_interface_device_owner = value
    # end set_virtual_machine_interface_device_owner

    @vnc_api.gen.resource_common.VirtualMachineInterface.virtual_machine_interface_disable_policy.setter
    def virtual_machine_interface_disable_policy(self, virtual_machine_interface_disable_policy):
        """Set virtual-machine-interface-disable-policy for virtual-machine-interface.
        
        :param virtual_machine_interface_disable_policy: xsd:boolean object
        
        """
        if 'virtual_machine_interface_disable_policy' not in self._pending_field_updates:
            self._pending_field_updates.add('virtual_machine_interface_disable_policy')

        self._virtual_machine_interface_disable_policy = virtual_machine_interface_disable_policy
    # end virtual_machine_interface_disable_policy

    def set_virtual_machine_interface_disable_policy(self, value):
        self.virtual_machine_interface_disable_policy = value
    # end set_virtual_machine_interface_disable_policy

    @vnc_api.gen.resource_common.VirtualMachineInterface.virtual_machine_interface_properties.setter
    def virtual_machine_interface_properties(self, virtual_machine_interface_properties):
        """Set virtual-machine-interface-properties for virtual-machine-interface.
        
        :param virtual_machine_interface_properties: VirtualMachineInterfacePropertiesType object
        
        """
        if 'virtual_machine_interface_properties' not in self._pending_field_updates:
            self._pending_field_updates.add('virtual_machine_interface_properties')

        self._virtual_machine_interface_properties = virtual_machine_interface_properties
    # end virtual_machine_interface_properties

    def set_virtual_machine_interface_properties(self, value):
        self.virtual_machine_interface_properties = value
    # end set_virtual_machine_interface_properties

    @vnc_api.gen.resource_common.VirtualMachineInterface.virtual_machine_interface_bindings.setter
    def virtual_machine_interface_bindings(self, virtual_machine_interface_bindings):
        """Set virtual-machine-interface-bindings for virtual-machine-interface.
        
        :param virtual_machine_interface_bindings: KeyValuePairs object
        
        """
        if 'virtual_machine_interface_bindings' not in self._pending_field_updates:
            self._pending_field_updates.add('virtual_machine_interface_bindings')

        if 'virtual_machine_interface_bindings' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['virtual_machine_interface_bindings']

        self._virtual_machine_interface_bindings = virtual_machine_interface_bindings
    # end virtual_machine_interface_bindings

    def set_virtual_machine_interface_bindings(self, value):
        self.virtual_machine_interface_bindings = value
    # end set_virtual_machine_interface_bindings

    @vnc_api.gen.resource_common.VirtualMachineInterface.virtual_machine_interface_fat_flow_protocols.setter
    def virtual_machine_interface_fat_flow_protocols(self, virtual_machine_interface_fat_flow_protocols):
        """Set virtual-machine-interface-fat-flow-protocols for virtual-machine-interface.
        
        :param virtual_machine_interface_fat_flow_protocols: FatFlowProtocols object
        
        """
        if 'virtual_machine_interface_fat_flow_protocols' not in self._pending_field_updates:
            self._pending_field_updates.add('virtual_machine_interface_fat_flow_protocols')

        if 'virtual_machine_interface_fat_flow_protocols' in self._pending_field_list_updates:
            # set clobbers earlier add/del on prop list elements
            del self._pending_field_list_updates['virtual_machine_interface_fat_flow_protocols']

        self._virtual_machine_interface_fat_flow_protocols = virtual_machine_interface_fat_flow_protocols
    # end virtual_machine_interface_fat_flow_protocols

    def set_virtual_machine_interface_fat_flow_protocols(self, value):
        self.virtual_machine_interface_fat_flow_protocols = value
    # end set_virtual_machine_interface_fat_flow_protocols

    @vnc_api.gen.resource_common.VirtualMachineInterface.vlan_tag_based_bridge_domain.setter
    def vlan_tag_based_bridge_domain(self, vlan_tag_based_bridge_domain):
        """Set vlan-tag-based-bridge-domain for virtual-machine-interface.
        
        :param vlan_tag_based_bridge_domain: xsd:boolean object
        
        """
        if 'vlan_tag_based_bridge_domain' not in self._pending_field_updates:
            self._pending_field_updates.add('vlan_tag_based_bridge_domain')

        self._vlan_tag_based_bridge_domain = vlan_tag_based_bridge_domain
    # end vlan_tag_based_bridge_domain

    def set_vlan_tag_based_bridge_domain(self, value):
        self.vlan_tag_based_bridge_domain = value
    # end set_vlan_tag_based_bridge_domain

    @vnc_api.gen.resource_common.VirtualMachineInterface.igmp_enable.setter
    def igmp_enable(self, igmp_enable):
        """Set igmp-enable for virtual-machine-interface.
        
        :param igmp_enable: xsd:boolean object
        
        """
        if 'igmp_enable' not in self._pending_field_updates:
            self._pending_field_updates.add('igmp_enable')

        self._igmp_enable = igmp_enable
    # end igmp_enable

    def set_igmp_enable(self, value):
        self.igmp_enable = value
    # end set_igmp_enable

    @vnc_api.gen.resource_common.VirtualMachineInterface.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for virtual-machine-interface.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.VirtualMachineInterface.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for virtual-machine-interface.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.VirtualMachineInterface.annotations.setter
    def annotations(self, annotations):
        """Set annotations for virtual-machine-interface.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.VirtualMachineInterface.display_name.setter
    def display_name(self, display_name):
        """Set display-name for virtual-machine-interface.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_virtual_machine_interface_fat_flow_protocols(self, elem_value, elem_position=None):
        """Add element to virtual-machine-interface-fat-flow-protocols for virtual-machine-interface.
        
        :param elem_value: xsd:string object
        :param elem_position: optional string order-key
        
        """
        if 'virtual_machine_interface_fat_flow_protocols' not in self._pending_field_list_updates:
            self._pending_field_list_updates['virtual_machine_interface_fat_flow_protocols'] = [
                ('add', elem_value, elem_position)]
        else:
            self._pending_field_list_updates['virtual_machine_interface_fat_flow_protocols'].append(
                ('add', elem_value, elem_position))
    # end add_virtual_machine_interface_fat_flow_protocols

    def del_virtual_machine_interface_fat_flow_protocols(self, elem_position):
        """Delete element from virtual-machine-interface-fat-flow-protocols for virtual-machine-interface.
        
        :param elem_position: string indicating order-key
        
        """
        if 'virtual_machine_interface_fat_flow_protocols' not in self._pending_field_list_updates:
            self._pending_field_list_updates['virtual_machine_interface_fat_flow_protocols'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_list_updates['virtual_machine_interface_fat_flow_protocols'].append(
                ('delete', None, elem_position))
    # end del_virtual_machine_interface_fat_flow_protocols
    def add_virtual_machine_interface_bindings(self, elem):
        """Add element to virtual-machine-interface-bindings for virtual-machine-interface.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'virtual_machine_interface_bindings' not in self._pending_field_map_updates:
            self._pending_field_map_updates['virtual_machine_interface_bindings'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['virtual_machine_interface_bindings'].append(
                ('set', elem, elem_position))
    # end set_virtual_machine_interface_bindings

    def del_virtual_machine_interface_bindings(self, elem_position):
        """Delete element from virtual-machine-interface-bindings for virtual-machine-interface.
        
        :param elem_position: string indicating map-key
        
        """
        if 'virtual_machine_interface_bindings' not in self._pending_field_map_updates:
            self._pending_field_map_updates['virtual_machine_interface_bindings'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['virtual_machine_interface_bindings'].append(
                ('delete', None, elem_position))
    # end del_virtual_machine_interface_bindings
    def add_annotations(self, elem):
        """Add element to annotations for virtual-machine-interface.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for virtual-machine-interface.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_security_logging_object(self, *args, **kwargs):
        """Set security-logging-object for virtual-machine-interface.
        
        :param ref_obj: SecurityLoggingObject object
        
        """
        self._pending_field_updates.add('security_logging_object_refs')
        self._pending_ref_updates.discard('security_logging_object_refs')
        super(VirtualMachineInterface, self).set_security_logging_object(*args, **kwargs)

    # end set_security_logging_object

    def add_security_logging_object(self, *args, **kwargs):
        """Add security-logging-object to virtual-machine-interface.
        
        :param ref_obj: SecurityLoggingObject object
        
        """
        if 'security_logging_object_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('security_logging_object_refs')
            self._original_security_logging_object_refs = copy.deepcopy(self.get_security_logging_object_refs() or [])
        super(VirtualMachineInterface, self).add_security_logging_object(*args, **kwargs)
    # end add_security_logging_object

    def del_security_logging_object(self, *args, **kwargs):
        if 'security_logging_object_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('security_logging_object_refs')
            self._original_security_logging_object_refs = copy.deepcopy(self.get_security_logging_object_refs() or [])
        super(VirtualMachineInterface, self).del_security_logging_object(*args, **kwargs)
    # end del_security_logging_object

    def set_security_logging_object_list(self, *args, **kwargs):
        """Set security-logging-object list for virtual-machine-interface.
        
        :param ref_obj_list: list of SecurityLoggingObject object
        
        """
        self._pending_field_updates.add('security_logging_object_refs')
        self._pending_ref_updates.discard('security_logging_object_refs')
        super(VirtualMachineInterface, self).set_security_logging_object_list(*args, **kwargs)
    # end set_security_logging_object_list

    def set_qos_config(self, *args, **kwargs):
        """Set qos-config for virtual-machine-interface.
        
        :param ref_obj: QosConfig object
        
        """
        self._pending_field_updates.add('qos_config_refs')
        self._pending_ref_updates.discard('qos_config_refs')
        super(VirtualMachineInterface, self).set_qos_config(*args, **kwargs)

    # end set_qos_config

    def add_qos_config(self, *args, **kwargs):
        """Add qos-config to virtual-machine-interface.
        
        :param ref_obj: QosConfig object
        
        """
        if 'qos_config_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('qos_config_refs')
            self._original_qos_config_refs = copy.deepcopy(self.get_qos_config_refs() or [])
        super(VirtualMachineInterface, self).add_qos_config(*args, **kwargs)
    # end add_qos_config

    def del_qos_config(self, *args, **kwargs):
        if 'qos_config_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('qos_config_refs')
            self._original_qos_config_refs = copy.deepcopy(self.get_qos_config_refs() or [])
        super(VirtualMachineInterface, self).del_qos_config(*args, **kwargs)
    # end del_qos_config

    def set_qos_config_list(self, *args, **kwargs):
        """Set qos-config list for virtual-machine-interface.
        
        :param ref_obj_list: list of QosConfig object
        
        """
        self._pending_field_updates.add('qos_config_refs')
        self._pending_ref_updates.discard('qos_config_refs')
        super(VirtualMachineInterface, self).set_qos_config_list(*args, **kwargs)
    # end set_qos_config_list

    def set_security_group(self, *args, **kwargs):
        """Set security-group for virtual-machine-interface.
        
        :param ref_obj: SecurityGroup object
        
        """
        self._pending_field_updates.add('security_group_refs')
        self._pending_ref_updates.discard('security_group_refs')
        super(VirtualMachineInterface, self).set_security_group(*args, **kwargs)

    # end set_security_group

    def add_security_group(self, *args, **kwargs):
        """Add security-group to virtual-machine-interface.
        
        :param ref_obj: SecurityGroup object
        
        """
        if 'security_group_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('security_group_refs')
            self._original_security_group_refs = copy.deepcopy(self.get_security_group_refs() or [])
        super(VirtualMachineInterface, self).add_security_group(*args, **kwargs)
    # end add_security_group

    def del_security_group(self, *args, **kwargs):
        if 'security_group_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('security_group_refs')
            self._original_security_group_refs = copy.deepcopy(self.get_security_group_refs() or [])
        super(VirtualMachineInterface, self).del_security_group(*args, **kwargs)
    # end del_security_group

    def set_security_group_list(self, *args, **kwargs):
        """Set security-group list for virtual-machine-interface.
        
        :param ref_obj_list: list of SecurityGroup object
        
        """
        self._pending_field_updates.add('security_group_refs')
        self._pending_ref_updates.discard('security_group_refs')
        super(VirtualMachineInterface, self).set_security_group_list(*args, **kwargs)
    # end set_security_group_list

    def set_virtual_machine_interface(self, *args, **kwargs):
        """Set virtual-machine-interface for virtual-machine-interface.
        
        :param ref_obj: VirtualMachineInterface object
        
        """
        self._pending_field_updates.add('virtual_machine_interface_refs')
        self._pending_ref_updates.discard('virtual_machine_interface_refs')
        super(VirtualMachineInterface, self).set_virtual_machine_interface(*args, **kwargs)

    # end set_virtual_machine_interface

    def add_virtual_machine_interface(self, *args, **kwargs):
        """Add virtual-machine-interface to virtual-machine-interface.
        
        :param ref_obj: VirtualMachineInterface object
        
        """
        if 'virtual_machine_interface_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('virtual_machine_interface_refs')
            self._original_virtual_machine_interface_refs = copy.deepcopy(self.get_virtual_machine_interface_refs() or [])
        super(VirtualMachineInterface, self).add_virtual_machine_interface(*args, **kwargs)
    # end add_virtual_machine_interface

    def del_virtual_machine_interface(self, *args, **kwargs):
        if 'virtual_machine_interface_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('virtual_machine_interface_refs')
            self._original_virtual_machine_interface_refs = copy.deepcopy(self.get_virtual_machine_interface_refs() or [])
        super(VirtualMachineInterface, self).del_virtual_machine_interface(*args, **kwargs)
    # end del_virtual_machine_interface

    def set_virtual_machine_interface_list(self, *args, **kwargs):
        """Set virtual-machine-interface list for virtual-machine-interface.
        
        :param ref_obj_list: list of VirtualMachineInterface object
        
        """
        self._pending_field_updates.add('virtual_machine_interface_refs')
        self._pending_ref_updates.discard('virtual_machine_interface_refs')
        super(VirtualMachineInterface, self).set_virtual_machine_interface_list(*args, **kwargs)
    # end set_virtual_machine_interface_list

    def set_virtual_machine(self, *args, **kwargs):
        """Set virtual-machine for virtual-machine-interface.
        
        :param ref_obj: VirtualMachine object
        
        """
        self._pending_field_updates.add('virtual_machine_refs')
        self._pending_ref_updates.discard('virtual_machine_refs')
        super(VirtualMachineInterface, self).set_virtual_machine(*args, **kwargs)

    # end set_virtual_machine

    def add_virtual_machine(self, *args, **kwargs):
        """Add virtual-machine to virtual-machine-interface.
        
        :param ref_obj: VirtualMachine object
        
        """
        if 'virtual_machine_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('virtual_machine_refs')
            self._original_virtual_machine_refs = copy.deepcopy(self.get_virtual_machine_refs() or [])
        super(VirtualMachineInterface, self).add_virtual_machine(*args, **kwargs)
    # end add_virtual_machine

    def del_virtual_machine(self, *args, **kwargs):
        if 'virtual_machine_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('virtual_machine_refs')
            self._original_virtual_machine_refs = copy.deepcopy(self.get_virtual_machine_refs() or [])
        super(VirtualMachineInterface, self).del_virtual_machine(*args, **kwargs)
    # end del_virtual_machine

    def set_virtual_machine_list(self, *args, **kwargs):
        """Set virtual-machine list for virtual-machine-interface.
        
        :param ref_obj_list: list of VirtualMachine object
        
        """
        self._pending_field_updates.add('virtual_machine_refs')
        self._pending_ref_updates.discard('virtual_machine_refs')
        super(VirtualMachineInterface, self).set_virtual_machine_list(*args, **kwargs)
    # end set_virtual_machine_list

    def set_virtual_network(self, *args, **kwargs):
        """Set virtual-network for virtual-machine-interface.
        
        :param ref_obj: VirtualNetwork object
        
        """
        self._pending_field_updates.add('virtual_network_refs')
        self._pending_ref_updates.discard('virtual_network_refs')
        super(VirtualMachineInterface, self).set_virtual_network(*args, **kwargs)

    # end set_virtual_network

    def add_virtual_network(self, *args, **kwargs):
        """Add virtual-network to virtual-machine-interface.
        
        :param ref_obj: VirtualNetwork object
        
        """
        if 'virtual_network_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('virtual_network_refs')
            self._original_virtual_network_refs = copy.deepcopy(self.get_virtual_network_refs() or [])
        super(VirtualMachineInterface, self).add_virtual_network(*args, **kwargs)
    # end add_virtual_network

    def del_virtual_network(self, *args, **kwargs):
        if 'virtual_network_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('virtual_network_refs')
            self._original_virtual_network_refs = copy.deepcopy(self.get_virtual_network_refs() or [])
        super(VirtualMachineInterface, self).del_virtual_network(*args, **kwargs)
    # end del_virtual_network

    def set_virtual_network_list(self, *args, **kwargs):
        """Set virtual-network list for virtual-machine-interface.
        
        :param ref_obj_list: list of VirtualNetwork object
        
        """
        self._pending_field_updates.add('virtual_network_refs')
        self._pending_ref_updates.discard('virtual_network_refs')
        super(VirtualMachineInterface, self).set_virtual_network_list(*args, **kwargs)
    # end set_virtual_network_list

    def set_routing_instance(self, *args, **kwargs):
        """Set routing-instance for virtual-machine-interface.
        
        :param ref_obj: RoutingInstance object
        :param ref_data: PolicyBasedForwardingRuleType object
        
        """
        self._pending_field_updates.add('routing_instance_refs')
        self._pending_ref_updates.discard('routing_instance_refs')
        super(VirtualMachineInterface, self).set_routing_instance(*args, **kwargs)

    # end set_routing_instance

    def add_routing_instance(self, *args, **kwargs):
        """Add routing-instance to virtual-machine-interface.
        
        :param ref_obj: RoutingInstance object
        :param ref_data: PolicyBasedForwardingRuleType object
        
        """
        if 'routing_instance_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('routing_instance_refs')
            self._original_routing_instance_refs = copy.deepcopy(self.get_routing_instance_refs() or [])
        super(VirtualMachineInterface, self).add_routing_instance(*args, **kwargs)
    # end add_routing_instance

    def del_routing_instance(self, *args, **kwargs):
        if 'routing_instance_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('routing_instance_refs')
            self._original_routing_instance_refs = copy.deepcopy(self.get_routing_instance_refs() or [])
        super(VirtualMachineInterface, self).del_routing_instance(*args, **kwargs)
    # end del_routing_instance

    def set_routing_instance_list(self, *args, **kwargs):
        """Set routing-instance list for virtual-machine-interface.
        
        :param ref_obj_list: list of RoutingInstance object
        :param ref_data_list: list of PolicyBasedForwardingRuleType summary
        
        """
        self._pending_field_updates.add('routing_instance_refs')
        self._pending_ref_updates.discard('routing_instance_refs')
        super(VirtualMachineInterface, self).set_routing_instance_list(*args, **kwargs)
    # end set_routing_instance_list

    def set_bgp_router(self, *args, **kwargs):
        """Set bgp-router for virtual-machine-interface.
        
        :param ref_obj: BgpRouter object
        
        """
        self._pending_field_updates.add('bgp_router_refs')
        self._pending_ref_updates.discard('bgp_router_refs')
        super(VirtualMachineInterface, self).set_bgp_router(*args, **kwargs)

    # end set_bgp_router

    def add_bgp_router(self, *args, **kwargs):
        """Add bgp-router to virtual-machine-interface.
        
        :param ref_obj: BgpRouter object
        
        """
        if 'bgp_router_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('bgp_router_refs')
            self._original_bgp_router_refs = copy.deepcopy(self.get_bgp_router_refs() or [])
        super(VirtualMachineInterface, self).add_bgp_router(*args, **kwargs)
    # end add_bgp_router

    def del_bgp_router(self, *args, **kwargs):
        if 'bgp_router_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('bgp_router_refs')
            self._original_bgp_router_refs = copy.deepcopy(self.get_bgp_router_refs() or [])
        super(VirtualMachineInterface, self).del_bgp_router(*args, **kwargs)
    # end del_bgp_router

    def set_bgp_router_list(self, *args, **kwargs):
        """Set bgp-router list for virtual-machine-interface.
        
        :param ref_obj_list: list of BgpRouter object
        
        """
        self._pending_field_updates.add('bgp_router_refs')
        self._pending_ref_updates.discard('bgp_router_refs')
        super(VirtualMachineInterface, self).set_bgp_router_list(*args, **kwargs)
    # end set_bgp_router_list

    def set_port_tuple(self, *args, **kwargs):
        """Set port-tuple for virtual-machine-interface.
        
        :param ref_obj: PortTuple object
        
        """
        self._pending_field_updates.add('port_tuple_refs')
        self._pending_ref_updates.discard('port_tuple_refs')
        super(VirtualMachineInterface, self).set_port_tuple(*args, **kwargs)

    # end set_port_tuple

    def add_port_tuple(self, *args, **kwargs):
        """Add port-tuple to virtual-machine-interface.
        
        :param ref_obj: PortTuple object
        
        """
        if 'port_tuple_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('port_tuple_refs')
            self._original_port_tuple_refs = copy.deepcopy(self.get_port_tuple_refs() or [])
        super(VirtualMachineInterface, self).add_port_tuple(*args, **kwargs)
    # end add_port_tuple

    def del_port_tuple(self, *args, **kwargs):
        if 'port_tuple_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('port_tuple_refs')
            self._original_port_tuple_refs = copy.deepcopy(self.get_port_tuple_refs() or [])
        super(VirtualMachineInterface, self).del_port_tuple(*args, **kwargs)
    # end del_port_tuple

    def set_port_tuple_list(self, *args, **kwargs):
        """Set port-tuple list for virtual-machine-interface.
        
        :param ref_obj_list: list of PortTuple object
        
        """
        self._pending_field_updates.add('port_tuple_refs')
        self._pending_ref_updates.discard('port_tuple_refs')
        super(VirtualMachineInterface, self).set_port_tuple_list(*args, **kwargs)
    # end set_port_tuple_list

    def set_service_health_check(self, *args, **kwargs):
        """Set service-health-check for virtual-machine-interface.
        
        :param ref_obj: ServiceHealthCheck object
        
        """
        self._pending_field_updates.add('service_health_check_refs')
        self._pending_ref_updates.discard('service_health_check_refs')
        super(VirtualMachineInterface, self).set_service_health_check(*args, **kwargs)

    # end set_service_health_check

    def add_service_health_check(self, *args, **kwargs):
        """Add service-health-check to virtual-machine-interface.
        
        :param ref_obj: ServiceHealthCheck object
        
        """
        if 'service_health_check_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('service_health_check_refs')
            self._original_service_health_check_refs = copy.deepcopy(self.get_service_health_check_refs() or [])
        super(VirtualMachineInterface, self).add_service_health_check(*args, **kwargs)
    # end add_service_health_check

    def del_service_health_check(self, *args, **kwargs):
        if 'service_health_check_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('service_health_check_refs')
            self._original_service_health_check_refs = copy.deepcopy(self.get_service_health_check_refs() or [])
        super(VirtualMachineInterface, self).del_service_health_check(*args, **kwargs)
    # end del_service_health_check

    def set_service_health_check_list(self, *args, **kwargs):
        """Set service-health-check list for virtual-machine-interface.
        
        :param ref_obj_list: list of ServiceHealthCheck object
        
        """
        self._pending_field_updates.add('service_health_check_refs')
        self._pending_ref_updates.discard('service_health_check_refs')
        super(VirtualMachineInterface, self).set_service_health_check_list(*args, **kwargs)
    # end set_service_health_check_list

    def set_interface_route_table(self, *args, **kwargs):
        """Set interface-route-table for virtual-machine-interface.
        
        :param ref_obj: InterfaceRouteTable object
        
        """
        self._pending_field_updates.add('interface_route_table_refs')
        self._pending_ref_updates.discard('interface_route_table_refs')
        super(VirtualMachineInterface, self).set_interface_route_table(*args, **kwargs)

    # end set_interface_route_table

    def add_interface_route_table(self, *args, **kwargs):
        """Add interface-route-table to virtual-machine-interface.
        
        :param ref_obj: InterfaceRouteTable object
        
        """
        if 'interface_route_table_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('interface_route_table_refs')
            self._original_interface_route_table_refs = copy.deepcopy(self.get_interface_route_table_refs() or [])
        super(VirtualMachineInterface, self).add_interface_route_table(*args, **kwargs)
    # end add_interface_route_table

    def del_interface_route_table(self, *args, **kwargs):
        if 'interface_route_table_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('interface_route_table_refs')
            self._original_interface_route_table_refs = copy.deepcopy(self.get_interface_route_table_refs() or [])
        super(VirtualMachineInterface, self).del_interface_route_table(*args, **kwargs)
    # end del_interface_route_table

    def set_interface_route_table_list(self, *args, **kwargs):
        """Set interface-route-table list for virtual-machine-interface.
        
        :param ref_obj_list: list of InterfaceRouteTable object
        
        """
        self._pending_field_updates.add('interface_route_table_refs')
        self._pending_ref_updates.discard('interface_route_table_refs')
        super(VirtualMachineInterface, self).set_interface_route_table_list(*args, **kwargs)
    # end set_interface_route_table_list

    def set_physical_interface(self, *args, **kwargs):
        """Set physical-interface for virtual-machine-interface.
        
        :param ref_obj: PhysicalInterface object
        
        """
        self._pending_field_updates.add('physical_interface_refs')
        self._pending_ref_updates.discard('physical_interface_refs')
        super(VirtualMachineInterface, self).set_physical_interface(*args, **kwargs)

    # end set_physical_interface

    def add_physical_interface(self, *args, **kwargs):
        """Add physical-interface to virtual-machine-interface.
        
        :param ref_obj: PhysicalInterface object
        
        """
        if 'physical_interface_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('physical_interface_refs')
            self._original_physical_interface_refs = copy.deepcopy(self.get_physical_interface_refs() or [])
        super(VirtualMachineInterface, self).add_physical_interface(*args, **kwargs)
    # end add_physical_interface

    def del_physical_interface(self, *args, **kwargs):
        if 'physical_interface_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('physical_interface_refs')
            self._original_physical_interface_refs = copy.deepcopy(self.get_physical_interface_refs() or [])
        super(VirtualMachineInterface, self).del_physical_interface(*args, **kwargs)
    # end del_physical_interface

    def set_physical_interface_list(self, *args, **kwargs):
        """Set physical-interface list for virtual-machine-interface.
        
        :param ref_obj_list: list of PhysicalInterface object
        
        """
        self._pending_field_updates.add('physical_interface_refs')
        self._pending_ref_updates.discard('physical_interface_refs')
        super(VirtualMachineInterface, self).set_physical_interface_list(*args, **kwargs)
    # end set_physical_interface_list

    def set_bridge_domain(self, *args, **kwargs):
        """Set bridge-domain for virtual-machine-interface.
        
        :param ref_obj: BridgeDomain object
        :param ref_data: BridgeDomainMembershipType object
        
        """
        self._pending_field_updates.add('bridge_domain_refs')
        self._pending_ref_updates.discard('bridge_domain_refs')
        super(VirtualMachineInterface, self).set_bridge_domain(*args, **kwargs)

    # end set_bridge_domain

    def add_bridge_domain(self, *args, **kwargs):
        """Add bridge-domain to virtual-machine-interface.
        
        :param ref_obj: BridgeDomain object
        :param ref_data: BridgeDomainMembershipType object
        
        """
        if 'bridge_domain_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('bridge_domain_refs')
            self._original_bridge_domain_refs = copy.deepcopy(self.get_bridge_domain_refs() or [])
        super(VirtualMachineInterface, self).add_bridge_domain(*args, **kwargs)
    # end add_bridge_domain

    def del_bridge_domain(self, *args, **kwargs):
        if 'bridge_domain_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('bridge_domain_refs')
            self._original_bridge_domain_refs = copy.deepcopy(self.get_bridge_domain_refs() or [])
        super(VirtualMachineInterface, self).del_bridge_domain(*args, **kwargs)
    # end del_bridge_domain

    def set_bridge_domain_list(self, *args, **kwargs):
        """Set bridge-domain list for virtual-machine-interface.
        
        :param ref_obj_list: list of BridgeDomain object
        :param ref_data_list: list of BridgeDomainMembershipType summary
        
        """
        self._pending_field_updates.add('bridge_domain_refs')
        self._pending_ref_updates.discard('bridge_domain_refs')
        super(VirtualMachineInterface, self).set_bridge_domain_list(*args, **kwargs)
    # end set_bridge_domain_list

    def set_service_endpoint(self, *args, **kwargs):
        """Set service-endpoint for virtual-machine-interface.
        
        :param ref_obj: ServiceEndpoint object
        
        """
        self._pending_field_updates.add('service_endpoint_refs')
        self._pending_ref_updates.discard('service_endpoint_refs')
        super(VirtualMachineInterface, self).set_service_endpoint(*args, **kwargs)

    # end set_service_endpoint

    def add_service_endpoint(self, *args, **kwargs):
        """Add service-endpoint to virtual-machine-interface.
        
        :param ref_obj: ServiceEndpoint object
        
        """
        if 'service_endpoint_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('service_endpoint_refs')
            self._original_service_endpoint_refs = copy.deepcopy(self.get_service_endpoint_refs() or [])
        super(VirtualMachineInterface, self).add_service_endpoint(*args, **kwargs)
    # end add_service_endpoint

    def del_service_endpoint(self, *args, **kwargs):
        if 'service_endpoint_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('service_endpoint_refs')
            self._original_service_endpoint_refs = copy.deepcopy(self.get_service_endpoint_refs() or [])
        super(VirtualMachineInterface, self).del_service_endpoint(*args, **kwargs)
    # end del_service_endpoint

    def set_service_endpoint_list(self, *args, **kwargs):
        """Set service-endpoint list for virtual-machine-interface.
        
        :param ref_obj_list: list of ServiceEndpoint object
        
        """
        self._pending_field_updates.add('service_endpoint_refs')
        self._pending_ref_updates.discard('service_endpoint_refs')
        super(VirtualMachineInterface, self).set_service_endpoint_list(*args, **kwargs)
    # end set_service_endpoint_list

    def set_port_profile(self, *args, **kwargs):
        """Set port-profile for virtual-machine-interface.
        
        :param ref_obj: PortProfile object
        
        """
        self._pending_field_updates.add('port_profile_refs')
        self._pending_ref_updates.discard('port_profile_refs')
        super(VirtualMachineInterface, self).set_port_profile(*args, **kwargs)

    # end set_port_profile

    def add_port_profile(self, *args, **kwargs):
        """Add port-profile to virtual-machine-interface.
        
        :param ref_obj: PortProfile object
        
        """
        if 'port_profile_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('port_profile_refs')
            self._original_port_profile_refs = copy.deepcopy(self.get_port_profile_refs() or [])
        super(VirtualMachineInterface, self).add_port_profile(*args, **kwargs)
    # end add_port_profile

    def del_port_profile(self, *args, **kwargs):
        if 'port_profile_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('port_profile_refs')
            self._original_port_profile_refs = copy.deepcopy(self.get_port_profile_refs() or [])
        super(VirtualMachineInterface, self).del_port_profile(*args, **kwargs)
    # end del_port_profile

    def set_port_profile_list(self, *args, **kwargs):
        """Set port-profile list for virtual-machine-interface.
        
        :param ref_obj_list: list of PortProfile object
        
        """
        self._pending_field_updates.add('port_profile_refs')
        self._pending_ref_updates.discard('port_profile_refs')
        super(VirtualMachineInterface, self).set_port_profile_list(*args, **kwargs)
    # end set_port_profile_list

    def set_tag(self, *args, **kwargs):
        """Set tag for virtual-machine-interface.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(VirtualMachineInterface, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to virtual-machine-interface.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(VirtualMachineInterface, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(VirtualMachineInterface, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for virtual-machine-interface.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(VirtualMachineInterface, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


    def get_virtual_machine_interface_back_refs(self):
        """Return list of all virtual-machine-interfaces using this virtual-machine-interface"""
        if hasattr(self, 'virtual_machine_interface_back_refs'):
            return self.virtual_machine_interface_back_refs

        if hasattr(super(VirtualMachineInterface, self), 'virtual_machine_interface_back_refs'):
            return super(VirtualMachineInterface, self).get_virtual_machine_interface_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.virtual_machine_interface_read(id = self.uuid, fields = ['virtual_machine_interface_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'virtual_machine_interface_back_refs', None)
        if not back_refs:
            return None
        self.virtual_machine_interface_back_refs = back_refs

        return back_refs
    # end get_virtual_machine_interface_back_refs

    def get_instance_ip_back_refs(self):
        """Return list of all instance-ips using this virtual-machine-interface"""
        if hasattr(self, 'instance_ip_back_refs'):
            return self.instance_ip_back_refs

        if hasattr(super(VirtualMachineInterface, self), 'instance_ip_back_refs'):
            return super(VirtualMachineInterface, self).get_instance_ip_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.virtual_machine_interface_read(id = self.uuid, fields = ['instance_ip_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'instance_ip_back_refs', None)
        if not back_refs:
            return None
        self.instance_ip_back_refs = back_refs

        return back_refs
    # end get_instance_ip_back_refs

    def get_subnet_back_refs(self):
        """Return list of all subnets using this virtual-machine-interface"""
        if hasattr(self, 'subnet_back_refs'):
            return self.subnet_back_refs

        if hasattr(super(VirtualMachineInterface, self), 'subnet_back_refs'):
            return super(VirtualMachineInterface, self).get_subnet_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.virtual_machine_interface_read(id = self.uuid, fields = ['subnet_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'subnet_back_refs', None)
        if not back_refs:
            return None
        self.subnet_back_refs = back_refs

        return back_refs
    # end get_subnet_back_refs

    def get_floating_ip_back_refs(self):
        """Return list of all floating-ips using this virtual-machine-interface"""
        if hasattr(self, 'floating_ip_back_refs'):
            return self.floating_ip_back_refs

        if hasattr(super(VirtualMachineInterface, self), 'floating_ip_back_refs'):
            return super(VirtualMachineInterface, self).get_floating_ip_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.virtual_machine_interface_read(id = self.uuid, fields = ['floating_ip_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'floating_ip_back_refs', None)
        if not back_refs:
            return None
        self.floating_ip_back_refs = back_refs

        return back_refs
    # end get_floating_ip_back_refs

    def get_alias_ip_back_refs(self):
        """Return list of all alias-ips using this virtual-machine-interface"""
        if hasattr(self, 'alias_ip_back_refs'):
            return self.alias_ip_back_refs

        if hasattr(super(VirtualMachineInterface, self), 'alias_ip_back_refs'):
            return super(VirtualMachineInterface, self).get_alias_ip_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.virtual_machine_interface_read(id = self.uuid, fields = ['alias_ip_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'alias_ip_back_refs', None)
        if not back_refs:
            return None
        self.alias_ip_back_refs = back_refs

        return back_refs
    # end get_alias_ip_back_refs

    def get_logical_interface_back_refs(self):
        """Return list of all logical-interfaces using this virtual-machine-interface"""
        if hasattr(self, 'logical_interface_back_refs'):
            return self.logical_interface_back_refs

        if hasattr(super(VirtualMachineInterface, self), 'logical_interface_back_refs'):
            return super(VirtualMachineInterface, self).get_logical_interface_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.virtual_machine_interface_read(id = self.uuid, fields = ['logical_interface_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'logical_interface_back_refs', None)
        if not back_refs:
            return None
        self.logical_interface_back_refs = back_refs

        return back_refs
    # end get_logical_interface_back_refs

    def get_bgp_as_a_service_back_refs(self):
        """Return list of all bgp-as-a-services using this virtual-machine-interface"""
        if hasattr(self, 'bgp_as_a_service_back_refs'):
            return self.bgp_as_a_service_back_refs

        if hasattr(super(VirtualMachineInterface, self), 'bgp_as_a_service_back_refs'):
            return super(VirtualMachineInterface, self).get_bgp_as_a_service_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.virtual_machine_interface_read(id = self.uuid, fields = ['bgp_as_a_service_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'bgp_as_a_service_back_refs', None)
        if not back_refs:
            return None
        self.bgp_as_a_service_back_refs = back_refs

        return back_refs
    # end get_bgp_as_a_service_back_refs

    def get_customer_attachment_back_refs(self):
        """Return list of all customer-attachments using this virtual-machine-interface"""
        if hasattr(self, 'customer_attachment_back_refs'):
            return self.customer_attachment_back_refs

        if hasattr(super(VirtualMachineInterface, self), 'customer_attachment_back_refs'):
            return super(VirtualMachineInterface, self).get_customer_attachment_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.virtual_machine_interface_read(id = self.uuid, fields = ['customer_attachment_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'customer_attachment_back_refs', None)
        if not back_refs:
            return None
        self.customer_attachment_back_refs = back_refs

        return back_refs
    # end get_customer_attachment_back_refs

    def get_logical_router_back_refs(self):
        """Return list of all logical-routers using this virtual-machine-interface"""
        if hasattr(self, 'logical_router_back_refs'):
            return self.logical_router_back_refs

        if hasattr(super(VirtualMachineInterface, self), 'logical_router_back_refs'):
            return super(VirtualMachineInterface, self).get_logical_router_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.virtual_machine_interface_read(id = self.uuid, fields = ['logical_router_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'logical_router_back_refs', None)
        if not back_refs:
            return None
        self.logical_router_back_refs = back_refs

        return back_refs
    # end get_logical_router_back_refs

    def get_loadbalancer_pool_back_refs(self):
        """Return list of all loadbalancer-pools using this virtual-machine-interface"""
        if hasattr(self, 'loadbalancer_pool_back_refs'):
            return self.loadbalancer_pool_back_refs

        if hasattr(super(VirtualMachineInterface, self), 'loadbalancer_pool_back_refs'):
            return super(VirtualMachineInterface, self).get_loadbalancer_pool_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.virtual_machine_interface_read(id = self.uuid, fields = ['loadbalancer_pool_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'loadbalancer_pool_back_refs', None)
        if not back_refs:
            return None
        self.loadbalancer_pool_back_refs = back_refs

        return back_refs
    # end get_loadbalancer_pool_back_refs

    def get_virtual_ip_back_refs(self):
        """Return list of all virtual-ips using this virtual-machine-interface"""
        if hasattr(self, 'virtual_ip_back_refs'):
            return self.virtual_ip_back_refs

        if hasattr(super(VirtualMachineInterface, self), 'virtual_ip_back_refs'):
            return super(VirtualMachineInterface, self).get_virtual_ip_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.virtual_machine_interface_read(id = self.uuid, fields = ['virtual_ip_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'virtual_ip_back_refs', None)
        if not back_refs:
            return None
        self.virtual_ip_back_refs = back_refs

        return back_refs
    # end get_virtual_ip_back_refs

    def get_loadbalancer_back_refs(self):
        """Return list of all loadbalancers using this virtual-machine-interface"""
        if hasattr(self, 'loadbalancer_back_refs'):
            return self.loadbalancer_back_refs

        if hasattr(super(VirtualMachineInterface, self), 'loadbalancer_back_refs'):
            return super(VirtualMachineInterface, self).get_loadbalancer_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.virtual_machine_interface_read(id = self.uuid, fields = ['loadbalancer_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'loadbalancer_back_refs', None)
        if not back_refs:
            return None
        self.loadbalancer_back_refs = back_refs

        return back_refs
    # end get_loadbalancer_back_refs

    def get_virtual_port_group_back_refs(self):
        """Return list of all virtual-port-groups using this virtual-machine-interface"""
        if hasattr(self, 'virtual_port_group_back_refs'):
            return self.virtual_port_group_back_refs

        if hasattr(super(VirtualMachineInterface, self), 'virtual_port_group_back_refs'):
            return super(VirtualMachineInterface, self).get_virtual_port_group_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.virtual_machine_interface_read(id = self.uuid, fields = ['virtual_port_group_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'virtual_port_group_back_refs', None)
        if not back_refs:
            return None
        self.virtual_port_group_back_refs = back_refs

        return back_refs
    # end get_virtual_port_group_back_refs

    def get_link_aggregation_group_back_refs(self):
        """Return list of all link-aggregation-groups using this virtual-machine-interface"""
        if hasattr(self, 'link_aggregation_group_back_refs'):
            return self.link_aggregation_group_back_refs

        if hasattr(super(VirtualMachineInterface, self), 'link_aggregation_group_back_refs'):
            return super(VirtualMachineInterface, self).get_link_aggregation_group_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.virtual_machine_interface_read(id = self.uuid, fields = ['link_aggregation_group_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'link_aggregation_group_back_refs', None)
        if not back_refs:
            return None
        self.link_aggregation_group_back_refs = back_refs

        return back_refs
    # end get_link_aggregation_group_back_refs

# end class VirtualMachineInterface

class CliConfig(vnc_api.gen.resource_common.CliConfig):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'accepted_cli_config' in kwargs:
            pending_fields.append('accepted_cli_config')
        if len(args) > 1 or 'commit_diff_list' in kwargs:
            pending_fields.append('commit_diff_list')
        if len(args) > 2 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 3 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 4 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 5 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(CliConfig, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            props_dict['accepted_cli_config'] = kwargs[u'accepted_cli_config']
        except KeyError:
            pass

        try:
            if kwargs['commit_diff_list'] is None:
                props_dict['commit_diff_list'] = None
            else:
                props_dict['commit_diff_list'] = vnc_api.gen.resource_xsd.CliDiffListType(params_dict=kwargs[u'commit_diff_list'])
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = CliConfig(**props_dict)
        else:
            obj = CliConfig(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.CliConfig.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.CliConfig.accepted_cli_config.setter
    def accepted_cli_config(self, accepted_cli_config):
        """Set accepted-cli-config for cli-config.
        
        :param accepted_cli_config: xsd:string object
        
        """
        if 'accepted_cli_config' not in self._pending_field_updates:
            self._pending_field_updates.add('accepted_cli_config')

        self._accepted_cli_config = accepted_cli_config
    # end accepted_cli_config

    def set_accepted_cli_config(self, value):
        self.accepted_cli_config = value
    # end set_accepted_cli_config

    @vnc_api.gen.resource_common.CliConfig.commit_diff_list.setter
    def commit_diff_list(self, commit_diff_list):
        """Set commit-diff-list for cli-config.
        
        :param commit_diff_list: CliDiffListType object
        
        """
        if 'commit_diff_list' not in self._pending_field_updates:
            self._pending_field_updates.add('commit_diff_list')

        if 'commit_diff_list' in self._pending_field_list_updates:
            # set clobbers earlier add/del on prop list elements
            del self._pending_field_list_updates['commit_diff_list']

        self._commit_diff_list = commit_diff_list
    # end commit_diff_list

    def set_commit_diff_list(self, value):
        self.commit_diff_list = value
    # end set_commit_diff_list

    @vnc_api.gen.resource_common.CliConfig.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for cli-config.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.CliConfig.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for cli-config.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.CliConfig.annotations.setter
    def annotations(self, annotations):
        """Set annotations for cli-config.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.CliConfig.display_name.setter
    def display_name(self, display_name):
        """Set display-name for cli-config.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_commit_diff_list(self, elem_value, elem_position=None):
        """Add element to commit-diff-list for cli-config.
        
        :param elem_value: xsd:string object
        :param elem_position: optional string order-key
        
        """
        if 'commit_diff_list' not in self._pending_field_list_updates:
            self._pending_field_list_updates['commit_diff_list'] = [
                ('add', elem_value, elem_position)]
        else:
            self._pending_field_list_updates['commit_diff_list'].append(
                ('add', elem_value, elem_position))
    # end add_commit_diff_list

    def del_commit_diff_list(self, elem_position):
        """Delete element from commit-diff-list for cli-config.
        
        :param elem_position: string indicating order-key
        
        """
        if 'commit_diff_list' not in self._pending_field_list_updates:
            self._pending_field_list_updates['commit_diff_list'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_list_updates['commit_diff_list'].append(
                ('delete', None, elem_position))
    # end del_commit_diff_list
    def add_annotations(self, elem):
        """Add element to annotations for cli-config.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for cli-config.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_tag(self, *args, **kwargs):
        """Set tag for cli-config.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(CliConfig, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to cli-config.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(CliConfig, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(CliConfig, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for cli-config.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(CliConfig, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


# end class CliConfig

class ServiceObject(vnc_api.gen.resource_common.ServiceObject):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, *args, **kwargs):
        pending_fields = ['fq_name']

        self._server_conn = None

        if len(args) > 0 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 1 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 2 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 3 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(ServiceObject, self).__init__(name, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = ServiceObject(**props_dict)
        else:
            obj = ServiceObject(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.service_endpoint_back_refs = kwargs[u'service_endpoint_back_refs']
        except KeyError:
            pass
        try:
            obj.service_connection_module_back_refs = kwargs[u'service_connection_module_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.ServiceObject.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.ServiceObject.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for service-object.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.ServiceObject.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for service-object.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.ServiceObject.annotations.setter
    def annotations(self, annotations):
        """Set annotations for service-object.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.ServiceObject.display_name.setter
    def display_name(self, display_name):
        """Set display-name for service-object.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for service-object.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for service-object.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_tag(self, *args, **kwargs):
        """Set tag for service-object.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(ServiceObject, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to service-object.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(ServiceObject, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(ServiceObject, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for service-object.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(ServiceObject, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


    def get_service_endpoint_back_refs(self):
        """Return list of all service-endpoints using this service-object"""
        if hasattr(self, 'service_endpoint_back_refs'):
            return self.service_endpoint_back_refs

        if hasattr(super(ServiceObject, self), 'service_endpoint_back_refs'):
            return super(ServiceObject, self).get_service_endpoint_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.service_object_read(id = self.uuid, fields = ['service_endpoint_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'service_endpoint_back_refs', None)
        if not back_refs:
            return None
        self.service_endpoint_back_refs = back_refs

        return back_refs
    # end get_service_endpoint_back_refs

    def get_service_connection_module_back_refs(self):
        """Return list of all service-connection-modules using this service-object"""
        if hasattr(self, 'service_connection_module_back_refs'):
            return self.service_connection_module_back_refs

        if hasattr(super(ServiceObject, self), 'service_connection_module_back_refs'):
            return super(ServiceObject, self).get_service_connection_module_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.service_object_read(id = self.uuid, fields = ['service_connection_module_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'service_connection_module_back_refs', None)
        if not back_refs:
            return None
        self.service_connection_module_back_refs = back_refs

        return back_refs
    # end get_service_connection_module_back_refs

# end class ServiceObject

class FeatureFlag(vnc_api.gen.resource_common.FeatureFlag):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'feature_description' in kwargs:
            pending_fields.append('feature_description')
        if len(args) > 1 or 'feature_id' in kwargs:
            pending_fields.append('feature_id')
        if len(args) > 2 or 'feature_flag_version' in kwargs:
            pending_fields.append('feature_flag_version')
        if len(args) > 3 or 'feature_release' in kwargs:
            pending_fields.append('feature_release')
        if len(args) > 4 or 'enable_feature' in kwargs:
            pending_fields.append('enable_feature')
        if len(args) > 5 or 'feature_state' in kwargs:
            pending_fields.append('feature_state')
        if len(args) > 6 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 7 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 8 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 9 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(FeatureFlag, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            props_dict['feature_description'] = kwargs[u'feature_description']
        except KeyError:
            pass

        try:
            props_dict['feature_id'] = kwargs[u'feature_id']
        except KeyError:
            pass

        try:
            props_dict['feature_flag_version'] = kwargs[u'feature_flag_version']
        except KeyError:
            pass

        try:
            props_dict['feature_release'] = kwargs[u'feature_release']
        except KeyError:
            pass

        try:
            props_dict['enable_feature'] = kwargs[u'enable_feature']
        except KeyError:
            pass

        try:
            props_dict['feature_state'] = kwargs[u'feature_state']
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = FeatureFlag(**props_dict)
        else:
            obj = FeatureFlag(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.FeatureFlag.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.FeatureFlag.feature_description.setter
    def feature_description(self, feature_description):
        """Set feature-description for feature-flag.
        
        :param feature_description: xsd:string object
        
        """
        if 'feature_description' not in self._pending_field_updates:
            self._pending_field_updates.add('feature_description')

        self._feature_description = feature_description
    # end feature_description

    def set_feature_description(self, value):
        self.feature_description = value
    # end set_feature_description

    @vnc_api.gen.resource_common.FeatureFlag.feature_id.setter
    def feature_id(self, feature_id):
        """Set feature-id for feature-flag.
        
        :param feature_id: FeatureIdType object
        
        """
        if 'feature_id' not in self._pending_field_updates:
            self._pending_field_updates.add('feature_id')

        self._feature_id = feature_id
    # end feature_id

    def set_feature_id(self, value):
        self.feature_id = value
    # end set_feature_id

    @vnc_api.gen.resource_common.FeatureFlag.feature_flag_version.setter
    def feature_flag_version(self, feature_flag_version):
        """Set feature-flag-version for feature-flag.
        
        :param feature_flag_version: xsd:string object
        
        """
        if 'feature_flag_version' not in self._pending_field_updates:
            self._pending_field_updates.add('feature_flag_version')

        self._feature_flag_version = feature_flag_version
    # end feature_flag_version

    def set_feature_flag_version(self, value):
        self.feature_flag_version = value
    # end set_feature_flag_version

    @vnc_api.gen.resource_common.FeatureFlag.feature_release.setter
    def feature_release(self, feature_release):
        """Set feature-release for feature-flag.
        
        :param feature_release: xsd:string object
        
        """
        if 'feature_release' not in self._pending_field_updates:
            self._pending_field_updates.add('feature_release')

        self._feature_release = feature_release
    # end feature_release

    def set_feature_release(self, value):
        self.feature_release = value
    # end set_feature_release

    @vnc_api.gen.resource_common.FeatureFlag.enable_feature.setter
    def enable_feature(self, enable_feature):
        """Set enable-feature for feature-flag.
        
        :param enable_feature: xsd:boolean object
        
        """
        if 'enable_feature' not in self._pending_field_updates:
            self._pending_field_updates.add('enable_feature')

        self._enable_feature = enable_feature
    # end enable_feature

    def set_enable_feature(self, value):
        self.enable_feature = value
    # end set_enable_feature

    @vnc_api.gen.resource_common.FeatureFlag.feature_state.setter
    def feature_state(self, feature_state):
        """Set feature-state for feature-flag.
        
        :param feature_state: FeatureStateType object
        
        """
        if 'feature_state' not in self._pending_field_updates:
            self._pending_field_updates.add('feature_state')

        self._feature_state = feature_state
    # end feature_state

    def set_feature_state(self, value):
        self.feature_state = value
    # end set_feature_state

    @vnc_api.gen.resource_common.FeatureFlag.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for feature-flag.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.FeatureFlag.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for feature-flag.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.FeatureFlag.annotations.setter
    def annotations(self, annotations):
        """Set annotations for feature-flag.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.FeatureFlag.display_name.setter
    def display_name(self, display_name):
        """Set display-name for feature-flag.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for feature-flag.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for feature-flag.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_tag(self, *args, **kwargs):
        """Set tag for feature-flag.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(FeatureFlag, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to feature-flag.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(FeatureFlag, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(FeatureFlag, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for feature-flag.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(FeatureFlag, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


# end class FeatureFlag

class Loadbalancer(vnc_api.gen.resource_common.Loadbalancer):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'loadbalancer_properties' in kwargs:
            pending_fields.append('loadbalancer_properties')
        if len(args) > 1 or 'loadbalancer_provider' in kwargs:
            pending_fields.append('loadbalancer_provider')
        if len(args) > 2 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 3 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 4 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 5 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(Loadbalancer, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            if kwargs['loadbalancer_properties'] is None:
                props_dict['loadbalancer_properties'] = None
            else:
                props_dict['loadbalancer_properties'] = vnc_api.gen.resource_xsd.LoadbalancerType(params_dict=kwargs[u'loadbalancer_properties'])
        except KeyError:
            pass

        try:
            props_dict['loadbalancer_provider'] = kwargs[u'loadbalancer_provider']
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = Loadbalancer(**props_dict)
        else:
            obj = Loadbalancer(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.service_appliance_set_refs = kwargs[u'service_appliance_set_refs']
        except KeyError:
            pass
        try:
            obj.service_instance_refs = kwargs[u'service_instance_refs']
        except KeyError:
            pass
        try:
            obj.virtual_machine_interface_refs = kwargs[u'virtual_machine_interface_refs']
        except KeyError:
            pass
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.loadbalancer_listener_back_refs = kwargs[u'loadbalancer_listener_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.Loadbalancer.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.Loadbalancer.loadbalancer_properties.setter
    def loadbalancer_properties(self, loadbalancer_properties):
        """Set loadbalancer-properties for loadbalancer.
        
        :param loadbalancer_properties: LoadbalancerType object
        
        """
        if 'loadbalancer_properties' not in self._pending_field_updates:
            self._pending_field_updates.add('loadbalancer_properties')

        self._loadbalancer_properties = loadbalancer_properties
    # end loadbalancer_properties

    def set_loadbalancer_properties(self, value):
        self.loadbalancer_properties = value
    # end set_loadbalancer_properties

    @vnc_api.gen.resource_common.Loadbalancer.loadbalancer_provider.setter
    def loadbalancer_provider(self, loadbalancer_provider):
        """Set loadbalancer-provider for loadbalancer.
        
        :param loadbalancer_provider: xsd:string object
        
        """
        if 'loadbalancer_provider' not in self._pending_field_updates:
            self._pending_field_updates.add('loadbalancer_provider')

        self._loadbalancer_provider = loadbalancer_provider
    # end loadbalancer_provider

    def set_loadbalancer_provider(self, value):
        self.loadbalancer_provider = value
    # end set_loadbalancer_provider

    @vnc_api.gen.resource_common.Loadbalancer.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for loadbalancer.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.Loadbalancer.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for loadbalancer.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.Loadbalancer.annotations.setter
    def annotations(self, annotations):
        """Set annotations for loadbalancer.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.Loadbalancer.display_name.setter
    def display_name(self, display_name):
        """Set display-name for loadbalancer.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for loadbalancer.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for loadbalancer.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_service_appliance_set(self, *args, **kwargs):
        """Set service-appliance-set for loadbalancer.
        
        :param ref_obj: ServiceApplianceSet object
        
        """
        self._pending_field_updates.add('service_appliance_set_refs')
        self._pending_ref_updates.discard('service_appliance_set_refs')
        super(Loadbalancer, self).set_service_appliance_set(*args, **kwargs)

    # end set_service_appliance_set

    def add_service_appliance_set(self, *args, **kwargs):
        """Add service-appliance-set to loadbalancer.
        
        :param ref_obj: ServiceApplianceSet object
        
        """
        if 'service_appliance_set_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('service_appliance_set_refs')
            self._original_service_appliance_set_refs = copy.deepcopy(self.get_service_appliance_set_refs() or [])
        super(Loadbalancer, self).add_service_appliance_set(*args, **kwargs)
    # end add_service_appliance_set

    def del_service_appliance_set(self, *args, **kwargs):
        if 'service_appliance_set_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('service_appliance_set_refs')
            self._original_service_appliance_set_refs = copy.deepcopy(self.get_service_appliance_set_refs() or [])
        super(Loadbalancer, self).del_service_appliance_set(*args, **kwargs)
    # end del_service_appliance_set

    def set_service_appliance_set_list(self, *args, **kwargs):
        """Set service-appliance-set list for loadbalancer.
        
        :param ref_obj_list: list of ServiceApplianceSet object
        
        """
        self._pending_field_updates.add('service_appliance_set_refs')
        self._pending_ref_updates.discard('service_appliance_set_refs')
        super(Loadbalancer, self).set_service_appliance_set_list(*args, **kwargs)
    # end set_service_appliance_set_list

    def set_service_instance(self, *args, **kwargs):
        """Set service-instance for loadbalancer.
        
        :param ref_obj: ServiceInstance object
        
        """
        self._pending_field_updates.add('service_instance_refs')
        self._pending_ref_updates.discard('service_instance_refs')
        super(Loadbalancer, self).set_service_instance(*args, **kwargs)

    # end set_service_instance

    def add_service_instance(self, *args, **kwargs):
        """Add service-instance to loadbalancer.
        
        :param ref_obj: ServiceInstance object
        
        """
        if 'service_instance_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('service_instance_refs')
            self._original_service_instance_refs = copy.deepcopy(self.get_service_instance_refs() or [])
        super(Loadbalancer, self).add_service_instance(*args, **kwargs)
    # end add_service_instance

    def del_service_instance(self, *args, **kwargs):
        if 'service_instance_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('service_instance_refs')
            self._original_service_instance_refs = copy.deepcopy(self.get_service_instance_refs() or [])
        super(Loadbalancer, self).del_service_instance(*args, **kwargs)
    # end del_service_instance

    def set_service_instance_list(self, *args, **kwargs):
        """Set service-instance list for loadbalancer.
        
        :param ref_obj_list: list of ServiceInstance object
        
        """
        self._pending_field_updates.add('service_instance_refs')
        self._pending_ref_updates.discard('service_instance_refs')
        super(Loadbalancer, self).set_service_instance_list(*args, **kwargs)
    # end set_service_instance_list

    def set_virtual_machine_interface(self, *args, **kwargs):
        """Set virtual-machine-interface for loadbalancer.
        
        :param ref_obj: VirtualMachineInterface object
        
        """
        self._pending_field_updates.add('virtual_machine_interface_refs')
        self._pending_ref_updates.discard('virtual_machine_interface_refs')
        super(Loadbalancer, self).set_virtual_machine_interface(*args, **kwargs)

    # end set_virtual_machine_interface

    def add_virtual_machine_interface(self, *args, **kwargs):
        """Add virtual-machine-interface to loadbalancer.
        
        :param ref_obj: VirtualMachineInterface object
        
        """
        if 'virtual_machine_interface_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('virtual_machine_interface_refs')
            self._original_virtual_machine_interface_refs = copy.deepcopy(self.get_virtual_machine_interface_refs() or [])
        super(Loadbalancer, self).add_virtual_machine_interface(*args, **kwargs)
    # end add_virtual_machine_interface

    def del_virtual_machine_interface(self, *args, **kwargs):
        if 'virtual_machine_interface_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('virtual_machine_interface_refs')
            self._original_virtual_machine_interface_refs = copy.deepcopy(self.get_virtual_machine_interface_refs() or [])
        super(Loadbalancer, self).del_virtual_machine_interface(*args, **kwargs)
    # end del_virtual_machine_interface

    def set_virtual_machine_interface_list(self, *args, **kwargs):
        """Set virtual-machine-interface list for loadbalancer.
        
        :param ref_obj_list: list of VirtualMachineInterface object
        
        """
        self._pending_field_updates.add('virtual_machine_interface_refs')
        self._pending_ref_updates.discard('virtual_machine_interface_refs')
        super(Loadbalancer, self).set_virtual_machine_interface_list(*args, **kwargs)
    # end set_virtual_machine_interface_list

    def set_tag(self, *args, **kwargs):
        """Set tag for loadbalancer.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(Loadbalancer, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to loadbalancer.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(Loadbalancer, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(Loadbalancer, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for loadbalancer.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(Loadbalancer, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


    def get_loadbalancer_listener_back_refs(self):
        """Return list of all loadbalancer-listeners using this loadbalancer"""
        if hasattr(self, 'loadbalancer_listener_back_refs'):
            return self.loadbalancer_listener_back_refs

        if hasattr(super(Loadbalancer, self), 'loadbalancer_listener_back_refs'):
            return super(Loadbalancer, self).get_loadbalancer_listener_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.loadbalancer_read(id = self.uuid, fields = ['loadbalancer_listener_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'loadbalancer_listener_back_refs', None)
        if not back_refs:
            return None
        self.loadbalancer_listener_back_refs = back_refs

        return back_refs
    # end get_loadbalancer_listener_back_refs

# end class Loadbalancer

class PeeringPolicy(vnc_api.gen.resource_common.PeeringPolicy):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, *args, **kwargs):
        pending_fields = ['fq_name']

        self._server_conn = None

        if len(args) > 0 or 'peering_service' in kwargs:
            pending_fields.append('peering_service')
        if len(args) > 1 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 2 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 3 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 4 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(PeeringPolicy, self).__init__(name, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            props_dict['peering_service'] = kwargs[u'peering_service']
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = PeeringPolicy(**props_dict)
        else:
            obj = PeeringPolicy(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.e2_service_provider_back_refs = kwargs[u'e2_service_provider_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.PeeringPolicy.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.PeeringPolicy.peering_service.setter
    def peering_service(self, peering_service):
        """Set peering-service for peering-policy.
        
        :param peering_service: PeeringServiceType object
        
        """
        if 'peering_service' not in self._pending_field_updates:
            self._pending_field_updates.add('peering_service')

        self._peering_service = peering_service
    # end peering_service

    def set_peering_service(self, value):
        self.peering_service = value
    # end set_peering_service

    @vnc_api.gen.resource_common.PeeringPolicy.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for peering-policy.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.PeeringPolicy.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for peering-policy.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.PeeringPolicy.annotations.setter
    def annotations(self, annotations):
        """Set annotations for peering-policy.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.PeeringPolicy.display_name.setter
    def display_name(self, display_name):
        """Set display-name for peering-policy.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for peering-policy.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for peering-policy.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_tag(self, *args, **kwargs):
        """Set tag for peering-policy.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(PeeringPolicy, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to peering-policy.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(PeeringPolicy, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(PeeringPolicy, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for peering-policy.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(PeeringPolicy, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


    def get_e2_service_provider_back_refs(self):
        """Return list of all e2-service-providers using this peering-policy"""
        if hasattr(self, 'e2_service_provider_back_refs'):
            return self.e2_service_provider_back_refs

        if hasattr(super(PeeringPolicy, self), 'e2_service_provider_back_refs'):
            return super(PeeringPolicy, self).get_e2_service_provider_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.peering_policy_read(id = self.uuid, fields = ['e2_service_provider_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'e2_service_provider_back_refs', None)
        if not back_refs:
            return None
        self.e2_service_provider_back_refs = back_refs

        return back_refs
    # end get_e2_service_provider_back_refs

# end class PeeringPolicy

class StructuredSyslogApplicationRecord(vnc_api.gen.resource_common.StructuredSyslogApplicationRecord):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'structured_syslog_app_category' in kwargs:
            pending_fields.append('structured_syslog_app_category')
        if len(args) > 1 or 'structured_syslog_app_subcategory' in kwargs:
            pending_fields.append('structured_syslog_app_subcategory')
        if len(args) > 2 or 'structured_syslog_app_groups' in kwargs:
            pending_fields.append('structured_syslog_app_groups')
        if len(args) > 3 or 'structured_syslog_app_risk' in kwargs:
            pending_fields.append('structured_syslog_app_risk')
        if len(args) > 4 or 'structured_syslog_app_service_tags' in kwargs:
            pending_fields.append('structured_syslog_app_service_tags')
        if len(args) > 5 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 6 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 7 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 8 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(StructuredSyslogApplicationRecord, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            props_dict['structured_syslog_app_category'] = kwargs[u'structured_syslog_app_category']
        except KeyError:
            pass

        try:
            props_dict['structured_syslog_app_subcategory'] = kwargs[u'structured_syslog_app_subcategory']
        except KeyError:
            pass

        try:
            props_dict['structured_syslog_app_groups'] = kwargs[u'structured_syslog_app_groups']
        except KeyError:
            pass

        try:
            props_dict['structured_syslog_app_risk'] = kwargs[u'structured_syslog_app_risk']
        except KeyError:
            pass

        try:
            props_dict['structured_syslog_app_service_tags'] = kwargs[u'structured_syslog_app_service_tags']
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = StructuredSyslogApplicationRecord(**props_dict)
        else:
            obj = StructuredSyslogApplicationRecord(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.StructuredSyslogApplicationRecord.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.StructuredSyslogApplicationRecord.structured_syslog_app_category.setter
    def structured_syslog_app_category(self, structured_syslog_app_category):
        """Set structured-syslog-app-category for structured-syslog-application-record.
        
        :param structured_syslog_app_category: xsd:string object
        
        """
        if 'structured_syslog_app_category' not in self._pending_field_updates:
            self._pending_field_updates.add('structured_syslog_app_category')

        self._structured_syslog_app_category = structured_syslog_app_category
    # end structured_syslog_app_category

    def set_structured_syslog_app_category(self, value):
        self.structured_syslog_app_category = value
    # end set_structured_syslog_app_category

    @vnc_api.gen.resource_common.StructuredSyslogApplicationRecord.structured_syslog_app_subcategory.setter
    def structured_syslog_app_subcategory(self, structured_syslog_app_subcategory):
        """Set structured-syslog-app-subcategory for structured-syslog-application-record.
        
        :param structured_syslog_app_subcategory: xsd:string object
        
        """
        if 'structured_syslog_app_subcategory' not in self._pending_field_updates:
            self._pending_field_updates.add('structured_syslog_app_subcategory')

        self._structured_syslog_app_subcategory = structured_syslog_app_subcategory
    # end structured_syslog_app_subcategory

    def set_structured_syslog_app_subcategory(self, value):
        self.structured_syslog_app_subcategory = value
    # end set_structured_syslog_app_subcategory

    @vnc_api.gen.resource_common.StructuredSyslogApplicationRecord.structured_syslog_app_groups.setter
    def structured_syslog_app_groups(self, structured_syslog_app_groups):
        """Set structured-syslog-app-groups for structured-syslog-application-record.
        
        :param structured_syslog_app_groups: xsd:string object
        
        """
        if 'structured_syslog_app_groups' not in self._pending_field_updates:
            self._pending_field_updates.add('structured_syslog_app_groups')

        self._structured_syslog_app_groups = structured_syslog_app_groups
    # end structured_syslog_app_groups

    def set_structured_syslog_app_groups(self, value):
        self.structured_syslog_app_groups = value
    # end set_structured_syslog_app_groups

    @vnc_api.gen.resource_common.StructuredSyslogApplicationRecord.structured_syslog_app_risk.setter
    def structured_syslog_app_risk(self, structured_syslog_app_risk):
        """Set structured-syslog-app-risk for structured-syslog-application-record.
        
        :param structured_syslog_app_risk: xsd:string object
        
        """
        if 'structured_syslog_app_risk' not in self._pending_field_updates:
            self._pending_field_updates.add('structured_syslog_app_risk')

        self._structured_syslog_app_risk = structured_syslog_app_risk
    # end structured_syslog_app_risk

    def set_structured_syslog_app_risk(self, value):
        self.structured_syslog_app_risk = value
    # end set_structured_syslog_app_risk

    @vnc_api.gen.resource_common.StructuredSyslogApplicationRecord.structured_syslog_app_service_tags.setter
    def structured_syslog_app_service_tags(self, structured_syslog_app_service_tags):
        """Set structured-syslog-app-service-tags for structured-syslog-application-record.
        
        :param structured_syslog_app_service_tags: xsd:string object
        
        """
        if 'structured_syslog_app_service_tags' not in self._pending_field_updates:
            self._pending_field_updates.add('structured_syslog_app_service_tags')

        self._structured_syslog_app_service_tags = structured_syslog_app_service_tags
    # end structured_syslog_app_service_tags

    def set_structured_syslog_app_service_tags(self, value):
        self.structured_syslog_app_service_tags = value
    # end set_structured_syslog_app_service_tags

    @vnc_api.gen.resource_common.StructuredSyslogApplicationRecord.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for structured-syslog-application-record.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.StructuredSyslogApplicationRecord.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for structured-syslog-application-record.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.StructuredSyslogApplicationRecord.annotations.setter
    def annotations(self, annotations):
        """Set annotations for structured-syslog-application-record.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.StructuredSyslogApplicationRecord.display_name.setter
    def display_name(self, display_name):
        """Set display-name for structured-syslog-application-record.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for structured-syslog-application-record.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for structured-syslog-application-record.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_tag(self, *args, **kwargs):
        """Set tag for structured-syslog-application-record.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(StructuredSyslogApplicationRecord, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to structured-syslog-application-record.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(StructuredSyslogApplicationRecord, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(StructuredSyslogApplicationRecord, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for structured-syslog-application-record.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(StructuredSyslogApplicationRecord, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


# end class StructuredSyslogApplicationRecord

class GlobalVrouterConfig(vnc_api.gen.resource_common.GlobalVrouterConfig):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'ecmp_hashing_include_fields' in kwargs:
            pending_fields.append('ecmp_hashing_include_fields')
        if len(args) > 1 or 'linklocal_services' in kwargs:
            pending_fields.append('linklocal_services')
        if len(args) > 2 or 'encapsulation_priorities' in kwargs:
            pending_fields.append('encapsulation_priorities')
        if len(args) > 3 or 'vxlan_network_identifier_mode' in kwargs:
            pending_fields.append('vxlan_network_identifier_mode')
        if len(args) > 4 or 'flow_export_rate' in kwargs:
            pending_fields.append('flow_export_rate')
        if len(args) > 5 or 'flow_aging_timeout_list' in kwargs:
            pending_fields.append('flow_aging_timeout_list')
        if len(args) > 6 or 'enable_security_logging' in kwargs:
            pending_fields.append('enable_security_logging')
        if len(args) > 7 or 'encryption_mode' in kwargs:
            pending_fields.append('encryption_mode')
        if len(args) > 8 or 'encryption_tunnel_endpoints' in kwargs:
            pending_fields.append('encryption_tunnel_endpoints')
        if len(args) > 9 or 'forwarding_mode' in kwargs:
            pending_fields.append('forwarding_mode')
        if len(args) > 10 or 'port_translation_pools' in kwargs:
            pending_fields.append('port_translation_pools')
        if len(args) > 11 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 12 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 13 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 14 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(GlobalVrouterConfig, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            if kwargs['ecmp_hashing_include_fields'] is None:
                props_dict['ecmp_hashing_include_fields'] = None
            else:
                props_dict['ecmp_hashing_include_fields'] = vnc_api.gen.resource_xsd.EcmpHashingIncludeFields(params_dict=kwargs[u'ecmp_hashing_include_fields'])
        except KeyError:
            pass

        try:
            if kwargs['linklocal_services'] is None:
                props_dict['linklocal_services'] = None
            else:
                props_dict['linklocal_services'] = vnc_api.gen.resource_xsd.LinklocalServicesTypes(params_dict=kwargs[u'linklocal_services'])
        except KeyError:
            pass

        try:
            if kwargs['encapsulation_priorities'] is None:
                props_dict['encapsulation_priorities'] = None
            else:
                props_dict['encapsulation_priorities'] = vnc_api.gen.resource_xsd.EncapsulationPrioritiesType(params_dict=kwargs[u'encapsulation_priorities'])
        except KeyError:
            pass

        try:
            props_dict['vxlan_network_identifier_mode'] = kwargs[u'vxlan_network_identifier_mode']
        except KeyError:
            pass

        try:
            props_dict['flow_export_rate'] = kwargs[u'flow_export_rate']
        except KeyError:
            pass

        try:
            if kwargs['flow_aging_timeout_list'] is None:
                props_dict['flow_aging_timeout_list'] = None
            else:
                props_dict['flow_aging_timeout_list'] = vnc_api.gen.resource_xsd.FlowAgingTimeoutList(params_dict=kwargs[u'flow_aging_timeout_list'])
        except KeyError:
            pass

        try:
            props_dict['enable_security_logging'] = kwargs[u'enable_security_logging']
        except KeyError:
            pass

        try:
            props_dict['encryption_mode'] = kwargs[u'encryption_mode']
        except KeyError:
            pass

        try:
            if kwargs['encryption_tunnel_endpoints'] is None:
                props_dict['encryption_tunnel_endpoints'] = None
            else:
                props_dict['encryption_tunnel_endpoints'] = vnc_api.gen.resource_xsd.EncryptionTunnelEndpointList(params_dict=kwargs[u'encryption_tunnel_endpoints'])
        except KeyError:
            pass

        try:
            props_dict['forwarding_mode'] = kwargs[u'forwarding_mode']
        except KeyError:
            pass

        try:
            if kwargs['port_translation_pools'] is None:
                props_dict['port_translation_pools'] = None
            else:
                props_dict['port_translation_pools'] = vnc_api.gen.resource_xsd.PortTranslationPools(params_dict=kwargs[u'port_translation_pools'])
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = GlobalVrouterConfig(**props_dict)
        else:
            obj = GlobalVrouterConfig(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...
        try:
            obj.security_logging_objects = kwargs[u'security_logging_objects']
        except KeyError:
            pass

        # add any specified references...
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.application_policy_set_back_refs = kwargs[u'application_policy_set_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.GlobalVrouterConfig.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.GlobalVrouterConfig.ecmp_hashing_include_fields.setter
    def ecmp_hashing_include_fields(self, ecmp_hashing_include_fields):
        """Set ecmp-hashing-include-fields for global-vrouter-config.
        
        :param ecmp_hashing_include_fields: EcmpHashingIncludeFields object
        
        """
        if 'ecmp_hashing_include_fields' not in self._pending_field_updates:
            self._pending_field_updates.add('ecmp_hashing_include_fields')

        self._ecmp_hashing_include_fields = ecmp_hashing_include_fields
    # end ecmp_hashing_include_fields

    def set_ecmp_hashing_include_fields(self, value):
        self.ecmp_hashing_include_fields = value
    # end set_ecmp_hashing_include_fields

    @vnc_api.gen.resource_common.GlobalVrouterConfig.linklocal_services.setter
    def linklocal_services(self, linklocal_services):
        """Set linklocal-services for global-vrouter-config.
        
        :param linklocal_services: LinklocalServicesTypes object
        
        """
        if 'linklocal_services' not in self._pending_field_updates:
            self._pending_field_updates.add('linklocal_services')

        self._linklocal_services = linklocal_services
    # end linklocal_services

    def set_linklocal_services(self, value):
        self.linklocal_services = value
    # end set_linklocal_services

    @vnc_api.gen.resource_common.GlobalVrouterConfig.encapsulation_priorities.setter
    def encapsulation_priorities(self, encapsulation_priorities):
        """Set encapsulation-priorities for global-vrouter-config.
        
        :param encapsulation_priorities: EncapsulationPrioritiesType object
        
        """
        if 'encapsulation_priorities' not in self._pending_field_updates:
            self._pending_field_updates.add('encapsulation_priorities')

        self._encapsulation_priorities = encapsulation_priorities
    # end encapsulation_priorities

    def set_encapsulation_priorities(self, value):
        self.encapsulation_priorities = value
    # end set_encapsulation_priorities

    @vnc_api.gen.resource_common.GlobalVrouterConfig.vxlan_network_identifier_mode.setter
    def vxlan_network_identifier_mode(self, vxlan_network_identifier_mode):
        """Set vxlan-network-identifier-mode for global-vrouter-config.
        
        :param vxlan_network_identifier_mode: VxlanNetworkIdentifierModeType object
        
        """
        if 'vxlan_network_identifier_mode' not in self._pending_field_updates:
            self._pending_field_updates.add('vxlan_network_identifier_mode')

        self._vxlan_network_identifier_mode = vxlan_network_identifier_mode
    # end vxlan_network_identifier_mode

    def set_vxlan_network_identifier_mode(self, value):
        self.vxlan_network_identifier_mode = value
    # end set_vxlan_network_identifier_mode

    @vnc_api.gen.resource_common.GlobalVrouterConfig.flow_export_rate.setter
    def flow_export_rate(self, flow_export_rate):
        """Set flow-export-rate for global-vrouter-config.
        
        :param flow_export_rate: xsd:integer object
        
        """
        if 'flow_export_rate' not in self._pending_field_updates:
            self._pending_field_updates.add('flow_export_rate')

        self._flow_export_rate = flow_export_rate
    # end flow_export_rate

    def set_flow_export_rate(self, value):
        self.flow_export_rate = value
    # end set_flow_export_rate

    @vnc_api.gen.resource_common.GlobalVrouterConfig.flow_aging_timeout_list.setter
    def flow_aging_timeout_list(self, flow_aging_timeout_list):
        """Set flow-aging-timeout-list for global-vrouter-config.
        
        :param flow_aging_timeout_list: FlowAgingTimeoutList object
        
        """
        if 'flow_aging_timeout_list' not in self._pending_field_updates:
            self._pending_field_updates.add('flow_aging_timeout_list')

        self._flow_aging_timeout_list = flow_aging_timeout_list
    # end flow_aging_timeout_list

    def set_flow_aging_timeout_list(self, value):
        self.flow_aging_timeout_list = value
    # end set_flow_aging_timeout_list

    @vnc_api.gen.resource_common.GlobalVrouterConfig.enable_security_logging.setter
    def enable_security_logging(self, enable_security_logging):
        """Set enable-security-logging for global-vrouter-config.
        
        :param enable_security_logging: xsd:boolean object
        
        """
        if 'enable_security_logging' not in self._pending_field_updates:
            self._pending_field_updates.add('enable_security_logging')

        self._enable_security_logging = enable_security_logging
    # end enable_security_logging

    def set_enable_security_logging(self, value):
        self.enable_security_logging = value
    # end set_enable_security_logging

    @vnc_api.gen.resource_common.GlobalVrouterConfig.encryption_mode.setter
    def encryption_mode(self, encryption_mode):
        """Set encryption-mode for global-vrouter-config.
        
        :param encryption_mode: EncryptionMode object
        
        """
        if 'encryption_mode' not in self._pending_field_updates:
            self._pending_field_updates.add('encryption_mode')

        self._encryption_mode = encryption_mode
    # end encryption_mode

    def set_encryption_mode(self, value):
        self.encryption_mode = value
    # end set_encryption_mode

    @vnc_api.gen.resource_common.GlobalVrouterConfig.encryption_tunnel_endpoints.setter
    def encryption_tunnel_endpoints(self, encryption_tunnel_endpoints):
        """Set encryption-tunnel-endpoints for global-vrouter-config.
        
        :param encryption_tunnel_endpoints: EncryptionTunnelEndpointList object
        
        """
        if 'encryption_tunnel_endpoints' not in self._pending_field_updates:
            self._pending_field_updates.add('encryption_tunnel_endpoints')

        if 'encryption_tunnel_endpoints' in self._pending_field_list_updates:
            # set clobbers earlier add/del on prop list elements
            del self._pending_field_list_updates['encryption_tunnel_endpoints']

        self._encryption_tunnel_endpoints = encryption_tunnel_endpoints
    # end encryption_tunnel_endpoints

    def set_encryption_tunnel_endpoints(self, value):
        self.encryption_tunnel_endpoints = value
    # end set_encryption_tunnel_endpoints

    @vnc_api.gen.resource_common.GlobalVrouterConfig.forwarding_mode.setter
    def forwarding_mode(self, forwarding_mode):
        """Set forwarding-mode for global-vrouter-config.
        
        :param forwarding_mode: ForwardingModeType object
        
        """
        if 'forwarding_mode' not in self._pending_field_updates:
            self._pending_field_updates.add('forwarding_mode')

        self._forwarding_mode = forwarding_mode
    # end forwarding_mode

    def set_forwarding_mode(self, value):
        self.forwarding_mode = value
    # end set_forwarding_mode

    @vnc_api.gen.resource_common.GlobalVrouterConfig.port_translation_pools.setter
    def port_translation_pools(self, port_translation_pools):
        """Set port-translation-pools for global-vrouter-config.
        
        :param port_translation_pools: PortTranslationPools object
        
        """
        if 'port_translation_pools' not in self._pending_field_updates:
            self._pending_field_updates.add('port_translation_pools')

        if 'port_translation_pools' in self._pending_field_list_updates:
            # set clobbers earlier add/del on prop list elements
            del self._pending_field_list_updates['port_translation_pools']

        self._port_translation_pools = port_translation_pools
    # end port_translation_pools

    def set_port_translation_pools(self, value):
        self.port_translation_pools = value
    # end set_port_translation_pools

    @vnc_api.gen.resource_common.GlobalVrouterConfig.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for global-vrouter-config.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.GlobalVrouterConfig.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for global-vrouter-config.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.GlobalVrouterConfig.annotations.setter
    def annotations(self, annotations):
        """Set annotations for global-vrouter-config.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.GlobalVrouterConfig.display_name.setter
    def display_name(self, display_name):
        """Set display-name for global-vrouter-config.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_encryption_tunnel_endpoints(self, elem_value, elem_position=None):
        """Add element to encryption-tunnel-endpoints for global-vrouter-config.
        
        :param elem_value: xsd:string object
        :param elem_position: optional string order-key
        
        """
        if 'encryption_tunnel_endpoints' not in self._pending_field_list_updates:
            self._pending_field_list_updates['encryption_tunnel_endpoints'] = [
                ('add', elem_value, elem_position)]
        else:
            self._pending_field_list_updates['encryption_tunnel_endpoints'].append(
                ('add', elem_value, elem_position))
    # end add_encryption_tunnel_endpoints

    def del_encryption_tunnel_endpoints(self, elem_position):
        """Delete element from encryption-tunnel-endpoints for global-vrouter-config.
        
        :param elem_position: string indicating order-key
        
        """
        if 'encryption_tunnel_endpoints' not in self._pending_field_list_updates:
            self._pending_field_list_updates['encryption_tunnel_endpoints'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_list_updates['encryption_tunnel_endpoints'].append(
                ('delete', None, elem_position))
    # end del_encryption_tunnel_endpoints
    def add_port_translation_pools(self, elem_value, elem_position=None):
        """Add element to port-translation-pools for global-vrouter-config.
        
        :param elem_value: xsd:string object
        :param elem_position: optional string order-key
        
        """
        if 'port_translation_pools' not in self._pending_field_list_updates:
            self._pending_field_list_updates['port_translation_pools'] = [
                ('add', elem_value, elem_position)]
        else:
            self._pending_field_list_updates['port_translation_pools'].append(
                ('add', elem_value, elem_position))
    # end add_port_translation_pools

    def del_port_translation_pools(self, elem_position):
        """Delete element from port-translation-pools for global-vrouter-config.
        
        :param elem_position: string indicating order-key
        
        """
        if 'port_translation_pools' not in self._pending_field_list_updates:
            self._pending_field_list_updates['port_translation_pools'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_list_updates['port_translation_pools'].append(
                ('delete', None, elem_position))
    # end del_port_translation_pools
    def add_annotations(self, elem):
        """Add element to annotations for global-vrouter-config.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for global-vrouter-config.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_tag(self, *args, **kwargs):
        """Set tag for global-vrouter-config.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(GlobalVrouterConfig, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to global-vrouter-config.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(GlobalVrouterConfig, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(GlobalVrouterConfig, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for global-vrouter-config.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(GlobalVrouterConfig, self).set_tag_list(*args, **kwargs)
    # end set_tag_list

    def get_security_logging_objects(self):
        if hasattr(self, 'security_logging_objects'):
            return self.security_logging_objects

        if hasattr(super(GlobalVrouterConfig, self), 'security_logging_objects'):
            return super(GlobalVrouterConfig, self).get_security_logging_objects()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.global_vrouter_config_read(id = self.uuid, fields = ['security_logging_objects'])
        except NoIdError:
            return None
        children = getattr(obj, 'security_logging_objects', None)
        if not children:
            return None
        self.security_logging_objects = children

        return children
    # end get_security_logging_objects


    def get_application_policy_set_back_refs(self):
        """Return list of all application-policy-sets using this global-vrouter-config"""
        if hasattr(self, 'application_policy_set_back_refs'):
            return self.application_policy_set_back_refs

        if hasattr(super(GlobalVrouterConfig, self), 'application_policy_set_back_refs'):
            return super(GlobalVrouterConfig, self).get_application_policy_set_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.global_vrouter_config_read(id = self.uuid, fields = ['application_policy_set_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'application_policy_set_back_refs', None)
        if not back_refs:
            return None
        self.application_policy_set_back_refs = back_refs

        return back_refs
    # end get_application_policy_set_back_refs

# end class GlobalVrouterConfig

class FloatingIp(vnc_api.gen.resource_common.FloatingIp):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'floating_ip_address' in kwargs:
            pending_fields.append('floating_ip_address')
        if len(args) > 1 or 'floating_ip_is_virtual_ip' in kwargs:
            pending_fields.append('floating_ip_is_virtual_ip')
        if len(args) > 2 or 'floating_ip_fixed_ip_address' in kwargs:
            pending_fields.append('floating_ip_fixed_ip_address')
        if len(args) > 3 or 'floating_ip_address_family' in kwargs:
            pending_fields.append('floating_ip_address_family')
        if len(args) > 4 or 'floating_ip_port_mappings_enable' in kwargs:
            pending_fields.append('floating_ip_port_mappings_enable')
        if len(args) > 5 or 'floating_ip_port_mappings' in kwargs:
            pending_fields.append('floating_ip_port_mappings')
        if len(args) > 6 or 'floating_ip_traffic_direction' in kwargs:
            pending_fields.append('floating_ip_traffic_direction')
        if len(args) > 7 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 8 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 9 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 10 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(FloatingIp, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            props_dict['floating_ip_address'] = kwargs[u'floating_ip_address']
        except KeyError:
            pass

        try:
            props_dict['floating_ip_is_virtual_ip'] = kwargs[u'floating_ip_is_virtual_ip']
        except KeyError:
            pass

        try:
            props_dict['floating_ip_fixed_ip_address'] = kwargs[u'floating_ip_fixed_ip_address']
        except KeyError:
            pass

        try:
            props_dict['floating_ip_address_family'] = kwargs[u'floating_ip_address_family']
        except KeyError:
            pass

        try:
            props_dict['floating_ip_port_mappings_enable'] = kwargs[u'floating_ip_port_mappings_enable']
        except KeyError:
            pass

        try:
            if kwargs['floating_ip_port_mappings'] is None:
                props_dict['floating_ip_port_mappings'] = None
            else:
                props_dict['floating_ip_port_mappings'] = vnc_api.gen.resource_xsd.PortMappings(params_dict=kwargs[u'floating_ip_port_mappings'])
        except KeyError:
            pass

        try:
            props_dict['floating_ip_traffic_direction'] = kwargs[u'floating_ip_traffic_direction']
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = FloatingIp(**props_dict)
        else:
            obj = FloatingIp(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.project_refs = kwargs[u'project_refs']
        except KeyError:
            pass
        try:
            obj.virtual_machine_interface_refs = kwargs[u'virtual_machine_interface_refs']
        except KeyError:
            pass
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.customer_attachment_back_refs = kwargs[u'customer_attachment_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.FloatingIp.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.FloatingIp.floating_ip_address.setter
    def floating_ip_address(self, floating_ip_address):
        """Set floating-ip-address for floating-ip.
        
        :param floating_ip_address: IpAddressType object
        
        """
        if 'floating_ip_address' not in self._pending_field_updates:
            self._pending_field_updates.add('floating_ip_address')

        self._floating_ip_address = floating_ip_address
    # end floating_ip_address

    def set_floating_ip_address(self, value):
        self.floating_ip_address = value
    # end set_floating_ip_address

    @vnc_api.gen.resource_common.FloatingIp.floating_ip_is_virtual_ip.setter
    def floating_ip_is_virtual_ip(self, floating_ip_is_virtual_ip):
        """Set floating-ip-is-virtual-ip for floating-ip.
        
        :param floating_ip_is_virtual_ip: xsd:boolean object
        
        """
        if 'floating_ip_is_virtual_ip' not in self._pending_field_updates:
            self._pending_field_updates.add('floating_ip_is_virtual_ip')

        self._floating_ip_is_virtual_ip = floating_ip_is_virtual_ip
    # end floating_ip_is_virtual_ip

    def set_floating_ip_is_virtual_ip(self, value):
        self.floating_ip_is_virtual_ip = value
    # end set_floating_ip_is_virtual_ip

    @vnc_api.gen.resource_common.FloatingIp.floating_ip_fixed_ip_address.setter
    def floating_ip_fixed_ip_address(self, floating_ip_fixed_ip_address):
        """Set floating-ip-fixed-ip-address for floating-ip.
        
        :param floating_ip_fixed_ip_address: IpAddressType object
        
        """
        if 'floating_ip_fixed_ip_address' not in self._pending_field_updates:
            self._pending_field_updates.add('floating_ip_fixed_ip_address')

        self._floating_ip_fixed_ip_address = floating_ip_fixed_ip_address
    # end floating_ip_fixed_ip_address

    def set_floating_ip_fixed_ip_address(self, value):
        self.floating_ip_fixed_ip_address = value
    # end set_floating_ip_fixed_ip_address

    @vnc_api.gen.resource_common.FloatingIp.floating_ip_address_family.setter
    def floating_ip_address_family(self, floating_ip_address_family):
        """Set floating-ip-address-family for floating-ip.
        
        :param floating_ip_address_family: IpAddressFamilyType object
        
        """
        if 'floating_ip_address_family' not in self._pending_field_updates:
            self._pending_field_updates.add('floating_ip_address_family')

        self._floating_ip_address_family = floating_ip_address_family
    # end floating_ip_address_family

    def set_floating_ip_address_family(self, value):
        self.floating_ip_address_family = value
    # end set_floating_ip_address_family

    @vnc_api.gen.resource_common.FloatingIp.floating_ip_port_mappings_enable.setter
    def floating_ip_port_mappings_enable(self, floating_ip_port_mappings_enable):
        """Set floating-ip-port-mappings-enable for floating-ip.
        
        :param floating_ip_port_mappings_enable: xsd:boolean object
        
        """
        if 'floating_ip_port_mappings_enable' not in self._pending_field_updates:
            self._pending_field_updates.add('floating_ip_port_mappings_enable')

        self._floating_ip_port_mappings_enable = floating_ip_port_mappings_enable
    # end floating_ip_port_mappings_enable

    def set_floating_ip_port_mappings_enable(self, value):
        self.floating_ip_port_mappings_enable = value
    # end set_floating_ip_port_mappings_enable

    @vnc_api.gen.resource_common.FloatingIp.floating_ip_port_mappings.setter
    def floating_ip_port_mappings(self, floating_ip_port_mappings):
        """Set floating-ip-port-mappings for floating-ip.
        
        :param floating_ip_port_mappings: PortMappings object
        
        """
        if 'floating_ip_port_mappings' not in self._pending_field_updates:
            self._pending_field_updates.add('floating_ip_port_mappings')

        if 'floating_ip_port_mappings' in self._pending_field_list_updates:
            # set clobbers earlier add/del on prop list elements
            del self._pending_field_list_updates['floating_ip_port_mappings']

        self._floating_ip_port_mappings = floating_ip_port_mappings
    # end floating_ip_port_mappings

    def set_floating_ip_port_mappings(self, value):
        self.floating_ip_port_mappings = value
    # end set_floating_ip_port_mappings

    @vnc_api.gen.resource_common.FloatingIp.floating_ip_traffic_direction.setter
    def floating_ip_traffic_direction(self, floating_ip_traffic_direction):
        """Set floating-ip-traffic-direction for floating-ip.
        
        :param floating_ip_traffic_direction: TrafficDirectionType object
        
        """
        if 'floating_ip_traffic_direction' not in self._pending_field_updates:
            self._pending_field_updates.add('floating_ip_traffic_direction')

        self._floating_ip_traffic_direction = floating_ip_traffic_direction
    # end floating_ip_traffic_direction

    def set_floating_ip_traffic_direction(self, value):
        self.floating_ip_traffic_direction = value
    # end set_floating_ip_traffic_direction

    @vnc_api.gen.resource_common.FloatingIp.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for floating-ip.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.FloatingIp.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for floating-ip.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.FloatingIp.annotations.setter
    def annotations(self, annotations):
        """Set annotations for floating-ip.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.FloatingIp.display_name.setter
    def display_name(self, display_name):
        """Set display-name for floating-ip.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_floating_ip_port_mappings(self, elem_value, elem_position=None):
        """Add element to floating-ip-port-mappings for floating-ip.
        
        :param elem_value: xsd:string object
        :param elem_position: optional string order-key
        
        """
        if 'floating_ip_port_mappings' not in self._pending_field_list_updates:
            self._pending_field_list_updates['floating_ip_port_mappings'] = [
                ('add', elem_value, elem_position)]
        else:
            self._pending_field_list_updates['floating_ip_port_mappings'].append(
                ('add', elem_value, elem_position))
    # end add_floating_ip_port_mappings

    def del_floating_ip_port_mappings(self, elem_position):
        """Delete element from floating-ip-port-mappings for floating-ip.
        
        :param elem_position: string indicating order-key
        
        """
        if 'floating_ip_port_mappings' not in self._pending_field_list_updates:
            self._pending_field_list_updates['floating_ip_port_mappings'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_list_updates['floating_ip_port_mappings'].append(
                ('delete', None, elem_position))
    # end del_floating_ip_port_mappings
    def add_annotations(self, elem):
        """Add element to annotations for floating-ip.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for floating-ip.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_project(self, *args, **kwargs):
        """Set project for floating-ip.
        
        :param ref_obj: Project object
        
        """
        self._pending_field_updates.add('project_refs')
        self._pending_ref_updates.discard('project_refs')
        super(FloatingIp, self).set_project(*args, **kwargs)

    # end set_project

    def add_project(self, *args, **kwargs):
        """Add project to floating-ip.
        
        :param ref_obj: Project object
        
        """
        if 'project_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('project_refs')
            self._original_project_refs = copy.deepcopy(self.get_project_refs() or [])
        super(FloatingIp, self).add_project(*args, **kwargs)
    # end add_project

    def del_project(self, *args, **kwargs):
        if 'project_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('project_refs')
            self._original_project_refs = copy.deepcopy(self.get_project_refs() or [])
        super(FloatingIp, self).del_project(*args, **kwargs)
    # end del_project

    def set_project_list(self, *args, **kwargs):
        """Set project list for floating-ip.
        
        :param ref_obj_list: list of Project object
        
        """
        self._pending_field_updates.add('project_refs')
        self._pending_ref_updates.discard('project_refs')
        super(FloatingIp, self).set_project_list(*args, **kwargs)
    # end set_project_list

    def set_virtual_machine_interface(self, *args, **kwargs):
        """Set virtual-machine-interface for floating-ip.
        
        :param ref_obj: VirtualMachineInterface object
        
        """
        self._pending_field_updates.add('virtual_machine_interface_refs')
        self._pending_ref_updates.discard('virtual_machine_interface_refs')
        super(FloatingIp, self).set_virtual_machine_interface(*args, **kwargs)

    # end set_virtual_machine_interface

    def add_virtual_machine_interface(self, *args, **kwargs):
        """Add virtual-machine-interface to floating-ip.
        
        :param ref_obj: VirtualMachineInterface object
        
        """
        if 'virtual_machine_interface_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('virtual_machine_interface_refs')
            self._original_virtual_machine_interface_refs = copy.deepcopy(self.get_virtual_machine_interface_refs() or [])
        super(FloatingIp, self).add_virtual_machine_interface(*args, **kwargs)
    # end add_virtual_machine_interface

    def del_virtual_machine_interface(self, *args, **kwargs):
        if 'virtual_machine_interface_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('virtual_machine_interface_refs')
            self._original_virtual_machine_interface_refs = copy.deepcopy(self.get_virtual_machine_interface_refs() or [])
        super(FloatingIp, self).del_virtual_machine_interface(*args, **kwargs)
    # end del_virtual_machine_interface

    def set_virtual_machine_interface_list(self, *args, **kwargs):
        """Set virtual-machine-interface list for floating-ip.
        
        :param ref_obj_list: list of VirtualMachineInterface object
        
        """
        self._pending_field_updates.add('virtual_machine_interface_refs')
        self._pending_ref_updates.discard('virtual_machine_interface_refs')
        super(FloatingIp, self).set_virtual_machine_interface_list(*args, **kwargs)
    # end set_virtual_machine_interface_list

    def set_tag(self, *args, **kwargs):
        """Set tag for floating-ip.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(FloatingIp, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to floating-ip.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(FloatingIp, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(FloatingIp, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for floating-ip.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(FloatingIp, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


    def get_customer_attachment_back_refs(self):
        """Return list of all customer-attachments using this floating-ip"""
        if hasattr(self, 'customer_attachment_back_refs'):
            return self.customer_attachment_back_refs

        if hasattr(super(FloatingIp, self), 'customer_attachment_back_refs'):
            return super(FloatingIp, self).get_customer_attachment_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.floating_ip_read(id = self.uuid, fields = ['customer_attachment_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'customer_attachment_back_refs', None)
        if not back_refs:
            return None
        self.customer_attachment_back_refs = back_refs

        return back_refs
    # end get_customer_attachment_back_refs

# end class FloatingIp

class LinkAggregationGroup(vnc_api.gen.resource_common.LinkAggregationGroup):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'link_aggregation_group_lacp_enabled' in kwargs:
            pending_fields.append('link_aggregation_group_lacp_enabled')
        if len(args) > 1 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 2 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 3 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 4 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(LinkAggregationGroup, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            props_dict['link_aggregation_group_lacp_enabled'] = kwargs[u'link_aggregation_group_lacp_enabled']
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = LinkAggregationGroup(**props_dict)
        else:
            obj = LinkAggregationGroup(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.physical_interface_refs = kwargs[u'physical_interface_refs']
        except KeyError:
            pass
        try:
            obj.virtual_machine_interface_refs = kwargs[u'virtual_machine_interface_refs']
        except KeyError:
            pass
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.LinkAggregationGroup.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.LinkAggregationGroup.link_aggregation_group_lacp_enabled.setter
    def link_aggregation_group_lacp_enabled(self, link_aggregation_group_lacp_enabled):
        """Set link-aggregation-group-lacp-enabled for link-aggregation-group.
        
        :param link_aggregation_group_lacp_enabled: xsd:boolean object
        
        """
        if 'link_aggregation_group_lacp_enabled' not in self._pending_field_updates:
            self._pending_field_updates.add('link_aggregation_group_lacp_enabled')

        self._link_aggregation_group_lacp_enabled = link_aggregation_group_lacp_enabled
    # end link_aggregation_group_lacp_enabled

    def set_link_aggregation_group_lacp_enabled(self, value):
        self.link_aggregation_group_lacp_enabled = value
    # end set_link_aggregation_group_lacp_enabled

    @vnc_api.gen.resource_common.LinkAggregationGroup.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for link-aggregation-group.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.LinkAggregationGroup.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for link-aggregation-group.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.LinkAggregationGroup.annotations.setter
    def annotations(self, annotations):
        """Set annotations for link-aggregation-group.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.LinkAggregationGroup.display_name.setter
    def display_name(self, display_name):
        """Set display-name for link-aggregation-group.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for link-aggregation-group.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for link-aggregation-group.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_physical_interface(self, *args, **kwargs):
        """Set physical-interface for link-aggregation-group.
        
        :param ref_obj: PhysicalInterface object
        
        """
        self._pending_field_updates.add('physical_interface_refs')
        self._pending_ref_updates.discard('physical_interface_refs')
        super(LinkAggregationGroup, self).set_physical_interface(*args, **kwargs)

    # end set_physical_interface

    def add_physical_interface(self, *args, **kwargs):
        """Add physical-interface to link-aggregation-group.
        
        :param ref_obj: PhysicalInterface object
        
        """
        if 'physical_interface_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('physical_interface_refs')
            self._original_physical_interface_refs = copy.deepcopy(self.get_physical_interface_refs() or [])
        super(LinkAggregationGroup, self).add_physical_interface(*args, **kwargs)
    # end add_physical_interface

    def del_physical_interface(self, *args, **kwargs):
        if 'physical_interface_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('physical_interface_refs')
            self._original_physical_interface_refs = copy.deepcopy(self.get_physical_interface_refs() or [])
        super(LinkAggregationGroup, self).del_physical_interface(*args, **kwargs)
    # end del_physical_interface

    def set_physical_interface_list(self, *args, **kwargs):
        """Set physical-interface list for link-aggregation-group.
        
        :param ref_obj_list: list of PhysicalInterface object
        
        """
        self._pending_field_updates.add('physical_interface_refs')
        self._pending_ref_updates.discard('physical_interface_refs')
        super(LinkAggregationGroup, self).set_physical_interface_list(*args, **kwargs)
    # end set_physical_interface_list

    def set_virtual_machine_interface(self, *args, **kwargs):
        """Set virtual-machine-interface for link-aggregation-group.
        
        :param ref_obj: VirtualMachineInterface object
        
        """
        self._pending_field_updates.add('virtual_machine_interface_refs')
        self._pending_ref_updates.discard('virtual_machine_interface_refs')
        super(LinkAggregationGroup, self).set_virtual_machine_interface(*args, **kwargs)

    # end set_virtual_machine_interface

    def add_virtual_machine_interface(self, *args, **kwargs):
        """Add virtual-machine-interface to link-aggregation-group.
        
        :param ref_obj: VirtualMachineInterface object
        
        """
        if 'virtual_machine_interface_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('virtual_machine_interface_refs')
            self._original_virtual_machine_interface_refs = copy.deepcopy(self.get_virtual_machine_interface_refs() or [])
        super(LinkAggregationGroup, self).add_virtual_machine_interface(*args, **kwargs)
    # end add_virtual_machine_interface

    def del_virtual_machine_interface(self, *args, **kwargs):
        if 'virtual_machine_interface_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('virtual_machine_interface_refs')
            self._original_virtual_machine_interface_refs = copy.deepcopy(self.get_virtual_machine_interface_refs() or [])
        super(LinkAggregationGroup, self).del_virtual_machine_interface(*args, **kwargs)
    # end del_virtual_machine_interface

    def set_virtual_machine_interface_list(self, *args, **kwargs):
        """Set virtual-machine-interface list for link-aggregation-group.
        
        :param ref_obj_list: list of VirtualMachineInterface object
        
        """
        self._pending_field_updates.add('virtual_machine_interface_refs')
        self._pending_ref_updates.discard('virtual_machine_interface_refs')
        super(LinkAggregationGroup, self).set_virtual_machine_interface_list(*args, **kwargs)
    # end set_virtual_machine_interface_list

    def set_tag(self, *args, **kwargs):
        """Set tag for link-aggregation-group.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(LinkAggregationGroup, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to link-aggregation-group.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(LinkAggregationGroup, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(LinkAggregationGroup, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for link-aggregation-group.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(LinkAggregationGroup, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


# end class LinkAggregationGroup

class VirtualRouter(vnc_api.gen.resource_common.VirtualRouter):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'virtual_router_type' in kwargs:
            pending_fields.append('virtual_router_type')
        if len(args) > 1 or 'virtual_router_dpdk_enabled' in kwargs:
            pending_fields.append('virtual_router_dpdk_enabled')
        if len(args) > 2 or 'virtual_router_ip_address' in kwargs:
            pending_fields.append('virtual_router_ip_address')
        if len(args) > 3 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 4 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 5 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 6 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(VirtualRouter, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            props_dict['virtual_router_type'] = kwargs[u'virtual_router_type']
        except KeyError:
            pass

        try:
            props_dict['virtual_router_dpdk_enabled'] = kwargs[u'virtual_router_dpdk_enabled']
        except KeyError:
            pass

        try:
            props_dict['virtual_router_ip_address'] = kwargs[u'virtual_router_ip_address']
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = VirtualRouter(**props_dict)
        else:
            obj = VirtualRouter(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...
        try:
            obj.virtual_machine_interfaces = kwargs[u'virtual_machine_interfaces']
        except KeyError:
            pass

        # add any specified references...
        try:
            obj.network_ipam_refs = kwargs[u'network_ipam_refs']
            for ref in obj.network_ipam_refs:
                ref['attr'] = vnc_api.gen.resource_xsd.VirtualRouterNetworkIpamType(params_dict=ref[u'attr'])
        except KeyError:
            pass
        try:
            obj.sub_cluster_refs = kwargs[u'sub_cluster_refs']
        except KeyError:
            pass
        try:
            obj.virtual_machine_refs = kwargs[u'virtual_machine_refs']
        except KeyError:
            pass
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.instance_ip_back_refs = kwargs[u'instance_ip_back_refs']
        except KeyError:
            pass
        try:
            obj.physical_router_back_refs = kwargs[u'physical_router_back_refs']
        except KeyError:
            pass
        try:
            obj.provider_attachment_back_refs = kwargs[u'provider_attachment_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.VirtualRouter.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.VirtualRouter.virtual_router_type.setter
    def virtual_router_type(self, virtual_router_type):
        """Set virtual-router-type for virtual-router.
        
        :param virtual_router_type: VirtualRouterType object
        
        """
        if 'virtual_router_type' not in self._pending_field_updates:
            self._pending_field_updates.add('virtual_router_type')

        self._virtual_router_type = virtual_router_type
    # end virtual_router_type

    def set_virtual_router_type(self, value):
        self.virtual_router_type = value
    # end set_virtual_router_type

    @vnc_api.gen.resource_common.VirtualRouter.virtual_router_dpdk_enabled.setter
    def virtual_router_dpdk_enabled(self, virtual_router_dpdk_enabled):
        """Set virtual-router-dpdk-enabled for virtual-router.
        
        :param virtual_router_dpdk_enabled: xsd:boolean object
        
        """
        if 'virtual_router_dpdk_enabled' not in self._pending_field_updates:
            self._pending_field_updates.add('virtual_router_dpdk_enabled')

        self._virtual_router_dpdk_enabled = virtual_router_dpdk_enabled
    # end virtual_router_dpdk_enabled

    def set_virtual_router_dpdk_enabled(self, value):
        self.virtual_router_dpdk_enabled = value
    # end set_virtual_router_dpdk_enabled

    @vnc_api.gen.resource_common.VirtualRouter.virtual_router_ip_address.setter
    def virtual_router_ip_address(self, virtual_router_ip_address):
        """Set virtual-router-ip-address for virtual-router.
        
        :param virtual_router_ip_address: IpAddressType object
        
        """
        if 'virtual_router_ip_address' not in self._pending_field_updates:
            self._pending_field_updates.add('virtual_router_ip_address')

        self._virtual_router_ip_address = virtual_router_ip_address
    # end virtual_router_ip_address

    def set_virtual_router_ip_address(self, value):
        self.virtual_router_ip_address = value
    # end set_virtual_router_ip_address

    @vnc_api.gen.resource_common.VirtualRouter.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for virtual-router.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.VirtualRouter.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for virtual-router.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.VirtualRouter.annotations.setter
    def annotations(self, annotations):
        """Set annotations for virtual-router.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.VirtualRouter.display_name.setter
    def display_name(self, display_name):
        """Set display-name for virtual-router.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for virtual-router.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for virtual-router.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_network_ipam(self, *args, **kwargs):
        """Set network-ipam for virtual-router.
        
        :param ref_obj: NetworkIpam object
        :param ref_data: VirtualRouterNetworkIpamType object
        
        """
        self._pending_field_updates.add('network_ipam_refs')
        self._pending_ref_updates.discard('network_ipam_refs')
        super(VirtualRouter, self).set_network_ipam(*args, **kwargs)

    # end set_network_ipam

    def add_network_ipam(self, *args, **kwargs):
        """Add network-ipam to virtual-router.
        
        :param ref_obj: NetworkIpam object
        :param ref_data: VirtualRouterNetworkIpamType object
        
        """
        if 'network_ipam_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('network_ipam_refs')
            self._original_network_ipam_refs = copy.deepcopy(self.get_network_ipam_refs() or [])
        super(VirtualRouter, self).add_network_ipam(*args, **kwargs)
    # end add_network_ipam

    def del_network_ipam(self, *args, **kwargs):
        if 'network_ipam_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('network_ipam_refs')
            self._original_network_ipam_refs = copy.deepcopy(self.get_network_ipam_refs() or [])
        super(VirtualRouter, self).del_network_ipam(*args, **kwargs)
    # end del_network_ipam

    def set_network_ipam_list(self, *args, **kwargs):
        """Set network-ipam list for virtual-router.
        
        :param ref_obj_list: list of NetworkIpam object
        :param ref_data_list: list of VirtualRouterNetworkIpamType summary
        
        """
        self._pending_field_updates.add('network_ipam_refs')
        self._pending_ref_updates.discard('network_ipam_refs')
        super(VirtualRouter, self).set_network_ipam_list(*args, **kwargs)
    # end set_network_ipam_list

    def set_sub_cluster(self, *args, **kwargs):
        """Set sub-cluster for virtual-router.
        
        :param ref_obj: SubCluster object
        
        """
        self._pending_field_updates.add('sub_cluster_refs')
        self._pending_ref_updates.discard('sub_cluster_refs')
        super(VirtualRouter, self).set_sub_cluster(*args, **kwargs)

    # end set_sub_cluster

    def add_sub_cluster(self, *args, **kwargs):
        """Add sub-cluster to virtual-router.
        
        :param ref_obj: SubCluster object
        
        """
        if 'sub_cluster_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('sub_cluster_refs')
            self._original_sub_cluster_refs = copy.deepcopy(self.get_sub_cluster_refs() or [])
        super(VirtualRouter, self).add_sub_cluster(*args, **kwargs)
    # end add_sub_cluster

    def del_sub_cluster(self, *args, **kwargs):
        if 'sub_cluster_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('sub_cluster_refs')
            self._original_sub_cluster_refs = copy.deepcopy(self.get_sub_cluster_refs() or [])
        super(VirtualRouter, self).del_sub_cluster(*args, **kwargs)
    # end del_sub_cluster

    def set_sub_cluster_list(self, *args, **kwargs):
        """Set sub-cluster list for virtual-router.
        
        :param ref_obj_list: list of SubCluster object
        
        """
        self._pending_field_updates.add('sub_cluster_refs')
        self._pending_ref_updates.discard('sub_cluster_refs')
        super(VirtualRouter, self).set_sub_cluster_list(*args, **kwargs)
    # end set_sub_cluster_list

    def set_virtual_machine(self, *args, **kwargs):
        """Set virtual-machine for virtual-router.
        
        :param ref_obj: VirtualMachine object
        
        """
        self._pending_field_updates.add('virtual_machine_refs')
        self._pending_ref_updates.discard('virtual_machine_refs')
        super(VirtualRouter, self).set_virtual_machine(*args, **kwargs)

    # end set_virtual_machine

    def add_virtual_machine(self, *args, **kwargs):
        """Add virtual-machine to virtual-router.
        
        :param ref_obj: VirtualMachine object
        
        """
        if 'virtual_machine_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('virtual_machine_refs')
            self._original_virtual_machine_refs = copy.deepcopy(self.get_virtual_machine_refs() or [])
        super(VirtualRouter, self).add_virtual_machine(*args, **kwargs)
    # end add_virtual_machine

    def del_virtual_machine(self, *args, **kwargs):
        if 'virtual_machine_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('virtual_machine_refs')
            self._original_virtual_machine_refs = copy.deepcopy(self.get_virtual_machine_refs() or [])
        super(VirtualRouter, self).del_virtual_machine(*args, **kwargs)
    # end del_virtual_machine

    def set_virtual_machine_list(self, *args, **kwargs):
        """Set virtual-machine list for virtual-router.
        
        :param ref_obj_list: list of VirtualMachine object
        
        """
        self._pending_field_updates.add('virtual_machine_refs')
        self._pending_ref_updates.discard('virtual_machine_refs')
        super(VirtualRouter, self).set_virtual_machine_list(*args, **kwargs)
    # end set_virtual_machine_list

    def set_tag(self, *args, **kwargs):
        """Set tag for virtual-router.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(VirtualRouter, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to virtual-router.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(VirtualRouter, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(VirtualRouter, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for virtual-router.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(VirtualRouter, self).set_tag_list(*args, **kwargs)
    # end set_tag_list

    def get_virtual_machine_interfaces(self):
        if hasattr(self, 'virtual_machine_interfaces'):
            return self.virtual_machine_interfaces

        if hasattr(super(VirtualRouter, self), 'virtual_machine_interfaces'):
            return super(VirtualRouter, self).get_virtual_machine_interfaces()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.virtual_router_read(id = self.uuid, fields = ['virtual_machine_interfaces'])
        except NoIdError:
            return None
        children = getattr(obj, 'virtual_machine_interfaces', None)
        if not children:
            return None
        self.virtual_machine_interfaces = children

        return children
    # end get_virtual_machine_interfaces


    def get_instance_ip_back_refs(self):
        """Return list of all instance-ips using this virtual-router"""
        if hasattr(self, 'instance_ip_back_refs'):
            return self.instance_ip_back_refs

        if hasattr(super(VirtualRouter, self), 'instance_ip_back_refs'):
            return super(VirtualRouter, self).get_instance_ip_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.virtual_router_read(id = self.uuid, fields = ['instance_ip_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'instance_ip_back_refs', None)
        if not back_refs:
            return None
        self.instance_ip_back_refs = back_refs

        return back_refs
    # end get_instance_ip_back_refs

    def get_physical_router_back_refs(self):
        """Return list of all physical-routers using this virtual-router"""
        if hasattr(self, 'physical_router_back_refs'):
            return self.physical_router_back_refs

        if hasattr(super(VirtualRouter, self), 'physical_router_back_refs'):
            return super(VirtualRouter, self).get_physical_router_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.virtual_router_read(id = self.uuid, fields = ['physical_router_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'physical_router_back_refs', None)
        if not back_refs:
            return None
        self.physical_router_back_refs = back_refs

        return back_refs
    # end get_physical_router_back_refs

    def get_provider_attachment_back_refs(self):
        """Return list of all provider-attachments using this virtual-router"""
        if hasattr(self, 'provider_attachment_back_refs'):
            return self.provider_attachment_back_refs

        if hasattr(super(VirtualRouter, self), 'provider_attachment_back_refs'):
            return super(VirtualRouter, self).get_provider_attachment_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.virtual_router_read(id = self.uuid, fields = ['provider_attachment_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'provider_attachment_back_refs', None)
        if not back_refs:
            return None
        self.provider_attachment_back_refs = back_refs

        return back_refs
    # end get_provider_attachment_back_refs

# end class VirtualRouter

class PortProfile(vnc_api.gen.resource_common.PortProfile):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 1 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 2 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 3 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(PortProfile, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = PortProfile(**props_dict)
        else:
            obj = PortProfile(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.storm_control_profile_refs = kwargs[u'storm_control_profile_refs']
        except KeyError:
            pass
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.virtual_machine_interface_back_refs = kwargs[u'virtual_machine_interface_back_refs']
        except KeyError:
            pass
        try:
            obj.virtual_port_group_back_refs = kwargs[u'virtual_port_group_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.PortProfile.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.PortProfile.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for port-profile.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.PortProfile.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for port-profile.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.PortProfile.annotations.setter
    def annotations(self, annotations):
        """Set annotations for port-profile.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.PortProfile.display_name.setter
    def display_name(self, display_name):
        """Set display-name for port-profile.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for port-profile.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for port-profile.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_storm_control_profile(self, *args, **kwargs):
        """Set storm-control-profile for port-profile.
        
        :param ref_obj: StormControlProfile object
        
        """
        self._pending_field_updates.add('storm_control_profile_refs')
        self._pending_ref_updates.discard('storm_control_profile_refs')
        super(PortProfile, self).set_storm_control_profile(*args, **kwargs)

    # end set_storm_control_profile

    def add_storm_control_profile(self, *args, **kwargs):
        """Add storm-control-profile to port-profile.
        
        :param ref_obj: StormControlProfile object
        
        """
        if 'storm_control_profile_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('storm_control_profile_refs')
            self._original_storm_control_profile_refs = copy.deepcopy(self.get_storm_control_profile_refs() or [])
        super(PortProfile, self).add_storm_control_profile(*args, **kwargs)
    # end add_storm_control_profile

    def del_storm_control_profile(self, *args, **kwargs):
        if 'storm_control_profile_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('storm_control_profile_refs')
            self._original_storm_control_profile_refs = copy.deepcopy(self.get_storm_control_profile_refs() or [])
        super(PortProfile, self).del_storm_control_profile(*args, **kwargs)
    # end del_storm_control_profile

    def set_storm_control_profile_list(self, *args, **kwargs):
        """Set storm-control-profile list for port-profile.
        
        :param ref_obj_list: list of StormControlProfile object
        
        """
        self._pending_field_updates.add('storm_control_profile_refs')
        self._pending_ref_updates.discard('storm_control_profile_refs')
        super(PortProfile, self).set_storm_control_profile_list(*args, **kwargs)
    # end set_storm_control_profile_list

    def set_tag(self, *args, **kwargs):
        """Set tag for port-profile.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(PortProfile, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to port-profile.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(PortProfile, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(PortProfile, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for port-profile.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(PortProfile, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


    def get_virtual_machine_interface_back_refs(self):
        """Return list of all virtual-machine-interfaces using this port-profile"""
        if hasattr(self, 'virtual_machine_interface_back_refs'):
            return self.virtual_machine_interface_back_refs

        if hasattr(super(PortProfile, self), 'virtual_machine_interface_back_refs'):
            return super(PortProfile, self).get_virtual_machine_interface_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.port_profile_read(id = self.uuid, fields = ['virtual_machine_interface_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'virtual_machine_interface_back_refs', None)
        if not back_refs:
            return None
        self.virtual_machine_interface_back_refs = back_refs

        return back_refs
    # end get_virtual_machine_interface_back_refs

    def get_virtual_port_group_back_refs(self):
        """Return list of all virtual-port-groups using this port-profile"""
        if hasattr(self, 'virtual_port_group_back_refs'):
            return self.virtual_port_group_back_refs

        if hasattr(super(PortProfile, self), 'virtual_port_group_back_refs'):
            return super(PortProfile, self).get_virtual_port_group_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.port_profile_read(id = self.uuid, fields = ['virtual_port_group_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'virtual_port_group_back_refs', None)
        if not back_refs:
            return None
        self.virtual_port_group_back_refs = back_refs

        return back_refs
    # end get_virtual_port_group_back_refs

# end class PortProfile

class PolicyManagement(vnc_api.gen.resource_common.PolicyManagement):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 1 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 2 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 3 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(PolicyManagement, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = PolicyManagement(**props_dict)
        else:
            obj = PolicyManagement(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...
        try:
            obj.service_groups = kwargs[u'service_groups']
        except KeyError:
            pass
        try:
            obj.address_groups = kwargs[u'address_groups']
        except KeyError:
            pass
        try:
            obj.firewall_rules = kwargs[u'firewall_rules']
        except KeyError:
            pass
        try:
            obj.firewall_policys = kwargs[u'firewall_policys']
        except KeyError:
            pass
        try:
            obj.application_policy_sets = kwargs[u'application_policy_sets']
        except KeyError:
            pass

        # add any specified references...
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.PolicyManagement.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.PolicyManagement.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for policy-management.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.PolicyManagement.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for policy-management.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.PolicyManagement.annotations.setter
    def annotations(self, annotations):
        """Set annotations for policy-management.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.PolicyManagement.display_name.setter
    def display_name(self, display_name):
        """Set display-name for policy-management.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for policy-management.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for policy-management.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_tag(self, *args, **kwargs):
        """Set tag for policy-management.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(PolicyManagement, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to policy-management.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(PolicyManagement, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(PolicyManagement, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for policy-management.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(PolicyManagement, self).set_tag_list(*args, **kwargs)
    # end set_tag_list

    def get_service_groups(self):
        if hasattr(self, 'service_groups'):
            return self.service_groups

        if hasattr(super(PolicyManagement, self), 'service_groups'):
            return super(PolicyManagement, self).get_service_groups()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.policy_management_read(id = self.uuid, fields = ['service_groups'])
        except NoIdError:
            return None
        children = getattr(obj, 'service_groups', None)
        if not children:
            return None
        self.service_groups = children

        return children
    # end get_service_groups

    def get_address_groups(self):
        if hasattr(self, 'address_groups'):
            return self.address_groups

        if hasattr(super(PolicyManagement, self), 'address_groups'):
            return super(PolicyManagement, self).get_address_groups()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.policy_management_read(id = self.uuid, fields = ['address_groups'])
        except NoIdError:
            return None
        children = getattr(obj, 'address_groups', None)
        if not children:
            return None
        self.address_groups = children

        return children
    # end get_address_groups

    def get_firewall_rules(self):
        if hasattr(self, 'firewall_rules'):
            return self.firewall_rules

        if hasattr(super(PolicyManagement, self), 'firewall_rules'):
            return super(PolicyManagement, self).get_firewall_rules()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.policy_management_read(id = self.uuid, fields = ['firewall_rules'])
        except NoIdError:
            return None
        children = getattr(obj, 'firewall_rules', None)
        if not children:
            return None
        self.firewall_rules = children

        return children
    # end get_firewall_rules

    def get_firewall_policys(self):
        if hasattr(self, 'firewall_policys'):
            return self.firewall_policys

        if hasattr(super(PolicyManagement, self), 'firewall_policys'):
            return super(PolicyManagement, self).get_firewall_policys()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.policy_management_read(id = self.uuid, fields = ['firewall_policys'])
        except NoIdError:
            return None
        children = getattr(obj, 'firewall_policys', None)
        if not children:
            return None
        self.firewall_policys = children

        return children
    # end get_firewall_policys

    def get_application_policy_sets(self):
        if hasattr(self, 'application_policy_sets'):
            return self.application_policy_sets

        if hasattr(super(PolicyManagement, self), 'application_policy_sets'):
            return super(PolicyManagement, self).get_application_policy_sets()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.policy_management_read(id = self.uuid, fields = ['application_policy_sets'])
        except NoIdError:
            return None
        children = getattr(obj, 'application_policy_sets', None)
        if not children:
            return None
        self.application_policy_sets = children

        return children
    # end get_application_policy_sets


# end class PolicyManagement

class E2ServiceProvider(vnc_api.gen.resource_common.E2ServiceProvider):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, *args, **kwargs):
        pending_fields = ['fq_name']

        self._server_conn = None

        if len(args) > 0 or 'e2_service_provider_promiscuous' in kwargs:
            pending_fields.append('e2_service_provider_promiscuous')
        if len(args) > 1 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 2 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 3 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 4 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(E2ServiceProvider, self).__init__(name, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            props_dict['e2_service_provider_promiscuous'] = kwargs[u'e2_service_provider_promiscuous']
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = E2ServiceProvider(**props_dict)
        else:
            obj = E2ServiceProvider(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.peering_policy_refs = kwargs[u'peering_policy_refs']
        except KeyError:
            pass
        try:
            obj.physical_router_refs = kwargs[u'physical_router_refs']
        except KeyError:
            pass
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.E2ServiceProvider.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.E2ServiceProvider.e2_service_provider_promiscuous.setter
    def e2_service_provider_promiscuous(self, e2_service_provider_promiscuous):
        """Set e2-service-provider-promiscuous for e2-service-provider.
        
        :param e2_service_provider_promiscuous: xsd:boolean object
        
        """
        if 'e2_service_provider_promiscuous' not in self._pending_field_updates:
            self._pending_field_updates.add('e2_service_provider_promiscuous')

        self._e2_service_provider_promiscuous = e2_service_provider_promiscuous
    # end e2_service_provider_promiscuous

    def set_e2_service_provider_promiscuous(self, value):
        self.e2_service_provider_promiscuous = value
    # end set_e2_service_provider_promiscuous

    @vnc_api.gen.resource_common.E2ServiceProvider.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for e2-service-provider.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.E2ServiceProvider.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for e2-service-provider.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.E2ServiceProvider.annotations.setter
    def annotations(self, annotations):
        """Set annotations for e2-service-provider.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.E2ServiceProvider.display_name.setter
    def display_name(self, display_name):
        """Set display-name for e2-service-provider.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for e2-service-provider.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for e2-service-provider.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_peering_policy(self, *args, **kwargs):
        """Set peering-policy for e2-service-provider.
        
        :param ref_obj: PeeringPolicy object
        
        """
        self._pending_field_updates.add('peering_policy_refs')
        self._pending_ref_updates.discard('peering_policy_refs')
        super(E2ServiceProvider, self).set_peering_policy(*args, **kwargs)

    # end set_peering_policy

    def add_peering_policy(self, *args, **kwargs):
        """Add peering-policy to e2-service-provider.
        
        :param ref_obj: PeeringPolicy object
        
        """
        if 'peering_policy_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('peering_policy_refs')
            self._original_peering_policy_refs = copy.deepcopy(self.get_peering_policy_refs() or [])
        super(E2ServiceProvider, self).add_peering_policy(*args, **kwargs)
    # end add_peering_policy

    def del_peering_policy(self, *args, **kwargs):
        if 'peering_policy_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('peering_policy_refs')
            self._original_peering_policy_refs = copy.deepcopy(self.get_peering_policy_refs() or [])
        super(E2ServiceProvider, self).del_peering_policy(*args, **kwargs)
    # end del_peering_policy

    def set_peering_policy_list(self, *args, **kwargs):
        """Set peering-policy list for e2-service-provider.
        
        :param ref_obj_list: list of PeeringPolicy object
        
        """
        self._pending_field_updates.add('peering_policy_refs')
        self._pending_ref_updates.discard('peering_policy_refs')
        super(E2ServiceProvider, self).set_peering_policy_list(*args, **kwargs)
    # end set_peering_policy_list

    def set_physical_router(self, *args, **kwargs):
        """Set physical-router for e2-service-provider.
        
        :param ref_obj: PhysicalRouter object
        
        """
        self._pending_field_updates.add('physical_router_refs')
        self._pending_ref_updates.discard('physical_router_refs')
        super(E2ServiceProvider, self).set_physical_router(*args, **kwargs)

    # end set_physical_router

    def add_physical_router(self, *args, **kwargs):
        """Add physical-router to e2-service-provider.
        
        :param ref_obj: PhysicalRouter object
        
        """
        if 'physical_router_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('physical_router_refs')
            self._original_physical_router_refs = copy.deepcopy(self.get_physical_router_refs() or [])
        super(E2ServiceProvider, self).add_physical_router(*args, **kwargs)
    # end add_physical_router

    def del_physical_router(self, *args, **kwargs):
        if 'physical_router_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('physical_router_refs')
            self._original_physical_router_refs = copy.deepcopy(self.get_physical_router_refs() or [])
        super(E2ServiceProvider, self).del_physical_router(*args, **kwargs)
    # end del_physical_router

    def set_physical_router_list(self, *args, **kwargs):
        """Set physical-router list for e2-service-provider.
        
        :param ref_obj_list: list of PhysicalRouter object
        
        """
        self._pending_field_updates.add('physical_router_refs')
        self._pending_ref_updates.discard('physical_router_refs')
        super(E2ServiceProvider, self).set_physical_router_list(*args, **kwargs)
    # end set_physical_router_list

    def set_tag(self, *args, **kwargs):
        """Set tag for e2-service-provider.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(E2ServiceProvider, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to e2-service-provider.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(E2ServiceProvider, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(E2ServiceProvider, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for e2-service-provider.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(E2ServiceProvider, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


# end class E2ServiceProvider

class Fabric(vnc_api.gen.resource_common.Fabric):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'fabric_ztp' in kwargs:
            pending_fields.append('fabric_ztp')
        if len(args) > 1 or 'fabric_os_version' in kwargs:
            pending_fields.append('fabric_os_version')
        if len(args) > 2 or 'fabric_credentials' in kwargs:
            pending_fields.append('fabric_credentials')
        if len(args) > 3 or 'fabric_enterprise_style' in kwargs:
            pending_fields.append('fabric_enterprise_style')
        if len(args) > 4 or 'disable_vlan_vn_uniqueness_check' in kwargs:
            pending_fields.append('disable_vlan_vn_uniqueness_check')
        if len(args) > 5 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 6 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 7 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 8 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(Fabric, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            props_dict['fabric_ztp'] = kwargs[u'fabric_ztp']
        except KeyError:
            pass

        try:
            props_dict['fabric_os_version'] = kwargs[u'fabric_os_version']
        except KeyError:
            pass

        try:
            if kwargs['fabric_credentials'] is None:
                props_dict['fabric_credentials'] = None
            else:
                props_dict['fabric_credentials'] = vnc_api.gen.resource_xsd.DeviceCredentialList(params_dict=kwargs[u'fabric_credentials'])
        except KeyError:
            pass

        try:
            props_dict['fabric_enterprise_style'] = kwargs[u'fabric_enterprise_style']
        except KeyError:
            pass

        try:
            props_dict['disable_vlan_vn_uniqueness_check'] = kwargs[u'disable_vlan_vn_uniqueness_check']
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = Fabric(**props_dict)
        else:
            obj = Fabric(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...
        try:
            obj.fabric_namespaces = kwargs[u'fabric_namespaces']
        except KeyError:
            pass
        try:
            obj.virtual_port_groups = kwargs[u'virtual_port_groups']
        except KeyError:
            pass

        # add any specified references...
        try:
            obj.intent_map_refs = kwargs[u'intent_map_refs']
        except KeyError:
            pass
        try:
            obj.virtual_network_refs = kwargs[u'virtual_network_refs']
            for ref in obj.virtual_network_refs:
                ref['attr'] = vnc_api.gen.resource_xsd.FabricNetworkTag(params_dict=ref[u'attr'])
        except KeyError:
            pass
        try:
            obj.node_profile_refs = kwargs[u'node_profile_refs']
            for ref in obj.node_profile_refs:
                ref['attr'] = vnc_api.gen.resource_xsd.SerialNumListType(params_dict=ref[u'attr'])
        except KeyError:
            pass
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.physical_router_back_refs = kwargs[u'physical_router_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.Fabric.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.Fabric.fabric_ztp.setter
    def fabric_ztp(self, fabric_ztp):
        """Set fabric-ztp for fabric.
        
        :param fabric_ztp: xsd:boolean object
        
        """
        if 'fabric_ztp' not in self._pending_field_updates:
            self._pending_field_updates.add('fabric_ztp')

        self._fabric_ztp = fabric_ztp
    # end fabric_ztp

    def set_fabric_ztp(self, value):
        self.fabric_ztp = value
    # end set_fabric_ztp

    @vnc_api.gen.resource_common.Fabric.fabric_os_version.setter
    def fabric_os_version(self, fabric_os_version):
        """Set fabric-os-version for fabric.
        
        :param fabric_os_version: xsd:string object
        
        """
        if 'fabric_os_version' not in self._pending_field_updates:
            self._pending_field_updates.add('fabric_os_version')

        self._fabric_os_version = fabric_os_version
    # end fabric_os_version

    def set_fabric_os_version(self, value):
        self.fabric_os_version = value
    # end set_fabric_os_version

    @vnc_api.gen.resource_common.Fabric.fabric_credentials.setter
    def fabric_credentials(self, fabric_credentials):
        """Set fabric-credentials for fabric.
        
        :param fabric_credentials: DeviceCredentialList object
        
        """
        if 'fabric_credentials' not in self._pending_field_updates:
            self._pending_field_updates.add('fabric_credentials')

        if 'fabric_credentials' in self._pending_field_list_updates:
            # set clobbers earlier add/del on prop list elements
            del self._pending_field_list_updates['fabric_credentials']

        self._fabric_credentials = fabric_credentials
    # end fabric_credentials

    def set_fabric_credentials(self, value):
        self.fabric_credentials = value
    # end set_fabric_credentials

    @vnc_api.gen.resource_common.Fabric.fabric_enterprise_style.setter
    def fabric_enterprise_style(self, fabric_enterprise_style):
        """Set fabric-enterprise-style for fabric.
        
        :param fabric_enterprise_style: xsd:boolean object
        
        """
        if 'fabric_enterprise_style' not in self._pending_field_updates:
            self._pending_field_updates.add('fabric_enterprise_style')

        self._fabric_enterprise_style = fabric_enterprise_style
    # end fabric_enterprise_style

    def set_fabric_enterprise_style(self, value):
        self.fabric_enterprise_style = value
    # end set_fabric_enterprise_style

    @vnc_api.gen.resource_common.Fabric.disable_vlan_vn_uniqueness_check.setter
    def disable_vlan_vn_uniqueness_check(self, disable_vlan_vn_uniqueness_check):
        """Set disable-vlan-vn-uniqueness-check for fabric.
        
        :param disable_vlan_vn_uniqueness_check: xsd:boolean object
        
        """
        if 'disable_vlan_vn_uniqueness_check' not in self._pending_field_updates:
            self._pending_field_updates.add('disable_vlan_vn_uniqueness_check')

        self._disable_vlan_vn_uniqueness_check = disable_vlan_vn_uniqueness_check
    # end disable_vlan_vn_uniqueness_check

    def set_disable_vlan_vn_uniqueness_check(self, value):
        self.disable_vlan_vn_uniqueness_check = value
    # end set_disable_vlan_vn_uniqueness_check

    @vnc_api.gen.resource_common.Fabric.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for fabric.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.Fabric.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for fabric.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.Fabric.annotations.setter
    def annotations(self, annotations):
        """Set annotations for fabric.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.Fabric.display_name.setter
    def display_name(self, display_name):
        """Set display-name for fabric.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_fabric_credentials(self, elem_value, elem_position=None):
        """Add element to fabric-credentials for fabric.
        
        :param elem_value: xsd:string object
        :param elem_position: optional string order-key
        
        """
        if 'fabric_credentials' not in self._pending_field_list_updates:
            self._pending_field_list_updates['fabric_credentials'] = [
                ('add', elem_value, elem_position)]
        else:
            self._pending_field_list_updates['fabric_credentials'].append(
                ('add', elem_value, elem_position))
    # end add_fabric_credentials

    def del_fabric_credentials(self, elem_position):
        """Delete element from fabric-credentials for fabric.
        
        :param elem_position: string indicating order-key
        
        """
        if 'fabric_credentials' not in self._pending_field_list_updates:
            self._pending_field_list_updates['fabric_credentials'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_list_updates['fabric_credentials'].append(
                ('delete', None, elem_position))
    # end del_fabric_credentials
    def add_annotations(self, elem):
        """Add element to annotations for fabric.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for fabric.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_intent_map(self, *args, **kwargs):
        """Set intent-map for fabric.
        
        :param ref_obj: IntentMap object
        
        """
        self._pending_field_updates.add('intent_map_refs')
        self._pending_ref_updates.discard('intent_map_refs')
        super(Fabric, self).set_intent_map(*args, **kwargs)

    # end set_intent_map

    def add_intent_map(self, *args, **kwargs):
        """Add intent-map to fabric.
        
        :param ref_obj: IntentMap object
        
        """
        if 'intent_map_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('intent_map_refs')
            self._original_intent_map_refs = copy.deepcopy(self.get_intent_map_refs() or [])
        super(Fabric, self).add_intent_map(*args, **kwargs)
    # end add_intent_map

    def del_intent_map(self, *args, **kwargs):
        if 'intent_map_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('intent_map_refs')
            self._original_intent_map_refs = copy.deepcopy(self.get_intent_map_refs() or [])
        super(Fabric, self).del_intent_map(*args, **kwargs)
    # end del_intent_map

    def set_intent_map_list(self, *args, **kwargs):
        """Set intent-map list for fabric.
        
        :param ref_obj_list: list of IntentMap object
        
        """
        self._pending_field_updates.add('intent_map_refs')
        self._pending_ref_updates.discard('intent_map_refs')
        super(Fabric, self).set_intent_map_list(*args, **kwargs)
    # end set_intent_map_list

    def set_virtual_network(self, *args, **kwargs):
        """Set virtual-network for fabric.
        
        :param ref_obj: VirtualNetwork object
        :param ref_data: FabricNetworkTag object
        
        """
        self._pending_field_updates.add('virtual_network_refs')
        self._pending_ref_updates.discard('virtual_network_refs')
        super(Fabric, self).set_virtual_network(*args, **kwargs)

    # end set_virtual_network

    def add_virtual_network(self, *args, **kwargs):
        """Add virtual-network to fabric.
        
        :param ref_obj: VirtualNetwork object
        :param ref_data: FabricNetworkTag object
        
        """
        if 'virtual_network_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('virtual_network_refs')
            self._original_virtual_network_refs = copy.deepcopy(self.get_virtual_network_refs() or [])
        super(Fabric, self).add_virtual_network(*args, **kwargs)
    # end add_virtual_network

    def del_virtual_network(self, *args, **kwargs):
        if 'virtual_network_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('virtual_network_refs')
            self._original_virtual_network_refs = copy.deepcopy(self.get_virtual_network_refs() or [])
        super(Fabric, self).del_virtual_network(*args, **kwargs)
    # end del_virtual_network

    def set_virtual_network_list(self, *args, **kwargs):
        """Set virtual-network list for fabric.
        
        :param ref_obj_list: list of VirtualNetwork object
        :param ref_data_list: list of FabricNetworkTag summary
        
        """
        self._pending_field_updates.add('virtual_network_refs')
        self._pending_ref_updates.discard('virtual_network_refs')
        super(Fabric, self).set_virtual_network_list(*args, **kwargs)
    # end set_virtual_network_list

    def set_node_profile(self, *args, **kwargs):
        """Set node-profile for fabric.
        
        :param ref_obj: NodeProfile object
        :param ref_data: SerialNumListType object
        
        """
        self._pending_field_updates.add('node_profile_refs')
        self._pending_ref_updates.discard('node_profile_refs')
        super(Fabric, self).set_node_profile(*args, **kwargs)

    # end set_node_profile

    def add_node_profile(self, *args, **kwargs):
        """Add node-profile to fabric.
        
        :param ref_obj: NodeProfile object
        :param ref_data: SerialNumListType object
        
        """
        if 'node_profile_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('node_profile_refs')
            self._original_node_profile_refs = copy.deepcopy(self.get_node_profile_refs() or [])
        super(Fabric, self).add_node_profile(*args, **kwargs)
    # end add_node_profile

    def del_node_profile(self, *args, **kwargs):
        if 'node_profile_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('node_profile_refs')
            self._original_node_profile_refs = copy.deepcopy(self.get_node_profile_refs() or [])
        super(Fabric, self).del_node_profile(*args, **kwargs)
    # end del_node_profile

    def set_node_profile_list(self, *args, **kwargs):
        """Set node-profile list for fabric.
        
        :param ref_obj_list: list of NodeProfile object
        :param ref_data_list: list of SerialNumListType summary
        
        """
        self._pending_field_updates.add('node_profile_refs')
        self._pending_ref_updates.discard('node_profile_refs')
        super(Fabric, self).set_node_profile_list(*args, **kwargs)
    # end set_node_profile_list

    def set_tag(self, *args, **kwargs):
        """Set tag for fabric.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(Fabric, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to fabric.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(Fabric, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(Fabric, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for fabric.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(Fabric, self).set_tag_list(*args, **kwargs)
    # end set_tag_list

    def get_fabric_namespaces(self):
        if hasattr(self, 'fabric_namespaces'):
            return self.fabric_namespaces

        if hasattr(super(Fabric, self), 'fabric_namespaces'):
            return super(Fabric, self).get_fabric_namespaces()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.fabric_read(id = self.uuid, fields = ['fabric_namespaces'])
        except NoIdError:
            return None
        children = getattr(obj, 'fabric_namespaces', None)
        if not children:
            return None
        self.fabric_namespaces = children

        return children
    # end get_fabric_namespaces

    def get_virtual_port_groups(self):
        if hasattr(self, 'virtual_port_groups'):
            return self.virtual_port_groups

        if hasattr(super(Fabric, self), 'virtual_port_groups'):
            return super(Fabric, self).get_virtual_port_groups()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.fabric_read(id = self.uuid, fields = ['virtual_port_groups'])
        except NoIdError:
            return None
        children = getattr(obj, 'virtual_port_groups', None)
        if not children:
            return None
        self.virtual_port_groups = children

        return children
    # end get_virtual_port_groups


    def get_physical_router_back_refs(self):
        """Return list of all physical-routers using this fabric"""
        if hasattr(self, 'physical_router_back_refs'):
            return self.physical_router_back_refs

        if hasattr(super(Fabric, self), 'physical_router_back_refs'):
            return super(Fabric, self).get_physical_router_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.fabric_read(id = self.uuid, fields = ['physical_router_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'physical_router_back_refs', None)
        if not back_refs:
            return None
        self.physical_router_back_refs = back_refs

        return back_refs
    # end get_physical_router_back_refs

# end class Fabric

class JobTemplate(vnc_api.gen.resource_common.JobTemplate):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'job_template_synchronous_job' in kwargs:
            pending_fields.append('job_template_synchronous_job')
        if len(args) > 1 or 'job_template_type' in kwargs:
            pending_fields.append('job_template_type')
        if len(args) > 2 or 'job_template_concurrency_level' in kwargs:
            pending_fields.append('job_template_concurrency_level')
        if len(args) > 3 or 'job_template_playbooks' in kwargs:
            pending_fields.append('job_template_playbooks')
        if len(args) > 4 or 'job_template_executables' in kwargs:
            pending_fields.append('job_template_executables')
        if len(args) > 5 or 'job_template_input_schema' in kwargs:
            pending_fields.append('job_template_input_schema')
        if len(args) > 6 or 'job_template_output_schema' in kwargs:
            pending_fields.append('job_template_output_schema')
        if len(args) > 7 or 'job_template_input_ui_schema' in kwargs:
            pending_fields.append('job_template_input_ui_schema')
        if len(args) > 8 or 'job_template_output_ui_schema' in kwargs:
            pending_fields.append('job_template_output_ui_schema')
        if len(args) > 9 or 'job_template_description' in kwargs:
            pending_fields.append('job_template_description')
        if len(args) > 10 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 11 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 12 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 13 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(JobTemplate, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            props_dict['job_template_synchronous_job'] = kwargs[u'job_template_synchronous_job']
        except KeyError:
            pass

        try:
            props_dict['job_template_type'] = kwargs[u'job_template_type']
        except KeyError:
            pass

        try:
            props_dict['job_template_concurrency_level'] = kwargs[u'job_template_concurrency_level']
        except KeyError:
            pass

        try:
            if kwargs['job_template_playbooks'] is None:
                props_dict['job_template_playbooks'] = None
            else:
                props_dict['job_template_playbooks'] = vnc_api.gen.resource_xsd.PlaybookInfoListType(params_dict=kwargs[u'job_template_playbooks'])
        except KeyError:
            pass

        try:
            if kwargs['job_template_executables'] is None:
                props_dict['job_template_executables'] = None
            else:
                props_dict['job_template_executables'] = vnc_api.gen.resource_xsd.ExecutableInfoListType(params_dict=kwargs[u'job_template_executables'])
        except KeyError:
            pass

        try:
            props_dict['job_template_input_schema'] = kwargs[u'job_template_input_schema']
        except KeyError:
            pass

        try:
            props_dict['job_template_output_schema'] = kwargs[u'job_template_output_schema']
        except KeyError:
            pass

        try:
            props_dict['job_template_input_ui_schema'] = kwargs[u'job_template_input_ui_schema']
        except KeyError:
            pass

        try:
            props_dict['job_template_output_ui_schema'] = kwargs[u'job_template_output_ui_schema']
        except KeyError:
            pass

        try:
            props_dict['job_template_description'] = kwargs[u'job_template_description']
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = JobTemplate(**props_dict)
        else:
            obj = JobTemplate(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.node_profile_back_refs = kwargs[u'node_profile_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.JobTemplate.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.JobTemplate.job_template_synchronous_job.setter
    def job_template_synchronous_job(self, job_template_synchronous_job):
        """Set job-template-synchronous-job for job-template.
        
        :param job_template_synchronous_job: xsd:boolean object
        
        """
        if 'job_template_synchronous_job' not in self._pending_field_updates:
            self._pending_field_updates.add('job_template_synchronous_job')

        self._job_template_synchronous_job = job_template_synchronous_job
    # end job_template_synchronous_job

    def set_job_template_synchronous_job(self, value):
        self.job_template_synchronous_job = value
    # end set_job_template_synchronous_job

    @vnc_api.gen.resource_common.JobTemplate.job_template_type.setter
    def job_template_type(self, job_template_type):
        """Set job-template-type for job-template.
        
        :param job_template_type: JobTemplateType object
        
        """
        if 'job_template_type' not in self._pending_field_updates:
            self._pending_field_updates.add('job_template_type')

        self._job_template_type = job_template_type
    # end job_template_type

    def set_job_template_type(self, value):
        self.job_template_type = value
    # end set_job_template_type

    @vnc_api.gen.resource_common.JobTemplate.job_template_concurrency_level.setter
    def job_template_concurrency_level(self, job_template_concurrency_level):
        """Set job-template-concurrency-level for job-template.
        
        :param job_template_concurrency_level: JobConcurrencyLevelType object
        
        """
        if 'job_template_concurrency_level' not in self._pending_field_updates:
            self._pending_field_updates.add('job_template_concurrency_level')

        self._job_template_concurrency_level = job_template_concurrency_level
    # end job_template_concurrency_level

    def set_job_template_concurrency_level(self, value):
        self.job_template_concurrency_level = value
    # end set_job_template_concurrency_level

    @vnc_api.gen.resource_common.JobTemplate.job_template_playbooks.setter
    def job_template_playbooks(self, job_template_playbooks):
        """Set job-template-playbooks for job-template.
        
        :param job_template_playbooks: PlaybookInfoListType object
        
        """
        if 'job_template_playbooks' not in self._pending_field_updates:
            self._pending_field_updates.add('job_template_playbooks')

        if 'job_template_playbooks' in self._pending_field_list_updates:
            # set clobbers earlier add/del on prop list elements
            del self._pending_field_list_updates['job_template_playbooks']

        self._job_template_playbooks = job_template_playbooks
    # end job_template_playbooks

    def set_job_template_playbooks(self, value):
        self.job_template_playbooks = value
    # end set_job_template_playbooks

    @vnc_api.gen.resource_common.JobTemplate.job_template_executables.setter
    def job_template_executables(self, job_template_executables):
        """Set job-template-executables for job-template.
        
        :param job_template_executables: ExecutableInfoListType object
        
        """
        if 'job_template_executables' not in self._pending_field_updates:
            self._pending_field_updates.add('job_template_executables')

        if 'job_template_executables' in self._pending_field_list_updates:
            # set clobbers earlier add/del on prop list elements
            del self._pending_field_list_updates['job_template_executables']

        self._job_template_executables = job_template_executables
    # end job_template_executables

    def set_job_template_executables(self, value):
        self.job_template_executables = value
    # end set_job_template_executables

    @vnc_api.gen.resource_common.JobTemplate.job_template_input_schema.setter
    def job_template_input_schema(self, job_template_input_schema):
        """Set job-template-input-schema for job-template.
        
        :param job_template_input_schema: xsd:string object
        
        """
        if 'job_template_input_schema' not in self._pending_field_updates:
            self._pending_field_updates.add('job_template_input_schema')

        self._job_template_input_schema = job_template_input_schema
    # end job_template_input_schema

    def set_job_template_input_schema(self, value):
        self.job_template_input_schema = value
    # end set_job_template_input_schema

    @vnc_api.gen.resource_common.JobTemplate.job_template_output_schema.setter
    def job_template_output_schema(self, job_template_output_schema):
        """Set job-template-output-schema for job-template.
        
        :param job_template_output_schema: xsd:string object
        
        """
        if 'job_template_output_schema' not in self._pending_field_updates:
            self._pending_field_updates.add('job_template_output_schema')

        self._job_template_output_schema = job_template_output_schema
    # end job_template_output_schema

    def set_job_template_output_schema(self, value):
        self.job_template_output_schema = value
    # end set_job_template_output_schema

    @vnc_api.gen.resource_common.JobTemplate.job_template_input_ui_schema.setter
    def job_template_input_ui_schema(self, job_template_input_ui_schema):
        """Set job-template-input-ui-schema for job-template.
        
        :param job_template_input_ui_schema: xsd:string object
        
        """
        if 'job_template_input_ui_schema' not in self._pending_field_updates:
            self._pending_field_updates.add('job_template_input_ui_schema')

        self._job_template_input_ui_schema = job_template_input_ui_schema
    # end job_template_input_ui_schema

    def set_job_template_input_ui_schema(self, value):
        self.job_template_input_ui_schema = value
    # end set_job_template_input_ui_schema

    @vnc_api.gen.resource_common.JobTemplate.job_template_output_ui_schema.setter
    def job_template_output_ui_schema(self, job_template_output_ui_schema):
        """Set job-template-output-ui-schema for job-template.
        
        :param job_template_output_ui_schema: xsd:string object
        
        """
        if 'job_template_output_ui_schema' not in self._pending_field_updates:
            self._pending_field_updates.add('job_template_output_ui_schema')

        self._job_template_output_ui_schema = job_template_output_ui_schema
    # end job_template_output_ui_schema

    def set_job_template_output_ui_schema(self, value):
        self.job_template_output_ui_schema = value
    # end set_job_template_output_ui_schema

    @vnc_api.gen.resource_common.JobTemplate.job_template_description.setter
    def job_template_description(self, job_template_description):
        """Set job-template-description for job-template.
        
        :param job_template_description: xsd:string object
        
        """
        if 'job_template_description' not in self._pending_field_updates:
            self._pending_field_updates.add('job_template_description')

        self._job_template_description = job_template_description
    # end job_template_description

    def set_job_template_description(self, value):
        self.job_template_description = value
    # end set_job_template_description

    @vnc_api.gen.resource_common.JobTemplate.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for job-template.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.JobTemplate.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for job-template.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.JobTemplate.annotations.setter
    def annotations(self, annotations):
        """Set annotations for job-template.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.JobTemplate.display_name.setter
    def display_name(self, display_name):
        """Set display-name for job-template.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_job_template_playbooks(self, elem_value, elem_position=None):
        """Add element to job-template-playbooks for job-template.
        
        :param elem_value: xsd:string object
        :param elem_position: optional string order-key
        
        """
        if 'job_template_playbooks' not in self._pending_field_list_updates:
            self._pending_field_list_updates['job_template_playbooks'] = [
                ('add', elem_value, elem_position)]
        else:
            self._pending_field_list_updates['job_template_playbooks'].append(
                ('add', elem_value, elem_position))
    # end add_job_template_playbooks

    def del_job_template_playbooks(self, elem_position):
        """Delete element from job-template-playbooks for job-template.
        
        :param elem_position: string indicating order-key
        
        """
        if 'job_template_playbooks' not in self._pending_field_list_updates:
            self._pending_field_list_updates['job_template_playbooks'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_list_updates['job_template_playbooks'].append(
                ('delete', None, elem_position))
    # end del_job_template_playbooks
    def add_job_template_executables(self, elem_value, elem_position=None):
        """Add element to job-template-executables for job-template.
        
        :param elem_value: xsd:string object
        :param elem_position: optional string order-key
        
        """
        if 'job_template_executables' not in self._pending_field_list_updates:
            self._pending_field_list_updates['job_template_executables'] = [
                ('add', elem_value, elem_position)]
        else:
            self._pending_field_list_updates['job_template_executables'].append(
                ('add', elem_value, elem_position))
    # end add_job_template_executables

    def del_job_template_executables(self, elem_position):
        """Delete element from job-template-executables for job-template.
        
        :param elem_position: string indicating order-key
        
        """
        if 'job_template_executables' not in self._pending_field_list_updates:
            self._pending_field_list_updates['job_template_executables'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_list_updates['job_template_executables'].append(
                ('delete', None, elem_position))
    # end del_job_template_executables
    def add_annotations(self, elem):
        """Add element to annotations for job-template.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for job-template.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_tag(self, *args, **kwargs):
        """Set tag for job-template.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(JobTemplate, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to job-template.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(JobTemplate, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(JobTemplate, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for job-template.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(JobTemplate, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


    def get_node_profile_back_refs(self):
        """Return list of all node-profiles using this job-template"""
        if hasattr(self, 'node_profile_back_refs'):
            return self.node_profile_back_refs

        if hasattr(super(JobTemplate, self), 'node_profile_back_refs'):
            return super(JobTemplate, self).get_node_profile_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.job_template_read(id = self.uuid, fields = ['node_profile_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'node_profile_back_refs', None)
        if not back_refs:
            return None
        self.node_profile_back_refs = back_refs

        return back_refs
    # end get_node_profile_back_refs

# end class JobTemplate

class RoutingPolicy(vnc_api.gen.resource_common.RoutingPolicy):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'routing_policy_entries' in kwargs:
            pending_fields.append('routing_policy_entries')
        if len(args) > 1 or 'term_type' in kwargs:
            pending_fields.append('term_type')
        if len(args) > 2 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 3 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 4 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 5 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(RoutingPolicy, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            if kwargs['routing_policy_entries'] is None:
                props_dict['routing_policy_entries'] = None
            else:
                props_dict['routing_policy_entries'] = vnc_api.gen.resource_xsd.PolicyStatementType(params_dict=kwargs[u'routing_policy_entries'])
        except KeyError:
            pass

        try:
            props_dict['term_type'] = kwargs[u'term_type']
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = RoutingPolicy(**props_dict)
        else:
            obj = RoutingPolicy(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.service_instance_refs = kwargs[u'service_instance_refs']
            for ref in obj.service_instance_refs:
                ref['attr'] = vnc_api.gen.resource_xsd.RoutingPolicyServiceInstanceType(params_dict=ref[u'attr'])
        except KeyError:
            pass
        try:
            obj.routing_instance_refs = kwargs[u'routing_instance_refs']
            for ref in obj.routing_instance_refs:
                ref['attr'] = vnc_api.gen.resource_xsd.RoutingPolicyType(params_dict=ref[u'attr'])
        except KeyError:
            pass
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.data_center_interconnect_back_refs = kwargs[u'data_center_interconnect_back_refs']
        except KeyError:
            pass
        try:
            obj.virtual_network_back_refs = kwargs[u'virtual_network_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.RoutingPolicy.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.RoutingPolicy.routing_policy_entries.setter
    def routing_policy_entries(self, routing_policy_entries):
        """Set routing-policy-entries for routing-policy.
        
        :param routing_policy_entries: PolicyStatementType object
        
        """
        if 'routing_policy_entries' not in self._pending_field_updates:
            self._pending_field_updates.add('routing_policy_entries')

        self._routing_policy_entries = routing_policy_entries
    # end routing_policy_entries

    def set_routing_policy_entries(self, value):
        self.routing_policy_entries = value
    # end set_routing_policy_entries

    @vnc_api.gen.resource_common.RoutingPolicy.term_type.setter
    def term_type(self, term_type):
        """Set term-type for routing-policy.
        
        :param term_type: TermType object
        
        """
        if 'term_type' not in self._pending_field_updates:
            self._pending_field_updates.add('term_type')

        self._term_type = term_type
    # end term_type

    def set_term_type(self, value):
        self.term_type = value
    # end set_term_type

    @vnc_api.gen.resource_common.RoutingPolicy.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for routing-policy.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.RoutingPolicy.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for routing-policy.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.RoutingPolicy.annotations.setter
    def annotations(self, annotations):
        """Set annotations for routing-policy.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.RoutingPolicy.display_name.setter
    def display_name(self, display_name):
        """Set display-name for routing-policy.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for routing-policy.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for routing-policy.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_service_instance(self, *args, **kwargs):
        """Set service-instance for routing-policy.
        
        :param ref_obj: ServiceInstance object
        :param ref_data: RoutingPolicyServiceInstanceType object
        
        """
        self._pending_field_updates.add('service_instance_refs')
        self._pending_ref_updates.discard('service_instance_refs')
        super(RoutingPolicy, self).set_service_instance(*args, **kwargs)

    # end set_service_instance

    def add_service_instance(self, *args, **kwargs):
        """Add service-instance to routing-policy.
        
        :param ref_obj: ServiceInstance object
        :param ref_data: RoutingPolicyServiceInstanceType object
        
        """
        if 'service_instance_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('service_instance_refs')
            self._original_service_instance_refs = copy.deepcopy(self.get_service_instance_refs() or [])
        super(RoutingPolicy, self).add_service_instance(*args, **kwargs)
    # end add_service_instance

    def del_service_instance(self, *args, **kwargs):
        if 'service_instance_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('service_instance_refs')
            self._original_service_instance_refs = copy.deepcopy(self.get_service_instance_refs() or [])
        super(RoutingPolicy, self).del_service_instance(*args, **kwargs)
    # end del_service_instance

    def set_service_instance_list(self, *args, **kwargs):
        """Set service-instance list for routing-policy.
        
        :param ref_obj_list: list of ServiceInstance object
        :param ref_data_list: list of RoutingPolicyServiceInstanceType summary
        
        """
        self._pending_field_updates.add('service_instance_refs')
        self._pending_ref_updates.discard('service_instance_refs')
        super(RoutingPolicy, self).set_service_instance_list(*args, **kwargs)
    # end set_service_instance_list

    def set_routing_instance(self, *args, **kwargs):
        """Set routing-instance for routing-policy.
        
        :param ref_obj: RoutingInstance object
        :param ref_data: RoutingPolicyType object
        
        """
        self._pending_field_updates.add('routing_instance_refs')
        self._pending_ref_updates.discard('routing_instance_refs')
        super(RoutingPolicy, self).set_routing_instance(*args, **kwargs)

    # end set_routing_instance

    def add_routing_instance(self, *args, **kwargs):
        """Add routing-instance to routing-policy.
        
        :param ref_obj: RoutingInstance object
        :param ref_data: RoutingPolicyType object
        
        """
        if 'routing_instance_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('routing_instance_refs')
            self._original_routing_instance_refs = copy.deepcopy(self.get_routing_instance_refs() or [])
        super(RoutingPolicy, self).add_routing_instance(*args, **kwargs)
    # end add_routing_instance

    def del_routing_instance(self, *args, **kwargs):
        if 'routing_instance_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('routing_instance_refs')
            self._original_routing_instance_refs = copy.deepcopy(self.get_routing_instance_refs() or [])
        super(RoutingPolicy, self).del_routing_instance(*args, **kwargs)
    # end del_routing_instance

    def set_routing_instance_list(self, *args, **kwargs):
        """Set routing-instance list for routing-policy.
        
        :param ref_obj_list: list of RoutingInstance object
        :param ref_data_list: list of RoutingPolicyType summary
        
        """
        self._pending_field_updates.add('routing_instance_refs')
        self._pending_ref_updates.discard('routing_instance_refs')
        super(RoutingPolicy, self).set_routing_instance_list(*args, **kwargs)
    # end set_routing_instance_list

    def set_tag(self, *args, **kwargs):
        """Set tag for routing-policy.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(RoutingPolicy, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to routing-policy.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(RoutingPolicy, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(RoutingPolicy, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for routing-policy.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(RoutingPolicy, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


    def get_data_center_interconnect_back_refs(self):
        """Return list of all data-center-interconnects using this routing-policy"""
        if hasattr(self, 'data_center_interconnect_back_refs'):
            return self.data_center_interconnect_back_refs

        if hasattr(super(RoutingPolicy, self), 'data_center_interconnect_back_refs'):
            return super(RoutingPolicy, self).get_data_center_interconnect_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.routing_policy_read(id = self.uuid, fields = ['data_center_interconnect_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'data_center_interconnect_back_refs', None)
        if not back_refs:
            return None
        self.data_center_interconnect_back_refs = back_refs

        return back_refs
    # end get_data_center_interconnect_back_refs

    def get_virtual_network_back_refs(self):
        """Return list of all virtual-networks using this routing-policy"""
        if hasattr(self, 'virtual_network_back_refs'):
            return self.virtual_network_back_refs

        if hasattr(super(RoutingPolicy, self), 'virtual_network_back_refs'):
            return super(RoutingPolicy, self).get_virtual_network_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.routing_policy_read(id = self.uuid, fields = ['virtual_network_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'virtual_network_back_refs', None)
        if not back_refs:
            return None
        self.virtual_network_back_refs = back_refs

        return back_refs
    # end get_virtual_network_back_refs

# end class RoutingPolicy

class RoleConfig(vnc_api.gen.resource_common.RoleConfig):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'role_config_config' in kwargs:
            pending_fields.append('role_config_config')
        if len(args) > 1 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 2 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 3 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 4 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(RoleConfig, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            props_dict['role_config_config'] = kwargs[u'role_config_config']
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = RoleConfig(**props_dict)
        else:
            obj = RoleConfig(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.RoleConfig.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.RoleConfig.role_config_config.setter
    def role_config_config(self, role_config_config):
        """Set role-config-config for role-config.
        
        :param role_config_config: xsd:string object
        
        """
        if 'role_config_config' not in self._pending_field_updates:
            self._pending_field_updates.add('role_config_config')

        self._role_config_config = role_config_config
    # end role_config_config

    def set_role_config_config(self, value):
        self.role_config_config = value
    # end set_role_config_config

    @vnc_api.gen.resource_common.RoleConfig.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for role-config.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.RoleConfig.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for role-config.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.RoleConfig.annotations.setter
    def annotations(self, annotations):
        """Set annotations for role-config.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.RoleConfig.display_name.setter
    def display_name(self, display_name):
        """Set display-name for role-config.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for role-config.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for role-config.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_tag(self, *args, **kwargs):
        """Set tag for role-config.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(RoleConfig, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to role-config.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(RoleConfig, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(RoleConfig, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for role-config.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(RoleConfig, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


# end class RoleConfig

class TagType(vnc_api.gen.resource_common.TagType):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, *args, **kwargs):
        pending_fields = ['fq_name']

        self._server_conn = None

        if len(args) > 0 or 'tag_type_id' in kwargs:
            pending_fields.append('tag_type_id')
        if len(args) > 1 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 2 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 3 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 4 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(TagType, self).__init__(name, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            props_dict['tag_type_id'] = kwargs[u'tag_type_id']
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = TagType(**props_dict)
        else:
            obj = TagType(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.tag_back_refs = kwargs[u'tag_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.TagType.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.TagType.tag_type_id.setter
    def tag_type_id(self, tag_type_id):
        """Set tag-type-id for tag-type.
        
        :param tag_type_id: U16BitHexInt object
        
        """
        if 'tag_type_id' not in self._pending_field_updates:
            self._pending_field_updates.add('tag_type_id')

        self._tag_type_id = tag_type_id
    # end tag_type_id

    def set_tag_type_id(self, value):
        self.tag_type_id = value
    # end set_tag_type_id

    @vnc_api.gen.resource_common.TagType.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for tag-type.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.TagType.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for tag-type.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.TagType.annotations.setter
    def annotations(self, annotations):
        """Set annotations for tag-type.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.TagType.display_name.setter
    def display_name(self, display_name):
        """Set display-name for tag-type.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for tag-type.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for tag-type.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_tag(self, *args, **kwargs):
        """Set tag for tag-type.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(TagType, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to tag-type.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(TagType, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(TagType, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for tag-type.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(TagType, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


    def get_tag_back_refs(self):
        """Return list of all tags using this tag-type"""
        if hasattr(self, 'tag_back_refs'):
            return self.tag_back_refs

        if hasattr(super(TagType, self), 'tag_back_refs'):
            return super(TagType, self).get_tag_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_type_read(id = self.uuid, fields = ['tag_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'tag_back_refs', None)
        if not back_refs:
            return None
        self.tag_back_refs = back_refs

        return back_refs
    # end get_tag_back_refs

# end class TagType

class StructuredSyslogMessage(vnc_api.gen.resource_common.StructuredSyslogMessage):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'structured_syslog_message_tagged_fields' in kwargs:
            pending_fields.append('structured_syslog_message_tagged_fields')
        if len(args) > 1 or 'structured_syslog_message_integer_fields' in kwargs:
            pending_fields.append('structured_syslog_message_integer_fields')
        if len(args) > 2 or 'structured_syslog_message_process_and_store' in kwargs:
            pending_fields.append('structured_syslog_message_process_and_store')
        if len(args) > 3 or 'structured_syslog_message_process_and_summarize' in kwargs:
            pending_fields.append('structured_syslog_message_process_and_summarize')
        if len(args) > 4 or 'structured_syslog_message_process_and_summarize_user' in kwargs:
            pending_fields.append('structured_syslog_message_process_and_summarize_user')
        if len(args) > 5 or 'structured_syslog_message_forward' in kwargs:
            pending_fields.append('structured_syslog_message_forward')
        if len(args) > 6 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 7 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 8 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 9 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(StructuredSyslogMessage, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            if kwargs['structured_syslog_message_tagged_fields'] is None:
                props_dict['structured_syslog_message_tagged_fields'] = None
            else:
                props_dict['structured_syslog_message_tagged_fields'] = vnc_api.gen.resource_xsd.FieldNamesList(params_dict=kwargs[u'structured_syslog_message_tagged_fields'])
        except KeyError:
            pass

        try:
            if kwargs['structured_syslog_message_integer_fields'] is None:
                props_dict['structured_syslog_message_integer_fields'] = None
            else:
                props_dict['structured_syslog_message_integer_fields'] = vnc_api.gen.resource_xsd.FieldNamesList(params_dict=kwargs[u'structured_syslog_message_integer_fields'])
        except KeyError:
            pass

        try:
            props_dict['structured_syslog_message_process_and_store'] = kwargs[u'structured_syslog_message_process_and_store']
        except KeyError:
            pass

        try:
            props_dict['structured_syslog_message_process_and_summarize'] = kwargs[u'structured_syslog_message_process_and_summarize']
        except KeyError:
            pass

        try:
            props_dict['structured_syslog_message_process_and_summarize_user'] = kwargs[u'structured_syslog_message_process_and_summarize_user']
        except KeyError:
            pass

        try:
            props_dict['structured_syslog_message_forward'] = kwargs[u'structured_syslog_message_forward']
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = StructuredSyslogMessage(**props_dict)
        else:
            obj = StructuredSyslogMessage(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.StructuredSyslogMessage.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.StructuredSyslogMessage.structured_syslog_message_tagged_fields.setter
    def structured_syslog_message_tagged_fields(self, structured_syslog_message_tagged_fields):
        """Set structured-syslog-message-tagged-fields for structured-syslog-message.
        
        :param structured_syslog_message_tagged_fields: FieldNamesList object
        
        """
        if 'structured_syslog_message_tagged_fields' not in self._pending_field_updates:
            self._pending_field_updates.add('structured_syslog_message_tagged_fields')

        self._structured_syslog_message_tagged_fields = structured_syslog_message_tagged_fields
    # end structured_syslog_message_tagged_fields

    def set_structured_syslog_message_tagged_fields(self, value):
        self.structured_syslog_message_tagged_fields = value
    # end set_structured_syslog_message_tagged_fields

    @vnc_api.gen.resource_common.StructuredSyslogMessage.structured_syslog_message_integer_fields.setter
    def structured_syslog_message_integer_fields(self, structured_syslog_message_integer_fields):
        """Set structured-syslog-message-integer-fields for structured-syslog-message.
        
        :param structured_syslog_message_integer_fields: FieldNamesList object
        
        """
        if 'structured_syslog_message_integer_fields' not in self._pending_field_updates:
            self._pending_field_updates.add('structured_syslog_message_integer_fields')

        self._structured_syslog_message_integer_fields = structured_syslog_message_integer_fields
    # end structured_syslog_message_integer_fields

    def set_structured_syslog_message_integer_fields(self, value):
        self.structured_syslog_message_integer_fields = value
    # end set_structured_syslog_message_integer_fields

    @vnc_api.gen.resource_common.StructuredSyslogMessage.structured_syslog_message_process_and_store.setter
    def structured_syslog_message_process_and_store(self, structured_syslog_message_process_and_store):
        """Set structured-syslog-message-process-and-store for structured-syslog-message.
        
        :param structured_syslog_message_process_and_store: xsd:boolean object
        
        """
        if 'structured_syslog_message_process_and_store' not in self._pending_field_updates:
            self._pending_field_updates.add('structured_syslog_message_process_and_store')

        self._structured_syslog_message_process_and_store = structured_syslog_message_process_and_store
    # end structured_syslog_message_process_and_store

    def set_structured_syslog_message_process_and_store(self, value):
        self.structured_syslog_message_process_and_store = value
    # end set_structured_syslog_message_process_and_store

    @vnc_api.gen.resource_common.StructuredSyslogMessage.structured_syslog_message_process_and_summarize.setter
    def structured_syslog_message_process_and_summarize(self, structured_syslog_message_process_and_summarize):
        """Set structured-syslog-message-process-and-summarize for structured-syslog-message.
        
        :param structured_syslog_message_process_and_summarize: xsd:boolean object
        
        """
        if 'structured_syslog_message_process_and_summarize' not in self._pending_field_updates:
            self._pending_field_updates.add('structured_syslog_message_process_and_summarize')

        self._structured_syslog_message_process_and_summarize = structured_syslog_message_process_and_summarize
    # end structured_syslog_message_process_and_summarize

    def set_structured_syslog_message_process_and_summarize(self, value):
        self.structured_syslog_message_process_and_summarize = value
    # end set_structured_syslog_message_process_and_summarize

    @vnc_api.gen.resource_common.StructuredSyslogMessage.structured_syslog_message_process_and_summarize_user.setter
    def structured_syslog_message_process_and_summarize_user(self, structured_syslog_message_process_and_summarize_user):
        """Set structured-syslog-message-process-and-summarize-user for structured-syslog-message.
        
        :param structured_syslog_message_process_and_summarize_user: xsd:boolean object
        
        """
        if 'structured_syslog_message_process_and_summarize_user' not in self._pending_field_updates:
            self._pending_field_updates.add('structured_syslog_message_process_and_summarize_user')

        self._structured_syslog_message_process_and_summarize_user = structured_syslog_message_process_and_summarize_user
    # end structured_syslog_message_process_and_summarize_user

    def set_structured_syslog_message_process_and_summarize_user(self, value):
        self.structured_syslog_message_process_and_summarize_user = value
    # end set_structured_syslog_message_process_and_summarize_user

    @vnc_api.gen.resource_common.StructuredSyslogMessage.structured_syslog_message_forward.setter
    def structured_syslog_message_forward(self, structured_syslog_message_forward):
        """Set structured-syslog-message-forward for structured-syslog-message.
        
        :param structured_syslog_message_forward: StructuredSyslogMessageForwardType object
        
        """
        if 'structured_syslog_message_forward' not in self._pending_field_updates:
            self._pending_field_updates.add('structured_syslog_message_forward')

        self._structured_syslog_message_forward = structured_syslog_message_forward
    # end structured_syslog_message_forward

    def set_structured_syslog_message_forward(self, value):
        self.structured_syslog_message_forward = value
    # end set_structured_syslog_message_forward

    @vnc_api.gen.resource_common.StructuredSyslogMessage.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for structured-syslog-message.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.StructuredSyslogMessage.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for structured-syslog-message.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.StructuredSyslogMessage.annotations.setter
    def annotations(self, annotations):
        """Set annotations for structured-syslog-message.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.StructuredSyslogMessage.display_name.setter
    def display_name(self, display_name):
        """Set display-name for structured-syslog-message.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for structured-syslog-message.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for structured-syslog-message.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_tag(self, *args, **kwargs):
        """Set tag for structured-syslog-message.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(StructuredSyslogMessage, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to structured-syslog-message.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(StructuredSyslogMessage, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(StructuredSyslogMessage, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for structured-syslog-message.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(StructuredSyslogMessage, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


# end class StructuredSyslogMessage

class LoadbalancerPool(vnc_api.gen.resource_common.LoadbalancerPool):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'loadbalancer_pool_properties' in kwargs:
            pending_fields.append('loadbalancer_pool_properties')
        if len(args) > 1 or 'loadbalancer_pool_provider' in kwargs:
            pending_fields.append('loadbalancer_pool_provider')
        if len(args) > 2 or 'loadbalancer_pool_custom_attributes' in kwargs:
            pending_fields.append('loadbalancer_pool_custom_attributes')
        if len(args) > 3 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 4 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 5 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 6 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(LoadbalancerPool, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            if kwargs['loadbalancer_pool_properties'] is None:
                props_dict['loadbalancer_pool_properties'] = None
            else:
                props_dict['loadbalancer_pool_properties'] = vnc_api.gen.resource_xsd.LoadbalancerPoolType(params_dict=kwargs[u'loadbalancer_pool_properties'])
        except KeyError:
            pass

        try:
            props_dict['loadbalancer_pool_provider'] = kwargs[u'loadbalancer_pool_provider']
        except KeyError:
            pass

        try:
            if kwargs['loadbalancer_pool_custom_attributes'] is None:
                props_dict['loadbalancer_pool_custom_attributes'] = None
            else:
                props_dict['loadbalancer_pool_custom_attributes'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'loadbalancer_pool_custom_attributes'])
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = LoadbalancerPool(**props_dict)
        else:
            obj = LoadbalancerPool(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...
        try:
            obj.loadbalancer_members = kwargs[u'loadbalancer_members']
        except KeyError:
            pass

        # add any specified references...
        try:
            obj.service_instance_refs = kwargs[u'service_instance_refs']
        except KeyError:
            pass
        try:
            obj.virtual_machine_interface_refs = kwargs[u'virtual_machine_interface_refs']
        except KeyError:
            pass
        try:
            obj.loadbalancer_listener_refs = kwargs[u'loadbalancer_listener_refs']
        except KeyError:
            pass
        try:
            obj.service_appliance_set_refs = kwargs[u'service_appliance_set_refs']
        except KeyError:
            pass
        try:
            obj.loadbalancer_healthmonitor_refs = kwargs[u'loadbalancer_healthmonitor_refs']
        except KeyError:
            pass
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.virtual_ip_back_refs = kwargs[u'virtual_ip_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.LoadbalancerPool.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.LoadbalancerPool.loadbalancer_pool_properties.setter
    def loadbalancer_pool_properties(self, loadbalancer_pool_properties):
        """Set loadbalancer-pool-properties for loadbalancer-pool.
        
        :param loadbalancer_pool_properties: LoadbalancerPoolType object
        
        """
        if 'loadbalancer_pool_properties' not in self._pending_field_updates:
            self._pending_field_updates.add('loadbalancer_pool_properties')

        self._loadbalancer_pool_properties = loadbalancer_pool_properties
    # end loadbalancer_pool_properties

    def set_loadbalancer_pool_properties(self, value):
        self.loadbalancer_pool_properties = value
    # end set_loadbalancer_pool_properties

    @vnc_api.gen.resource_common.LoadbalancerPool.loadbalancer_pool_provider.setter
    def loadbalancer_pool_provider(self, loadbalancer_pool_provider):
        """Set loadbalancer-pool-provider for loadbalancer-pool.
        
        :param loadbalancer_pool_provider: xsd:string object
        
        """
        if 'loadbalancer_pool_provider' not in self._pending_field_updates:
            self._pending_field_updates.add('loadbalancer_pool_provider')

        self._loadbalancer_pool_provider = loadbalancer_pool_provider
    # end loadbalancer_pool_provider

    def set_loadbalancer_pool_provider(self, value):
        self.loadbalancer_pool_provider = value
    # end set_loadbalancer_pool_provider

    @vnc_api.gen.resource_common.LoadbalancerPool.loadbalancer_pool_custom_attributes.setter
    def loadbalancer_pool_custom_attributes(self, loadbalancer_pool_custom_attributes):
        """Set loadbalancer-pool-custom-attributes for loadbalancer-pool.
        
        :param loadbalancer_pool_custom_attributes: KeyValuePairs object
        
        """
        if 'loadbalancer_pool_custom_attributes' not in self._pending_field_updates:
            self._pending_field_updates.add('loadbalancer_pool_custom_attributes')

        self._loadbalancer_pool_custom_attributes = loadbalancer_pool_custom_attributes
    # end loadbalancer_pool_custom_attributes

    def set_loadbalancer_pool_custom_attributes(self, value):
        self.loadbalancer_pool_custom_attributes = value
    # end set_loadbalancer_pool_custom_attributes

    @vnc_api.gen.resource_common.LoadbalancerPool.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for loadbalancer-pool.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.LoadbalancerPool.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for loadbalancer-pool.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.LoadbalancerPool.annotations.setter
    def annotations(self, annotations):
        """Set annotations for loadbalancer-pool.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.LoadbalancerPool.display_name.setter
    def display_name(self, display_name):
        """Set display-name for loadbalancer-pool.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for loadbalancer-pool.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for loadbalancer-pool.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_service_instance(self, *args, **kwargs):
        """Set service-instance for loadbalancer-pool.
        
        :param ref_obj: ServiceInstance object
        
        """
        self._pending_field_updates.add('service_instance_refs')
        self._pending_ref_updates.discard('service_instance_refs')
        super(LoadbalancerPool, self).set_service_instance(*args, **kwargs)

    # end set_service_instance

    def add_service_instance(self, *args, **kwargs):
        """Add service-instance to loadbalancer-pool.
        
        :param ref_obj: ServiceInstance object
        
        """
        if 'service_instance_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('service_instance_refs')
            self._original_service_instance_refs = copy.deepcopy(self.get_service_instance_refs() or [])
        super(LoadbalancerPool, self).add_service_instance(*args, **kwargs)
    # end add_service_instance

    def del_service_instance(self, *args, **kwargs):
        if 'service_instance_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('service_instance_refs')
            self._original_service_instance_refs = copy.deepcopy(self.get_service_instance_refs() or [])
        super(LoadbalancerPool, self).del_service_instance(*args, **kwargs)
    # end del_service_instance

    def set_service_instance_list(self, *args, **kwargs):
        """Set service-instance list for loadbalancer-pool.
        
        :param ref_obj_list: list of ServiceInstance object
        
        """
        self._pending_field_updates.add('service_instance_refs')
        self._pending_ref_updates.discard('service_instance_refs')
        super(LoadbalancerPool, self).set_service_instance_list(*args, **kwargs)
    # end set_service_instance_list

    def set_virtual_machine_interface(self, *args, **kwargs):
        """Set virtual-machine-interface for loadbalancer-pool.
        
        :param ref_obj: VirtualMachineInterface object
        
        """
        self._pending_field_updates.add('virtual_machine_interface_refs')
        self._pending_ref_updates.discard('virtual_machine_interface_refs')
        super(LoadbalancerPool, self).set_virtual_machine_interface(*args, **kwargs)

    # end set_virtual_machine_interface

    def add_virtual_machine_interface(self, *args, **kwargs):
        """Add virtual-machine-interface to loadbalancer-pool.
        
        :param ref_obj: VirtualMachineInterface object
        
        """
        if 'virtual_machine_interface_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('virtual_machine_interface_refs')
            self._original_virtual_machine_interface_refs = copy.deepcopy(self.get_virtual_machine_interface_refs() or [])
        super(LoadbalancerPool, self).add_virtual_machine_interface(*args, **kwargs)
    # end add_virtual_machine_interface

    def del_virtual_machine_interface(self, *args, **kwargs):
        if 'virtual_machine_interface_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('virtual_machine_interface_refs')
            self._original_virtual_machine_interface_refs = copy.deepcopy(self.get_virtual_machine_interface_refs() or [])
        super(LoadbalancerPool, self).del_virtual_machine_interface(*args, **kwargs)
    # end del_virtual_machine_interface

    def set_virtual_machine_interface_list(self, *args, **kwargs):
        """Set virtual-machine-interface list for loadbalancer-pool.
        
        :param ref_obj_list: list of VirtualMachineInterface object
        
        """
        self._pending_field_updates.add('virtual_machine_interface_refs')
        self._pending_ref_updates.discard('virtual_machine_interface_refs')
        super(LoadbalancerPool, self).set_virtual_machine_interface_list(*args, **kwargs)
    # end set_virtual_machine_interface_list

    def set_loadbalancer_listener(self, *args, **kwargs):
        """Set loadbalancer-listener for loadbalancer-pool.
        
        :param ref_obj: LoadbalancerListener object
        
        """
        self._pending_field_updates.add('loadbalancer_listener_refs')
        self._pending_ref_updates.discard('loadbalancer_listener_refs')
        super(LoadbalancerPool, self).set_loadbalancer_listener(*args, **kwargs)

    # end set_loadbalancer_listener

    def add_loadbalancer_listener(self, *args, **kwargs):
        """Add loadbalancer-listener to loadbalancer-pool.
        
        :param ref_obj: LoadbalancerListener object
        
        """
        if 'loadbalancer_listener_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('loadbalancer_listener_refs')
            self._original_loadbalancer_listener_refs = copy.deepcopy(self.get_loadbalancer_listener_refs() or [])
        super(LoadbalancerPool, self).add_loadbalancer_listener(*args, **kwargs)
    # end add_loadbalancer_listener

    def del_loadbalancer_listener(self, *args, **kwargs):
        if 'loadbalancer_listener_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('loadbalancer_listener_refs')
            self._original_loadbalancer_listener_refs = copy.deepcopy(self.get_loadbalancer_listener_refs() or [])
        super(LoadbalancerPool, self).del_loadbalancer_listener(*args, **kwargs)
    # end del_loadbalancer_listener

    def set_loadbalancer_listener_list(self, *args, **kwargs):
        """Set loadbalancer-listener list for loadbalancer-pool.
        
        :param ref_obj_list: list of LoadbalancerListener object
        
        """
        self._pending_field_updates.add('loadbalancer_listener_refs')
        self._pending_ref_updates.discard('loadbalancer_listener_refs')
        super(LoadbalancerPool, self).set_loadbalancer_listener_list(*args, **kwargs)
    # end set_loadbalancer_listener_list

    def set_service_appliance_set(self, *args, **kwargs):
        """Set service-appliance-set for loadbalancer-pool.
        
        :param ref_obj: ServiceApplianceSet object
        
        """
        self._pending_field_updates.add('service_appliance_set_refs')
        self._pending_ref_updates.discard('service_appliance_set_refs')
        super(LoadbalancerPool, self).set_service_appliance_set(*args, **kwargs)

    # end set_service_appliance_set

    def add_service_appliance_set(self, *args, **kwargs):
        """Add service-appliance-set to loadbalancer-pool.
        
        :param ref_obj: ServiceApplianceSet object
        
        """
        if 'service_appliance_set_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('service_appliance_set_refs')
            self._original_service_appliance_set_refs = copy.deepcopy(self.get_service_appliance_set_refs() or [])
        super(LoadbalancerPool, self).add_service_appliance_set(*args, **kwargs)
    # end add_service_appliance_set

    def del_service_appliance_set(self, *args, **kwargs):
        if 'service_appliance_set_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('service_appliance_set_refs')
            self._original_service_appliance_set_refs = copy.deepcopy(self.get_service_appliance_set_refs() or [])
        super(LoadbalancerPool, self).del_service_appliance_set(*args, **kwargs)
    # end del_service_appliance_set

    def set_service_appliance_set_list(self, *args, **kwargs):
        """Set service-appliance-set list for loadbalancer-pool.
        
        :param ref_obj_list: list of ServiceApplianceSet object
        
        """
        self._pending_field_updates.add('service_appliance_set_refs')
        self._pending_ref_updates.discard('service_appliance_set_refs')
        super(LoadbalancerPool, self).set_service_appliance_set_list(*args, **kwargs)
    # end set_service_appliance_set_list

    def set_loadbalancer_healthmonitor(self, *args, **kwargs):
        """Set loadbalancer-healthmonitor for loadbalancer-pool.
        
        :param ref_obj: LoadbalancerHealthmonitor object
        
        """
        self._pending_field_updates.add('loadbalancer_healthmonitor_refs')
        self._pending_ref_updates.discard('loadbalancer_healthmonitor_refs')
        super(LoadbalancerPool, self).set_loadbalancer_healthmonitor(*args, **kwargs)

    # end set_loadbalancer_healthmonitor

    def add_loadbalancer_healthmonitor(self, *args, **kwargs):
        """Add loadbalancer-healthmonitor to loadbalancer-pool.
        
        :param ref_obj: LoadbalancerHealthmonitor object
        
        """
        if 'loadbalancer_healthmonitor_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('loadbalancer_healthmonitor_refs')
            self._original_loadbalancer_healthmonitor_refs = copy.deepcopy(self.get_loadbalancer_healthmonitor_refs() or [])
        super(LoadbalancerPool, self).add_loadbalancer_healthmonitor(*args, **kwargs)
    # end add_loadbalancer_healthmonitor

    def del_loadbalancer_healthmonitor(self, *args, **kwargs):
        if 'loadbalancer_healthmonitor_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('loadbalancer_healthmonitor_refs')
            self._original_loadbalancer_healthmonitor_refs = copy.deepcopy(self.get_loadbalancer_healthmonitor_refs() or [])
        super(LoadbalancerPool, self).del_loadbalancer_healthmonitor(*args, **kwargs)
    # end del_loadbalancer_healthmonitor

    def set_loadbalancer_healthmonitor_list(self, *args, **kwargs):
        """Set loadbalancer-healthmonitor list for loadbalancer-pool.
        
        :param ref_obj_list: list of LoadbalancerHealthmonitor object
        
        """
        self._pending_field_updates.add('loadbalancer_healthmonitor_refs')
        self._pending_ref_updates.discard('loadbalancer_healthmonitor_refs')
        super(LoadbalancerPool, self).set_loadbalancer_healthmonitor_list(*args, **kwargs)
    # end set_loadbalancer_healthmonitor_list

    def set_tag(self, *args, **kwargs):
        """Set tag for loadbalancer-pool.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(LoadbalancerPool, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to loadbalancer-pool.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(LoadbalancerPool, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(LoadbalancerPool, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for loadbalancer-pool.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(LoadbalancerPool, self).set_tag_list(*args, **kwargs)
    # end set_tag_list

    def get_loadbalancer_members(self):
        if hasattr(self, 'loadbalancer_members'):
            return self.loadbalancer_members

        if hasattr(super(LoadbalancerPool, self), 'loadbalancer_members'):
            return super(LoadbalancerPool, self).get_loadbalancer_members()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.loadbalancer_pool_read(id = self.uuid, fields = ['loadbalancer_members'])
        except NoIdError:
            return None
        children = getattr(obj, 'loadbalancer_members', None)
        if not children:
            return None
        self.loadbalancer_members = children

        return children
    # end get_loadbalancer_members


    def get_virtual_ip_back_refs(self):
        """Return list of all virtual-ips using this loadbalancer-pool"""
        if hasattr(self, 'virtual_ip_back_refs'):
            return self.virtual_ip_back_refs

        if hasattr(super(LoadbalancerPool, self), 'virtual_ip_back_refs'):
            return super(LoadbalancerPool, self).get_virtual_ip_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.loadbalancer_pool_read(id = self.uuid, fields = ['virtual_ip_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'virtual_ip_back_refs', None)
        if not back_refs:
            return None
        self.virtual_ip_back_refs = back_refs

        return back_refs
    # end get_virtual_ip_back_refs

# end class LoadbalancerPool

class DeviceChassis(vnc_api.gen.resource_common.DeviceChassis):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, *args, **kwargs):
        pending_fields = ['fq_name']

        self._server_conn = None

        if len(args) > 0 or 'device_chassis_type' in kwargs:
            pending_fields.append('device_chassis_type')
        if len(args) > 1 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 2 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 3 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 4 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(DeviceChassis, self).__init__(name, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            props_dict['device_chassis_type'] = kwargs[u'device_chassis_type']
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = DeviceChassis(**props_dict)
        else:
            obj = DeviceChassis(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.physical_router_back_refs = kwargs[u'physical_router_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.DeviceChassis.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.DeviceChassis.device_chassis_type.setter
    def device_chassis_type(self, device_chassis_type):
        """Set device-chassis-type for device-chassis.
        
        :param device_chassis_type: xsd:string object
        
        """
        if 'device_chassis_type' not in self._pending_field_updates:
            self._pending_field_updates.add('device_chassis_type')

        self._device_chassis_type = device_chassis_type
    # end device_chassis_type

    def set_device_chassis_type(self, value):
        self.device_chassis_type = value
    # end set_device_chassis_type

    @vnc_api.gen.resource_common.DeviceChassis.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for device-chassis.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.DeviceChassis.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for device-chassis.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.DeviceChassis.annotations.setter
    def annotations(self, annotations):
        """Set annotations for device-chassis.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.DeviceChassis.display_name.setter
    def display_name(self, display_name):
        """Set display-name for device-chassis.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for device-chassis.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for device-chassis.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_tag(self, *args, **kwargs):
        """Set tag for device-chassis.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(DeviceChassis, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to device-chassis.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(DeviceChassis, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(DeviceChassis, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for device-chassis.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(DeviceChassis, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


    def get_physical_router_back_refs(self):
        """Return list of all physical-routers using this device-chassis"""
        if hasattr(self, 'physical_router_back_refs'):
            return self.physical_router_back_refs

        if hasattr(super(DeviceChassis, self), 'physical_router_back_refs'):
            return super(DeviceChassis, self).get_physical_router_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.device_chassis_read(id = self.uuid, fields = ['physical_router_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'physical_router_back_refs', None)
        if not back_refs:
            return None
        self.physical_router_back_refs = back_refs

        return back_refs
    # end get_physical_router_back_refs

# end class DeviceChassis

class GlobalQosConfig(vnc_api.gen.resource_common.GlobalQosConfig):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'control_traffic_dscp' in kwargs:
            pending_fields.append('control_traffic_dscp')
        if len(args) > 1 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 2 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 3 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 4 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(GlobalQosConfig, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            if kwargs['control_traffic_dscp'] is None:
                props_dict['control_traffic_dscp'] = None
            else:
                props_dict['control_traffic_dscp'] = vnc_api.gen.resource_xsd.ControlTrafficDscpType(params_dict=kwargs[u'control_traffic_dscp'])
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = GlobalQosConfig(**props_dict)
        else:
            obj = GlobalQosConfig(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...
        try:
            obj.qos_configs = kwargs[u'qos_configs']
        except KeyError:
            pass
        try:
            obj.forwarding_classs = kwargs[u'forwarding_classs']
        except KeyError:
            pass
        try:
            obj.qos_queues = kwargs[u'qos_queues']
        except KeyError:
            pass

        # add any specified references...
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.GlobalQosConfig.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.GlobalQosConfig.control_traffic_dscp.setter
    def control_traffic_dscp(self, control_traffic_dscp):
        """Set control-traffic-dscp for global-qos-config.
        
        :param control_traffic_dscp: ControlTrafficDscpType object
        
        """
        if 'control_traffic_dscp' not in self._pending_field_updates:
            self._pending_field_updates.add('control_traffic_dscp')

        self._control_traffic_dscp = control_traffic_dscp
    # end control_traffic_dscp

    def set_control_traffic_dscp(self, value):
        self.control_traffic_dscp = value
    # end set_control_traffic_dscp

    @vnc_api.gen.resource_common.GlobalQosConfig.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for global-qos-config.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.GlobalQosConfig.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for global-qos-config.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.GlobalQosConfig.annotations.setter
    def annotations(self, annotations):
        """Set annotations for global-qos-config.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.GlobalQosConfig.display_name.setter
    def display_name(self, display_name):
        """Set display-name for global-qos-config.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for global-qos-config.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for global-qos-config.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_tag(self, *args, **kwargs):
        """Set tag for global-qos-config.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(GlobalQosConfig, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to global-qos-config.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(GlobalQosConfig, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(GlobalQosConfig, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for global-qos-config.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(GlobalQosConfig, self).set_tag_list(*args, **kwargs)
    # end set_tag_list

    def get_qos_configs(self):
        if hasattr(self, 'qos_configs'):
            return self.qos_configs

        if hasattr(super(GlobalQosConfig, self), 'qos_configs'):
            return super(GlobalQosConfig, self).get_qos_configs()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.global_qos_config_read(id = self.uuid, fields = ['qos_configs'])
        except NoIdError:
            return None
        children = getattr(obj, 'qos_configs', None)
        if not children:
            return None
        self.qos_configs = children

        return children
    # end get_qos_configs

    def get_forwarding_classs(self):
        if hasattr(self, 'forwarding_classs'):
            return self.forwarding_classs

        if hasattr(super(GlobalQosConfig, self), 'forwarding_classs'):
            return super(GlobalQosConfig, self).get_forwarding_classs()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.global_qos_config_read(id = self.uuid, fields = ['forwarding_classs'])
        except NoIdError:
            return None
        children = getattr(obj, 'forwarding_classs', None)
        if not children:
            return None
        self.forwarding_classs = children

        return children
    # end get_forwarding_classs

    def get_qos_queues(self):
        if hasattr(self, 'qos_queues'):
            return self.qos_queues

        if hasattr(super(GlobalQosConfig, self), 'qos_queues'):
            return super(GlobalQosConfig, self).get_qos_queues()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.global_qos_config_read(id = self.uuid, fields = ['qos_queues'])
        except NoIdError:
            return None
        children = getattr(obj, 'qos_queues', None)
        if not children:
            return None
        self.qos_queues = children

        return children
    # end get_qos_queues


# end class GlobalQosConfig

class AnalyticsNode(vnc_api.gen.resource_common.AnalyticsNode):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'analytics_node_ip_address' in kwargs:
            pending_fields.append('analytics_node_ip_address')
        if len(args) > 1 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 2 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 3 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 4 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(AnalyticsNode, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            props_dict['analytics_node_ip_address'] = kwargs[u'analytics_node_ip_address']
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = AnalyticsNode(**props_dict)
        else:
            obj = AnalyticsNode(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.AnalyticsNode.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.AnalyticsNode.analytics_node_ip_address.setter
    def analytics_node_ip_address(self, analytics_node_ip_address):
        """Set analytics-node-ip-address for analytics-node.
        
        :param analytics_node_ip_address: IpAddressType object
        
        """
        if 'analytics_node_ip_address' not in self._pending_field_updates:
            self._pending_field_updates.add('analytics_node_ip_address')

        self._analytics_node_ip_address = analytics_node_ip_address
    # end analytics_node_ip_address

    def set_analytics_node_ip_address(self, value):
        self.analytics_node_ip_address = value
    # end set_analytics_node_ip_address

    @vnc_api.gen.resource_common.AnalyticsNode.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for analytics-node.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.AnalyticsNode.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for analytics-node.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.AnalyticsNode.annotations.setter
    def annotations(self, annotations):
        """Set annotations for analytics-node.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.AnalyticsNode.display_name.setter
    def display_name(self, display_name):
        """Set display-name for analytics-node.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for analytics-node.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for analytics-node.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_tag(self, *args, **kwargs):
        """Set tag for analytics-node.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(AnalyticsNode, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to analytics-node.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(AnalyticsNode, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(AnalyticsNode, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for analytics-node.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(AnalyticsNode, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


# end class AnalyticsNode

class VirtualDns(vnc_api.gen.resource_common.VirtualDns):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'virtual_DNS_data' in kwargs:
            pending_fields.append('virtual_DNS_data')
        if len(args) > 1 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 2 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 3 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 4 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(VirtualDns, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            if kwargs['virtual_DNS_data'] is None:
                props_dict['virtual_DNS_data'] = None
            else:
                props_dict['virtual_DNS_data'] = vnc_api.gen.resource_xsd.VirtualDnsType(params_dict=kwargs[u'virtual_DNS_data'])
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = VirtualDns(**props_dict)
        else:
            obj = VirtualDns(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...
        try:
            obj.virtual_DNS_records = kwargs[u'virtual_DNS_records']
        except KeyError:
            pass

        # add any specified references...
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.network_ipam_back_refs = kwargs[u'network_ipam_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.VirtualDns.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.VirtualDns.virtual_DNS_data.setter
    def virtual_DNS_data(self, virtual_DNS_data):
        """Set virtual-DNS-data for virtual-DNS.
        
        :param virtual_DNS_data: VirtualDnsType object
        
        """
        if 'virtual_DNS_data' not in self._pending_field_updates:
            self._pending_field_updates.add('virtual_DNS_data')

        self._virtual_DNS_data = virtual_DNS_data
    # end virtual_DNS_data

    def set_virtual_DNS_data(self, value):
        self.virtual_DNS_data = value
    # end set_virtual_DNS_data

    @vnc_api.gen.resource_common.VirtualDns.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for virtual-DNS.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.VirtualDns.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for virtual-DNS.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.VirtualDns.annotations.setter
    def annotations(self, annotations):
        """Set annotations for virtual-DNS.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.VirtualDns.display_name.setter
    def display_name(self, display_name):
        """Set display-name for virtual-DNS.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for virtual-DNS.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for virtual-DNS.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_tag(self, *args, **kwargs):
        """Set tag for virtual-DNS.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(VirtualDns, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to virtual-DNS.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(VirtualDns, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(VirtualDns, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for virtual-DNS.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(VirtualDns, self).set_tag_list(*args, **kwargs)
    # end set_tag_list

    def get_virtual_DNS_records(self):
        if hasattr(self, 'virtual_DNS_records'):
            return self.virtual_DNS_records

        if hasattr(super(VirtualDns, self), 'virtual_DNS_records'):
            return super(VirtualDns, self).get_virtual_DNS_records()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.virtual_DNS_read(id = self.uuid, fields = ['virtual_DNS_records'])
        except NoIdError:
            return None
        children = getattr(obj, 'virtual_DNS_records', None)
        if not children:
            return None
        self.virtual_DNS_records = children

        return children
    # end get_virtual_DNS_records


    def get_network_ipam_back_refs(self):
        """Return list of all network-ipams using this virtual-DNS"""
        if hasattr(self, 'network_ipam_back_refs'):
            return self.network_ipam_back_refs

        if hasattr(super(VirtualDns, self), 'network_ipam_back_refs'):
            return super(VirtualDns, self).get_network_ipam_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.virtual_DNS_read(id = self.uuid, fields = ['network_ipam_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'network_ipam_back_refs', None)
        if not back_refs:
            return None
        self.network_ipam_back_refs = back_refs

        return back_refs
    # end get_network_ipam_back_refs

# end class VirtualDns

class ConfigDatabaseNode(vnc_api.gen.resource_common.ConfigDatabaseNode):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'config_database_node_ip_address' in kwargs:
            pending_fields.append('config_database_node_ip_address')
        if len(args) > 1 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 2 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 3 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 4 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(ConfigDatabaseNode, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            props_dict['config_database_node_ip_address'] = kwargs[u'config_database_node_ip_address']
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = ConfigDatabaseNode(**props_dict)
        else:
            obj = ConfigDatabaseNode(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.ConfigDatabaseNode.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.ConfigDatabaseNode.config_database_node_ip_address.setter
    def config_database_node_ip_address(self, config_database_node_ip_address):
        """Set config-database-node-ip-address for config-database-node.
        
        :param config_database_node_ip_address: IpAddressType object
        
        """
        if 'config_database_node_ip_address' not in self._pending_field_updates:
            self._pending_field_updates.add('config_database_node_ip_address')

        self._config_database_node_ip_address = config_database_node_ip_address
    # end config_database_node_ip_address

    def set_config_database_node_ip_address(self, value):
        self.config_database_node_ip_address = value
    # end set_config_database_node_ip_address

    @vnc_api.gen.resource_common.ConfigDatabaseNode.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for config-database-node.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.ConfigDatabaseNode.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for config-database-node.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.ConfigDatabaseNode.annotations.setter
    def annotations(self, annotations):
        """Set annotations for config-database-node.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.ConfigDatabaseNode.display_name.setter
    def display_name(self, display_name):
        """Set display-name for config-database-node.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for config-database-node.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for config-database-node.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_tag(self, *args, **kwargs):
        """Set tag for config-database-node.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(ConfigDatabaseNode, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to config-database-node.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(ConfigDatabaseNode, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(ConfigDatabaseNode, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for config-database-node.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(ConfigDatabaseNode, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


# end class ConfigDatabaseNode

class ConfigNode(vnc_api.gen.resource_common.ConfigNode):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'config_node_ip_address' in kwargs:
            pending_fields.append('config_node_ip_address')
        if len(args) > 1 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 2 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 3 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 4 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(ConfigNode, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            props_dict['config_node_ip_address'] = kwargs[u'config_node_ip_address']
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = ConfigNode(**props_dict)
        else:
            obj = ConfigNode(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.ConfigNode.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.ConfigNode.config_node_ip_address.setter
    def config_node_ip_address(self, config_node_ip_address):
        """Set config-node-ip-address for config-node.
        
        :param config_node_ip_address: IpAddressType object
        
        """
        if 'config_node_ip_address' not in self._pending_field_updates:
            self._pending_field_updates.add('config_node_ip_address')

        self._config_node_ip_address = config_node_ip_address
    # end config_node_ip_address

    def set_config_node_ip_address(self, value):
        self.config_node_ip_address = value
    # end set_config_node_ip_address

    @vnc_api.gen.resource_common.ConfigNode.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for config-node.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.ConfigNode.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for config-node.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.ConfigNode.annotations.setter
    def annotations(self, annotations):
        """Set annotations for config-node.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.ConfigNode.display_name.setter
    def display_name(self, display_name):
        """Set display-name for config-node.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for config-node.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for config-node.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_tag(self, *args, **kwargs):
        """Set tag for config-node.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(ConfigNode, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to config-node.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(ConfigNode, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(ConfigNode, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for config-node.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(ConfigNode, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


# end class ConfigNode

class DeviceFunctionalGroup(vnc_api.gen.resource_common.DeviceFunctionalGroup):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'device_functional_group_description' in kwargs:
            pending_fields.append('device_functional_group_description')
        if len(args) > 1 or 'device_functional_group_os_version' in kwargs:
            pending_fields.append('device_functional_group_os_version')
        if len(args) > 2 or 'device_functional_group_routing_bridging_roles' in kwargs:
            pending_fields.append('device_functional_group_routing_bridging_roles')
        if len(args) > 3 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 4 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 5 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 6 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(DeviceFunctionalGroup, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            props_dict['device_functional_group_description'] = kwargs[u'device_functional_group_description']
        except KeyError:
            pass

        try:
            props_dict['device_functional_group_os_version'] = kwargs[u'device_functional_group_os_version']
        except KeyError:
            pass

        try:
            if kwargs['device_functional_group_routing_bridging_roles'] is None:
                props_dict['device_functional_group_routing_bridging_roles'] = None
            else:
                props_dict['device_functional_group_routing_bridging_roles'] = vnc_api.gen.resource_xsd.RoutingBridgingRolesType(params_dict=kwargs[u'device_functional_group_routing_bridging_roles'])
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = DeviceFunctionalGroup(**props_dict)
        else:
            obj = DeviceFunctionalGroup(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.physical_role_refs = kwargs[u'physical_role_refs']
        except KeyError:
            pass
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.physical_router_back_refs = kwargs[u'physical_router_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.DeviceFunctionalGroup.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.DeviceFunctionalGroup.device_functional_group_description.setter
    def device_functional_group_description(self, device_functional_group_description):
        """Set device-functional-group-description for device-functional-group.
        
        :param device_functional_group_description: xsd:string object
        
        """
        if 'device_functional_group_description' not in self._pending_field_updates:
            self._pending_field_updates.add('device_functional_group_description')

        self._device_functional_group_description = device_functional_group_description
    # end device_functional_group_description

    def set_device_functional_group_description(self, value):
        self.device_functional_group_description = value
    # end set_device_functional_group_description

    @vnc_api.gen.resource_common.DeviceFunctionalGroup.device_functional_group_os_version.setter
    def device_functional_group_os_version(self, device_functional_group_os_version):
        """Set device-functional-group-os-version for device-functional-group.
        
        :param device_functional_group_os_version: xsd:string object
        
        """
        if 'device_functional_group_os_version' not in self._pending_field_updates:
            self._pending_field_updates.add('device_functional_group_os_version')

        self._device_functional_group_os_version = device_functional_group_os_version
    # end device_functional_group_os_version

    def set_device_functional_group_os_version(self, value):
        self.device_functional_group_os_version = value
    # end set_device_functional_group_os_version

    @vnc_api.gen.resource_common.DeviceFunctionalGroup.device_functional_group_routing_bridging_roles.setter
    def device_functional_group_routing_bridging_roles(self, device_functional_group_routing_bridging_roles):
        """Set device-functional-group-routing-bridging-roles for device-functional-group.
        
        :param device_functional_group_routing_bridging_roles: RoutingBridgingRolesType object
        
        """
        if 'device_functional_group_routing_bridging_roles' not in self._pending_field_updates:
            self._pending_field_updates.add('device_functional_group_routing_bridging_roles')

        self._device_functional_group_routing_bridging_roles = device_functional_group_routing_bridging_roles
    # end device_functional_group_routing_bridging_roles

    def set_device_functional_group_routing_bridging_roles(self, value):
        self.device_functional_group_routing_bridging_roles = value
    # end set_device_functional_group_routing_bridging_roles

    @vnc_api.gen.resource_common.DeviceFunctionalGroup.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for device-functional-group.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.DeviceFunctionalGroup.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for device-functional-group.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.DeviceFunctionalGroup.annotations.setter
    def annotations(self, annotations):
        """Set annotations for device-functional-group.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.DeviceFunctionalGroup.display_name.setter
    def display_name(self, display_name):
        """Set display-name for device-functional-group.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for device-functional-group.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for device-functional-group.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_physical_role(self, *args, **kwargs):
        """Set physical-role for device-functional-group.
        
        :param ref_obj: PhysicalRole object
        
        """
        self._pending_field_updates.add('physical_role_refs')
        self._pending_ref_updates.discard('physical_role_refs')
        super(DeviceFunctionalGroup, self).set_physical_role(*args, **kwargs)

    # end set_physical_role

    def add_physical_role(self, *args, **kwargs):
        """Add physical-role to device-functional-group.
        
        :param ref_obj: PhysicalRole object
        
        """
        if 'physical_role_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('physical_role_refs')
            self._original_physical_role_refs = copy.deepcopy(self.get_physical_role_refs() or [])
        super(DeviceFunctionalGroup, self).add_physical_role(*args, **kwargs)
    # end add_physical_role

    def del_physical_role(self, *args, **kwargs):
        if 'physical_role_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('physical_role_refs')
            self._original_physical_role_refs = copy.deepcopy(self.get_physical_role_refs() or [])
        super(DeviceFunctionalGroup, self).del_physical_role(*args, **kwargs)
    # end del_physical_role

    def set_physical_role_list(self, *args, **kwargs):
        """Set physical-role list for device-functional-group.
        
        :param ref_obj_list: list of PhysicalRole object
        
        """
        self._pending_field_updates.add('physical_role_refs')
        self._pending_ref_updates.discard('physical_role_refs')
        super(DeviceFunctionalGroup, self).set_physical_role_list(*args, **kwargs)
    # end set_physical_role_list

    def set_tag(self, *args, **kwargs):
        """Set tag for device-functional-group.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(DeviceFunctionalGroup, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to device-functional-group.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(DeviceFunctionalGroup, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(DeviceFunctionalGroup, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for device-functional-group.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(DeviceFunctionalGroup, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


    def get_physical_router_back_refs(self):
        """Return list of all physical-routers using this device-functional-group"""
        if hasattr(self, 'physical_router_back_refs'):
            return self.physical_router_back_refs

        if hasattr(super(DeviceFunctionalGroup, self), 'physical_router_back_refs'):
            return super(DeviceFunctionalGroup, self).get_physical_router_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.device_functional_group_read(id = self.uuid, fields = ['physical_router_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'physical_router_back_refs', None)
        if not back_refs:
            return None
        self.physical_router_back_refs = back_refs

        return back_refs
    # end get_physical_router_back_refs

# end class DeviceFunctionalGroup

class FirewallRule(vnc_api.gen.resource_common.FirewallRule):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'draft_mode_state' in kwargs:
            pending_fields.append('draft_mode_state')
        if len(args) > 1 or 'action_list' in kwargs:
            pending_fields.append('action_list')
        if len(args) > 2 or 'service' in kwargs:
            pending_fields.append('service')
        if len(args) > 3 or 'endpoint_1' in kwargs:
            pending_fields.append('endpoint_1')
        if len(args) > 4 or 'endpoint_2' in kwargs:
            pending_fields.append('endpoint_2')
        if len(args) > 5 or 'match_tags' in kwargs:
            pending_fields.append('match_tags')
        if len(args) > 6 or 'match_tag_types' in kwargs:
            pending_fields.append('match_tag_types')
        if len(args) > 7 or 'direction' in kwargs:
            pending_fields.append('direction')
        if len(args) > 8 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 9 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 10 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 11 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(FirewallRule, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            props_dict['draft_mode_state'] = kwargs[u'draft_mode_state']
        except KeyError:
            pass

        try:
            if kwargs['action_list'] is None:
                props_dict['action_list'] = None
            else:
                props_dict['action_list'] = vnc_api.gen.resource_xsd.ActionListType(params_dict=kwargs[u'action_list'])
        except KeyError:
            pass

        try:
            if kwargs['service'] is None:
                props_dict['service'] = None
            else:
                props_dict['service'] = vnc_api.gen.resource_xsd.FirewallServiceType(params_dict=kwargs[u'service'])
        except KeyError:
            pass

        try:
            if kwargs['endpoint_1'] is None:
                props_dict['endpoint_1'] = None
            else:
                props_dict['endpoint_1'] = vnc_api.gen.resource_xsd.FirewallRuleEndpointType(params_dict=kwargs[u'endpoint_1'])
        except KeyError:
            pass

        try:
            if kwargs['endpoint_2'] is None:
                props_dict['endpoint_2'] = None
            else:
                props_dict['endpoint_2'] = vnc_api.gen.resource_xsd.FirewallRuleEndpointType(params_dict=kwargs[u'endpoint_2'])
        except KeyError:
            pass

        try:
            if kwargs['match_tags'] is None:
                props_dict['match_tags'] = None
            else:
                props_dict['match_tags'] = vnc_api.gen.resource_xsd.FirewallRuleMatchTagsType(params_dict=kwargs[u'match_tags'])
        except KeyError:
            pass

        try:
            if kwargs['match_tag_types'] is None:
                props_dict['match_tag_types'] = None
            else:
                props_dict['match_tag_types'] = vnc_api.gen.resource_xsd.FirewallRuleMatchTagsTypeIdList(params_dict=kwargs[u'match_tag_types'])
        except KeyError:
            pass

        try:
            props_dict['direction'] = kwargs[u'direction']
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = FirewallRule(**props_dict)
        else:
            obj = FirewallRule(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.service_group_refs = kwargs[u'service_group_refs']
        except KeyError:
            pass
        try:
            obj.address_group_refs = kwargs[u'address_group_refs']
        except KeyError:
            pass
        try:
            obj.virtual_network_refs = kwargs[u'virtual_network_refs']
        except KeyError:
            pass
        try:
            obj.security_logging_object_refs = kwargs[u'security_logging_object_refs']
            for ref in obj.security_logging_object_refs:
                ref['attr'] = vnc_api.gen.resource_xsd.SloRateType(params_dict=ref[u'attr'])
        except KeyError:
            pass
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.firewall_policy_back_refs = kwargs[u'firewall_policy_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.FirewallRule.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.FirewallRule.draft_mode_state.setter
    def draft_mode_state(self, draft_mode_state):
        """Set draft-mode-state for firewall-rule.
        
        :param draft_mode_state: DraftModeState object
        
        """
        if 'draft_mode_state' not in self._pending_field_updates:
            self._pending_field_updates.add('draft_mode_state')

        self._draft_mode_state = draft_mode_state
    # end draft_mode_state

    def set_draft_mode_state(self, value):
        self.draft_mode_state = value
    # end set_draft_mode_state

    @vnc_api.gen.resource_common.FirewallRule.action_list.setter
    def action_list(self, action_list):
        """Set action-list for firewall-rule.
        
        :param action_list: ActionListType object
        
        """
        if 'action_list' not in self._pending_field_updates:
            self._pending_field_updates.add('action_list')

        self._action_list = action_list
    # end action_list

    def set_action_list(self, value):
        self.action_list = value
    # end set_action_list

    @vnc_api.gen.resource_common.FirewallRule.service.setter
    def service(self, service):
        """Set service for firewall-rule.
        
        :param service: FirewallServiceType object
        
        """
        if 'service' not in self._pending_field_updates:
            self._pending_field_updates.add('service')

        self._service = service
    # end service

    def set_service(self, value):
        self.service = value
    # end set_service

    @vnc_api.gen.resource_common.FirewallRule.endpoint_1.setter
    def endpoint_1(self, endpoint_1):
        """Set endpoint-1 for firewall-rule.
        
        :param endpoint_1: FirewallRuleEndpointType object
        
        """
        if 'endpoint_1' not in self._pending_field_updates:
            self._pending_field_updates.add('endpoint_1')

        self._endpoint_1 = endpoint_1
    # end endpoint_1

    def set_endpoint_1(self, value):
        self.endpoint_1 = value
    # end set_endpoint_1

    @vnc_api.gen.resource_common.FirewallRule.endpoint_2.setter
    def endpoint_2(self, endpoint_2):
        """Set endpoint-2 for firewall-rule.
        
        :param endpoint_2: FirewallRuleEndpointType object
        
        """
        if 'endpoint_2' not in self._pending_field_updates:
            self._pending_field_updates.add('endpoint_2')

        self._endpoint_2 = endpoint_2
    # end endpoint_2

    def set_endpoint_2(self, value):
        self.endpoint_2 = value
    # end set_endpoint_2

    @vnc_api.gen.resource_common.FirewallRule.match_tags.setter
    def match_tags(self, match_tags):
        """Set match-tags for firewall-rule.
        
        :param match_tags: FirewallRuleMatchTagsType object
        
        """
        if 'match_tags' not in self._pending_field_updates:
            self._pending_field_updates.add('match_tags')

        if 'match_tags' in self._pending_field_list_updates:
            # set clobbers earlier add/del on prop list elements
            del self._pending_field_list_updates['match_tags']

        self._match_tags = match_tags
    # end match_tags

    def set_match_tags(self, value):
        self.match_tags = value
    # end set_match_tags

    @vnc_api.gen.resource_common.FirewallRule.match_tag_types.setter
    def match_tag_types(self, match_tag_types):
        """Set match-tag-types for firewall-rule.
        
        :param match_tag_types: FirewallRuleMatchTagsTypeIdList object
        
        """
        if 'match_tag_types' not in self._pending_field_updates:
            self._pending_field_updates.add('match_tag_types')

        self._match_tag_types = match_tag_types
    # end match_tag_types

    def set_match_tag_types(self, value):
        self.match_tag_types = value
    # end set_match_tag_types

    @vnc_api.gen.resource_common.FirewallRule.direction.setter
    def direction(self, direction):
        """Set direction for firewall-rule.
        
        :param direction: FirewallRuleDirectionType object
        
        """
        if 'direction' not in self._pending_field_updates:
            self._pending_field_updates.add('direction')

        self._direction = direction
    # end direction

    def set_direction(self, value):
        self.direction = value
    # end set_direction

    @vnc_api.gen.resource_common.FirewallRule.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for firewall-rule.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.FirewallRule.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for firewall-rule.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.FirewallRule.annotations.setter
    def annotations(self, annotations):
        """Set annotations for firewall-rule.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.FirewallRule.display_name.setter
    def display_name(self, display_name):
        """Set display-name for firewall-rule.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_match_tags(self, elem_value, elem_position=None):
        """Add element to match-tags for firewall-rule.
        
        :param elem_value: xsd:string object
        :param elem_position: optional string order-key
        
        """
        if 'match_tags' not in self._pending_field_list_updates:
            self._pending_field_list_updates['match_tags'] = [
                ('add', elem_value, elem_position)]
        else:
            self._pending_field_list_updates['match_tags'].append(
                ('add', elem_value, elem_position))
    # end add_match_tags

    def del_match_tags(self, elem_position):
        """Delete element from match-tags for firewall-rule.
        
        :param elem_position: string indicating order-key
        
        """
        if 'match_tags' not in self._pending_field_list_updates:
            self._pending_field_list_updates['match_tags'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_list_updates['match_tags'].append(
                ('delete', None, elem_position))
    # end del_match_tags
    def add_annotations(self, elem):
        """Add element to annotations for firewall-rule.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for firewall-rule.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_service_group(self, *args, **kwargs):
        """Set service-group for firewall-rule.
        
        :param ref_obj: ServiceGroup object
        
        """
        self._pending_field_updates.add('service_group_refs')
        self._pending_ref_updates.discard('service_group_refs')
        super(FirewallRule, self).set_service_group(*args, **kwargs)

    # end set_service_group

    def add_service_group(self, *args, **kwargs):
        """Add service-group to firewall-rule.
        
        :param ref_obj: ServiceGroup object
        
        """
        if 'service_group_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('service_group_refs')
            self._original_service_group_refs = copy.deepcopy(self.get_service_group_refs() or [])
        super(FirewallRule, self).add_service_group(*args, **kwargs)
    # end add_service_group

    def del_service_group(self, *args, **kwargs):
        if 'service_group_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('service_group_refs')
            self._original_service_group_refs = copy.deepcopy(self.get_service_group_refs() or [])
        super(FirewallRule, self).del_service_group(*args, **kwargs)
    # end del_service_group

    def set_service_group_list(self, *args, **kwargs):
        """Set service-group list for firewall-rule.
        
        :param ref_obj_list: list of ServiceGroup object
        
        """
        self._pending_field_updates.add('service_group_refs')
        self._pending_ref_updates.discard('service_group_refs')
        super(FirewallRule, self).set_service_group_list(*args, **kwargs)
    # end set_service_group_list

    def set_address_group(self, *args, **kwargs):
        """Set address-group for firewall-rule.
        
        :param ref_obj: AddressGroup object
        
        """
        self._pending_field_updates.add('address_group_refs')
        self._pending_ref_updates.discard('address_group_refs')
        super(FirewallRule, self).set_address_group(*args, **kwargs)

    # end set_address_group

    def add_address_group(self, *args, **kwargs):
        """Add address-group to firewall-rule.
        
        :param ref_obj: AddressGroup object
        
        """
        if 'address_group_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('address_group_refs')
            self._original_address_group_refs = copy.deepcopy(self.get_address_group_refs() or [])
        super(FirewallRule, self).add_address_group(*args, **kwargs)
    # end add_address_group

    def del_address_group(self, *args, **kwargs):
        if 'address_group_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('address_group_refs')
            self._original_address_group_refs = copy.deepcopy(self.get_address_group_refs() or [])
        super(FirewallRule, self).del_address_group(*args, **kwargs)
    # end del_address_group

    def set_address_group_list(self, *args, **kwargs):
        """Set address-group list for firewall-rule.
        
        :param ref_obj_list: list of AddressGroup object
        
        """
        self._pending_field_updates.add('address_group_refs')
        self._pending_ref_updates.discard('address_group_refs')
        super(FirewallRule, self).set_address_group_list(*args, **kwargs)
    # end set_address_group_list

    def set_virtual_network(self, *args, **kwargs):
        """Set virtual-network for firewall-rule.
        
        :param ref_obj: VirtualNetwork object
        
        """
        self._pending_field_updates.add('virtual_network_refs')
        self._pending_ref_updates.discard('virtual_network_refs')
        super(FirewallRule, self).set_virtual_network(*args, **kwargs)

    # end set_virtual_network

    def add_virtual_network(self, *args, **kwargs):
        """Add virtual-network to firewall-rule.
        
        :param ref_obj: VirtualNetwork object
        
        """
        if 'virtual_network_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('virtual_network_refs')
            self._original_virtual_network_refs = copy.deepcopy(self.get_virtual_network_refs() or [])
        super(FirewallRule, self).add_virtual_network(*args, **kwargs)
    # end add_virtual_network

    def del_virtual_network(self, *args, **kwargs):
        if 'virtual_network_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('virtual_network_refs')
            self._original_virtual_network_refs = copy.deepcopy(self.get_virtual_network_refs() or [])
        super(FirewallRule, self).del_virtual_network(*args, **kwargs)
    # end del_virtual_network

    def set_virtual_network_list(self, *args, **kwargs):
        """Set virtual-network list for firewall-rule.
        
        :param ref_obj_list: list of VirtualNetwork object
        
        """
        self._pending_field_updates.add('virtual_network_refs')
        self._pending_ref_updates.discard('virtual_network_refs')
        super(FirewallRule, self).set_virtual_network_list(*args, **kwargs)
    # end set_virtual_network_list

    def set_security_logging_object(self, *args, **kwargs):
        """Set security-logging-object for firewall-rule.
        
        :param ref_obj: SecurityLoggingObject object
        :param ref_data: SloRateType object
        
        """
        self._pending_field_updates.add('security_logging_object_refs')
        self._pending_ref_updates.discard('security_logging_object_refs')
        super(FirewallRule, self).set_security_logging_object(*args, **kwargs)

    # end set_security_logging_object

    def add_security_logging_object(self, *args, **kwargs):
        """Add security-logging-object to firewall-rule.
        
        :param ref_obj: SecurityLoggingObject object
        :param ref_data: SloRateType object
        
        """
        if 'security_logging_object_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('security_logging_object_refs')
            self._original_security_logging_object_refs = copy.deepcopy(self.get_security_logging_object_refs() or [])
        super(FirewallRule, self).add_security_logging_object(*args, **kwargs)
    # end add_security_logging_object

    def del_security_logging_object(self, *args, **kwargs):
        if 'security_logging_object_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('security_logging_object_refs')
            self._original_security_logging_object_refs = copy.deepcopy(self.get_security_logging_object_refs() or [])
        super(FirewallRule, self).del_security_logging_object(*args, **kwargs)
    # end del_security_logging_object

    def set_security_logging_object_list(self, *args, **kwargs):
        """Set security-logging-object list for firewall-rule.
        
        :param ref_obj_list: list of SecurityLoggingObject object
        :param ref_data_list: list of SloRateType summary
        
        """
        self._pending_field_updates.add('security_logging_object_refs')
        self._pending_ref_updates.discard('security_logging_object_refs')
        super(FirewallRule, self).set_security_logging_object_list(*args, **kwargs)
    # end set_security_logging_object_list

    def set_tag(self, *args, **kwargs):
        """Set tag for firewall-rule.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(FirewallRule, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to firewall-rule.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(FirewallRule, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(FirewallRule, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for firewall-rule.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(FirewallRule, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


    def get_firewall_policy_back_refs(self):
        """Return list of all firewall-policys using this firewall-rule"""
        if hasattr(self, 'firewall_policy_back_refs'):
            return self.firewall_policy_back_refs

        if hasattr(super(FirewallRule, self), 'firewall_policy_back_refs'):
            return super(FirewallRule, self).get_firewall_policy_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.firewall_rule_read(id = self.uuid, fields = ['firewall_policy_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'firewall_policy_back_refs', None)
        if not back_refs:
            return None
        self.firewall_policy_back_refs = back_refs

        return back_refs
    # end get_firewall_policy_back_refs

# end class FirewallRule

class Bgpvpn(vnc_api.gen.resource_common.Bgpvpn):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'route_target_list' in kwargs:
            pending_fields.append('route_target_list')
        if len(args) > 1 or 'import_route_target_list' in kwargs:
            pending_fields.append('import_route_target_list')
        if len(args) > 2 or 'export_route_target_list' in kwargs:
            pending_fields.append('export_route_target_list')
        if len(args) > 3 or 'bgpvpn_type' in kwargs:
            pending_fields.append('bgpvpn_type')
        if len(args) > 4 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 5 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 6 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 7 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(Bgpvpn, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            if kwargs['route_target_list'] is None:
                props_dict['route_target_list'] = None
            else:
                props_dict['route_target_list'] = vnc_api.gen.resource_xsd.RouteTargetList(params_dict=kwargs[u'route_target_list'])
        except KeyError:
            pass

        try:
            if kwargs['import_route_target_list'] is None:
                props_dict['import_route_target_list'] = None
            else:
                props_dict['import_route_target_list'] = vnc_api.gen.resource_xsd.RouteTargetList(params_dict=kwargs[u'import_route_target_list'])
        except KeyError:
            pass

        try:
            if kwargs['export_route_target_list'] is None:
                props_dict['export_route_target_list'] = None
            else:
                props_dict['export_route_target_list'] = vnc_api.gen.resource_xsd.RouteTargetList(params_dict=kwargs[u'export_route_target_list'])
        except KeyError:
            pass

        try:
            props_dict['bgpvpn_type'] = kwargs[u'bgpvpn_type']
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = Bgpvpn(**props_dict)
        else:
            obj = Bgpvpn(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.virtual_network_back_refs = kwargs[u'virtual_network_back_refs']
        except KeyError:
            pass
        try:
            obj.logical_router_back_refs = kwargs[u'logical_router_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.Bgpvpn.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.Bgpvpn.route_target_list.setter
    def route_target_list(self, route_target_list):
        """Set route-target-list for bgpvpn.
        
        :param route_target_list: RouteTargetList object
        
        """
        if 'route_target_list' not in self._pending_field_updates:
            self._pending_field_updates.add('route_target_list')

        self._route_target_list = route_target_list
    # end route_target_list

    def set_route_target_list(self, value):
        self.route_target_list = value
    # end set_route_target_list

    @vnc_api.gen.resource_common.Bgpvpn.import_route_target_list.setter
    def import_route_target_list(self, import_route_target_list):
        """Set import-route-target-list for bgpvpn.
        
        :param import_route_target_list: RouteTargetList object
        
        """
        if 'import_route_target_list' not in self._pending_field_updates:
            self._pending_field_updates.add('import_route_target_list')

        self._import_route_target_list = import_route_target_list
    # end import_route_target_list

    def set_import_route_target_list(self, value):
        self.import_route_target_list = value
    # end set_import_route_target_list

    @vnc_api.gen.resource_common.Bgpvpn.export_route_target_list.setter
    def export_route_target_list(self, export_route_target_list):
        """Set export-route-target-list for bgpvpn.
        
        :param export_route_target_list: RouteTargetList object
        
        """
        if 'export_route_target_list' not in self._pending_field_updates:
            self._pending_field_updates.add('export_route_target_list')

        self._export_route_target_list = export_route_target_list
    # end export_route_target_list

    def set_export_route_target_list(self, value):
        self.export_route_target_list = value
    # end set_export_route_target_list

    @vnc_api.gen.resource_common.Bgpvpn.bgpvpn_type.setter
    def bgpvpn_type(self, bgpvpn_type):
        """Set bgpvpn-type for bgpvpn.
        
        :param bgpvpn_type: VpnType object
        
        """
        if 'bgpvpn_type' not in self._pending_field_updates:
            self._pending_field_updates.add('bgpvpn_type')

        self._bgpvpn_type = bgpvpn_type
    # end bgpvpn_type

    def set_bgpvpn_type(self, value):
        self.bgpvpn_type = value
    # end set_bgpvpn_type

    @vnc_api.gen.resource_common.Bgpvpn.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for bgpvpn.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.Bgpvpn.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for bgpvpn.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.Bgpvpn.annotations.setter
    def annotations(self, annotations):
        """Set annotations for bgpvpn.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.Bgpvpn.display_name.setter
    def display_name(self, display_name):
        """Set display-name for bgpvpn.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for bgpvpn.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for bgpvpn.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_tag(self, *args, **kwargs):
        """Set tag for bgpvpn.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(Bgpvpn, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to bgpvpn.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(Bgpvpn, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(Bgpvpn, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for bgpvpn.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(Bgpvpn, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


    def get_virtual_network_back_refs(self):
        """Return list of all virtual-networks using this bgpvpn"""
        if hasattr(self, 'virtual_network_back_refs'):
            return self.virtual_network_back_refs

        if hasattr(super(Bgpvpn, self), 'virtual_network_back_refs'):
            return super(Bgpvpn, self).get_virtual_network_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.bgpvpn_read(id = self.uuid, fields = ['virtual_network_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'virtual_network_back_refs', None)
        if not back_refs:
            return None
        self.virtual_network_back_refs = back_refs

        return back_refs
    # end get_virtual_network_back_refs

    def get_logical_router_back_refs(self):
        """Return list of all logical-routers using this bgpvpn"""
        if hasattr(self, 'logical_router_back_refs'):
            return self.logical_router_back_refs

        if hasattr(super(Bgpvpn, self), 'logical_router_back_refs'):
            return super(Bgpvpn, self).get_logical_router_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.bgpvpn_read(id = self.uuid, fields = ['logical_router_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'logical_router_back_refs', None)
        if not back_refs:
            return None
        self.logical_router_back_refs = back_refs

        return back_refs
    # end get_logical_router_back_refs

# end class Bgpvpn

class RoleDefinition(vnc_api.gen.resource_common.RoleDefinition):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 1 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 2 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 3 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(RoleDefinition, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = RoleDefinition(**props_dict)
        else:
            obj = RoleDefinition(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...
        try:
            obj.feature_configs = kwargs[u'feature_configs']
        except KeyError:
            pass

        # add any specified references...
        try:
            obj.feature_refs = kwargs[u'feature_refs']
        except KeyError:
            pass
        try:
            obj.physical_role_refs = kwargs[u'physical_role_refs']
        except KeyError:
            pass
        try:
            obj.overlay_role_refs = kwargs[u'overlay_role_refs']
        except KeyError:
            pass
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.node_profile_back_refs = kwargs[u'node_profile_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.RoleDefinition.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.RoleDefinition.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for role-definition.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.RoleDefinition.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for role-definition.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.RoleDefinition.annotations.setter
    def annotations(self, annotations):
        """Set annotations for role-definition.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.RoleDefinition.display_name.setter
    def display_name(self, display_name):
        """Set display-name for role-definition.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for role-definition.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for role-definition.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_feature(self, *args, **kwargs):
        """Set feature for role-definition.
        
        :param ref_obj: Feature object
        
        """
        self._pending_field_updates.add('feature_refs')
        self._pending_ref_updates.discard('feature_refs')
        super(RoleDefinition, self).set_feature(*args, **kwargs)

    # end set_feature

    def add_feature(self, *args, **kwargs):
        """Add feature to role-definition.
        
        :param ref_obj: Feature object
        
        """
        if 'feature_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('feature_refs')
            self._original_feature_refs = copy.deepcopy(self.get_feature_refs() or [])
        super(RoleDefinition, self).add_feature(*args, **kwargs)
    # end add_feature

    def del_feature(self, *args, **kwargs):
        if 'feature_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('feature_refs')
            self._original_feature_refs = copy.deepcopy(self.get_feature_refs() or [])
        super(RoleDefinition, self).del_feature(*args, **kwargs)
    # end del_feature

    def set_feature_list(self, *args, **kwargs):
        """Set feature list for role-definition.
        
        :param ref_obj_list: list of Feature object
        
        """
        self._pending_field_updates.add('feature_refs')
        self._pending_ref_updates.discard('feature_refs')
        super(RoleDefinition, self).set_feature_list(*args, **kwargs)
    # end set_feature_list

    def set_physical_role(self, *args, **kwargs):
        """Set physical-role for role-definition.
        
        :param ref_obj: PhysicalRole object
        
        """
        self._pending_field_updates.add('physical_role_refs')
        self._pending_ref_updates.discard('physical_role_refs')
        super(RoleDefinition, self).set_physical_role(*args, **kwargs)

    # end set_physical_role

    def add_physical_role(self, *args, **kwargs):
        """Add physical-role to role-definition.
        
        :param ref_obj: PhysicalRole object
        
        """
        if 'physical_role_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('physical_role_refs')
            self._original_physical_role_refs = copy.deepcopy(self.get_physical_role_refs() or [])
        super(RoleDefinition, self).add_physical_role(*args, **kwargs)
    # end add_physical_role

    def del_physical_role(self, *args, **kwargs):
        if 'physical_role_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('physical_role_refs')
            self._original_physical_role_refs = copy.deepcopy(self.get_physical_role_refs() or [])
        super(RoleDefinition, self).del_physical_role(*args, **kwargs)
    # end del_physical_role

    def set_physical_role_list(self, *args, **kwargs):
        """Set physical-role list for role-definition.
        
        :param ref_obj_list: list of PhysicalRole object
        
        """
        self._pending_field_updates.add('physical_role_refs')
        self._pending_ref_updates.discard('physical_role_refs')
        super(RoleDefinition, self).set_physical_role_list(*args, **kwargs)
    # end set_physical_role_list

    def set_overlay_role(self, *args, **kwargs):
        """Set overlay-role for role-definition.
        
        :param ref_obj: OverlayRole object
        
        """
        self._pending_field_updates.add('overlay_role_refs')
        self._pending_ref_updates.discard('overlay_role_refs')
        super(RoleDefinition, self).set_overlay_role(*args, **kwargs)

    # end set_overlay_role

    def add_overlay_role(self, *args, **kwargs):
        """Add overlay-role to role-definition.
        
        :param ref_obj: OverlayRole object
        
        """
        if 'overlay_role_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('overlay_role_refs')
            self._original_overlay_role_refs = copy.deepcopy(self.get_overlay_role_refs() or [])
        super(RoleDefinition, self).add_overlay_role(*args, **kwargs)
    # end add_overlay_role

    def del_overlay_role(self, *args, **kwargs):
        if 'overlay_role_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('overlay_role_refs')
            self._original_overlay_role_refs = copy.deepcopy(self.get_overlay_role_refs() or [])
        super(RoleDefinition, self).del_overlay_role(*args, **kwargs)
    # end del_overlay_role

    def set_overlay_role_list(self, *args, **kwargs):
        """Set overlay-role list for role-definition.
        
        :param ref_obj_list: list of OverlayRole object
        
        """
        self._pending_field_updates.add('overlay_role_refs')
        self._pending_ref_updates.discard('overlay_role_refs')
        super(RoleDefinition, self).set_overlay_role_list(*args, **kwargs)
    # end set_overlay_role_list

    def set_tag(self, *args, **kwargs):
        """Set tag for role-definition.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(RoleDefinition, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to role-definition.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(RoleDefinition, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(RoleDefinition, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for role-definition.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(RoleDefinition, self).set_tag_list(*args, **kwargs)
    # end set_tag_list

    def get_feature_configs(self):
        if hasattr(self, 'feature_configs'):
            return self.feature_configs

        if hasattr(super(RoleDefinition, self), 'feature_configs'):
            return super(RoleDefinition, self).get_feature_configs()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.role_definition_read(id = self.uuid, fields = ['feature_configs'])
        except NoIdError:
            return None
        children = getattr(obj, 'feature_configs', None)
        if not children:
            return None
        self.feature_configs = children

        return children
    # end get_feature_configs


    def get_node_profile_back_refs(self):
        """Return list of all node-profiles using this role-definition"""
        if hasattr(self, 'node_profile_back_refs'):
            return self.node_profile_back_refs

        if hasattr(super(RoleDefinition, self), 'node_profile_back_refs'):
            return super(RoleDefinition, self).get_node_profile_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.role_definition_read(id = self.uuid, fields = ['node_profile_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'node_profile_back_refs', None)
        if not back_refs:
            return None
        self.node_profile_back_refs = back_refs

        return back_refs
    # end get_node_profile_back_refs

# end class RoleDefinition

class ServiceConnectionModule(vnc_api.gen.resource_common.ServiceConnectionModule):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, *args, **kwargs):
        pending_fields = ['fq_name']

        self._server_conn = None

        if len(args) > 0 or 'e2_service' in kwargs:
            pending_fields.append('e2_service')
        if len(args) > 1 or 'service_type' in kwargs:
            pending_fields.append('service_type')
        if len(args) > 2 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 3 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 4 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 5 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(ServiceConnectionModule, self).__init__(name, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            props_dict['e2_service'] = kwargs[u'e2_service']
        except KeyError:
            pass

        try:
            props_dict['service_type'] = kwargs[u'service_type']
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = ServiceConnectionModule(**props_dict)
        else:
            obj = ServiceConnectionModule(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.service_object_refs = kwargs[u'service_object_refs']
        except KeyError:
            pass
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.service_endpoint_back_refs = kwargs[u'service_endpoint_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.ServiceConnectionModule.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.ServiceConnectionModule.e2_service.setter
    def e2_service(self, e2_service):
        """Set e2-service for service-connection-module.
        
        :param e2_service: E2servicetype object
        
        """
        if 'e2_service' not in self._pending_field_updates:
            self._pending_field_updates.add('e2_service')

        self._e2_service = e2_service
    # end e2_service

    def set_e2_service(self, value):
        self.e2_service = value
    # end set_e2_service

    @vnc_api.gen.resource_common.ServiceConnectionModule.service_type.setter
    def service_type(self, service_type):
        """Set service-type for service-connection-module.
        
        :param service_type: ServiceConnectionType object
        
        """
        if 'service_type' not in self._pending_field_updates:
            self._pending_field_updates.add('service_type')

        self._service_type = service_type
    # end service_type

    def set_service_type(self, value):
        self.service_type = value
    # end set_service_type

    @vnc_api.gen.resource_common.ServiceConnectionModule.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for service-connection-module.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.ServiceConnectionModule.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for service-connection-module.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.ServiceConnectionModule.annotations.setter
    def annotations(self, annotations):
        """Set annotations for service-connection-module.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.ServiceConnectionModule.display_name.setter
    def display_name(self, display_name):
        """Set display-name for service-connection-module.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for service-connection-module.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for service-connection-module.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_service_object(self, *args, **kwargs):
        """Set service-object for service-connection-module.
        
        :param ref_obj: ServiceObject object
        
        """
        self._pending_field_updates.add('service_object_refs')
        self._pending_ref_updates.discard('service_object_refs')
        super(ServiceConnectionModule, self).set_service_object(*args, **kwargs)

    # end set_service_object

    def add_service_object(self, *args, **kwargs):
        """Add service-object to service-connection-module.
        
        :param ref_obj: ServiceObject object
        
        """
        if 'service_object_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('service_object_refs')
            self._original_service_object_refs = copy.deepcopy(self.get_service_object_refs() or [])
        super(ServiceConnectionModule, self).add_service_object(*args, **kwargs)
    # end add_service_object

    def del_service_object(self, *args, **kwargs):
        if 'service_object_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('service_object_refs')
            self._original_service_object_refs = copy.deepcopy(self.get_service_object_refs() or [])
        super(ServiceConnectionModule, self).del_service_object(*args, **kwargs)
    # end del_service_object

    def set_service_object_list(self, *args, **kwargs):
        """Set service-object list for service-connection-module.
        
        :param ref_obj_list: list of ServiceObject object
        
        """
        self._pending_field_updates.add('service_object_refs')
        self._pending_ref_updates.discard('service_object_refs')
        super(ServiceConnectionModule, self).set_service_object_list(*args, **kwargs)
    # end set_service_object_list

    def set_tag(self, *args, **kwargs):
        """Set tag for service-connection-module.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(ServiceConnectionModule, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to service-connection-module.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(ServiceConnectionModule, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(ServiceConnectionModule, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for service-connection-module.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(ServiceConnectionModule, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


    def get_service_endpoint_back_refs(self):
        """Return list of all service-endpoints using this service-connection-module"""
        if hasattr(self, 'service_endpoint_back_refs'):
            return self.service_endpoint_back_refs

        if hasattr(super(ServiceConnectionModule, self), 'service_endpoint_back_refs'):
            return super(ServiceConnectionModule, self).get_service_endpoint_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.service_connection_module_read(id = self.uuid, fields = ['service_endpoint_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'service_endpoint_back_refs', None)
        if not back_refs:
            return None
        self.service_endpoint_back_refs = back_refs

        return back_refs
    # end get_service_endpoint_back_refs

# end class ServiceConnectionModule

class SecurityGroup(vnc_api.gen.resource_common.SecurityGroup):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'security_group_id' in kwargs:
            pending_fields.append('security_group_id')
        if len(args) > 1 or 'configured_security_group_id' in kwargs:
            pending_fields.append('configured_security_group_id')
        if len(args) > 2 or 'security_group_entries' in kwargs:
            pending_fields.append('security_group_entries')
        if len(args) > 3 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 4 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 5 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 6 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(SecurityGroup, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            props_dict['security_group_id'] = kwargs[u'security_group_id']
        except KeyError:
            pass

        try:
            props_dict['configured_security_group_id'] = kwargs[u'configured_security_group_id']
        except KeyError:
            pass

        try:
            if kwargs['security_group_entries'] is None:
                props_dict['security_group_entries'] = None
            else:
                props_dict['security_group_entries'] = vnc_api.gen.resource_xsd.PolicyEntriesType(params_dict=kwargs[u'security_group_entries'])
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = SecurityGroup(**props_dict)
        else:
            obj = SecurityGroup(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...
        try:
            obj.access_control_lists = kwargs[u'access_control_lists']
        except KeyError:
            pass

        # add any specified references...
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.security_logging_object_back_refs = kwargs[u'security_logging_object_back_refs']
        except KeyError:
            pass
        try:
            obj.virtual_machine_interface_back_refs = kwargs[u'virtual_machine_interface_back_refs']
        except KeyError:
            pass
        try:
            obj.virtual_port_group_back_refs = kwargs[u'virtual_port_group_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.SecurityGroup.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.SecurityGroup.security_group_id.setter
    def security_group_id(self, security_group_id):
        """Set security-group-id for security-group.
        
        :param security_group_id: SecurityGroupIdType object
        
        """
        if 'security_group_id' not in self._pending_field_updates:
            self._pending_field_updates.add('security_group_id')

        self._security_group_id = security_group_id
    # end security_group_id

    def set_security_group_id(self, value):
        self.security_group_id = value
    # end set_security_group_id

    @vnc_api.gen.resource_common.SecurityGroup.configured_security_group_id.setter
    def configured_security_group_id(self, configured_security_group_id):
        """Set configured-security-group-id for security-group.
        
        :param configured_security_group_id: ConfiguredSecurityGroupIdType object
        
        """
        if 'configured_security_group_id' not in self._pending_field_updates:
            self._pending_field_updates.add('configured_security_group_id')

        self._configured_security_group_id = configured_security_group_id
    # end configured_security_group_id

    def set_configured_security_group_id(self, value):
        self.configured_security_group_id = value
    # end set_configured_security_group_id

    @vnc_api.gen.resource_common.SecurityGroup.security_group_entries.setter
    def security_group_entries(self, security_group_entries):
        """Set security-group-entries for security-group.
        
        :param security_group_entries: PolicyEntriesType object
        
        """
        if 'security_group_entries' not in self._pending_field_updates:
            self._pending_field_updates.add('security_group_entries')

        self._security_group_entries = security_group_entries
    # end security_group_entries

    def set_security_group_entries(self, value):
        self.security_group_entries = value
    # end set_security_group_entries

    @vnc_api.gen.resource_common.SecurityGroup.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for security-group.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.SecurityGroup.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for security-group.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.SecurityGroup.annotations.setter
    def annotations(self, annotations):
        """Set annotations for security-group.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.SecurityGroup.display_name.setter
    def display_name(self, display_name):
        """Set display-name for security-group.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for security-group.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for security-group.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_tag(self, *args, **kwargs):
        """Set tag for security-group.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(SecurityGroup, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to security-group.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(SecurityGroup, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(SecurityGroup, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for security-group.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(SecurityGroup, self).set_tag_list(*args, **kwargs)
    # end set_tag_list

    def get_access_control_lists(self):
        if hasattr(self, 'access_control_lists'):
            return self.access_control_lists

        if hasattr(super(SecurityGroup, self), 'access_control_lists'):
            return super(SecurityGroup, self).get_access_control_lists()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.security_group_read(id = self.uuid, fields = ['access_control_lists'])
        except NoIdError:
            return None
        children = getattr(obj, 'access_control_lists', None)
        if not children:
            return None
        self.access_control_lists = children

        return children
    # end get_access_control_lists


    def get_security_logging_object_back_refs(self):
        """Return list of all security-logging-objects using this security-group"""
        if hasattr(self, 'security_logging_object_back_refs'):
            return self.security_logging_object_back_refs

        if hasattr(super(SecurityGroup, self), 'security_logging_object_back_refs'):
            return super(SecurityGroup, self).get_security_logging_object_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.security_group_read(id = self.uuid, fields = ['security_logging_object_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'security_logging_object_back_refs', None)
        if not back_refs:
            return None
        self.security_logging_object_back_refs = back_refs

        return back_refs
    # end get_security_logging_object_back_refs

    def get_virtual_machine_interface_back_refs(self):
        """Return list of all virtual-machine-interfaces using this security-group"""
        if hasattr(self, 'virtual_machine_interface_back_refs'):
            return self.virtual_machine_interface_back_refs

        if hasattr(super(SecurityGroup, self), 'virtual_machine_interface_back_refs'):
            return super(SecurityGroup, self).get_virtual_machine_interface_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.security_group_read(id = self.uuid, fields = ['virtual_machine_interface_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'virtual_machine_interface_back_refs', None)
        if not back_refs:
            return None
        self.virtual_machine_interface_back_refs = back_refs

        return back_refs
    # end get_virtual_machine_interface_back_refs

    def get_virtual_port_group_back_refs(self):
        """Return list of all virtual-port-groups using this security-group"""
        if hasattr(self, 'virtual_port_group_back_refs'):
            return self.virtual_port_group_back_refs

        if hasattr(super(SecurityGroup, self), 'virtual_port_group_back_refs'):
            return super(SecurityGroup, self).get_virtual_port_group_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.security_group_read(id = self.uuid, fields = ['virtual_port_group_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'virtual_port_group_back_refs', None)
        if not back_refs:
            return None
        self.virtual_port_group_back_refs = back_refs

        return back_refs
    # end get_virtual_port_group_back_refs

# end class SecurityGroup

class DatabaseNode(vnc_api.gen.resource_common.DatabaseNode):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'database_node_ip_address' in kwargs:
            pending_fields.append('database_node_ip_address')
        if len(args) > 1 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 2 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 3 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 4 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(DatabaseNode, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            props_dict['database_node_ip_address'] = kwargs[u'database_node_ip_address']
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = DatabaseNode(**props_dict)
        else:
            obj = DatabaseNode(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.DatabaseNode.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.DatabaseNode.database_node_ip_address.setter
    def database_node_ip_address(self, database_node_ip_address):
        """Set database-node-ip-address for database-node.
        
        :param database_node_ip_address: IpAddressType object
        
        """
        if 'database_node_ip_address' not in self._pending_field_updates:
            self._pending_field_updates.add('database_node_ip_address')

        self._database_node_ip_address = database_node_ip_address
    # end database_node_ip_address

    def set_database_node_ip_address(self, value):
        self.database_node_ip_address = value
    # end set_database_node_ip_address

    @vnc_api.gen.resource_common.DatabaseNode.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for database-node.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.DatabaseNode.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for database-node.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.DatabaseNode.annotations.setter
    def annotations(self, annotations):
        """Set annotations for database-node.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.DatabaseNode.display_name.setter
    def display_name(self, display_name):
        """Set display-name for database-node.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for database-node.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for database-node.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_tag(self, *args, **kwargs):
        """Set tag for database-node.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(DatabaseNode, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to database-node.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(DatabaseNode, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(DatabaseNode, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for database-node.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(DatabaseNode, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


# end class DatabaseNode

class LoadbalancerHealthmonitor(vnc_api.gen.resource_common.LoadbalancerHealthmonitor):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'loadbalancer_healthmonitor_properties' in kwargs:
            pending_fields.append('loadbalancer_healthmonitor_properties')
        if len(args) > 1 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 2 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 3 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 4 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(LoadbalancerHealthmonitor, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            if kwargs['loadbalancer_healthmonitor_properties'] is None:
                props_dict['loadbalancer_healthmonitor_properties'] = None
            else:
                props_dict['loadbalancer_healthmonitor_properties'] = vnc_api.gen.resource_xsd.LoadbalancerHealthmonitorType(params_dict=kwargs[u'loadbalancer_healthmonitor_properties'])
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = LoadbalancerHealthmonitor(**props_dict)
        else:
            obj = LoadbalancerHealthmonitor(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.loadbalancer_pool_back_refs = kwargs[u'loadbalancer_pool_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.LoadbalancerHealthmonitor.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.LoadbalancerHealthmonitor.loadbalancer_healthmonitor_properties.setter
    def loadbalancer_healthmonitor_properties(self, loadbalancer_healthmonitor_properties):
        """Set loadbalancer-healthmonitor-properties for loadbalancer-healthmonitor.
        
        :param loadbalancer_healthmonitor_properties: LoadbalancerHealthmonitorType object
        
        """
        if 'loadbalancer_healthmonitor_properties' not in self._pending_field_updates:
            self._pending_field_updates.add('loadbalancer_healthmonitor_properties')

        self._loadbalancer_healthmonitor_properties = loadbalancer_healthmonitor_properties
    # end loadbalancer_healthmonitor_properties

    def set_loadbalancer_healthmonitor_properties(self, value):
        self.loadbalancer_healthmonitor_properties = value
    # end set_loadbalancer_healthmonitor_properties

    @vnc_api.gen.resource_common.LoadbalancerHealthmonitor.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for loadbalancer-healthmonitor.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.LoadbalancerHealthmonitor.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for loadbalancer-healthmonitor.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.LoadbalancerHealthmonitor.annotations.setter
    def annotations(self, annotations):
        """Set annotations for loadbalancer-healthmonitor.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.LoadbalancerHealthmonitor.display_name.setter
    def display_name(self, display_name):
        """Set display-name for loadbalancer-healthmonitor.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for loadbalancer-healthmonitor.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for loadbalancer-healthmonitor.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_tag(self, *args, **kwargs):
        """Set tag for loadbalancer-healthmonitor.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(LoadbalancerHealthmonitor, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to loadbalancer-healthmonitor.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(LoadbalancerHealthmonitor, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(LoadbalancerHealthmonitor, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for loadbalancer-healthmonitor.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(LoadbalancerHealthmonitor, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


    def get_loadbalancer_pool_back_refs(self):
        """Return list of all loadbalancer-pools using this loadbalancer-healthmonitor"""
        if hasattr(self, 'loadbalancer_pool_back_refs'):
            return self.loadbalancer_pool_back_refs

        if hasattr(super(LoadbalancerHealthmonitor, self), 'loadbalancer_pool_back_refs'):
            return super(LoadbalancerHealthmonitor, self).get_loadbalancer_pool_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.loadbalancer_healthmonitor_read(id = self.uuid, fields = ['loadbalancer_pool_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'loadbalancer_pool_back_refs', None)
        if not back_refs:
            return None
        self.loadbalancer_pool_back_refs = back_refs

        return back_refs
    # end get_loadbalancer_pool_back_refs

# end class LoadbalancerHealthmonitor

class DevicemgrNode(vnc_api.gen.resource_common.DevicemgrNode):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'devicemgr_node_ip_address' in kwargs:
            pending_fields.append('devicemgr_node_ip_address')
        if len(args) > 1 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 2 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 3 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 4 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(DevicemgrNode, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            props_dict['devicemgr_node_ip_address'] = kwargs[u'devicemgr_node_ip_address']
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = DevicemgrNode(**props_dict)
        else:
            obj = DevicemgrNode(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.DevicemgrNode.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.DevicemgrNode.devicemgr_node_ip_address.setter
    def devicemgr_node_ip_address(self, devicemgr_node_ip_address):
        """Set devicemgr-node-ip-address for devicemgr-node.
        
        :param devicemgr_node_ip_address: IpAddressType object
        
        """
        if 'devicemgr_node_ip_address' not in self._pending_field_updates:
            self._pending_field_updates.add('devicemgr_node_ip_address')

        self._devicemgr_node_ip_address = devicemgr_node_ip_address
    # end devicemgr_node_ip_address

    def set_devicemgr_node_ip_address(self, value):
        self.devicemgr_node_ip_address = value
    # end set_devicemgr_node_ip_address

    @vnc_api.gen.resource_common.DevicemgrNode.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for devicemgr-node.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.DevicemgrNode.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for devicemgr-node.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.DevicemgrNode.annotations.setter
    def annotations(self, annotations):
        """Set annotations for devicemgr-node.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.DevicemgrNode.display_name.setter
    def display_name(self, display_name):
        """Set display-name for devicemgr-node.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for devicemgr-node.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for devicemgr-node.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_tag(self, *args, **kwargs):
        """Set tag for devicemgr-node.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(DevicemgrNode, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to devicemgr-node.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(DevicemgrNode, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(DevicemgrNode, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for devicemgr-node.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(DevicemgrNode, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


# end class DevicemgrNode

class Project(vnc_api.gen.resource_common.Project):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'quota' in kwargs:
            pending_fields.append('quota')
        if len(args) > 1 or 'vxlan_routing' in kwargs:
            pending_fields.append('vxlan_routing')
        if len(args) > 2 or 'alarm_enable' in kwargs:
            pending_fields.append('alarm_enable')
        if len(args) > 3 or 'enable_security_policy_draft' in kwargs:
            pending_fields.append('enable_security_policy_draft')
        if len(args) > 4 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 5 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 6 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 7 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(Project, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            if kwargs['quota'] is None:
                props_dict['quota'] = None
            else:
                props_dict['quota'] = vnc_api.gen.resource_xsd.QuotaType(params_dict=kwargs[u'quota'])
        except KeyError:
            pass

        try:
            props_dict['vxlan_routing'] = kwargs[u'vxlan_routing']
        except KeyError:
            pass

        try:
            props_dict['alarm_enable'] = kwargs[u'alarm_enable']
        except KeyError:
            pass

        try:
            props_dict['enable_security_policy_draft'] = kwargs[u'enable_security_policy_draft']
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = Project(**props_dict)
        else:
            obj = Project(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...
        try:
            obj.security_logging_objects = kwargs[u'security_logging_objects']
        except KeyError:
            pass
        try:
            obj.security_groups = kwargs[u'security_groups']
        except KeyError:
            pass
        try:
            obj.virtual_networks = kwargs[u'virtual_networks']
        except KeyError:
            pass
        try:
            obj.qos_configs = kwargs[u'qos_configs']
        except KeyError:
            pass
        try:
            obj.network_ipams = kwargs[u'network_ipams']
        except KeyError:
            pass
        try:
            obj.network_policys = kwargs[u'network_policys']
        except KeyError:
            pass
        try:
            obj.virtual_machine_interfaces = kwargs[u'virtual_machine_interfaces']
        except KeyError:
            pass
        try:
            obj.bgp_as_a_services = kwargs[u'bgp_as_a_services']
        except KeyError:
            pass
        try:
            obj.routing_policys = kwargs[u'routing_policys']
        except KeyError:
            pass
        try:
            obj.route_aggregates = kwargs[u'route_aggregates']
        except KeyError:
            pass
        try:
            obj.service_instances = kwargs[u'service_instances']
        except KeyError:
            pass
        try:
            obj.service_health_checks = kwargs[u'service_health_checks']
        except KeyError:
            pass
        try:
            obj.route_tables = kwargs[u'route_tables']
        except KeyError:
            pass
        try:
            obj.interface_route_tables = kwargs[u'interface_route_tables']
        except KeyError:
            pass
        try:
            obj.logical_routers = kwargs[u'logical_routers']
        except KeyError:
            pass
        try:
            obj.api_access_lists = kwargs[u'api_access_lists']
        except KeyError:
            pass
        try:
            obj.multicast_policys = kwargs[u'multicast_policys']
        except KeyError:
            pass
        try:
            obj.loadbalancer_pools = kwargs[u'loadbalancer_pools']
        except KeyError:
            pass
        try:
            obj.loadbalancer_healthmonitors = kwargs[u'loadbalancer_healthmonitors']
        except KeyError:
            pass
        try:
            obj.virtual_ips = kwargs[u'virtual_ips']
        except KeyError:
            pass
        try:
            obj.loadbalancer_listeners = kwargs[u'loadbalancer_listeners']
        except KeyError:
            pass
        try:
            obj.loadbalancers = kwargs[u'loadbalancers']
        except KeyError:
            pass
        try:
            obj.bgpvpns = kwargs[u'bgpvpns']
        except KeyError:
            pass
        try:
            obj.alarms = kwargs[u'alarms']
        except KeyError:
            pass
        try:
            obj.policy_managements = kwargs[u'policy_managements']
        except KeyError:
            pass
        try:
            obj.service_groups = kwargs[u'service_groups']
        except KeyError:
            pass
        try:
            obj.address_groups = kwargs[u'address_groups']
        except KeyError:
            pass
        try:
            obj.firewall_rules = kwargs[u'firewall_rules']
        except KeyError:
            pass
        try:
            obj.firewall_policys = kwargs[u'firewall_policys']
        except KeyError:
            pass
        try:
            obj.application_policy_sets = kwargs[u'application_policy_sets']
        except KeyError:
            pass
        try:
            obj.tags = kwargs[u'tags']
        except KeyError:
            pass
        try:
            obj.device_functional_groups = kwargs[u'device_functional_groups']
        except KeyError:
            pass
        try:
            obj.virtual_port_groups = kwargs[u'virtual_port_groups']
        except KeyError:
            pass
        try:
            obj.telemetry_profiles = kwargs[u'telemetry_profiles']
        except KeyError:
            pass
        try:
            obj.sflow_profiles = kwargs[u'sflow_profiles']
        except KeyError:
            pass
        try:
            obj.storm_control_profiles = kwargs[u'storm_control_profiles']
        except KeyError:
            pass
        try:
            obj.port_profiles = kwargs[u'port_profiles']
        except KeyError:
            pass
        try:
            obj.host_based_services = kwargs[u'host_based_services']
        except KeyError:
            pass
        try:
            obj.structured_syslog_configs = kwargs[u'structured_syslog_configs']
        except KeyError:
            pass

        # add any specified references...
        try:
            obj.namespace_refs = kwargs[u'namespace_refs']
            for ref in obj.namespace_refs:
                ref['attr'] = vnc_api.gen.resource_xsd.SubnetType(params_dict=ref[u'attr'])
        except KeyError:
            pass
        try:
            obj.floating_ip_pool_refs = kwargs[u'floating_ip_pool_refs']
        except KeyError:
            pass
        try:
            obj.alias_ip_pool_refs = kwargs[u'alias_ip_pool_refs']
        except KeyError:
            pass
        try:
            obj.application_policy_set_refs = kwargs[u'application_policy_set_refs']
        except KeyError:
            pass
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.floating_ip_back_refs = kwargs[u'floating_ip_back_refs']
        except KeyError:
            pass
        try:
            obj.alias_ip_back_refs = kwargs[u'alias_ip_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.Project.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.Project.quota.setter
    def quota(self, quota):
        """Set quota for project.
        
        :param quota: QuotaType object
        
        """
        if 'quota' not in self._pending_field_updates:
            self._pending_field_updates.add('quota')

        self._quota = quota
    # end quota

    def set_quota(self, value):
        self.quota = value
    # end set_quota

    @vnc_api.gen.resource_common.Project.vxlan_routing.setter
    def vxlan_routing(self, vxlan_routing):
        """Set vxlan-routing for project.
        
        :param vxlan_routing: xsd:boolean object
        
        """
        if 'vxlan_routing' not in self._pending_field_updates:
            self._pending_field_updates.add('vxlan_routing')

        self._vxlan_routing = vxlan_routing
    # end vxlan_routing

    def set_vxlan_routing(self, value):
        self.vxlan_routing = value
    # end set_vxlan_routing

    @vnc_api.gen.resource_common.Project.alarm_enable.setter
    def alarm_enable(self, alarm_enable):
        """Set alarm-enable for project.
        
        :param alarm_enable: xsd:boolean object
        
        """
        if 'alarm_enable' not in self._pending_field_updates:
            self._pending_field_updates.add('alarm_enable')

        self._alarm_enable = alarm_enable
    # end alarm_enable

    def set_alarm_enable(self, value):
        self.alarm_enable = value
    # end set_alarm_enable

    @vnc_api.gen.resource_common.Project.enable_security_policy_draft.setter
    def enable_security_policy_draft(self, enable_security_policy_draft):
        """Set enable-security-policy-draft for project.
        
        :param enable_security_policy_draft: xsd:boolean object
        
        """
        if 'enable_security_policy_draft' not in self._pending_field_updates:
            self._pending_field_updates.add('enable_security_policy_draft')

        self._enable_security_policy_draft = enable_security_policy_draft
    # end enable_security_policy_draft

    def set_enable_security_policy_draft(self, value):
        self.enable_security_policy_draft = value
    # end set_enable_security_policy_draft

    @vnc_api.gen.resource_common.Project.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for project.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.Project.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for project.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.Project.annotations.setter
    def annotations(self, annotations):
        """Set annotations for project.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.Project.display_name.setter
    def display_name(self, display_name):
        """Set display-name for project.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for project.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for project.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_namespace(self, *args, **kwargs):
        """Set namespace for project.
        
        :param ref_obj: Namespace object
        :param ref_data: SubnetType object
        
        """
        self._pending_field_updates.add('namespace_refs')
        self._pending_ref_updates.discard('namespace_refs')
        super(Project, self).set_namespace(*args, **kwargs)

    # end set_namespace

    def add_namespace(self, *args, **kwargs):
        """Add namespace to project.
        
        :param ref_obj: Namespace object
        :param ref_data: SubnetType object
        
        """
        if 'namespace_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('namespace_refs')
            self._original_namespace_refs = copy.deepcopy(self.get_namespace_refs() or [])
        super(Project, self).add_namespace(*args, **kwargs)
    # end add_namespace

    def del_namespace(self, *args, **kwargs):
        if 'namespace_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('namespace_refs')
            self._original_namespace_refs = copy.deepcopy(self.get_namespace_refs() or [])
        super(Project, self).del_namespace(*args, **kwargs)
    # end del_namespace

    def set_namespace_list(self, *args, **kwargs):
        """Set namespace list for project.
        
        :param ref_obj_list: list of Namespace object
        :param ref_data_list: list of SubnetType summary
        
        """
        self._pending_field_updates.add('namespace_refs')
        self._pending_ref_updates.discard('namespace_refs')
        super(Project, self).set_namespace_list(*args, **kwargs)
    # end set_namespace_list

    def set_floating_ip_pool(self, *args, **kwargs):
        """Set floating-ip-pool for project.
        
        :param ref_obj: FloatingIpPool object
        
        """
        self._pending_field_updates.add('floating_ip_pool_refs')
        self._pending_ref_updates.discard('floating_ip_pool_refs')
        super(Project, self).set_floating_ip_pool(*args, **kwargs)

    # end set_floating_ip_pool

    def add_floating_ip_pool(self, *args, **kwargs):
        """Add floating-ip-pool to project.
        
        :param ref_obj: FloatingIpPool object
        
        """
        if 'floating_ip_pool_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('floating_ip_pool_refs')
            self._original_floating_ip_pool_refs = copy.deepcopy(self.get_floating_ip_pool_refs() or [])
        super(Project, self).add_floating_ip_pool(*args, **kwargs)
    # end add_floating_ip_pool

    def del_floating_ip_pool(self, *args, **kwargs):
        if 'floating_ip_pool_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('floating_ip_pool_refs')
            self._original_floating_ip_pool_refs = copy.deepcopy(self.get_floating_ip_pool_refs() or [])
        super(Project, self).del_floating_ip_pool(*args, **kwargs)
    # end del_floating_ip_pool

    def set_floating_ip_pool_list(self, *args, **kwargs):
        """Set floating-ip-pool list for project.
        
        :param ref_obj_list: list of FloatingIpPool object
        
        """
        self._pending_field_updates.add('floating_ip_pool_refs')
        self._pending_ref_updates.discard('floating_ip_pool_refs')
        super(Project, self).set_floating_ip_pool_list(*args, **kwargs)
    # end set_floating_ip_pool_list

    def set_alias_ip_pool(self, *args, **kwargs):
        """Set alias-ip-pool for project.
        
        :param ref_obj: AliasIpPool object
        
        """
        self._pending_field_updates.add('alias_ip_pool_refs')
        self._pending_ref_updates.discard('alias_ip_pool_refs')
        super(Project, self).set_alias_ip_pool(*args, **kwargs)

    # end set_alias_ip_pool

    def add_alias_ip_pool(self, *args, **kwargs):
        """Add alias-ip-pool to project.
        
        :param ref_obj: AliasIpPool object
        
        """
        if 'alias_ip_pool_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('alias_ip_pool_refs')
            self._original_alias_ip_pool_refs = copy.deepcopy(self.get_alias_ip_pool_refs() or [])
        super(Project, self).add_alias_ip_pool(*args, **kwargs)
    # end add_alias_ip_pool

    def del_alias_ip_pool(self, *args, **kwargs):
        if 'alias_ip_pool_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('alias_ip_pool_refs')
            self._original_alias_ip_pool_refs = copy.deepcopy(self.get_alias_ip_pool_refs() or [])
        super(Project, self).del_alias_ip_pool(*args, **kwargs)
    # end del_alias_ip_pool

    def set_alias_ip_pool_list(self, *args, **kwargs):
        """Set alias-ip-pool list for project.
        
        :param ref_obj_list: list of AliasIpPool object
        
        """
        self._pending_field_updates.add('alias_ip_pool_refs')
        self._pending_ref_updates.discard('alias_ip_pool_refs')
        super(Project, self).set_alias_ip_pool_list(*args, **kwargs)
    # end set_alias_ip_pool_list

    def set_application_policy_set(self, *args, **kwargs):
        """Set application-policy-set for project.
        
        :param ref_obj: ApplicationPolicySet object
        
        """
        self._pending_field_updates.add('application_policy_set_refs')
        self._pending_ref_updates.discard('application_policy_set_refs')
        super(Project, self).set_application_policy_set(*args, **kwargs)

    # end set_application_policy_set

    def add_application_policy_set(self, *args, **kwargs):
        """Add application-policy-set to project.
        
        :param ref_obj: ApplicationPolicySet object
        
        """
        if 'application_policy_set_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('application_policy_set_refs')
            self._original_application_policy_set_refs = copy.deepcopy(self.get_application_policy_set_refs() or [])
        super(Project, self).add_application_policy_set(*args, **kwargs)
    # end add_application_policy_set

    def del_application_policy_set(self, *args, **kwargs):
        if 'application_policy_set_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('application_policy_set_refs')
            self._original_application_policy_set_refs = copy.deepcopy(self.get_application_policy_set_refs() or [])
        super(Project, self).del_application_policy_set(*args, **kwargs)
    # end del_application_policy_set

    def set_application_policy_set_list(self, *args, **kwargs):
        """Set application-policy-set list for project.
        
        :param ref_obj_list: list of ApplicationPolicySet object
        
        """
        self._pending_field_updates.add('application_policy_set_refs')
        self._pending_ref_updates.discard('application_policy_set_refs')
        super(Project, self).set_application_policy_set_list(*args, **kwargs)
    # end set_application_policy_set_list

    def set_tag(self, *args, **kwargs):
        """Set tag for project.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(Project, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to project.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(Project, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(Project, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for project.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(Project, self).set_tag_list(*args, **kwargs)
    # end set_tag_list

    def get_security_logging_objects(self):
        if hasattr(self, 'security_logging_objects'):
            return self.security_logging_objects

        if hasattr(super(Project, self), 'security_logging_objects'):
            return super(Project, self).get_security_logging_objects()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.project_read(id = self.uuid, fields = ['security_logging_objects'])
        except NoIdError:
            return None
        children = getattr(obj, 'security_logging_objects', None)
        if not children:
            return None
        self.security_logging_objects = children

        return children
    # end get_security_logging_objects

    def get_security_groups(self):
        if hasattr(self, 'security_groups'):
            return self.security_groups

        if hasattr(super(Project, self), 'security_groups'):
            return super(Project, self).get_security_groups()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.project_read(id = self.uuid, fields = ['security_groups'])
        except NoIdError:
            return None
        children = getattr(obj, 'security_groups', None)
        if not children:
            return None
        self.security_groups = children

        return children
    # end get_security_groups

    def get_virtual_networks(self):
        if hasattr(self, 'virtual_networks'):
            return self.virtual_networks

        if hasattr(super(Project, self), 'virtual_networks'):
            return super(Project, self).get_virtual_networks()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.project_read(id = self.uuid, fields = ['virtual_networks'])
        except NoIdError:
            return None
        children = getattr(obj, 'virtual_networks', None)
        if not children:
            return None
        self.virtual_networks = children

        return children
    # end get_virtual_networks

    def get_qos_configs(self):
        if hasattr(self, 'qos_configs'):
            return self.qos_configs

        if hasattr(super(Project, self), 'qos_configs'):
            return super(Project, self).get_qos_configs()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.project_read(id = self.uuid, fields = ['qos_configs'])
        except NoIdError:
            return None
        children = getattr(obj, 'qos_configs', None)
        if not children:
            return None
        self.qos_configs = children

        return children
    # end get_qos_configs

    def get_network_ipams(self):
        if hasattr(self, 'network_ipams'):
            return self.network_ipams

        if hasattr(super(Project, self), 'network_ipams'):
            return super(Project, self).get_network_ipams()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.project_read(id = self.uuid, fields = ['network_ipams'])
        except NoIdError:
            return None
        children = getattr(obj, 'network_ipams', None)
        if not children:
            return None
        self.network_ipams = children

        return children
    # end get_network_ipams

    def get_network_policys(self):
        if hasattr(self, 'network_policys'):
            return self.network_policys

        if hasattr(super(Project, self), 'network_policys'):
            return super(Project, self).get_network_policys()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.project_read(id = self.uuid, fields = ['network_policys'])
        except NoIdError:
            return None
        children = getattr(obj, 'network_policys', None)
        if not children:
            return None
        self.network_policys = children

        return children
    # end get_network_policys

    def get_virtual_machine_interfaces(self):
        if hasattr(self, 'virtual_machine_interfaces'):
            return self.virtual_machine_interfaces

        if hasattr(super(Project, self), 'virtual_machine_interfaces'):
            return super(Project, self).get_virtual_machine_interfaces()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.project_read(id = self.uuid, fields = ['virtual_machine_interfaces'])
        except NoIdError:
            return None
        children = getattr(obj, 'virtual_machine_interfaces', None)
        if not children:
            return None
        self.virtual_machine_interfaces = children

        return children
    # end get_virtual_machine_interfaces

    def get_bgp_as_a_services(self):
        if hasattr(self, 'bgp_as_a_services'):
            return self.bgp_as_a_services

        if hasattr(super(Project, self), 'bgp_as_a_services'):
            return super(Project, self).get_bgp_as_a_services()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.project_read(id = self.uuid, fields = ['bgp_as_a_services'])
        except NoIdError:
            return None
        children = getattr(obj, 'bgp_as_a_services', None)
        if not children:
            return None
        self.bgp_as_a_services = children

        return children
    # end get_bgp_as_a_services

    def get_routing_policys(self):
        if hasattr(self, 'routing_policys'):
            return self.routing_policys

        if hasattr(super(Project, self), 'routing_policys'):
            return super(Project, self).get_routing_policys()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.project_read(id = self.uuid, fields = ['routing_policys'])
        except NoIdError:
            return None
        children = getattr(obj, 'routing_policys', None)
        if not children:
            return None
        self.routing_policys = children

        return children
    # end get_routing_policys

    def get_route_aggregates(self):
        if hasattr(self, 'route_aggregates'):
            return self.route_aggregates

        if hasattr(super(Project, self), 'route_aggregates'):
            return super(Project, self).get_route_aggregates()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.project_read(id = self.uuid, fields = ['route_aggregates'])
        except NoIdError:
            return None
        children = getattr(obj, 'route_aggregates', None)
        if not children:
            return None
        self.route_aggregates = children

        return children
    # end get_route_aggregates

    def get_service_instances(self):
        if hasattr(self, 'service_instances'):
            return self.service_instances

        if hasattr(super(Project, self), 'service_instances'):
            return super(Project, self).get_service_instances()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.project_read(id = self.uuid, fields = ['service_instances'])
        except NoIdError:
            return None
        children = getattr(obj, 'service_instances', None)
        if not children:
            return None
        self.service_instances = children

        return children
    # end get_service_instances

    def get_service_health_checks(self):
        if hasattr(self, 'service_health_checks'):
            return self.service_health_checks

        if hasattr(super(Project, self), 'service_health_checks'):
            return super(Project, self).get_service_health_checks()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.project_read(id = self.uuid, fields = ['service_health_checks'])
        except NoIdError:
            return None
        children = getattr(obj, 'service_health_checks', None)
        if not children:
            return None
        self.service_health_checks = children

        return children
    # end get_service_health_checks

    def get_route_tables(self):
        if hasattr(self, 'route_tables'):
            return self.route_tables

        if hasattr(super(Project, self), 'route_tables'):
            return super(Project, self).get_route_tables()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.project_read(id = self.uuid, fields = ['route_tables'])
        except NoIdError:
            return None
        children = getattr(obj, 'route_tables', None)
        if not children:
            return None
        self.route_tables = children

        return children
    # end get_route_tables

    def get_interface_route_tables(self):
        if hasattr(self, 'interface_route_tables'):
            return self.interface_route_tables

        if hasattr(super(Project, self), 'interface_route_tables'):
            return super(Project, self).get_interface_route_tables()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.project_read(id = self.uuid, fields = ['interface_route_tables'])
        except NoIdError:
            return None
        children = getattr(obj, 'interface_route_tables', None)
        if not children:
            return None
        self.interface_route_tables = children

        return children
    # end get_interface_route_tables

    def get_logical_routers(self):
        if hasattr(self, 'logical_routers'):
            return self.logical_routers

        if hasattr(super(Project, self), 'logical_routers'):
            return super(Project, self).get_logical_routers()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.project_read(id = self.uuid, fields = ['logical_routers'])
        except NoIdError:
            return None
        children = getattr(obj, 'logical_routers', None)
        if not children:
            return None
        self.logical_routers = children

        return children
    # end get_logical_routers

    def get_api_access_lists(self):
        if hasattr(self, 'api_access_lists'):
            return self.api_access_lists

        if hasattr(super(Project, self), 'api_access_lists'):
            return super(Project, self).get_api_access_lists()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.project_read(id = self.uuid, fields = ['api_access_lists'])
        except NoIdError:
            return None
        children = getattr(obj, 'api_access_lists', None)
        if not children:
            return None
        self.api_access_lists = children

        return children
    # end get_api_access_lists

    def get_multicast_policys(self):
        if hasattr(self, 'multicast_policys'):
            return self.multicast_policys

        if hasattr(super(Project, self), 'multicast_policys'):
            return super(Project, self).get_multicast_policys()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.project_read(id = self.uuid, fields = ['multicast_policys'])
        except NoIdError:
            return None
        children = getattr(obj, 'multicast_policys', None)
        if not children:
            return None
        self.multicast_policys = children

        return children
    # end get_multicast_policys

    def get_loadbalancer_pools(self):
        if hasattr(self, 'loadbalancer_pools'):
            return self.loadbalancer_pools

        if hasattr(super(Project, self), 'loadbalancer_pools'):
            return super(Project, self).get_loadbalancer_pools()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.project_read(id = self.uuid, fields = ['loadbalancer_pools'])
        except NoIdError:
            return None
        children = getattr(obj, 'loadbalancer_pools', None)
        if not children:
            return None
        self.loadbalancer_pools = children

        return children
    # end get_loadbalancer_pools

    def get_loadbalancer_healthmonitors(self):
        if hasattr(self, 'loadbalancer_healthmonitors'):
            return self.loadbalancer_healthmonitors

        if hasattr(super(Project, self), 'loadbalancer_healthmonitors'):
            return super(Project, self).get_loadbalancer_healthmonitors()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.project_read(id = self.uuid, fields = ['loadbalancer_healthmonitors'])
        except NoIdError:
            return None
        children = getattr(obj, 'loadbalancer_healthmonitors', None)
        if not children:
            return None
        self.loadbalancer_healthmonitors = children

        return children
    # end get_loadbalancer_healthmonitors

    def get_virtual_ips(self):
        if hasattr(self, 'virtual_ips'):
            return self.virtual_ips

        if hasattr(super(Project, self), 'virtual_ips'):
            return super(Project, self).get_virtual_ips()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.project_read(id = self.uuid, fields = ['virtual_ips'])
        except NoIdError:
            return None
        children = getattr(obj, 'virtual_ips', None)
        if not children:
            return None
        self.virtual_ips = children

        return children
    # end get_virtual_ips

    def get_loadbalancer_listeners(self):
        if hasattr(self, 'loadbalancer_listeners'):
            return self.loadbalancer_listeners

        if hasattr(super(Project, self), 'loadbalancer_listeners'):
            return super(Project, self).get_loadbalancer_listeners()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.project_read(id = self.uuid, fields = ['loadbalancer_listeners'])
        except NoIdError:
            return None
        children = getattr(obj, 'loadbalancer_listeners', None)
        if not children:
            return None
        self.loadbalancer_listeners = children

        return children
    # end get_loadbalancer_listeners

    def get_loadbalancers(self):
        if hasattr(self, 'loadbalancers'):
            return self.loadbalancers

        if hasattr(super(Project, self), 'loadbalancers'):
            return super(Project, self).get_loadbalancers()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.project_read(id = self.uuid, fields = ['loadbalancers'])
        except NoIdError:
            return None
        children = getattr(obj, 'loadbalancers', None)
        if not children:
            return None
        self.loadbalancers = children

        return children
    # end get_loadbalancers

    def get_bgpvpns(self):
        if hasattr(self, 'bgpvpns'):
            return self.bgpvpns

        if hasattr(super(Project, self), 'bgpvpns'):
            return super(Project, self).get_bgpvpns()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.project_read(id = self.uuid, fields = ['bgpvpns'])
        except NoIdError:
            return None
        children = getattr(obj, 'bgpvpns', None)
        if not children:
            return None
        self.bgpvpns = children

        return children
    # end get_bgpvpns

    def get_alarms(self):
        if hasattr(self, 'alarms'):
            return self.alarms

        if hasattr(super(Project, self), 'alarms'):
            return super(Project, self).get_alarms()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.project_read(id = self.uuid, fields = ['alarms'])
        except NoIdError:
            return None
        children = getattr(obj, 'alarms', None)
        if not children:
            return None
        self.alarms = children

        return children
    # end get_alarms

    def get_policy_managements(self):
        if hasattr(self, 'policy_managements'):
            return self.policy_managements

        if hasattr(super(Project, self), 'policy_managements'):
            return super(Project, self).get_policy_managements()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.project_read(id = self.uuid, fields = ['policy_managements'])
        except NoIdError:
            return None
        children = getattr(obj, 'policy_managements', None)
        if not children:
            return None
        self.policy_managements = children

        return children
    # end get_policy_managements

    def get_service_groups(self):
        if hasattr(self, 'service_groups'):
            return self.service_groups

        if hasattr(super(Project, self), 'service_groups'):
            return super(Project, self).get_service_groups()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.project_read(id = self.uuid, fields = ['service_groups'])
        except NoIdError:
            return None
        children = getattr(obj, 'service_groups', None)
        if not children:
            return None
        self.service_groups = children

        return children
    # end get_service_groups

    def get_address_groups(self):
        if hasattr(self, 'address_groups'):
            return self.address_groups

        if hasattr(super(Project, self), 'address_groups'):
            return super(Project, self).get_address_groups()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.project_read(id = self.uuid, fields = ['address_groups'])
        except NoIdError:
            return None
        children = getattr(obj, 'address_groups', None)
        if not children:
            return None
        self.address_groups = children

        return children
    # end get_address_groups

    def get_firewall_rules(self):
        if hasattr(self, 'firewall_rules'):
            return self.firewall_rules

        if hasattr(super(Project, self), 'firewall_rules'):
            return super(Project, self).get_firewall_rules()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.project_read(id = self.uuid, fields = ['firewall_rules'])
        except NoIdError:
            return None
        children = getattr(obj, 'firewall_rules', None)
        if not children:
            return None
        self.firewall_rules = children

        return children
    # end get_firewall_rules

    def get_firewall_policys(self):
        if hasattr(self, 'firewall_policys'):
            return self.firewall_policys

        if hasattr(super(Project, self), 'firewall_policys'):
            return super(Project, self).get_firewall_policys()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.project_read(id = self.uuid, fields = ['firewall_policys'])
        except NoIdError:
            return None
        children = getattr(obj, 'firewall_policys', None)
        if not children:
            return None
        self.firewall_policys = children

        return children
    # end get_firewall_policys

    def get_application_policy_sets(self):
        if hasattr(self, 'application_policy_sets'):
            return self.application_policy_sets

        if hasattr(super(Project, self), 'application_policy_sets'):
            return super(Project, self).get_application_policy_sets()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.project_read(id = self.uuid, fields = ['application_policy_sets'])
        except NoIdError:
            return None
        children = getattr(obj, 'application_policy_sets', None)
        if not children:
            return None
        self.application_policy_sets = children

        return children
    # end get_application_policy_sets

    def get_tags(self):
        if hasattr(self, 'tags'):
            return self.tags

        if hasattr(super(Project, self), 'tags'):
            return super(Project, self).get_tags()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.project_read(id = self.uuid, fields = ['tags'])
        except NoIdError:
            return None
        children = getattr(obj, 'tags', None)
        if not children:
            return None
        self.tags = children

        return children
    # end get_tags

    def get_device_functional_groups(self):
        if hasattr(self, 'device_functional_groups'):
            return self.device_functional_groups

        if hasattr(super(Project, self), 'device_functional_groups'):
            return super(Project, self).get_device_functional_groups()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.project_read(id = self.uuid, fields = ['device_functional_groups'])
        except NoIdError:
            return None
        children = getattr(obj, 'device_functional_groups', None)
        if not children:
            return None
        self.device_functional_groups = children

        return children
    # end get_device_functional_groups

    def get_virtual_port_groups(self):
        if hasattr(self, 'virtual_port_groups'):
            return self.virtual_port_groups

        if hasattr(super(Project, self), 'virtual_port_groups'):
            return super(Project, self).get_virtual_port_groups()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.project_read(id = self.uuid, fields = ['virtual_port_groups'])
        except NoIdError:
            return None
        children = getattr(obj, 'virtual_port_groups', None)
        if not children:
            return None
        self.virtual_port_groups = children

        return children
    # end get_virtual_port_groups

    def get_telemetry_profiles(self):
        if hasattr(self, 'telemetry_profiles'):
            return self.telemetry_profiles

        if hasattr(super(Project, self), 'telemetry_profiles'):
            return super(Project, self).get_telemetry_profiles()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.project_read(id = self.uuid, fields = ['telemetry_profiles'])
        except NoIdError:
            return None
        children = getattr(obj, 'telemetry_profiles', None)
        if not children:
            return None
        self.telemetry_profiles = children

        return children
    # end get_telemetry_profiles

    def get_sflow_profiles(self):
        if hasattr(self, 'sflow_profiles'):
            return self.sflow_profiles

        if hasattr(super(Project, self), 'sflow_profiles'):
            return super(Project, self).get_sflow_profiles()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.project_read(id = self.uuid, fields = ['sflow_profiles'])
        except NoIdError:
            return None
        children = getattr(obj, 'sflow_profiles', None)
        if not children:
            return None
        self.sflow_profiles = children

        return children
    # end get_sflow_profiles

    def get_storm_control_profiles(self):
        if hasattr(self, 'storm_control_profiles'):
            return self.storm_control_profiles

        if hasattr(super(Project, self), 'storm_control_profiles'):
            return super(Project, self).get_storm_control_profiles()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.project_read(id = self.uuid, fields = ['storm_control_profiles'])
        except NoIdError:
            return None
        children = getattr(obj, 'storm_control_profiles', None)
        if not children:
            return None
        self.storm_control_profiles = children

        return children
    # end get_storm_control_profiles

    def get_port_profiles(self):
        if hasattr(self, 'port_profiles'):
            return self.port_profiles

        if hasattr(super(Project, self), 'port_profiles'):
            return super(Project, self).get_port_profiles()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.project_read(id = self.uuid, fields = ['port_profiles'])
        except NoIdError:
            return None
        children = getattr(obj, 'port_profiles', None)
        if not children:
            return None
        self.port_profiles = children

        return children
    # end get_port_profiles

    def get_host_based_services(self):
        if hasattr(self, 'host_based_services'):
            return self.host_based_services

        if hasattr(super(Project, self), 'host_based_services'):
            return super(Project, self).get_host_based_services()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.project_read(id = self.uuid, fields = ['host_based_services'])
        except NoIdError:
            return None
        children = getattr(obj, 'host_based_services', None)
        if not children:
            return None
        self.host_based_services = children

        return children
    # end get_host_based_services

    def get_structured_syslog_configs(self):
        if hasattr(self, 'structured_syslog_configs'):
            return self.structured_syslog_configs

        if hasattr(super(Project, self), 'structured_syslog_configs'):
            return super(Project, self).get_structured_syslog_configs()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.project_read(id = self.uuid, fields = ['structured_syslog_configs'])
        except NoIdError:
            return None
        children = getattr(obj, 'structured_syslog_configs', None)
        if not children:
            return None
        self.structured_syslog_configs = children

        return children
    # end get_structured_syslog_configs


    def get_floating_ip_back_refs(self):
        """Return list of all floating-ips using this project"""
        if hasattr(self, 'floating_ip_back_refs'):
            return self.floating_ip_back_refs

        if hasattr(super(Project, self), 'floating_ip_back_refs'):
            return super(Project, self).get_floating_ip_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.project_read(id = self.uuid, fields = ['floating_ip_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'floating_ip_back_refs', None)
        if not back_refs:
            return None
        self.floating_ip_back_refs = back_refs

        return back_refs
    # end get_floating_ip_back_refs

    def get_alias_ip_back_refs(self):
        """Return list of all alias-ips using this project"""
        if hasattr(self, 'alias_ip_back_refs'):
            return self.alias_ip_back_refs

        if hasattr(super(Project, self), 'alias_ip_back_refs'):
            return super(Project, self).get_alias_ip_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.project_read(id = self.uuid, fields = ['alias_ip_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'alias_ip_back_refs', None)
        if not back_refs:
            return None
        self.alias_ip_back_refs = back_refs

        return back_refs
    # end get_alias_ip_back_refs

# end class Project

class FabricNamespace(vnc_api.gen.resource_common.FabricNamespace):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'fabric_namespace_type' in kwargs:
            pending_fields.append('fabric_namespace_type')
        if len(args) > 1 or 'fabric_namespace_value' in kwargs:
            pending_fields.append('fabric_namespace_value')
        if len(args) > 2 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 3 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 4 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 5 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(FabricNamespace, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            props_dict['fabric_namespace_type'] = kwargs[u'fabric_namespace_type']
        except KeyError:
            pass

        try:
            if kwargs['fabric_namespace_value'] is None:
                props_dict['fabric_namespace_value'] = None
            else:
                props_dict['fabric_namespace_value'] = vnc_api.gen.resource_xsd.NamespaceValue(params_dict=kwargs[u'fabric_namespace_value'])
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = FabricNamespace(**props_dict)
        else:
            obj = FabricNamespace(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.FabricNamespace.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.FabricNamespace.fabric_namespace_type.setter
    def fabric_namespace_type(self, fabric_namespace_type):
        """Set fabric-namespace-type for fabric-namespace.
        
        :param fabric_namespace_type: NamespaceType object
        
        """
        if 'fabric_namespace_type' not in self._pending_field_updates:
            self._pending_field_updates.add('fabric_namespace_type')

        self._fabric_namespace_type = fabric_namespace_type
    # end fabric_namespace_type

    def set_fabric_namespace_type(self, value):
        self.fabric_namespace_type = value
    # end set_fabric_namespace_type

    @vnc_api.gen.resource_common.FabricNamespace.fabric_namespace_value.setter
    def fabric_namespace_value(self, fabric_namespace_value):
        """Set fabric-namespace-value for fabric-namespace.
        
        :param fabric_namespace_value: NamespaceValue object
        
        """
        if 'fabric_namespace_value' not in self._pending_field_updates:
            self._pending_field_updates.add('fabric_namespace_value')

        self._fabric_namespace_value = fabric_namespace_value
    # end fabric_namespace_value

    def set_fabric_namespace_value(self, value):
        self.fabric_namespace_value = value
    # end set_fabric_namespace_value

    @vnc_api.gen.resource_common.FabricNamespace.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for fabric-namespace.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.FabricNamespace.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for fabric-namespace.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.FabricNamespace.annotations.setter
    def annotations(self, annotations):
        """Set annotations for fabric-namespace.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.FabricNamespace.display_name.setter
    def display_name(self, display_name):
        """Set display-name for fabric-namespace.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for fabric-namespace.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for fabric-namespace.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_tag(self, *args, **kwargs):
        """Set tag for fabric-namespace.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(FabricNamespace, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to fabric-namespace.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(FabricNamespace, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(FabricNamespace, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for fabric-namespace.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(FabricNamespace, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


# end class FabricNamespace

class NetworkIpam(vnc_api.gen.resource_common.NetworkIpam):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'network_ipam_mgmt' in kwargs:
            pending_fields.append('network_ipam_mgmt')
        if len(args) > 1 or 'ipam_subnets' in kwargs:
            pending_fields.append('ipam_subnets')
        if len(args) > 2 or 'ipam_subnet_method' in kwargs:
            pending_fields.append('ipam_subnet_method')
        if len(args) > 3 or 'ipam_subnetting' in kwargs:
            pending_fields.append('ipam_subnetting')
        if len(args) > 4 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 5 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 6 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 7 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(NetworkIpam, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            if kwargs['network_ipam_mgmt'] is None:
                props_dict['network_ipam_mgmt'] = None
            else:
                props_dict['network_ipam_mgmt'] = vnc_api.gen.resource_xsd.IpamType(params_dict=kwargs[u'network_ipam_mgmt'])
        except KeyError:
            pass

        try:
            if kwargs['ipam_subnets'] is None:
                props_dict['ipam_subnets'] = None
            else:
                props_dict['ipam_subnets'] = vnc_api.gen.resource_xsd.IpamSubnets(params_dict=kwargs[u'ipam_subnets'])
        except KeyError:
            pass

        try:
            props_dict['ipam_subnet_method'] = kwargs[u'ipam_subnet_method']
        except KeyError:
            pass

        try:
            props_dict['ipam_subnetting'] = kwargs[u'ipam_subnetting']
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = NetworkIpam(**props_dict)
        else:
            obj = NetworkIpam(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.virtual_DNS_refs = kwargs[u'virtual_DNS_refs']
        except KeyError:
            pass
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.virtual_network_back_refs = kwargs[u'virtual_network_back_refs']
        except KeyError:
            pass
        try:
            obj.virtual_router_back_refs = kwargs[u'virtual_router_back_refs']
        except KeyError:
            pass
        try:
            obj.instance_ip_back_refs = kwargs[u'instance_ip_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.NetworkIpam.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.NetworkIpam.network_ipam_mgmt.setter
    def network_ipam_mgmt(self, network_ipam_mgmt):
        """Set network-ipam-mgmt for network-ipam.
        
        :param network_ipam_mgmt: IpamType object
        
        """
        if 'network_ipam_mgmt' not in self._pending_field_updates:
            self._pending_field_updates.add('network_ipam_mgmt')

        self._network_ipam_mgmt = network_ipam_mgmt
    # end network_ipam_mgmt

    def set_network_ipam_mgmt(self, value):
        self.network_ipam_mgmt = value
    # end set_network_ipam_mgmt

    @vnc_api.gen.resource_common.NetworkIpam.ipam_subnets.setter
    def ipam_subnets(self, ipam_subnets):
        """Set ipam-subnets for network-ipam.
        
        :param ipam_subnets: IpamSubnets object
        
        """
        if 'ipam_subnets' not in self._pending_field_updates:
            self._pending_field_updates.add('ipam_subnets')

        if 'ipam_subnets' in self._pending_field_list_updates:
            # set clobbers earlier add/del on prop list elements
            del self._pending_field_list_updates['ipam_subnets']

        self._ipam_subnets = ipam_subnets
    # end ipam_subnets

    def set_ipam_subnets(self, value):
        self.ipam_subnets = value
    # end set_ipam_subnets

    @vnc_api.gen.resource_common.NetworkIpam.ipam_subnet_method.setter
    def ipam_subnet_method(self, ipam_subnet_method):
        """Set ipam-subnet-method for network-ipam.
        
        :param ipam_subnet_method: SubnetMethodType object
        
        """
        if 'ipam_subnet_method' not in self._pending_field_updates:
            self._pending_field_updates.add('ipam_subnet_method')

        self._ipam_subnet_method = ipam_subnet_method
    # end ipam_subnet_method

    def set_ipam_subnet_method(self, value):
        self.ipam_subnet_method = value
    # end set_ipam_subnet_method

    @vnc_api.gen.resource_common.NetworkIpam.ipam_subnetting.setter
    def ipam_subnetting(self, ipam_subnetting):
        """Set ipam-subnetting for network-ipam.
        
        :param ipam_subnetting: xsd:boolean object
        
        """
        if 'ipam_subnetting' not in self._pending_field_updates:
            self._pending_field_updates.add('ipam_subnetting')

        self._ipam_subnetting = ipam_subnetting
    # end ipam_subnetting

    def set_ipam_subnetting(self, value):
        self.ipam_subnetting = value
    # end set_ipam_subnetting

    @vnc_api.gen.resource_common.NetworkIpam.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for network-ipam.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.NetworkIpam.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for network-ipam.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.NetworkIpam.annotations.setter
    def annotations(self, annotations):
        """Set annotations for network-ipam.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.NetworkIpam.display_name.setter
    def display_name(self, display_name):
        """Set display-name for network-ipam.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_ipam_subnets(self, elem_value, elem_position=None):
        """Add element to ipam-subnets for network-ipam.
        
        :param elem_value: xsd:string object
        :param elem_position: optional string order-key
        
        """
        if 'ipam_subnets' not in self._pending_field_list_updates:
            self._pending_field_list_updates['ipam_subnets'] = [
                ('add', elem_value, elem_position)]
        else:
            self._pending_field_list_updates['ipam_subnets'].append(
                ('add', elem_value, elem_position))
    # end add_ipam_subnets

    def del_ipam_subnets(self, elem_position):
        """Delete element from ipam-subnets for network-ipam.
        
        :param elem_position: string indicating order-key
        
        """
        if 'ipam_subnets' not in self._pending_field_list_updates:
            self._pending_field_list_updates['ipam_subnets'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_list_updates['ipam_subnets'].append(
                ('delete', None, elem_position))
    # end del_ipam_subnets
    def add_annotations(self, elem):
        """Add element to annotations for network-ipam.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for network-ipam.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_virtual_DNS(self, *args, **kwargs):
        """Set virtual-DNS for network-ipam.
        
        :param ref_obj: VirtualDns object
        
        """
        self._pending_field_updates.add('virtual_DNS_refs')
        self._pending_ref_updates.discard('virtual_DNS_refs')
        super(NetworkIpam, self).set_virtual_DNS(*args, **kwargs)

    # end set_virtual_DNS

    def add_virtual_DNS(self, *args, **kwargs):
        """Add virtual-DNS to network-ipam.
        
        :param ref_obj: VirtualDns object
        
        """
        if 'virtual_DNS_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('virtual_DNS_refs')
            self._original_virtual_DNS_refs = copy.deepcopy(self.get_virtual_DNS_refs() or [])
        super(NetworkIpam, self).add_virtual_DNS(*args, **kwargs)
    # end add_virtual_DNS

    def del_virtual_DNS(self, *args, **kwargs):
        if 'virtual_DNS_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('virtual_DNS_refs')
            self._original_virtual_DNS_refs = copy.deepcopy(self.get_virtual_DNS_refs() or [])
        super(NetworkIpam, self).del_virtual_DNS(*args, **kwargs)
    # end del_virtual_DNS

    def set_virtual_DNS_list(self, *args, **kwargs):
        """Set virtual-DNS list for network-ipam.
        
        :param ref_obj_list: list of VirtualDns object
        
        """
        self._pending_field_updates.add('virtual_DNS_refs')
        self._pending_ref_updates.discard('virtual_DNS_refs')
        super(NetworkIpam, self).set_virtual_DNS_list(*args, **kwargs)
    # end set_virtual_DNS_list

    def set_tag(self, *args, **kwargs):
        """Set tag for network-ipam.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(NetworkIpam, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to network-ipam.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(NetworkIpam, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(NetworkIpam, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for network-ipam.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(NetworkIpam, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


    def get_virtual_network_back_refs(self):
        """Return list of all virtual-networks using this network-ipam"""
        if hasattr(self, 'virtual_network_back_refs'):
            return self.virtual_network_back_refs

        if hasattr(super(NetworkIpam, self), 'virtual_network_back_refs'):
            return super(NetworkIpam, self).get_virtual_network_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.network_ipam_read(id = self.uuid, fields = ['virtual_network_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'virtual_network_back_refs', None)
        if not back_refs:
            return None
        self.virtual_network_back_refs = back_refs

        return back_refs
    # end get_virtual_network_back_refs

    def get_virtual_router_back_refs(self):
        """Return list of all virtual-routers using this network-ipam"""
        if hasattr(self, 'virtual_router_back_refs'):
            return self.virtual_router_back_refs

        if hasattr(super(NetworkIpam, self), 'virtual_router_back_refs'):
            return super(NetworkIpam, self).get_virtual_router_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.network_ipam_read(id = self.uuid, fields = ['virtual_router_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'virtual_router_back_refs', None)
        if not back_refs:
            return None
        self.virtual_router_back_refs = back_refs

        return back_refs
    # end get_virtual_router_back_refs

    def get_instance_ip_back_refs(self):
        """Return list of all instance-ips using this network-ipam"""
        if hasattr(self, 'instance_ip_back_refs'):
            return self.instance_ip_back_refs

        if hasattr(super(NetworkIpam, self), 'instance_ip_back_refs'):
            return super(NetworkIpam, self).get_instance_ip_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.network_ipam_read(id = self.uuid, fields = ['instance_ip_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'instance_ip_back_refs', None)
        if not back_refs:
            return None
        self.instance_ip_back_refs = back_refs

        return back_refs
    # end get_instance_ip_back_refs

# end class NetworkIpam

class NetworkPolicy(vnc_api.gen.resource_common.NetworkPolicy):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'network_policy_entries' in kwargs:
            pending_fields.append('network_policy_entries')
        if len(args) > 1 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 2 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 3 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 4 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(NetworkPolicy, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            if kwargs['network_policy_entries'] is None:
                props_dict['network_policy_entries'] = None
            else:
                props_dict['network_policy_entries'] = vnc_api.gen.resource_xsd.PolicyEntriesType(params_dict=kwargs[u'network_policy_entries'])
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = NetworkPolicy(**props_dict)
        else:
            obj = NetworkPolicy(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.security_logging_object_back_refs = kwargs[u'security_logging_object_back_refs']
        except KeyError:
            pass
        try:
            obj.virtual_network_back_refs = kwargs[u'virtual_network_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.NetworkPolicy.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.NetworkPolicy.network_policy_entries.setter
    def network_policy_entries(self, network_policy_entries):
        """Set network-policy-entries for network-policy.
        
        :param network_policy_entries: PolicyEntriesType object
        
        """
        if 'network_policy_entries' not in self._pending_field_updates:
            self._pending_field_updates.add('network_policy_entries')

        self._network_policy_entries = network_policy_entries
    # end network_policy_entries

    def set_network_policy_entries(self, value):
        self.network_policy_entries = value
    # end set_network_policy_entries

    @vnc_api.gen.resource_common.NetworkPolicy.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for network-policy.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.NetworkPolicy.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for network-policy.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.NetworkPolicy.annotations.setter
    def annotations(self, annotations):
        """Set annotations for network-policy.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.NetworkPolicy.display_name.setter
    def display_name(self, display_name):
        """Set display-name for network-policy.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for network-policy.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for network-policy.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_tag(self, *args, **kwargs):
        """Set tag for network-policy.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(NetworkPolicy, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to network-policy.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(NetworkPolicy, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(NetworkPolicy, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for network-policy.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(NetworkPolicy, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


    def get_security_logging_object_back_refs(self):
        """Return list of all security-logging-objects using this network-policy"""
        if hasattr(self, 'security_logging_object_back_refs'):
            return self.security_logging_object_back_refs

        if hasattr(super(NetworkPolicy, self), 'security_logging_object_back_refs'):
            return super(NetworkPolicy, self).get_security_logging_object_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.network_policy_read(id = self.uuid, fields = ['security_logging_object_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'security_logging_object_back_refs', None)
        if not back_refs:
            return None
        self.security_logging_object_back_refs = back_refs

        return back_refs
    # end get_security_logging_object_back_refs

    def get_virtual_network_back_refs(self):
        """Return list of all virtual-networks using this network-policy"""
        if hasattr(self, 'virtual_network_back_refs'):
            return self.virtual_network_back_refs

        if hasattr(super(NetworkPolicy, self), 'virtual_network_back_refs'):
            return super(NetworkPolicy, self).get_virtual_network_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.network_policy_read(id = self.uuid, fields = ['virtual_network_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'virtual_network_back_refs', None)
        if not back_refs:
            return None
        self.virtual_network_back_refs = back_refs

        return back_refs
    # end get_virtual_network_back_refs

# end class NetworkPolicy

class SflowProfile(vnc_api.gen.resource_common.SflowProfile):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'sflow_profile_is_default' in kwargs:
            pending_fields.append('sflow_profile_is_default')
        if len(args) > 1 or 'sflow_parameters' in kwargs:
            pending_fields.append('sflow_parameters')
        if len(args) > 2 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 3 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 4 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 5 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(SflowProfile, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            props_dict['sflow_profile_is_default'] = kwargs[u'sflow_profile_is_default']
        except KeyError:
            pass

        try:
            if kwargs['sflow_parameters'] is None:
                props_dict['sflow_parameters'] = None
            else:
                props_dict['sflow_parameters'] = vnc_api.gen.resource_xsd.SflowParameters(params_dict=kwargs[u'sflow_parameters'])
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = SflowProfile(**props_dict)
        else:
            obj = SflowProfile(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.telemetry_profile_back_refs = kwargs[u'telemetry_profile_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.SflowProfile.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.SflowProfile.sflow_profile_is_default.setter
    def sflow_profile_is_default(self, sflow_profile_is_default):
        """Set sflow-profile-is-default for sflow-profile.
        
        :param sflow_profile_is_default: xsd:boolean object
        
        """
        if 'sflow_profile_is_default' not in self._pending_field_updates:
            self._pending_field_updates.add('sflow_profile_is_default')

        self._sflow_profile_is_default = sflow_profile_is_default
    # end sflow_profile_is_default

    def set_sflow_profile_is_default(self, value):
        self.sflow_profile_is_default = value
    # end set_sflow_profile_is_default

    @vnc_api.gen.resource_common.SflowProfile.sflow_parameters.setter
    def sflow_parameters(self, sflow_parameters):
        """Set sflow-parameters for sflow-profile.
        
        :param sflow_parameters: SflowParameters object
        
        """
        if 'sflow_parameters' not in self._pending_field_updates:
            self._pending_field_updates.add('sflow_parameters')

        self._sflow_parameters = sflow_parameters
    # end sflow_parameters

    def set_sflow_parameters(self, value):
        self.sflow_parameters = value
    # end set_sflow_parameters

    @vnc_api.gen.resource_common.SflowProfile.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for sflow-profile.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.SflowProfile.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for sflow-profile.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.SflowProfile.annotations.setter
    def annotations(self, annotations):
        """Set annotations for sflow-profile.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.SflowProfile.display_name.setter
    def display_name(self, display_name):
        """Set display-name for sflow-profile.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for sflow-profile.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for sflow-profile.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_tag(self, *args, **kwargs):
        """Set tag for sflow-profile.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(SflowProfile, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to sflow-profile.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(SflowProfile, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(SflowProfile, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for sflow-profile.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(SflowProfile, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


    def get_telemetry_profile_back_refs(self):
        """Return list of all telemetry-profiles using this sflow-profile"""
        if hasattr(self, 'telemetry_profile_back_refs'):
            return self.telemetry_profile_back_refs

        if hasattr(super(SflowProfile, self), 'telemetry_profile_back_refs'):
            return super(SflowProfile, self).get_telemetry_profile_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.sflow_profile_read(id = self.uuid, fields = ['telemetry_profile_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'telemetry_profile_back_refs', None)
        if not back_refs:
            return None
        self.telemetry_profile_back_refs = back_refs

        return back_refs
    # end get_telemetry_profile_back_refs

# end class SflowProfile

class Hardware(vnc_api.gen.resource_common.Hardware):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, *args, **kwargs):
        pending_fields = ['fq_name']

        self._server_conn = None

        if len(args) > 0 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 1 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 2 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 3 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(Hardware, self).__init__(name, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = Hardware(**props_dict)
        else:
            obj = Hardware(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.card_refs = kwargs[u'card_refs']
        except KeyError:
            pass
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.node_profile_back_refs = kwargs[u'node_profile_back_refs']
        except KeyError:
            pass
        try:
            obj.device_image_back_refs = kwargs[u'device_image_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.Hardware.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.Hardware.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for hardware.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.Hardware.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for hardware.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.Hardware.annotations.setter
    def annotations(self, annotations):
        """Set annotations for hardware.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.Hardware.display_name.setter
    def display_name(self, display_name):
        """Set display-name for hardware.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for hardware.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for hardware.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_card(self, *args, **kwargs):
        """Set card for hardware.
        
        :param ref_obj: Card object
        
        """
        self._pending_field_updates.add('card_refs')
        self._pending_ref_updates.discard('card_refs')
        super(Hardware, self).set_card(*args, **kwargs)

    # end set_card

    def add_card(self, *args, **kwargs):
        """Add card to hardware.
        
        :param ref_obj: Card object
        
        """
        if 'card_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('card_refs')
            self._original_card_refs = copy.deepcopy(self.get_card_refs() or [])
        super(Hardware, self).add_card(*args, **kwargs)
    # end add_card

    def del_card(self, *args, **kwargs):
        if 'card_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('card_refs')
            self._original_card_refs = copy.deepcopy(self.get_card_refs() or [])
        super(Hardware, self).del_card(*args, **kwargs)
    # end del_card

    def set_card_list(self, *args, **kwargs):
        """Set card list for hardware.
        
        :param ref_obj_list: list of Card object
        
        """
        self._pending_field_updates.add('card_refs')
        self._pending_ref_updates.discard('card_refs')
        super(Hardware, self).set_card_list(*args, **kwargs)
    # end set_card_list

    def set_tag(self, *args, **kwargs):
        """Set tag for hardware.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(Hardware, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to hardware.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(Hardware, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(Hardware, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for hardware.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(Hardware, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


    def get_node_profile_back_refs(self):
        """Return list of all node-profiles using this hardware"""
        if hasattr(self, 'node_profile_back_refs'):
            return self.node_profile_back_refs

        if hasattr(super(Hardware, self), 'node_profile_back_refs'):
            return super(Hardware, self).get_node_profile_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.hardware_read(id = self.uuid, fields = ['node_profile_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'node_profile_back_refs', None)
        if not back_refs:
            return None
        self.node_profile_back_refs = back_refs

        return back_refs
    # end get_node_profile_back_refs

    def get_device_image_back_refs(self):
        """Return list of all device-images using this hardware"""
        if hasattr(self, 'device_image_back_refs'):
            return self.device_image_back_refs

        if hasattr(super(Hardware, self), 'device_image_back_refs'):
            return super(Hardware, self).get_device_image_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.hardware_read(id = self.uuid, fields = ['device_image_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'device_image_back_refs', None)
        if not back_refs:
            return None
        self.device_image_back_refs = back_refs

        return back_refs
    # end get_device_image_back_refs

# end class Hardware

class Tag(vnc_api.gen.resource_common.Tag):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'tag_type_name' in kwargs:
            pending_fields.append('tag_type_name')
        if len(args) > 1 or 'tag_value' in kwargs:
            pending_fields.append('tag_value')
        if len(args) > 2 or 'tag_predefined' in kwargs:
            pending_fields.append('tag_predefined')
        if len(args) > 3 or 'tag_id' in kwargs:
            pending_fields.append('tag_id')
        if len(args) > 4 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 5 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 6 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 7 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(Tag, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            props_dict['tag_type_name'] = kwargs[u'tag_type_name']
        except KeyError:
            pass

        try:
            props_dict['tag_value'] = kwargs[u'tag_value']
        except KeyError:
            pass

        try:
            props_dict['tag_predefined'] = kwargs[u'tag_predefined']
        except KeyError:
            pass

        try:
            props_dict['tag_id'] = kwargs[u'tag_id']
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = Tag(**props_dict)
        else:
            obj = Tag(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.tag_type_refs = kwargs[u'tag_type_refs']
        except KeyError:
            pass
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.service_endpoint_back_refs = kwargs[u'service_endpoint_back_refs']
        except KeyError:
            pass
        try:
            obj.instance_ip_back_refs = kwargs[u'instance_ip_back_refs']
        except KeyError:
            pass
        try:
            obj.service_appliance_set_back_refs = kwargs[u'service_appliance_set_back_refs']
        except KeyError:
            pass
        try:
            obj.route_target_back_refs = kwargs[u'route_target_back_refs']
        except KeyError:
            pass
        try:
            obj.loadbalancer_listener_back_refs = kwargs[u'loadbalancer_listener_back_refs']
        except KeyError:
            pass
        try:
            obj.floating_ip_pool_back_refs = kwargs[u'floating_ip_pool_back_refs']
        except KeyError:
            pass
        try:
            obj.physical_router_back_refs = kwargs[u'physical_router_back_refs']
        except KeyError:
            pass
        try:
            obj.config_root_back_refs = kwargs[u'config_root_back_refs']
        except KeyError:
            pass
        try:
            obj.service_template_back_refs = kwargs[u'service_template_back_refs']
        except KeyError:
            pass
        try:
            obj.hardware_inventory_back_refs = kwargs[u'hardware_inventory_back_refs']
        except KeyError:
            pass
        try:
            obj.firewall_policy_back_refs = kwargs[u'firewall_policy_back_refs']
        except KeyError:
            pass
        try:
            obj.route_table_back_refs = kwargs[u'route_table_back_refs']
        except KeyError:
            pass
        try:
            obj.provider_attachment_back_refs = kwargs[u'provider_attachment_back_refs']
        except KeyError:
            pass
        try:
            obj.overlay_role_back_refs = kwargs[u'overlay_role_back_refs']
        except KeyError:
            pass
        try:
            obj.multicast_policy_back_refs = kwargs[u'multicast_policy_back_refs']
        except KeyError:
            pass
        try:
            obj.network_device_config_back_refs = kwargs[u'network_device_config_back_refs']
        except KeyError:
            pass
        try:
            obj.virtual_DNS_record_back_refs = kwargs[u'virtual_DNS_record_back_refs']
        except KeyError:
            pass
        try:
            obj.control_node_zone_back_refs = kwargs[u'control_node_zone_back_refs']
        except KeyError:
            pass
        try:
            obj.dsa_rule_back_refs = kwargs[u'dsa_rule_back_refs']
        except KeyError:
            pass
        try:
            obj.structured_syslog_config_back_refs = kwargs[u'structured_syslog_config_back_refs']
        except KeyError:
            pass
        try:
            obj.discovery_service_assignment_back_refs = kwargs[u'discovery_service_assignment_back_refs']
        except KeyError:
            pass
        try:
            obj.logical_interface_back_refs = kwargs[u'logical_interface_back_refs']
        except KeyError:
            pass
        try:
            obj.flow_node_back_refs = kwargs[u'flow_node_back_refs']
        except KeyError:
            pass
        try:
            obj.port_group_back_refs = kwargs[u'port_group_back_refs']
        except KeyError:
            pass
        try:
            obj.route_aggregate_back_refs = kwargs[u'route_aggregate_back_refs']
        except KeyError:
            pass
        try:
            obj.logical_router_back_refs = kwargs[u'logical_router_back_refs']
        except KeyError:
            pass
        try:
            obj.domain_back_refs = kwargs[u'domain_back_refs']
        except KeyError:
            pass
        try:
            obj.structured_syslog_hostname_record_back_refs = kwargs[u'structured_syslog_hostname_record_back_refs']
        except KeyError:
            pass
        try:
            obj.service_instance_back_refs = kwargs[u'service_instance_back_refs']
        except KeyError:
            pass
        try:
            obj.node_profile_back_refs = kwargs[u'node_profile_back_refs']
        except KeyError:
            pass
        try:
            obj.bridge_domain_back_refs = kwargs[u'bridge_domain_back_refs']
        except KeyError:
            pass
        try:
            obj.alias_ip_back_refs = kwargs[u'alias_ip_back_refs']
        except KeyError:
            pass
        try:
            obj.webui_node_back_refs = kwargs[u'webui_node_back_refs']
        except KeyError:
            pass
        try:
            obj.port_back_refs = kwargs[u'port_back_refs']
        except KeyError:
            pass
        try:
            obj.bgp_as_a_service_back_refs = kwargs[u'bgp_as_a_service_back_refs']
        except KeyError:
            pass
        try:
            obj.subnet_back_refs = kwargs[u'subnet_back_refs']
        except KeyError:
            pass
        try:
            obj.global_system_config_back_refs = kwargs[u'global_system_config_back_refs']
        except KeyError:
            pass
        try:
            obj.sub_cluster_back_refs = kwargs[u'sub_cluster_back_refs']
        except KeyError:
            pass
        try:
            obj.forwarding_class_back_refs = kwargs[u'forwarding_class_back_refs']
        except KeyError:
            pass
        try:
            obj.service_group_back_refs = kwargs[u'service_group_back_refs']
        except KeyError:
            pass
        try:
            obj.global_analytics_config_back_refs = kwargs[u'global_analytics_config_back_refs']
        except KeyError:
            pass
        try:
            obj.address_group_back_refs = kwargs[u'address_group_back_refs']
        except KeyError:
            pass
        try:
            obj.application_policy_set_back_refs = kwargs[u'application_policy_set_back_refs']
        except KeyError:
            pass
        try:
            obj.virtual_ip_back_refs = kwargs[u'virtual_ip_back_refs']
        except KeyError:
            pass
        try:
            obj.intent_map_back_refs = kwargs[u'intent_map_back_refs']
        except KeyError:
            pass
        try:
            obj.port_tuple_back_refs = kwargs[u'port_tuple_back_refs']
        except KeyError:
            pass
        try:
            obj.analytics_alarm_node_back_refs = kwargs[u'analytics_alarm_node_back_refs']
        except KeyError:
            pass
        try:
            obj.qos_queue_back_refs = kwargs[u'qos_queue_back_refs']
        except KeyError:
            pass
        try:
            obj.physical_role_back_refs = kwargs[u'physical_role_back_refs']
        except KeyError:
            pass
        try:
            obj.card_back_refs = kwargs[u'card_back_refs']
        except KeyError:
            pass
        try:
            obj.security_logging_object_back_refs = kwargs[u'security_logging_object_back_refs']
        except KeyError:
            pass
        try:
            obj.qos_config_back_refs = kwargs[u'qos_config_back_refs']
        except KeyError:
            pass
        try:
            obj.analytics_snmp_node_back_refs = kwargs[u'analytics_snmp_node_back_refs']
        except KeyError:
            pass
        try:
            obj.virtual_machine_interface_back_refs = kwargs[u'virtual_machine_interface_back_refs']
        except KeyError:
            pass
        try:
            obj.cli_config_back_refs = kwargs[u'cli_config_back_refs']
        except KeyError:
            pass
        try:
            obj.service_object_back_refs = kwargs[u'service_object_back_refs']
        except KeyError:
            pass
        try:
            obj.feature_flag_back_refs = kwargs[u'feature_flag_back_refs']
        except KeyError:
            pass
        try:
            obj.loadbalancer_back_refs = kwargs[u'loadbalancer_back_refs']
        except KeyError:
            pass
        try:
            obj.peering_policy_back_refs = kwargs[u'peering_policy_back_refs']
        except KeyError:
            pass
        try:
            obj.structured_syslog_application_record_back_refs = kwargs[u'structured_syslog_application_record_back_refs']
        except KeyError:
            pass
        try:
            obj.global_vrouter_config_back_refs = kwargs[u'global_vrouter_config_back_refs']
        except KeyError:
            pass
        try:
            obj.floating_ip_back_refs = kwargs[u'floating_ip_back_refs']
        except KeyError:
            pass
        try:
            obj.link_aggregation_group_back_refs = kwargs[u'link_aggregation_group_back_refs']
        except KeyError:
            pass
        try:
            obj.virtual_router_back_refs = kwargs[u'virtual_router_back_refs']
        except KeyError:
            pass
        try:
            obj.port_profile_back_refs = kwargs[u'port_profile_back_refs']
        except KeyError:
            pass
        try:
            obj.policy_management_back_refs = kwargs[u'policy_management_back_refs']
        except KeyError:
            pass
        try:
            obj.e2_service_provider_back_refs = kwargs[u'e2_service_provider_back_refs']
        except KeyError:
            pass
        try:
            obj.fabric_back_refs = kwargs[u'fabric_back_refs']
        except KeyError:
            pass
        try:
            obj.job_template_back_refs = kwargs[u'job_template_back_refs']
        except KeyError:
            pass
        try:
            obj.routing_policy_back_refs = kwargs[u'routing_policy_back_refs']
        except KeyError:
            pass
        try:
            obj.role_config_back_refs = kwargs[u'role_config_back_refs']
        except KeyError:
            pass
        try:
            obj.tag_type_back_refs = kwargs[u'tag_type_back_refs']
        except KeyError:
            pass
        try:
            obj.structured_syslog_message_back_refs = kwargs[u'structured_syslog_message_back_refs']
        except KeyError:
            pass
        try:
            obj.loadbalancer_pool_back_refs = kwargs[u'loadbalancer_pool_back_refs']
        except KeyError:
            pass
        try:
            obj.device_chassis_back_refs = kwargs[u'device_chassis_back_refs']
        except KeyError:
            pass
        try:
            obj.global_qos_config_back_refs = kwargs[u'global_qos_config_back_refs']
        except KeyError:
            pass
        try:
            obj.analytics_node_back_refs = kwargs[u'analytics_node_back_refs']
        except KeyError:
            pass
        try:
            obj.virtual_DNS_back_refs = kwargs[u'virtual_DNS_back_refs']
        except KeyError:
            pass
        try:
            obj.config_database_node_back_refs = kwargs[u'config_database_node_back_refs']
        except KeyError:
            pass
        try:
            obj.config_node_back_refs = kwargs[u'config_node_back_refs']
        except KeyError:
            pass
        try:
            obj.device_functional_group_back_refs = kwargs[u'device_functional_group_back_refs']
        except KeyError:
            pass
        try:
            obj.firewall_rule_back_refs = kwargs[u'firewall_rule_back_refs']
        except KeyError:
            pass
        try:
            obj.bgpvpn_back_refs = kwargs[u'bgpvpn_back_refs']
        except KeyError:
            pass
        try:
            obj.role_definition_back_refs = kwargs[u'role_definition_back_refs']
        except KeyError:
            pass
        try:
            obj.service_connection_module_back_refs = kwargs[u'service_connection_module_back_refs']
        except KeyError:
            pass
        try:
            obj.security_group_back_refs = kwargs[u'security_group_back_refs']
        except KeyError:
            pass
        try:
            obj.database_node_back_refs = kwargs[u'database_node_back_refs']
        except KeyError:
            pass
        try:
            obj.loadbalancer_healthmonitor_back_refs = kwargs[u'loadbalancer_healthmonitor_back_refs']
        except KeyError:
            pass
        try:
            obj.devicemgr_node_back_refs = kwargs[u'devicemgr_node_back_refs']
        except KeyError:
            pass
        try:
            obj.project_back_refs = kwargs[u'project_back_refs']
        except KeyError:
            pass
        try:
            obj.fabric_namespace_back_refs = kwargs[u'fabric_namespace_back_refs']
        except KeyError:
            pass
        try:
            obj.network_ipam_back_refs = kwargs[u'network_ipam_back_refs']
        except KeyError:
            pass
        try:
            obj.network_policy_back_refs = kwargs[u'network_policy_back_refs']
        except KeyError:
            pass
        try:
            obj.sflow_profile_back_refs = kwargs[u'sflow_profile_back_refs']
        except KeyError:
            pass
        try:
            obj.hardware_back_refs = kwargs[u'hardware_back_refs']
        except KeyError:
            pass
        try:
            obj.tag_back_refs = kwargs[u'tag_back_refs']
        except KeyError:
            pass
        try:
            obj.feature_config_back_refs = kwargs[u'feature_config_back_refs']
        except KeyError:
            pass
        try:
            obj.telemetry_profile_back_refs = kwargs[u'telemetry_profile_back_refs']
        except KeyError:
            pass
        try:
            obj.bgp_router_back_refs = kwargs[u'bgp_router_back_refs']
        except KeyError:
            pass
        try:
            obj.virtual_network_back_refs = kwargs[u'virtual_network_back_refs']
        except KeyError:
            pass
        try:
            obj.virtual_port_group_back_refs = kwargs[u'virtual_port_group_back_refs']
        except KeyError:
            pass
        try:
            obj.service_appliance_back_refs = kwargs[u'service_appliance_back_refs']
        except KeyError:
            pass
        try:
            obj.namespace_back_refs = kwargs[u'namespace_back_refs']
        except KeyError:
            pass
        try:
            obj.feature_back_refs = kwargs[u'feature_back_refs']
        except KeyError:
            pass
        try:
            obj.storm_control_profile_back_refs = kwargs[u'storm_control_profile_back_refs']
        except KeyError:
            pass
        try:
            obj.device_image_back_refs = kwargs[u'device_image_back_refs']
        except KeyError:
            pass
        try:
            obj.physical_interface_back_refs = kwargs[u'physical_interface_back_refs']
        except KeyError:
            pass
        try:
            obj.access_control_list_back_refs = kwargs[u'access_control_list_back_refs']
        except KeyError:
            pass
        try:
            obj.node_back_refs = kwargs[u'node_back_refs']
        except KeyError:
            pass
        try:
            obj.customer_attachment_back_refs = kwargs[u'customer_attachment_back_refs']
        except KeyError:
            pass
        try:
            obj.structured_syslog_sla_profile_back_refs = kwargs[u'structured_syslog_sla_profile_back_refs']
        except KeyError:
            pass
        try:
            obj.host_based_service_back_refs = kwargs[u'host_based_service_back_refs']
        except KeyError:
            pass
        try:
            obj.virtual_machine_back_refs = kwargs[u'virtual_machine_back_refs']
        except KeyError:
            pass
        try:
            obj.interface_route_table_back_refs = kwargs[u'interface_route_table_back_refs']
        except KeyError:
            pass
        try:
            obj.loadbalancer_member_back_refs = kwargs[u'loadbalancer_member_back_refs']
        except KeyError:
            pass
        try:
            obj.service_health_check_back_refs = kwargs[u'service_health_check_back_refs']
        except KeyError:
            pass
        try:
            obj.alarm_back_refs = kwargs[u'alarm_back_refs']
        except KeyError:
            pass
        try:
            obj.api_access_list_back_refs = kwargs[u'api_access_list_back_refs']
        except KeyError:
            pass
        try:
            obj.routing_instance_back_refs = kwargs[u'routing_instance_back_refs']
        except KeyError:
            pass
        try:
            obj.alias_ip_pool_back_refs = kwargs[u'alias_ip_pool_back_refs']
        except KeyError:
            pass
        try:
            obj.data_center_interconnect_back_refs = kwargs[u'data_center_interconnect_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.Tag.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.Tag.tag_type_name.setter
    def tag_type_name(self, tag_type_name):
        """Set tag-type-name for tag.
        
        :param tag_type_name: xsd:string object
        
        """
        if 'tag_type_name' not in self._pending_field_updates:
            self._pending_field_updates.add('tag_type_name')

        self._tag_type_name = tag_type_name
    # end tag_type_name

    def set_tag_type_name(self, value):
        self.tag_type_name = value
    # end set_tag_type_name

    @vnc_api.gen.resource_common.Tag.tag_value.setter
    def tag_value(self, tag_value):
        """Set tag-value for tag.
        
        :param tag_value: xsd:string object
        
        """
        if 'tag_value' not in self._pending_field_updates:
            self._pending_field_updates.add('tag_value')

        self._tag_value = tag_value
    # end tag_value

    def set_tag_value(self, value):
        self.tag_value = value
    # end set_tag_value

    @vnc_api.gen.resource_common.Tag.tag_predefined.setter
    def tag_predefined(self, tag_predefined):
        """Set tag-predefined for tag.
        
        :param tag_predefined: xsd:boolean object
        
        """
        if 'tag_predefined' not in self._pending_field_updates:
            self._pending_field_updates.add('tag_predefined')

        self._tag_predefined = tag_predefined
    # end tag_predefined

    def set_tag_predefined(self, value):
        self.tag_predefined = value
    # end set_tag_predefined

    @vnc_api.gen.resource_common.Tag.tag_id.setter
    def tag_id(self, tag_id):
        """Set tag-id for tag.
        
        :param tag_id: U32BitHexInt object
        
        """
        if 'tag_id' not in self._pending_field_updates:
            self._pending_field_updates.add('tag_id')

        self._tag_id = tag_id
    # end tag_id

    def set_tag_id(self, value):
        self.tag_id = value
    # end set_tag_id

    @vnc_api.gen.resource_common.Tag.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for tag.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.Tag.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for tag.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.Tag.annotations.setter
    def annotations(self, annotations):
        """Set annotations for tag.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.Tag.display_name.setter
    def display_name(self, display_name):
        """Set display-name for tag.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for tag.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for tag.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_tag_type(self, *args, **kwargs):
        """Set tag-type for tag.
        
        :param ref_obj: TagType object
        
        """
        self._pending_field_updates.add('tag_type_refs')
        self._pending_ref_updates.discard('tag_type_refs')
        super(Tag, self).set_tag_type(*args, **kwargs)

    # end set_tag_type

    def add_tag_type(self, *args, **kwargs):
        """Add tag-type to tag.
        
        :param ref_obj: TagType object
        
        """
        if 'tag_type_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_type_refs')
            self._original_tag_type_refs = copy.deepcopy(self.get_tag_type_refs() or [])
        super(Tag, self).add_tag_type(*args, **kwargs)
    # end add_tag_type

    def del_tag_type(self, *args, **kwargs):
        if 'tag_type_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_type_refs')
            self._original_tag_type_refs = copy.deepcopy(self.get_tag_type_refs() or [])
        super(Tag, self).del_tag_type(*args, **kwargs)
    # end del_tag_type

    def set_tag_type_list(self, *args, **kwargs):
        """Set tag-type list for tag.
        
        :param ref_obj_list: list of TagType object
        
        """
        self._pending_field_updates.add('tag_type_refs')
        self._pending_ref_updates.discard('tag_type_refs')
        super(Tag, self).set_tag_type_list(*args, **kwargs)
    # end set_tag_type_list

    def set_tag(self, *args, **kwargs):
        """Set tag for tag.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(Tag, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to tag.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(Tag, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(Tag, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for tag.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(Tag, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


    def get_service_endpoint_back_refs(self):
        """Return list of all service-endpoints using this tag"""
        if hasattr(self, 'service_endpoint_back_refs'):
            return self.service_endpoint_back_refs

        if hasattr(super(Tag, self), 'service_endpoint_back_refs'):
            return super(Tag, self).get_service_endpoint_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['service_endpoint_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'service_endpoint_back_refs', None)
        if not back_refs:
            return None
        self.service_endpoint_back_refs = back_refs

        return back_refs
    # end get_service_endpoint_back_refs

    def get_instance_ip_back_refs(self):
        """Return list of all instance-ips using this tag"""
        if hasattr(self, 'instance_ip_back_refs'):
            return self.instance_ip_back_refs

        if hasattr(super(Tag, self), 'instance_ip_back_refs'):
            return super(Tag, self).get_instance_ip_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['instance_ip_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'instance_ip_back_refs', None)
        if not back_refs:
            return None
        self.instance_ip_back_refs = back_refs

        return back_refs
    # end get_instance_ip_back_refs

    def get_service_appliance_set_back_refs(self):
        """Return list of all service-appliance-sets using this tag"""
        if hasattr(self, 'service_appliance_set_back_refs'):
            return self.service_appliance_set_back_refs

        if hasattr(super(Tag, self), 'service_appliance_set_back_refs'):
            return super(Tag, self).get_service_appliance_set_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['service_appliance_set_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'service_appliance_set_back_refs', None)
        if not back_refs:
            return None
        self.service_appliance_set_back_refs = back_refs

        return back_refs
    # end get_service_appliance_set_back_refs

    def get_route_target_back_refs(self):
        """Return list of all route-targets using this tag"""
        if hasattr(self, 'route_target_back_refs'):
            return self.route_target_back_refs

        if hasattr(super(Tag, self), 'route_target_back_refs'):
            return super(Tag, self).get_route_target_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['route_target_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'route_target_back_refs', None)
        if not back_refs:
            return None
        self.route_target_back_refs = back_refs

        return back_refs
    # end get_route_target_back_refs

    def get_loadbalancer_listener_back_refs(self):
        """Return list of all loadbalancer-listeners using this tag"""
        if hasattr(self, 'loadbalancer_listener_back_refs'):
            return self.loadbalancer_listener_back_refs

        if hasattr(super(Tag, self), 'loadbalancer_listener_back_refs'):
            return super(Tag, self).get_loadbalancer_listener_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['loadbalancer_listener_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'loadbalancer_listener_back_refs', None)
        if not back_refs:
            return None
        self.loadbalancer_listener_back_refs = back_refs

        return back_refs
    # end get_loadbalancer_listener_back_refs

    def get_floating_ip_pool_back_refs(self):
        """Return list of all floating-ip-pools using this tag"""
        if hasattr(self, 'floating_ip_pool_back_refs'):
            return self.floating_ip_pool_back_refs

        if hasattr(super(Tag, self), 'floating_ip_pool_back_refs'):
            return super(Tag, self).get_floating_ip_pool_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['floating_ip_pool_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'floating_ip_pool_back_refs', None)
        if not back_refs:
            return None
        self.floating_ip_pool_back_refs = back_refs

        return back_refs
    # end get_floating_ip_pool_back_refs

    def get_physical_router_back_refs(self):
        """Return list of all physical-routers using this tag"""
        if hasattr(self, 'physical_router_back_refs'):
            return self.physical_router_back_refs

        if hasattr(super(Tag, self), 'physical_router_back_refs'):
            return super(Tag, self).get_physical_router_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['physical_router_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'physical_router_back_refs', None)
        if not back_refs:
            return None
        self.physical_router_back_refs = back_refs

        return back_refs
    # end get_physical_router_back_refs

    def get_config_root_back_refs(self):
        """Return list of all config-roots using this tag"""
        if hasattr(self, 'config_root_back_refs'):
            return self.config_root_back_refs

        if hasattr(super(Tag, self), 'config_root_back_refs'):
            return super(Tag, self).get_config_root_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['config_root_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'config_root_back_refs', None)
        if not back_refs:
            return None
        self.config_root_back_refs = back_refs

        return back_refs
    # end get_config_root_back_refs

    def get_service_template_back_refs(self):
        """Return list of all service-templates using this tag"""
        if hasattr(self, 'service_template_back_refs'):
            return self.service_template_back_refs

        if hasattr(super(Tag, self), 'service_template_back_refs'):
            return super(Tag, self).get_service_template_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['service_template_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'service_template_back_refs', None)
        if not back_refs:
            return None
        self.service_template_back_refs = back_refs

        return back_refs
    # end get_service_template_back_refs

    def get_hardware_inventory_back_refs(self):
        """Return list of all hardware-inventorys using this tag"""
        if hasattr(self, 'hardware_inventory_back_refs'):
            return self.hardware_inventory_back_refs

        if hasattr(super(Tag, self), 'hardware_inventory_back_refs'):
            return super(Tag, self).get_hardware_inventory_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['hardware_inventory_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'hardware_inventory_back_refs', None)
        if not back_refs:
            return None
        self.hardware_inventory_back_refs = back_refs

        return back_refs
    # end get_hardware_inventory_back_refs

    def get_firewall_policy_back_refs(self):
        """Return list of all firewall-policys using this tag"""
        if hasattr(self, 'firewall_policy_back_refs'):
            return self.firewall_policy_back_refs

        if hasattr(super(Tag, self), 'firewall_policy_back_refs'):
            return super(Tag, self).get_firewall_policy_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['firewall_policy_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'firewall_policy_back_refs', None)
        if not back_refs:
            return None
        self.firewall_policy_back_refs = back_refs

        return back_refs
    # end get_firewall_policy_back_refs

    def get_route_table_back_refs(self):
        """Return list of all route-tables using this tag"""
        if hasattr(self, 'route_table_back_refs'):
            return self.route_table_back_refs

        if hasattr(super(Tag, self), 'route_table_back_refs'):
            return super(Tag, self).get_route_table_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['route_table_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'route_table_back_refs', None)
        if not back_refs:
            return None
        self.route_table_back_refs = back_refs

        return back_refs
    # end get_route_table_back_refs

    def get_provider_attachment_back_refs(self):
        """Return list of all provider-attachments using this tag"""
        if hasattr(self, 'provider_attachment_back_refs'):
            return self.provider_attachment_back_refs

        if hasattr(super(Tag, self), 'provider_attachment_back_refs'):
            return super(Tag, self).get_provider_attachment_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['provider_attachment_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'provider_attachment_back_refs', None)
        if not back_refs:
            return None
        self.provider_attachment_back_refs = back_refs

        return back_refs
    # end get_provider_attachment_back_refs

    def get_overlay_role_back_refs(self):
        """Return list of all overlay-roles using this tag"""
        if hasattr(self, 'overlay_role_back_refs'):
            return self.overlay_role_back_refs

        if hasattr(super(Tag, self), 'overlay_role_back_refs'):
            return super(Tag, self).get_overlay_role_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['overlay_role_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'overlay_role_back_refs', None)
        if not back_refs:
            return None
        self.overlay_role_back_refs = back_refs

        return back_refs
    # end get_overlay_role_back_refs

    def get_multicast_policy_back_refs(self):
        """Return list of all multicast-policys using this tag"""
        if hasattr(self, 'multicast_policy_back_refs'):
            return self.multicast_policy_back_refs

        if hasattr(super(Tag, self), 'multicast_policy_back_refs'):
            return super(Tag, self).get_multicast_policy_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['multicast_policy_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'multicast_policy_back_refs', None)
        if not back_refs:
            return None
        self.multicast_policy_back_refs = back_refs

        return back_refs
    # end get_multicast_policy_back_refs

    def get_network_device_config_back_refs(self):
        """Return list of all network-device-configs using this tag"""
        if hasattr(self, 'network_device_config_back_refs'):
            return self.network_device_config_back_refs

        if hasattr(super(Tag, self), 'network_device_config_back_refs'):
            return super(Tag, self).get_network_device_config_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['network_device_config_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'network_device_config_back_refs', None)
        if not back_refs:
            return None
        self.network_device_config_back_refs = back_refs

        return back_refs
    # end get_network_device_config_back_refs

    def get_virtual_DNS_record_back_refs(self):
        """Return list of all virtual-DNS-records using this tag"""
        if hasattr(self, 'virtual_DNS_record_back_refs'):
            return self.virtual_DNS_record_back_refs

        if hasattr(super(Tag, self), 'virtual_DNS_record_back_refs'):
            return super(Tag, self).get_virtual_DNS_record_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['virtual_DNS_record_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'virtual_DNS_record_back_refs', None)
        if not back_refs:
            return None
        self.virtual_DNS_record_back_refs = back_refs

        return back_refs
    # end get_virtual_DNS_record_back_refs

    def get_control_node_zone_back_refs(self):
        """Return list of all control-node-zones using this tag"""
        if hasattr(self, 'control_node_zone_back_refs'):
            return self.control_node_zone_back_refs

        if hasattr(super(Tag, self), 'control_node_zone_back_refs'):
            return super(Tag, self).get_control_node_zone_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['control_node_zone_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'control_node_zone_back_refs', None)
        if not back_refs:
            return None
        self.control_node_zone_back_refs = back_refs

        return back_refs
    # end get_control_node_zone_back_refs

    def get_dsa_rule_back_refs(self):
        """Return list of all dsa-rules using this tag"""
        if hasattr(self, 'dsa_rule_back_refs'):
            return self.dsa_rule_back_refs

        if hasattr(super(Tag, self), 'dsa_rule_back_refs'):
            return super(Tag, self).get_dsa_rule_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['dsa_rule_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'dsa_rule_back_refs', None)
        if not back_refs:
            return None
        self.dsa_rule_back_refs = back_refs

        return back_refs
    # end get_dsa_rule_back_refs

    def get_structured_syslog_config_back_refs(self):
        """Return list of all structured-syslog-configs using this tag"""
        if hasattr(self, 'structured_syslog_config_back_refs'):
            return self.structured_syslog_config_back_refs

        if hasattr(super(Tag, self), 'structured_syslog_config_back_refs'):
            return super(Tag, self).get_structured_syslog_config_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['structured_syslog_config_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'structured_syslog_config_back_refs', None)
        if not back_refs:
            return None
        self.structured_syslog_config_back_refs = back_refs

        return back_refs
    # end get_structured_syslog_config_back_refs

    def get_discovery_service_assignment_back_refs(self):
        """Return list of all discovery-service-assignments using this tag"""
        if hasattr(self, 'discovery_service_assignment_back_refs'):
            return self.discovery_service_assignment_back_refs

        if hasattr(super(Tag, self), 'discovery_service_assignment_back_refs'):
            return super(Tag, self).get_discovery_service_assignment_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['discovery_service_assignment_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'discovery_service_assignment_back_refs', None)
        if not back_refs:
            return None
        self.discovery_service_assignment_back_refs = back_refs

        return back_refs
    # end get_discovery_service_assignment_back_refs

    def get_logical_interface_back_refs(self):
        """Return list of all logical-interfaces using this tag"""
        if hasattr(self, 'logical_interface_back_refs'):
            return self.logical_interface_back_refs

        if hasattr(super(Tag, self), 'logical_interface_back_refs'):
            return super(Tag, self).get_logical_interface_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['logical_interface_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'logical_interface_back_refs', None)
        if not back_refs:
            return None
        self.logical_interface_back_refs = back_refs

        return back_refs
    # end get_logical_interface_back_refs

    def get_flow_node_back_refs(self):
        """Return list of all flow-nodes using this tag"""
        if hasattr(self, 'flow_node_back_refs'):
            return self.flow_node_back_refs

        if hasattr(super(Tag, self), 'flow_node_back_refs'):
            return super(Tag, self).get_flow_node_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['flow_node_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'flow_node_back_refs', None)
        if not back_refs:
            return None
        self.flow_node_back_refs = back_refs

        return back_refs
    # end get_flow_node_back_refs

    def get_port_group_back_refs(self):
        """Return list of all port-groups using this tag"""
        if hasattr(self, 'port_group_back_refs'):
            return self.port_group_back_refs

        if hasattr(super(Tag, self), 'port_group_back_refs'):
            return super(Tag, self).get_port_group_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['port_group_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'port_group_back_refs', None)
        if not back_refs:
            return None
        self.port_group_back_refs = back_refs

        return back_refs
    # end get_port_group_back_refs

    def get_route_aggregate_back_refs(self):
        """Return list of all route-aggregates using this tag"""
        if hasattr(self, 'route_aggregate_back_refs'):
            return self.route_aggregate_back_refs

        if hasattr(super(Tag, self), 'route_aggregate_back_refs'):
            return super(Tag, self).get_route_aggregate_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['route_aggregate_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'route_aggregate_back_refs', None)
        if not back_refs:
            return None
        self.route_aggregate_back_refs = back_refs

        return back_refs
    # end get_route_aggregate_back_refs

    def get_logical_router_back_refs(self):
        """Return list of all logical-routers using this tag"""
        if hasattr(self, 'logical_router_back_refs'):
            return self.logical_router_back_refs

        if hasattr(super(Tag, self), 'logical_router_back_refs'):
            return super(Tag, self).get_logical_router_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['logical_router_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'logical_router_back_refs', None)
        if not back_refs:
            return None
        self.logical_router_back_refs = back_refs

        return back_refs
    # end get_logical_router_back_refs

    def get_domain_back_refs(self):
        """Return list of all domains using this tag"""
        if hasattr(self, 'domain_back_refs'):
            return self.domain_back_refs

        if hasattr(super(Tag, self), 'domain_back_refs'):
            return super(Tag, self).get_domain_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['domain_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'domain_back_refs', None)
        if not back_refs:
            return None
        self.domain_back_refs = back_refs

        return back_refs
    # end get_domain_back_refs

    def get_structured_syslog_hostname_record_back_refs(self):
        """Return list of all structured-syslog-hostname-records using this tag"""
        if hasattr(self, 'structured_syslog_hostname_record_back_refs'):
            return self.structured_syslog_hostname_record_back_refs

        if hasattr(super(Tag, self), 'structured_syslog_hostname_record_back_refs'):
            return super(Tag, self).get_structured_syslog_hostname_record_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['structured_syslog_hostname_record_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'structured_syslog_hostname_record_back_refs', None)
        if not back_refs:
            return None
        self.structured_syslog_hostname_record_back_refs = back_refs

        return back_refs
    # end get_structured_syslog_hostname_record_back_refs

    def get_service_instance_back_refs(self):
        """Return list of all service-instances using this tag"""
        if hasattr(self, 'service_instance_back_refs'):
            return self.service_instance_back_refs

        if hasattr(super(Tag, self), 'service_instance_back_refs'):
            return super(Tag, self).get_service_instance_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['service_instance_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'service_instance_back_refs', None)
        if not back_refs:
            return None
        self.service_instance_back_refs = back_refs

        return back_refs
    # end get_service_instance_back_refs

    def get_node_profile_back_refs(self):
        """Return list of all node-profiles using this tag"""
        if hasattr(self, 'node_profile_back_refs'):
            return self.node_profile_back_refs

        if hasattr(super(Tag, self), 'node_profile_back_refs'):
            return super(Tag, self).get_node_profile_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['node_profile_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'node_profile_back_refs', None)
        if not back_refs:
            return None
        self.node_profile_back_refs = back_refs

        return back_refs
    # end get_node_profile_back_refs

    def get_bridge_domain_back_refs(self):
        """Return list of all bridge-domains using this tag"""
        if hasattr(self, 'bridge_domain_back_refs'):
            return self.bridge_domain_back_refs

        if hasattr(super(Tag, self), 'bridge_domain_back_refs'):
            return super(Tag, self).get_bridge_domain_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['bridge_domain_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'bridge_domain_back_refs', None)
        if not back_refs:
            return None
        self.bridge_domain_back_refs = back_refs

        return back_refs
    # end get_bridge_domain_back_refs

    def get_alias_ip_back_refs(self):
        """Return list of all alias-ips using this tag"""
        if hasattr(self, 'alias_ip_back_refs'):
            return self.alias_ip_back_refs

        if hasattr(super(Tag, self), 'alias_ip_back_refs'):
            return super(Tag, self).get_alias_ip_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['alias_ip_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'alias_ip_back_refs', None)
        if not back_refs:
            return None
        self.alias_ip_back_refs = back_refs

        return back_refs
    # end get_alias_ip_back_refs

    def get_webui_node_back_refs(self):
        """Return list of all webui-nodes using this tag"""
        if hasattr(self, 'webui_node_back_refs'):
            return self.webui_node_back_refs

        if hasattr(super(Tag, self), 'webui_node_back_refs'):
            return super(Tag, self).get_webui_node_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['webui_node_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'webui_node_back_refs', None)
        if not back_refs:
            return None
        self.webui_node_back_refs = back_refs

        return back_refs
    # end get_webui_node_back_refs

    def get_port_back_refs(self):
        """Return list of all ports using this tag"""
        if hasattr(self, 'port_back_refs'):
            return self.port_back_refs

        if hasattr(super(Tag, self), 'port_back_refs'):
            return super(Tag, self).get_port_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['port_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'port_back_refs', None)
        if not back_refs:
            return None
        self.port_back_refs = back_refs

        return back_refs
    # end get_port_back_refs

    def get_bgp_as_a_service_back_refs(self):
        """Return list of all bgp-as-a-services using this tag"""
        if hasattr(self, 'bgp_as_a_service_back_refs'):
            return self.bgp_as_a_service_back_refs

        if hasattr(super(Tag, self), 'bgp_as_a_service_back_refs'):
            return super(Tag, self).get_bgp_as_a_service_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['bgp_as_a_service_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'bgp_as_a_service_back_refs', None)
        if not back_refs:
            return None
        self.bgp_as_a_service_back_refs = back_refs

        return back_refs
    # end get_bgp_as_a_service_back_refs

    def get_subnet_back_refs(self):
        """Return list of all subnets using this tag"""
        if hasattr(self, 'subnet_back_refs'):
            return self.subnet_back_refs

        if hasattr(super(Tag, self), 'subnet_back_refs'):
            return super(Tag, self).get_subnet_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['subnet_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'subnet_back_refs', None)
        if not back_refs:
            return None
        self.subnet_back_refs = back_refs

        return back_refs
    # end get_subnet_back_refs

    def get_global_system_config_back_refs(self):
        """Return list of all global-system-configs using this tag"""
        if hasattr(self, 'global_system_config_back_refs'):
            return self.global_system_config_back_refs

        if hasattr(super(Tag, self), 'global_system_config_back_refs'):
            return super(Tag, self).get_global_system_config_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['global_system_config_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'global_system_config_back_refs', None)
        if not back_refs:
            return None
        self.global_system_config_back_refs = back_refs

        return back_refs
    # end get_global_system_config_back_refs

    def get_sub_cluster_back_refs(self):
        """Return list of all sub-clusters using this tag"""
        if hasattr(self, 'sub_cluster_back_refs'):
            return self.sub_cluster_back_refs

        if hasattr(super(Tag, self), 'sub_cluster_back_refs'):
            return super(Tag, self).get_sub_cluster_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['sub_cluster_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'sub_cluster_back_refs', None)
        if not back_refs:
            return None
        self.sub_cluster_back_refs = back_refs

        return back_refs
    # end get_sub_cluster_back_refs

    def get_forwarding_class_back_refs(self):
        """Return list of all forwarding-classs using this tag"""
        if hasattr(self, 'forwarding_class_back_refs'):
            return self.forwarding_class_back_refs

        if hasattr(super(Tag, self), 'forwarding_class_back_refs'):
            return super(Tag, self).get_forwarding_class_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['forwarding_class_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'forwarding_class_back_refs', None)
        if not back_refs:
            return None
        self.forwarding_class_back_refs = back_refs

        return back_refs
    # end get_forwarding_class_back_refs

    def get_service_group_back_refs(self):
        """Return list of all service-groups using this tag"""
        if hasattr(self, 'service_group_back_refs'):
            return self.service_group_back_refs

        if hasattr(super(Tag, self), 'service_group_back_refs'):
            return super(Tag, self).get_service_group_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['service_group_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'service_group_back_refs', None)
        if not back_refs:
            return None
        self.service_group_back_refs = back_refs

        return back_refs
    # end get_service_group_back_refs

    def get_global_analytics_config_back_refs(self):
        """Return list of all global-analytics-configs using this tag"""
        if hasattr(self, 'global_analytics_config_back_refs'):
            return self.global_analytics_config_back_refs

        if hasattr(super(Tag, self), 'global_analytics_config_back_refs'):
            return super(Tag, self).get_global_analytics_config_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['global_analytics_config_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'global_analytics_config_back_refs', None)
        if not back_refs:
            return None
        self.global_analytics_config_back_refs = back_refs

        return back_refs
    # end get_global_analytics_config_back_refs

    def get_address_group_back_refs(self):
        """Return list of all address-groups using this tag"""
        if hasattr(self, 'address_group_back_refs'):
            return self.address_group_back_refs

        if hasattr(super(Tag, self), 'address_group_back_refs'):
            return super(Tag, self).get_address_group_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['address_group_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'address_group_back_refs', None)
        if not back_refs:
            return None
        self.address_group_back_refs = back_refs

        return back_refs
    # end get_address_group_back_refs

    def get_application_policy_set_back_refs(self):
        """Return list of all application-policy-sets using this tag"""
        if hasattr(self, 'application_policy_set_back_refs'):
            return self.application_policy_set_back_refs

        if hasattr(super(Tag, self), 'application_policy_set_back_refs'):
            return super(Tag, self).get_application_policy_set_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['application_policy_set_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'application_policy_set_back_refs', None)
        if not back_refs:
            return None
        self.application_policy_set_back_refs = back_refs

        return back_refs
    # end get_application_policy_set_back_refs

    def get_virtual_ip_back_refs(self):
        """Return list of all virtual-ips using this tag"""
        if hasattr(self, 'virtual_ip_back_refs'):
            return self.virtual_ip_back_refs

        if hasattr(super(Tag, self), 'virtual_ip_back_refs'):
            return super(Tag, self).get_virtual_ip_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['virtual_ip_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'virtual_ip_back_refs', None)
        if not back_refs:
            return None
        self.virtual_ip_back_refs = back_refs

        return back_refs
    # end get_virtual_ip_back_refs

    def get_intent_map_back_refs(self):
        """Return list of all intent-maps using this tag"""
        if hasattr(self, 'intent_map_back_refs'):
            return self.intent_map_back_refs

        if hasattr(super(Tag, self), 'intent_map_back_refs'):
            return super(Tag, self).get_intent_map_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['intent_map_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'intent_map_back_refs', None)
        if not back_refs:
            return None
        self.intent_map_back_refs = back_refs

        return back_refs
    # end get_intent_map_back_refs

    def get_port_tuple_back_refs(self):
        """Return list of all port-tuples using this tag"""
        if hasattr(self, 'port_tuple_back_refs'):
            return self.port_tuple_back_refs

        if hasattr(super(Tag, self), 'port_tuple_back_refs'):
            return super(Tag, self).get_port_tuple_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['port_tuple_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'port_tuple_back_refs', None)
        if not back_refs:
            return None
        self.port_tuple_back_refs = back_refs

        return back_refs
    # end get_port_tuple_back_refs

    def get_analytics_alarm_node_back_refs(self):
        """Return list of all analytics-alarm-nodes using this tag"""
        if hasattr(self, 'analytics_alarm_node_back_refs'):
            return self.analytics_alarm_node_back_refs

        if hasattr(super(Tag, self), 'analytics_alarm_node_back_refs'):
            return super(Tag, self).get_analytics_alarm_node_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['analytics_alarm_node_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'analytics_alarm_node_back_refs', None)
        if not back_refs:
            return None
        self.analytics_alarm_node_back_refs = back_refs

        return back_refs
    # end get_analytics_alarm_node_back_refs

    def get_qos_queue_back_refs(self):
        """Return list of all qos-queues using this tag"""
        if hasattr(self, 'qos_queue_back_refs'):
            return self.qos_queue_back_refs

        if hasattr(super(Tag, self), 'qos_queue_back_refs'):
            return super(Tag, self).get_qos_queue_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['qos_queue_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'qos_queue_back_refs', None)
        if not back_refs:
            return None
        self.qos_queue_back_refs = back_refs

        return back_refs
    # end get_qos_queue_back_refs

    def get_physical_role_back_refs(self):
        """Return list of all physical-roles using this tag"""
        if hasattr(self, 'physical_role_back_refs'):
            return self.physical_role_back_refs

        if hasattr(super(Tag, self), 'physical_role_back_refs'):
            return super(Tag, self).get_physical_role_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['physical_role_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'physical_role_back_refs', None)
        if not back_refs:
            return None
        self.physical_role_back_refs = back_refs

        return back_refs
    # end get_physical_role_back_refs

    def get_card_back_refs(self):
        """Return list of all cards using this tag"""
        if hasattr(self, 'card_back_refs'):
            return self.card_back_refs

        if hasattr(super(Tag, self), 'card_back_refs'):
            return super(Tag, self).get_card_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['card_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'card_back_refs', None)
        if not back_refs:
            return None
        self.card_back_refs = back_refs

        return back_refs
    # end get_card_back_refs

    def get_security_logging_object_back_refs(self):
        """Return list of all security-logging-objects using this tag"""
        if hasattr(self, 'security_logging_object_back_refs'):
            return self.security_logging_object_back_refs

        if hasattr(super(Tag, self), 'security_logging_object_back_refs'):
            return super(Tag, self).get_security_logging_object_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['security_logging_object_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'security_logging_object_back_refs', None)
        if not back_refs:
            return None
        self.security_logging_object_back_refs = back_refs

        return back_refs
    # end get_security_logging_object_back_refs

    def get_qos_config_back_refs(self):
        """Return list of all qos-configs using this tag"""
        if hasattr(self, 'qos_config_back_refs'):
            return self.qos_config_back_refs

        if hasattr(super(Tag, self), 'qos_config_back_refs'):
            return super(Tag, self).get_qos_config_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['qos_config_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'qos_config_back_refs', None)
        if not back_refs:
            return None
        self.qos_config_back_refs = back_refs

        return back_refs
    # end get_qos_config_back_refs

    def get_analytics_snmp_node_back_refs(self):
        """Return list of all analytics-snmp-nodes using this tag"""
        if hasattr(self, 'analytics_snmp_node_back_refs'):
            return self.analytics_snmp_node_back_refs

        if hasattr(super(Tag, self), 'analytics_snmp_node_back_refs'):
            return super(Tag, self).get_analytics_snmp_node_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['analytics_snmp_node_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'analytics_snmp_node_back_refs', None)
        if not back_refs:
            return None
        self.analytics_snmp_node_back_refs = back_refs

        return back_refs
    # end get_analytics_snmp_node_back_refs

    def get_virtual_machine_interface_back_refs(self):
        """Return list of all virtual-machine-interfaces using this tag"""
        if hasattr(self, 'virtual_machine_interface_back_refs'):
            return self.virtual_machine_interface_back_refs

        if hasattr(super(Tag, self), 'virtual_machine_interface_back_refs'):
            return super(Tag, self).get_virtual_machine_interface_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['virtual_machine_interface_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'virtual_machine_interface_back_refs', None)
        if not back_refs:
            return None
        self.virtual_machine_interface_back_refs = back_refs

        return back_refs
    # end get_virtual_machine_interface_back_refs

    def get_cli_config_back_refs(self):
        """Return list of all cli-configs using this tag"""
        if hasattr(self, 'cli_config_back_refs'):
            return self.cli_config_back_refs

        if hasattr(super(Tag, self), 'cli_config_back_refs'):
            return super(Tag, self).get_cli_config_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['cli_config_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'cli_config_back_refs', None)
        if not back_refs:
            return None
        self.cli_config_back_refs = back_refs

        return back_refs
    # end get_cli_config_back_refs

    def get_service_object_back_refs(self):
        """Return list of all service-objects using this tag"""
        if hasattr(self, 'service_object_back_refs'):
            return self.service_object_back_refs

        if hasattr(super(Tag, self), 'service_object_back_refs'):
            return super(Tag, self).get_service_object_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['service_object_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'service_object_back_refs', None)
        if not back_refs:
            return None
        self.service_object_back_refs = back_refs

        return back_refs
    # end get_service_object_back_refs

    def get_feature_flag_back_refs(self):
        """Return list of all feature-flags using this tag"""
        if hasattr(self, 'feature_flag_back_refs'):
            return self.feature_flag_back_refs

        if hasattr(super(Tag, self), 'feature_flag_back_refs'):
            return super(Tag, self).get_feature_flag_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['feature_flag_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'feature_flag_back_refs', None)
        if not back_refs:
            return None
        self.feature_flag_back_refs = back_refs

        return back_refs
    # end get_feature_flag_back_refs

    def get_loadbalancer_back_refs(self):
        """Return list of all loadbalancers using this tag"""
        if hasattr(self, 'loadbalancer_back_refs'):
            return self.loadbalancer_back_refs

        if hasattr(super(Tag, self), 'loadbalancer_back_refs'):
            return super(Tag, self).get_loadbalancer_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['loadbalancer_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'loadbalancer_back_refs', None)
        if not back_refs:
            return None
        self.loadbalancer_back_refs = back_refs

        return back_refs
    # end get_loadbalancer_back_refs

    def get_peering_policy_back_refs(self):
        """Return list of all peering-policys using this tag"""
        if hasattr(self, 'peering_policy_back_refs'):
            return self.peering_policy_back_refs

        if hasattr(super(Tag, self), 'peering_policy_back_refs'):
            return super(Tag, self).get_peering_policy_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['peering_policy_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'peering_policy_back_refs', None)
        if not back_refs:
            return None
        self.peering_policy_back_refs = back_refs

        return back_refs
    # end get_peering_policy_back_refs

    def get_structured_syslog_application_record_back_refs(self):
        """Return list of all structured-syslog-application-records using this tag"""
        if hasattr(self, 'structured_syslog_application_record_back_refs'):
            return self.structured_syslog_application_record_back_refs

        if hasattr(super(Tag, self), 'structured_syslog_application_record_back_refs'):
            return super(Tag, self).get_structured_syslog_application_record_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['structured_syslog_application_record_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'structured_syslog_application_record_back_refs', None)
        if not back_refs:
            return None
        self.structured_syslog_application_record_back_refs = back_refs

        return back_refs
    # end get_structured_syslog_application_record_back_refs

    def get_global_vrouter_config_back_refs(self):
        """Return list of all global-vrouter-configs using this tag"""
        if hasattr(self, 'global_vrouter_config_back_refs'):
            return self.global_vrouter_config_back_refs

        if hasattr(super(Tag, self), 'global_vrouter_config_back_refs'):
            return super(Tag, self).get_global_vrouter_config_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['global_vrouter_config_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'global_vrouter_config_back_refs', None)
        if not back_refs:
            return None
        self.global_vrouter_config_back_refs = back_refs

        return back_refs
    # end get_global_vrouter_config_back_refs

    def get_floating_ip_back_refs(self):
        """Return list of all floating-ips using this tag"""
        if hasattr(self, 'floating_ip_back_refs'):
            return self.floating_ip_back_refs

        if hasattr(super(Tag, self), 'floating_ip_back_refs'):
            return super(Tag, self).get_floating_ip_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['floating_ip_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'floating_ip_back_refs', None)
        if not back_refs:
            return None
        self.floating_ip_back_refs = back_refs

        return back_refs
    # end get_floating_ip_back_refs

    def get_link_aggregation_group_back_refs(self):
        """Return list of all link-aggregation-groups using this tag"""
        if hasattr(self, 'link_aggregation_group_back_refs'):
            return self.link_aggregation_group_back_refs

        if hasattr(super(Tag, self), 'link_aggregation_group_back_refs'):
            return super(Tag, self).get_link_aggregation_group_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['link_aggregation_group_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'link_aggregation_group_back_refs', None)
        if not back_refs:
            return None
        self.link_aggregation_group_back_refs = back_refs

        return back_refs
    # end get_link_aggregation_group_back_refs

    def get_virtual_router_back_refs(self):
        """Return list of all virtual-routers using this tag"""
        if hasattr(self, 'virtual_router_back_refs'):
            return self.virtual_router_back_refs

        if hasattr(super(Tag, self), 'virtual_router_back_refs'):
            return super(Tag, self).get_virtual_router_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['virtual_router_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'virtual_router_back_refs', None)
        if not back_refs:
            return None
        self.virtual_router_back_refs = back_refs

        return back_refs
    # end get_virtual_router_back_refs

    def get_port_profile_back_refs(self):
        """Return list of all port-profiles using this tag"""
        if hasattr(self, 'port_profile_back_refs'):
            return self.port_profile_back_refs

        if hasattr(super(Tag, self), 'port_profile_back_refs'):
            return super(Tag, self).get_port_profile_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['port_profile_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'port_profile_back_refs', None)
        if not back_refs:
            return None
        self.port_profile_back_refs = back_refs

        return back_refs
    # end get_port_profile_back_refs

    def get_policy_management_back_refs(self):
        """Return list of all policy-managements using this tag"""
        if hasattr(self, 'policy_management_back_refs'):
            return self.policy_management_back_refs

        if hasattr(super(Tag, self), 'policy_management_back_refs'):
            return super(Tag, self).get_policy_management_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['policy_management_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'policy_management_back_refs', None)
        if not back_refs:
            return None
        self.policy_management_back_refs = back_refs

        return back_refs
    # end get_policy_management_back_refs

    def get_e2_service_provider_back_refs(self):
        """Return list of all e2-service-providers using this tag"""
        if hasattr(self, 'e2_service_provider_back_refs'):
            return self.e2_service_provider_back_refs

        if hasattr(super(Tag, self), 'e2_service_provider_back_refs'):
            return super(Tag, self).get_e2_service_provider_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['e2_service_provider_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'e2_service_provider_back_refs', None)
        if not back_refs:
            return None
        self.e2_service_provider_back_refs = back_refs

        return back_refs
    # end get_e2_service_provider_back_refs

    def get_fabric_back_refs(self):
        """Return list of all fabrics using this tag"""
        if hasattr(self, 'fabric_back_refs'):
            return self.fabric_back_refs

        if hasattr(super(Tag, self), 'fabric_back_refs'):
            return super(Tag, self).get_fabric_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['fabric_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'fabric_back_refs', None)
        if not back_refs:
            return None
        self.fabric_back_refs = back_refs

        return back_refs
    # end get_fabric_back_refs

    def get_job_template_back_refs(self):
        """Return list of all job-templates using this tag"""
        if hasattr(self, 'job_template_back_refs'):
            return self.job_template_back_refs

        if hasattr(super(Tag, self), 'job_template_back_refs'):
            return super(Tag, self).get_job_template_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['job_template_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'job_template_back_refs', None)
        if not back_refs:
            return None
        self.job_template_back_refs = back_refs

        return back_refs
    # end get_job_template_back_refs

    def get_routing_policy_back_refs(self):
        """Return list of all routing-policys using this tag"""
        if hasattr(self, 'routing_policy_back_refs'):
            return self.routing_policy_back_refs

        if hasattr(super(Tag, self), 'routing_policy_back_refs'):
            return super(Tag, self).get_routing_policy_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['routing_policy_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'routing_policy_back_refs', None)
        if not back_refs:
            return None
        self.routing_policy_back_refs = back_refs

        return back_refs
    # end get_routing_policy_back_refs

    def get_role_config_back_refs(self):
        """Return list of all role-configs using this tag"""
        if hasattr(self, 'role_config_back_refs'):
            return self.role_config_back_refs

        if hasattr(super(Tag, self), 'role_config_back_refs'):
            return super(Tag, self).get_role_config_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['role_config_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'role_config_back_refs', None)
        if not back_refs:
            return None
        self.role_config_back_refs = back_refs

        return back_refs
    # end get_role_config_back_refs

    def get_tag_type_back_refs(self):
        """Return list of all tag-types using this tag"""
        if hasattr(self, 'tag_type_back_refs'):
            return self.tag_type_back_refs

        if hasattr(super(Tag, self), 'tag_type_back_refs'):
            return super(Tag, self).get_tag_type_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['tag_type_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'tag_type_back_refs', None)
        if not back_refs:
            return None
        self.tag_type_back_refs = back_refs

        return back_refs
    # end get_tag_type_back_refs

    def get_structured_syslog_message_back_refs(self):
        """Return list of all structured-syslog-messages using this tag"""
        if hasattr(self, 'structured_syslog_message_back_refs'):
            return self.structured_syslog_message_back_refs

        if hasattr(super(Tag, self), 'structured_syslog_message_back_refs'):
            return super(Tag, self).get_structured_syslog_message_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['structured_syslog_message_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'structured_syslog_message_back_refs', None)
        if not back_refs:
            return None
        self.structured_syslog_message_back_refs = back_refs

        return back_refs
    # end get_structured_syslog_message_back_refs

    def get_loadbalancer_pool_back_refs(self):
        """Return list of all loadbalancer-pools using this tag"""
        if hasattr(self, 'loadbalancer_pool_back_refs'):
            return self.loadbalancer_pool_back_refs

        if hasattr(super(Tag, self), 'loadbalancer_pool_back_refs'):
            return super(Tag, self).get_loadbalancer_pool_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['loadbalancer_pool_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'loadbalancer_pool_back_refs', None)
        if not back_refs:
            return None
        self.loadbalancer_pool_back_refs = back_refs

        return back_refs
    # end get_loadbalancer_pool_back_refs

    def get_device_chassis_back_refs(self):
        """Return list of all device-chassiss using this tag"""
        if hasattr(self, 'device_chassis_back_refs'):
            return self.device_chassis_back_refs

        if hasattr(super(Tag, self), 'device_chassis_back_refs'):
            return super(Tag, self).get_device_chassis_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['device_chassis_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'device_chassis_back_refs', None)
        if not back_refs:
            return None
        self.device_chassis_back_refs = back_refs

        return back_refs
    # end get_device_chassis_back_refs

    def get_global_qos_config_back_refs(self):
        """Return list of all global-qos-configs using this tag"""
        if hasattr(self, 'global_qos_config_back_refs'):
            return self.global_qos_config_back_refs

        if hasattr(super(Tag, self), 'global_qos_config_back_refs'):
            return super(Tag, self).get_global_qos_config_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['global_qos_config_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'global_qos_config_back_refs', None)
        if not back_refs:
            return None
        self.global_qos_config_back_refs = back_refs

        return back_refs
    # end get_global_qos_config_back_refs

    def get_analytics_node_back_refs(self):
        """Return list of all analytics-nodes using this tag"""
        if hasattr(self, 'analytics_node_back_refs'):
            return self.analytics_node_back_refs

        if hasattr(super(Tag, self), 'analytics_node_back_refs'):
            return super(Tag, self).get_analytics_node_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['analytics_node_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'analytics_node_back_refs', None)
        if not back_refs:
            return None
        self.analytics_node_back_refs = back_refs

        return back_refs
    # end get_analytics_node_back_refs

    def get_virtual_DNS_back_refs(self):
        """Return list of all virtual-DNSs using this tag"""
        if hasattr(self, 'virtual_DNS_back_refs'):
            return self.virtual_DNS_back_refs

        if hasattr(super(Tag, self), 'virtual_DNS_back_refs'):
            return super(Tag, self).get_virtual_DNS_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['virtual_DNS_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'virtual_DNS_back_refs', None)
        if not back_refs:
            return None
        self.virtual_DNS_back_refs = back_refs

        return back_refs
    # end get_virtual_DNS_back_refs

    def get_config_database_node_back_refs(self):
        """Return list of all config-database-nodes using this tag"""
        if hasattr(self, 'config_database_node_back_refs'):
            return self.config_database_node_back_refs

        if hasattr(super(Tag, self), 'config_database_node_back_refs'):
            return super(Tag, self).get_config_database_node_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['config_database_node_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'config_database_node_back_refs', None)
        if not back_refs:
            return None
        self.config_database_node_back_refs = back_refs

        return back_refs
    # end get_config_database_node_back_refs

    def get_config_node_back_refs(self):
        """Return list of all config-nodes using this tag"""
        if hasattr(self, 'config_node_back_refs'):
            return self.config_node_back_refs

        if hasattr(super(Tag, self), 'config_node_back_refs'):
            return super(Tag, self).get_config_node_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['config_node_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'config_node_back_refs', None)
        if not back_refs:
            return None
        self.config_node_back_refs = back_refs

        return back_refs
    # end get_config_node_back_refs

    def get_device_functional_group_back_refs(self):
        """Return list of all device-functional-groups using this tag"""
        if hasattr(self, 'device_functional_group_back_refs'):
            return self.device_functional_group_back_refs

        if hasattr(super(Tag, self), 'device_functional_group_back_refs'):
            return super(Tag, self).get_device_functional_group_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['device_functional_group_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'device_functional_group_back_refs', None)
        if not back_refs:
            return None
        self.device_functional_group_back_refs = back_refs

        return back_refs
    # end get_device_functional_group_back_refs

    def get_firewall_rule_back_refs(self):
        """Return list of all firewall-rules using this tag"""
        if hasattr(self, 'firewall_rule_back_refs'):
            return self.firewall_rule_back_refs

        if hasattr(super(Tag, self), 'firewall_rule_back_refs'):
            return super(Tag, self).get_firewall_rule_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['firewall_rule_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'firewall_rule_back_refs', None)
        if not back_refs:
            return None
        self.firewall_rule_back_refs = back_refs

        return back_refs
    # end get_firewall_rule_back_refs

    def get_bgpvpn_back_refs(self):
        """Return list of all bgpvpns using this tag"""
        if hasattr(self, 'bgpvpn_back_refs'):
            return self.bgpvpn_back_refs

        if hasattr(super(Tag, self), 'bgpvpn_back_refs'):
            return super(Tag, self).get_bgpvpn_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['bgpvpn_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'bgpvpn_back_refs', None)
        if not back_refs:
            return None
        self.bgpvpn_back_refs = back_refs

        return back_refs
    # end get_bgpvpn_back_refs

    def get_role_definition_back_refs(self):
        """Return list of all role-definitions using this tag"""
        if hasattr(self, 'role_definition_back_refs'):
            return self.role_definition_back_refs

        if hasattr(super(Tag, self), 'role_definition_back_refs'):
            return super(Tag, self).get_role_definition_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['role_definition_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'role_definition_back_refs', None)
        if not back_refs:
            return None
        self.role_definition_back_refs = back_refs

        return back_refs
    # end get_role_definition_back_refs

    def get_service_connection_module_back_refs(self):
        """Return list of all service-connection-modules using this tag"""
        if hasattr(self, 'service_connection_module_back_refs'):
            return self.service_connection_module_back_refs

        if hasattr(super(Tag, self), 'service_connection_module_back_refs'):
            return super(Tag, self).get_service_connection_module_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['service_connection_module_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'service_connection_module_back_refs', None)
        if not back_refs:
            return None
        self.service_connection_module_back_refs = back_refs

        return back_refs
    # end get_service_connection_module_back_refs

    def get_security_group_back_refs(self):
        """Return list of all security-groups using this tag"""
        if hasattr(self, 'security_group_back_refs'):
            return self.security_group_back_refs

        if hasattr(super(Tag, self), 'security_group_back_refs'):
            return super(Tag, self).get_security_group_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['security_group_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'security_group_back_refs', None)
        if not back_refs:
            return None
        self.security_group_back_refs = back_refs

        return back_refs
    # end get_security_group_back_refs

    def get_database_node_back_refs(self):
        """Return list of all database-nodes using this tag"""
        if hasattr(self, 'database_node_back_refs'):
            return self.database_node_back_refs

        if hasattr(super(Tag, self), 'database_node_back_refs'):
            return super(Tag, self).get_database_node_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['database_node_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'database_node_back_refs', None)
        if not back_refs:
            return None
        self.database_node_back_refs = back_refs

        return back_refs
    # end get_database_node_back_refs

    def get_loadbalancer_healthmonitor_back_refs(self):
        """Return list of all loadbalancer-healthmonitors using this tag"""
        if hasattr(self, 'loadbalancer_healthmonitor_back_refs'):
            return self.loadbalancer_healthmonitor_back_refs

        if hasattr(super(Tag, self), 'loadbalancer_healthmonitor_back_refs'):
            return super(Tag, self).get_loadbalancer_healthmonitor_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['loadbalancer_healthmonitor_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'loadbalancer_healthmonitor_back_refs', None)
        if not back_refs:
            return None
        self.loadbalancer_healthmonitor_back_refs = back_refs

        return back_refs
    # end get_loadbalancer_healthmonitor_back_refs

    def get_devicemgr_node_back_refs(self):
        """Return list of all devicemgr-nodes using this tag"""
        if hasattr(self, 'devicemgr_node_back_refs'):
            return self.devicemgr_node_back_refs

        if hasattr(super(Tag, self), 'devicemgr_node_back_refs'):
            return super(Tag, self).get_devicemgr_node_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['devicemgr_node_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'devicemgr_node_back_refs', None)
        if not back_refs:
            return None
        self.devicemgr_node_back_refs = back_refs

        return back_refs
    # end get_devicemgr_node_back_refs

    def get_project_back_refs(self):
        """Return list of all projects using this tag"""
        if hasattr(self, 'project_back_refs'):
            return self.project_back_refs

        if hasattr(super(Tag, self), 'project_back_refs'):
            return super(Tag, self).get_project_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['project_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'project_back_refs', None)
        if not back_refs:
            return None
        self.project_back_refs = back_refs

        return back_refs
    # end get_project_back_refs

    def get_fabric_namespace_back_refs(self):
        """Return list of all fabric-namespaces using this tag"""
        if hasattr(self, 'fabric_namespace_back_refs'):
            return self.fabric_namespace_back_refs

        if hasattr(super(Tag, self), 'fabric_namespace_back_refs'):
            return super(Tag, self).get_fabric_namespace_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['fabric_namespace_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'fabric_namespace_back_refs', None)
        if not back_refs:
            return None
        self.fabric_namespace_back_refs = back_refs

        return back_refs
    # end get_fabric_namespace_back_refs

    def get_network_ipam_back_refs(self):
        """Return list of all network-ipams using this tag"""
        if hasattr(self, 'network_ipam_back_refs'):
            return self.network_ipam_back_refs

        if hasattr(super(Tag, self), 'network_ipam_back_refs'):
            return super(Tag, self).get_network_ipam_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['network_ipam_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'network_ipam_back_refs', None)
        if not back_refs:
            return None
        self.network_ipam_back_refs = back_refs

        return back_refs
    # end get_network_ipam_back_refs

    def get_network_policy_back_refs(self):
        """Return list of all network-policys using this tag"""
        if hasattr(self, 'network_policy_back_refs'):
            return self.network_policy_back_refs

        if hasattr(super(Tag, self), 'network_policy_back_refs'):
            return super(Tag, self).get_network_policy_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['network_policy_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'network_policy_back_refs', None)
        if not back_refs:
            return None
        self.network_policy_back_refs = back_refs

        return back_refs
    # end get_network_policy_back_refs

    def get_sflow_profile_back_refs(self):
        """Return list of all sflow-profiles using this tag"""
        if hasattr(self, 'sflow_profile_back_refs'):
            return self.sflow_profile_back_refs

        if hasattr(super(Tag, self), 'sflow_profile_back_refs'):
            return super(Tag, self).get_sflow_profile_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['sflow_profile_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'sflow_profile_back_refs', None)
        if not back_refs:
            return None
        self.sflow_profile_back_refs = back_refs

        return back_refs
    # end get_sflow_profile_back_refs

    def get_hardware_back_refs(self):
        """Return list of all hardwares using this tag"""
        if hasattr(self, 'hardware_back_refs'):
            return self.hardware_back_refs

        if hasattr(super(Tag, self), 'hardware_back_refs'):
            return super(Tag, self).get_hardware_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['hardware_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'hardware_back_refs', None)
        if not back_refs:
            return None
        self.hardware_back_refs = back_refs

        return back_refs
    # end get_hardware_back_refs

    def get_tag_back_refs(self):
        """Return list of all tags using this tag"""
        if hasattr(self, 'tag_back_refs'):
            return self.tag_back_refs

        if hasattr(super(Tag, self), 'tag_back_refs'):
            return super(Tag, self).get_tag_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['tag_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'tag_back_refs', None)
        if not back_refs:
            return None
        self.tag_back_refs = back_refs

        return back_refs
    # end get_tag_back_refs

    def get_feature_config_back_refs(self):
        """Return list of all feature-configs using this tag"""
        if hasattr(self, 'feature_config_back_refs'):
            return self.feature_config_back_refs

        if hasattr(super(Tag, self), 'feature_config_back_refs'):
            return super(Tag, self).get_feature_config_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['feature_config_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'feature_config_back_refs', None)
        if not back_refs:
            return None
        self.feature_config_back_refs = back_refs

        return back_refs
    # end get_feature_config_back_refs

    def get_telemetry_profile_back_refs(self):
        """Return list of all telemetry-profiles using this tag"""
        if hasattr(self, 'telemetry_profile_back_refs'):
            return self.telemetry_profile_back_refs

        if hasattr(super(Tag, self), 'telemetry_profile_back_refs'):
            return super(Tag, self).get_telemetry_profile_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['telemetry_profile_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'telemetry_profile_back_refs', None)
        if not back_refs:
            return None
        self.telemetry_profile_back_refs = back_refs

        return back_refs
    # end get_telemetry_profile_back_refs

    def get_bgp_router_back_refs(self):
        """Return list of all bgp-routers using this tag"""
        if hasattr(self, 'bgp_router_back_refs'):
            return self.bgp_router_back_refs

        if hasattr(super(Tag, self), 'bgp_router_back_refs'):
            return super(Tag, self).get_bgp_router_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['bgp_router_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'bgp_router_back_refs', None)
        if not back_refs:
            return None
        self.bgp_router_back_refs = back_refs

        return back_refs
    # end get_bgp_router_back_refs

    def get_virtual_network_back_refs(self):
        """Return list of all virtual-networks using this tag"""
        if hasattr(self, 'virtual_network_back_refs'):
            return self.virtual_network_back_refs

        if hasattr(super(Tag, self), 'virtual_network_back_refs'):
            return super(Tag, self).get_virtual_network_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['virtual_network_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'virtual_network_back_refs', None)
        if not back_refs:
            return None
        self.virtual_network_back_refs = back_refs

        return back_refs
    # end get_virtual_network_back_refs

    def get_virtual_port_group_back_refs(self):
        """Return list of all virtual-port-groups using this tag"""
        if hasattr(self, 'virtual_port_group_back_refs'):
            return self.virtual_port_group_back_refs

        if hasattr(super(Tag, self), 'virtual_port_group_back_refs'):
            return super(Tag, self).get_virtual_port_group_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['virtual_port_group_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'virtual_port_group_back_refs', None)
        if not back_refs:
            return None
        self.virtual_port_group_back_refs = back_refs

        return back_refs
    # end get_virtual_port_group_back_refs

    def get_service_appliance_back_refs(self):
        """Return list of all service-appliances using this tag"""
        if hasattr(self, 'service_appliance_back_refs'):
            return self.service_appliance_back_refs

        if hasattr(super(Tag, self), 'service_appliance_back_refs'):
            return super(Tag, self).get_service_appliance_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['service_appliance_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'service_appliance_back_refs', None)
        if not back_refs:
            return None
        self.service_appliance_back_refs = back_refs

        return back_refs
    # end get_service_appliance_back_refs

    def get_namespace_back_refs(self):
        """Return list of all namespaces using this tag"""
        if hasattr(self, 'namespace_back_refs'):
            return self.namespace_back_refs

        if hasattr(super(Tag, self), 'namespace_back_refs'):
            return super(Tag, self).get_namespace_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['namespace_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'namespace_back_refs', None)
        if not back_refs:
            return None
        self.namespace_back_refs = back_refs

        return back_refs
    # end get_namespace_back_refs

    def get_feature_back_refs(self):
        """Return list of all features using this tag"""
        if hasattr(self, 'feature_back_refs'):
            return self.feature_back_refs

        if hasattr(super(Tag, self), 'feature_back_refs'):
            return super(Tag, self).get_feature_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['feature_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'feature_back_refs', None)
        if not back_refs:
            return None
        self.feature_back_refs = back_refs

        return back_refs
    # end get_feature_back_refs

    def get_storm_control_profile_back_refs(self):
        """Return list of all storm-control-profiles using this tag"""
        if hasattr(self, 'storm_control_profile_back_refs'):
            return self.storm_control_profile_back_refs

        if hasattr(super(Tag, self), 'storm_control_profile_back_refs'):
            return super(Tag, self).get_storm_control_profile_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['storm_control_profile_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'storm_control_profile_back_refs', None)
        if not back_refs:
            return None
        self.storm_control_profile_back_refs = back_refs

        return back_refs
    # end get_storm_control_profile_back_refs

    def get_device_image_back_refs(self):
        """Return list of all device-images using this tag"""
        if hasattr(self, 'device_image_back_refs'):
            return self.device_image_back_refs

        if hasattr(super(Tag, self), 'device_image_back_refs'):
            return super(Tag, self).get_device_image_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['device_image_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'device_image_back_refs', None)
        if not back_refs:
            return None
        self.device_image_back_refs = back_refs

        return back_refs
    # end get_device_image_back_refs

    def get_physical_interface_back_refs(self):
        """Return list of all physical-interfaces using this tag"""
        if hasattr(self, 'physical_interface_back_refs'):
            return self.physical_interface_back_refs

        if hasattr(super(Tag, self), 'physical_interface_back_refs'):
            return super(Tag, self).get_physical_interface_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['physical_interface_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'physical_interface_back_refs', None)
        if not back_refs:
            return None
        self.physical_interface_back_refs = back_refs

        return back_refs
    # end get_physical_interface_back_refs

    def get_access_control_list_back_refs(self):
        """Return list of all access-control-lists using this tag"""
        if hasattr(self, 'access_control_list_back_refs'):
            return self.access_control_list_back_refs

        if hasattr(super(Tag, self), 'access_control_list_back_refs'):
            return super(Tag, self).get_access_control_list_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['access_control_list_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'access_control_list_back_refs', None)
        if not back_refs:
            return None
        self.access_control_list_back_refs = back_refs

        return back_refs
    # end get_access_control_list_back_refs

    def get_node_back_refs(self):
        """Return list of all nodes using this tag"""
        if hasattr(self, 'node_back_refs'):
            return self.node_back_refs

        if hasattr(super(Tag, self), 'node_back_refs'):
            return super(Tag, self).get_node_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['node_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'node_back_refs', None)
        if not back_refs:
            return None
        self.node_back_refs = back_refs

        return back_refs
    # end get_node_back_refs

    def get_customer_attachment_back_refs(self):
        """Return list of all customer-attachments using this tag"""
        if hasattr(self, 'customer_attachment_back_refs'):
            return self.customer_attachment_back_refs

        if hasattr(super(Tag, self), 'customer_attachment_back_refs'):
            return super(Tag, self).get_customer_attachment_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['customer_attachment_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'customer_attachment_back_refs', None)
        if not back_refs:
            return None
        self.customer_attachment_back_refs = back_refs

        return back_refs
    # end get_customer_attachment_back_refs

    def get_structured_syslog_sla_profile_back_refs(self):
        """Return list of all structured-syslog-sla-profiles using this tag"""
        if hasattr(self, 'structured_syslog_sla_profile_back_refs'):
            return self.structured_syslog_sla_profile_back_refs

        if hasattr(super(Tag, self), 'structured_syslog_sla_profile_back_refs'):
            return super(Tag, self).get_structured_syslog_sla_profile_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['structured_syslog_sla_profile_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'structured_syslog_sla_profile_back_refs', None)
        if not back_refs:
            return None
        self.structured_syslog_sla_profile_back_refs = back_refs

        return back_refs
    # end get_structured_syslog_sla_profile_back_refs

    def get_host_based_service_back_refs(self):
        """Return list of all host-based-services using this tag"""
        if hasattr(self, 'host_based_service_back_refs'):
            return self.host_based_service_back_refs

        if hasattr(super(Tag, self), 'host_based_service_back_refs'):
            return super(Tag, self).get_host_based_service_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['host_based_service_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'host_based_service_back_refs', None)
        if not back_refs:
            return None
        self.host_based_service_back_refs = back_refs

        return back_refs
    # end get_host_based_service_back_refs

    def get_virtual_machine_back_refs(self):
        """Return list of all virtual-machines using this tag"""
        if hasattr(self, 'virtual_machine_back_refs'):
            return self.virtual_machine_back_refs

        if hasattr(super(Tag, self), 'virtual_machine_back_refs'):
            return super(Tag, self).get_virtual_machine_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['virtual_machine_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'virtual_machine_back_refs', None)
        if not back_refs:
            return None
        self.virtual_machine_back_refs = back_refs

        return back_refs
    # end get_virtual_machine_back_refs

    def get_interface_route_table_back_refs(self):
        """Return list of all interface-route-tables using this tag"""
        if hasattr(self, 'interface_route_table_back_refs'):
            return self.interface_route_table_back_refs

        if hasattr(super(Tag, self), 'interface_route_table_back_refs'):
            return super(Tag, self).get_interface_route_table_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['interface_route_table_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'interface_route_table_back_refs', None)
        if not back_refs:
            return None
        self.interface_route_table_back_refs = back_refs

        return back_refs
    # end get_interface_route_table_back_refs

    def get_loadbalancer_member_back_refs(self):
        """Return list of all loadbalancer-members using this tag"""
        if hasattr(self, 'loadbalancer_member_back_refs'):
            return self.loadbalancer_member_back_refs

        if hasattr(super(Tag, self), 'loadbalancer_member_back_refs'):
            return super(Tag, self).get_loadbalancer_member_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['loadbalancer_member_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'loadbalancer_member_back_refs', None)
        if not back_refs:
            return None
        self.loadbalancer_member_back_refs = back_refs

        return back_refs
    # end get_loadbalancer_member_back_refs

    def get_service_health_check_back_refs(self):
        """Return list of all service-health-checks using this tag"""
        if hasattr(self, 'service_health_check_back_refs'):
            return self.service_health_check_back_refs

        if hasattr(super(Tag, self), 'service_health_check_back_refs'):
            return super(Tag, self).get_service_health_check_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['service_health_check_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'service_health_check_back_refs', None)
        if not back_refs:
            return None
        self.service_health_check_back_refs = back_refs

        return back_refs
    # end get_service_health_check_back_refs

    def get_alarm_back_refs(self):
        """Return list of all alarms using this tag"""
        if hasattr(self, 'alarm_back_refs'):
            return self.alarm_back_refs

        if hasattr(super(Tag, self), 'alarm_back_refs'):
            return super(Tag, self).get_alarm_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['alarm_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'alarm_back_refs', None)
        if not back_refs:
            return None
        self.alarm_back_refs = back_refs

        return back_refs
    # end get_alarm_back_refs

    def get_api_access_list_back_refs(self):
        """Return list of all api-access-lists using this tag"""
        if hasattr(self, 'api_access_list_back_refs'):
            return self.api_access_list_back_refs

        if hasattr(super(Tag, self), 'api_access_list_back_refs'):
            return super(Tag, self).get_api_access_list_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['api_access_list_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'api_access_list_back_refs', None)
        if not back_refs:
            return None
        self.api_access_list_back_refs = back_refs

        return back_refs
    # end get_api_access_list_back_refs

    def get_routing_instance_back_refs(self):
        """Return list of all routing-instances using this tag"""
        if hasattr(self, 'routing_instance_back_refs'):
            return self.routing_instance_back_refs

        if hasattr(super(Tag, self), 'routing_instance_back_refs'):
            return super(Tag, self).get_routing_instance_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['routing_instance_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'routing_instance_back_refs', None)
        if not back_refs:
            return None
        self.routing_instance_back_refs = back_refs

        return back_refs
    # end get_routing_instance_back_refs

    def get_alias_ip_pool_back_refs(self):
        """Return list of all alias-ip-pools using this tag"""
        if hasattr(self, 'alias_ip_pool_back_refs'):
            return self.alias_ip_pool_back_refs

        if hasattr(super(Tag, self), 'alias_ip_pool_back_refs'):
            return super(Tag, self).get_alias_ip_pool_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['alias_ip_pool_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'alias_ip_pool_back_refs', None)
        if not back_refs:
            return None
        self.alias_ip_pool_back_refs = back_refs

        return back_refs
    # end get_alias_ip_pool_back_refs

    def get_data_center_interconnect_back_refs(self):
        """Return list of all data-center-interconnects using this tag"""
        if hasattr(self, 'data_center_interconnect_back_refs'):
            return self.data_center_interconnect_back_refs

        if hasattr(super(Tag, self), 'data_center_interconnect_back_refs'):
            return super(Tag, self).get_data_center_interconnect_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.tag_read(id = self.uuid, fields = ['data_center_interconnect_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'data_center_interconnect_back_refs', None)
        if not back_refs:
            return None
        self.data_center_interconnect_back_refs = back_refs

        return back_refs
    # end get_data_center_interconnect_back_refs

# end class Tag

class FeatureConfig(vnc_api.gen.resource_common.FeatureConfig):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'feature_config_additional_params' in kwargs:
            pending_fields.append('feature_config_additional_params')
        if len(args) > 1 or 'feature_config_vendor_config' in kwargs:
            pending_fields.append('feature_config_vendor_config')
        if len(args) > 2 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 3 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 4 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 5 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(FeatureConfig, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            if kwargs['feature_config_additional_params'] is None:
                props_dict['feature_config_additional_params'] = None
            else:
                props_dict['feature_config_additional_params'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'feature_config_additional_params'])
        except KeyError:
            pass

        try:
            if kwargs['feature_config_vendor_config'] is None:
                props_dict['feature_config_vendor_config'] = None
            else:
                props_dict['feature_config_vendor_config'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'feature_config_vendor_config'])
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = FeatureConfig(**props_dict)
        else:
            obj = FeatureConfig(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.FeatureConfig.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.FeatureConfig.feature_config_additional_params.setter
    def feature_config_additional_params(self, feature_config_additional_params):
        """Set feature-config-additional-params for feature-config.
        
        :param feature_config_additional_params: KeyValuePairs object
        
        """
        if 'feature_config_additional_params' not in self._pending_field_updates:
            self._pending_field_updates.add('feature_config_additional_params')

        self._feature_config_additional_params = feature_config_additional_params
    # end feature_config_additional_params

    def set_feature_config_additional_params(self, value):
        self.feature_config_additional_params = value
    # end set_feature_config_additional_params

    @vnc_api.gen.resource_common.FeatureConfig.feature_config_vendor_config.setter
    def feature_config_vendor_config(self, feature_config_vendor_config):
        """Set feature-config-vendor-config for feature-config.
        
        :param feature_config_vendor_config: KeyValuePairs object
        
        """
        if 'feature_config_vendor_config' not in self._pending_field_updates:
            self._pending_field_updates.add('feature_config_vendor_config')

        self._feature_config_vendor_config = feature_config_vendor_config
    # end feature_config_vendor_config

    def set_feature_config_vendor_config(self, value):
        self.feature_config_vendor_config = value
    # end set_feature_config_vendor_config

    @vnc_api.gen.resource_common.FeatureConfig.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for feature-config.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.FeatureConfig.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for feature-config.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.FeatureConfig.annotations.setter
    def annotations(self, annotations):
        """Set annotations for feature-config.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.FeatureConfig.display_name.setter
    def display_name(self, display_name):
        """Set display-name for feature-config.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for feature-config.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for feature-config.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_tag(self, *args, **kwargs):
        """Set tag for feature-config.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(FeatureConfig, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to feature-config.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(FeatureConfig, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(FeatureConfig, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for feature-config.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(FeatureConfig, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


# end class FeatureConfig

class TelemetryProfile(vnc_api.gen.resource_common.TelemetryProfile):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'telemetry_profile_is_default' in kwargs:
            pending_fields.append('telemetry_profile_is_default')
        if len(args) > 1 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 2 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 3 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 4 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(TelemetryProfile, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            props_dict['telemetry_profile_is_default'] = kwargs[u'telemetry_profile_is_default']
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = TelemetryProfile(**props_dict)
        else:
            obj = TelemetryProfile(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.sflow_profile_refs = kwargs[u'sflow_profile_refs']
        except KeyError:
            pass
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.physical_router_back_refs = kwargs[u'physical_router_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.TelemetryProfile.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.TelemetryProfile.telemetry_profile_is_default.setter
    def telemetry_profile_is_default(self, telemetry_profile_is_default):
        """Set telemetry-profile-is-default for telemetry-profile.
        
        :param telemetry_profile_is_default: xsd:boolean object
        
        """
        if 'telemetry_profile_is_default' not in self._pending_field_updates:
            self._pending_field_updates.add('telemetry_profile_is_default')

        self._telemetry_profile_is_default = telemetry_profile_is_default
    # end telemetry_profile_is_default

    def set_telemetry_profile_is_default(self, value):
        self.telemetry_profile_is_default = value
    # end set_telemetry_profile_is_default

    @vnc_api.gen.resource_common.TelemetryProfile.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for telemetry-profile.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.TelemetryProfile.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for telemetry-profile.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.TelemetryProfile.annotations.setter
    def annotations(self, annotations):
        """Set annotations for telemetry-profile.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.TelemetryProfile.display_name.setter
    def display_name(self, display_name):
        """Set display-name for telemetry-profile.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for telemetry-profile.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for telemetry-profile.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_sflow_profile(self, *args, **kwargs):
        """Set sflow-profile for telemetry-profile.
        
        :param ref_obj: SflowProfile object
        
        """
        self._pending_field_updates.add('sflow_profile_refs')
        self._pending_ref_updates.discard('sflow_profile_refs')
        super(TelemetryProfile, self).set_sflow_profile(*args, **kwargs)

    # end set_sflow_profile

    def add_sflow_profile(self, *args, **kwargs):
        """Add sflow-profile to telemetry-profile.
        
        :param ref_obj: SflowProfile object
        
        """
        if 'sflow_profile_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('sflow_profile_refs')
            self._original_sflow_profile_refs = copy.deepcopy(self.get_sflow_profile_refs() or [])
        super(TelemetryProfile, self).add_sflow_profile(*args, **kwargs)
    # end add_sflow_profile

    def del_sflow_profile(self, *args, **kwargs):
        if 'sflow_profile_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('sflow_profile_refs')
            self._original_sflow_profile_refs = copy.deepcopy(self.get_sflow_profile_refs() or [])
        super(TelemetryProfile, self).del_sflow_profile(*args, **kwargs)
    # end del_sflow_profile

    def set_sflow_profile_list(self, *args, **kwargs):
        """Set sflow-profile list for telemetry-profile.
        
        :param ref_obj_list: list of SflowProfile object
        
        """
        self._pending_field_updates.add('sflow_profile_refs')
        self._pending_ref_updates.discard('sflow_profile_refs')
        super(TelemetryProfile, self).set_sflow_profile_list(*args, **kwargs)
    # end set_sflow_profile_list

    def set_tag(self, *args, **kwargs):
        """Set tag for telemetry-profile.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(TelemetryProfile, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to telemetry-profile.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(TelemetryProfile, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(TelemetryProfile, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for telemetry-profile.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(TelemetryProfile, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


    def get_physical_router_back_refs(self):
        """Return list of all physical-routers using this telemetry-profile"""
        if hasattr(self, 'physical_router_back_refs'):
            return self.physical_router_back_refs

        if hasattr(super(TelemetryProfile, self), 'physical_router_back_refs'):
            return super(TelemetryProfile, self).get_physical_router_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.telemetry_profile_read(id = self.uuid, fields = ['physical_router_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'physical_router_back_refs', None)
        if not back_refs:
            return None
        self.physical_router_back_refs = back_refs

        return back_refs
    # end get_physical_router_back_refs

# end class TelemetryProfile

class BgpRouter(vnc_api.gen.resource_common.BgpRouter):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'bgp_router_parameters' in kwargs:
            pending_fields.append('bgp_router_parameters')
        if len(args) > 1 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 2 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 3 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 4 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(BgpRouter, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            if kwargs['bgp_router_parameters'] is None:
                props_dict['bgp_router_parameters'] = None
            else:
                props_dict['bgp_router_parameters'] = vnc_api.gen.resource_xsd.BgpRouterParams(params_dict=kwargs[u'bgp_router_parameters'])
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = BgpRouter(**props_dict)
        else:
            obj = BgpRouter(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.control_node_zone_refs = kwargs[u'control_node_zone_refs']
        except KeyError:
            pass
        try:
            obj.sub_cluster_refs = kwargs[u'sub_cluster_refs']
        except KeyError:
            pass
        try:
            obj.bgp_router_refs = kwargs[u'bgp_router_refs']
            for ref in obj.bgp_router_refs:
                ref['attr'] = vnc_api.gen.resource_xsd.BgpPeeringAttributes(params_dict=ref[u'attr'])
        except KeyError:
            pass
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.global_system_config_back_refs = kwargs[u'global_system_config_back_refs']
        except KeyError:
            pass
        try:
            obj.physical_router_back_refs = kwargs[u'physical_router_back_refs']
        except KeyError:
            pass
        try:
            obj.virtual_machine_interface_back_refs = kwargs[u'virtual_machine_interface_back_refs']
        except KeyError:
            pass
        try:
            obj.bgp_as_a_service_back_refs = kwargs[u'bgp_as_a_service_back_refs']
        except KeyError:
            pass
        try:
            obj.bgp_router_back_refs = kwargs[u'bgp_router_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.BgpRouter.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.BgpRouter.bgp_router_parameters.setter
    def bgp_router_parameters(self, bgp_router_parameters):
        """Set bgp-router-parameters for bgp-router.
        
        :param bgp_router_parameters: BgpRouterParams object
        
        """
        if 'bgp_router_parameters' not in self._pending_field_updates:
            self._pending_field_updates.add('bgp_router_parameters')

        self._bgp_router_parameters = bgp_router_parameters
    # end bgp_router_parameters

    def set_bgp_router_parameters(self, value):
        self.bgp_router_parameters = value
    # end set_bgp_router_parameters

    @vnc_api.gen.resource_common.BgpRouter.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for bgp-router.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.BgpRouter.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for bgp-router.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.BgpRouter.annotations.setter
    def annotations(self, annotations):
        """Set annotations for bgp-router.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.BgpRouter.display_name.setter
    def display_name(self, display_name):
        """Set display-name for bgp-router.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for bgp-router.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for bgp-router.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_control_node_zone(self, *args, **kwargs):
        """Set control-node-zone for bgp-router.
        
        :param ref_obj: ControlNodeZone object
        
        """
        self._pending_field_updates.add('control_node_zone_refs')
        self._pending_ref_updates.discard('control_node_zone_refs')
        super(BgpRouter, self).set_control_node_zone(*args, **kwargs)

    # end set_control_node_zone

    def add_control_node_zone(self, *args, **kwargs):
        """Add control-node-zone to bgp-router.
        
        :param ref_obj: ControlNodeZone object
        
        """
        if 'control_node_zone_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('control_node_zone_refs')
            self._original_control_node_zone_refs = copy.deepcopy(self.get_control_node_zone_refs() or [])
        super(BgpRouter, self).add_control_node_zone(*args, **kwargs)
    # end add_control_node_zone

    def del_control_node_zone(self, *args, **kwargs):
        if 'control_node_zone_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('control_node_zone_refs')
            self._original_control_node_zone_refs = copy.deepcopy(self.get_control_node_zone_refs() or [])
        super(BgpRouter, self).del_control_node_zone(*args, **kwargs)
    # end del_control_node_zone

    def set_control_node_zone_list(self, *args, **kwargs):
        """Set control-node-zone list for bgp-router.
        
        :param ref_obj_list: list of ControlNodeZone object
        
        """
        self._pending_field_updates.add('control_node_zone_refs')
        self._pending_ref_updates.discard('control_node_zone_refs')
        super(BgpRouter, self).set_control_node_zone_list(*args, **kwargs)
    # end set_control_node_zone_list

    def set_sub_cluster(self, *args, **kwargs):
        """Set sub-cluster for bgp-router.
        
        :param ref_obj: SubCluster object
        
        """
        self._pending_field_updates.add('sub_cluster_refs')
        self._pending_ref_updates.discard('sub_cluster_refs')
        super(BgpRouter, self).set_sub_cluster(*args, **kwargs)

    # end set_sub_cluster

    def add_sub_cluster(self, *args, **kwargs):
        """Add sub-cluster to bgp-router.
        
        :param ref_obj: SubCluster object
        
        """
        if 'sub_cluster_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('sub_cluster_refs')
            self._original_sub_cluster_refs = copy.deepcopy(self.get_sub_cluster_refs() or [])
        super(BgpRouter, self).add_sub_cluster(*args, **kwargs)
    # end add_sub_cluster

    def del_sub_cluster(self, *args, **kwargs):
        if 'sub_cluster_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('sub_cluster_refs')
            self._original_sub_cluster_refs = copy.deepcopy(self.get_sub_cluster_refs() or [])
        super(BgpRouter, self).del_sub_cluster(*args, **kwargs)
    # end del_sub_cluster

    def set_sub_cluster_list(self, *args, **kwargs):
        """Set sub-cluster list for bgp-router.
        
        :param ref_obj_list: list of SubCluster object
        
        """
        self._pending_field_updates.add('sub_cluster_refs')
        self._pending_ref_updates.discard('sub_cluster_refs')
        super(BgpRouter, self).set_sub_cluster_list(*args, **kwargs)
    # end set_sub_cluster_list

    def set_bgp_router(self, *args, **kwargs):
        """Set bgp-router for bgp-router.
        
        :param ref_obj: BgpRouter object
        :param ref_data: BgpPeeringAttributes object
        
        """
        self._pending_field_updates.add('bgp_router_refs')
        self._pending_ref_updates.discard('bgp_router_refs')
        super(BgpRouter, self).set_bgp_router(*args, **kwargs)

    # end set_bgp_router

    def add_bgp_router(self, *args, **kwargs):
        """Add bgp-router to bgp-router.
        
        :param ref_obj: BgpRouter object
        :param ref_data: BgpPeeringAttributes object
        
        """
        if 'bgp_router_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('bgp_router_refs')
            self._original_bgp_router_refs = copy.deepcopy(self.get_bgp_router_refs() or [])
        super(BgpRouter, self).add_bgp_router(*args, **kwargs)
    # end add_bgp_router

    def del_bgp_router(self, *args, **kwargs):
        if 'bgp_router_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('bgp_router_refs')
            self._original_bgp_router_refs = copy.deepcopy(self.get_bgp_router_refs() or [])
        super(BgpRouter, self).del_bgp_router(*args, **kwargs)
    # end del_bgp_router

    def set_bgp_router_list(self, *args, **kwargs):
        """Set bgp-router list for bgp-router.
        
        :param ref_obj_list: list of BgpRouter object
        :param ref_data_list: list of BgpPeeringAttributes summary
        
        """
        self._pending_field_updates.add('bgp_router_refs')
        self._pending_ref_updates.discard('bgp_router_refs')
        super(BgpRouter, self).set_bgp_router_list(*args, **kwargs)
    # end set_bgp_router_list

    def set_tag(self, *args, **kwargs):
        """Set tag for bgp-router.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(BgpRouter, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to bgp-router.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(BgpRouter, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(BgpRouter, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for bgp-router.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(BgpRouter, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


    def get_global_system_config_back_refs(self):
        """Return list of all global-system-configs using this bgp-router"""
        if hasattr(self, 'global_system_config_back_refs'):
            return self.global_system_config_back_refs

        if hasattr(super(BgpRouter, self), 'global_system_config_back_refs'):
            return super(BgpRouter, self).get_global_system_config_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.bgp_router_read(id = self.uuid, fields = ['global_system_config_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'global_system_config_back_refs', None)
        if not back_refs:
            return None
        self.global_system_config_back_refs = back_refs

        return back_refs
    # end get_global_system_config_back_refs

    def get_physical_router_back_refs(self):
        """Return list of all physical-routers using this bgp-router"""
        if hasattr(self, 'physical_router_back_refs'):
            return self.physical_router_back_refs

        if hasattr(super(BgpRouter, self), 'physical_router_back_refs'):
            return super(BgpRouter, self).get_physical_router_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.bgp_router_read(id = self.uuid, fields = ['physical_router_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'physical_router_back_refs', None)
        if not back_refs:
            return None
        self.physical_router_back_refs = back_refs

        return back_refs
    # end get_physical_router_back_refs

    def get_virtual_machine_interface_back_refs(self):
        """Return list of all virtual-machine-interfaces using this bgp-router"""
        if hasattr(self, 'virtual_machine_interface_back_refs'):
            return self.virtual_machine_interface_back_refs

        if hasattr(super(BgpRouter, self), 'virtual_machine_interface_back_refs'):
            return super(BgpRouter, self).get_virtual_machine_interface_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.bgp_router_read(id = self.uuid, fields = ['virtual_machine_interface_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'virtual_machine_interface_back_refs', None)
        if not back_refs:
            return None
        self.virtual_machine_interface_back_refs = back_refs

        return back_refs
    # end get_virtual_machine_interface_back_refs

    def get_bgp_as_a_service_back_refs(self):
        """Return list of all bgp-as-a-services using this bgp-router"""
        if hasattr(self, 'bgp_as_a_service_back_refs'):
            return self.bgp_as_a_service_back_refs

        if hasattr(super(BgpRouter, self), 'bgp_as_a_service_back_refs'):
            return super(BgpRouter, self).get_bgp_as_a_service_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.bgp_router_read(id = self.uuid, fields = ['bgp_as_a_service_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'bgp_as_a_service_back_refs', None)
        if not back_refs:
            return None
        self.bgp_as_a_service_back_refs = back_refs

        return back_refs
    # end get_bgp_as_a_service_back_refs

    def get_bgp_router_back_refs(self):
        """Return list of all bgp-routers using this bgp-router"""
        if hasattr(self, 'bgp_router_back_refs'):
            return self.bgp_router_back_refs

        if hasattr(super(BgpRouter, self), 'bgp_router_back_refs'):
            return super(BgpRouter, self).get_bgp_router_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.bgp_router_read(id = self.uuid, fields = ['bgp_router_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'bgp_router_back_refs', None)
        if not back_refs:
            return None
        self.bgp_router_back_refs = back_refs

        return back_refs
    # end get_bgp_router_back_refs

# end class BgpRouter

class VirtualNetwork(vnc_api.gen.resource_common.VirtualNetwork):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'ecmp_hashing_include_fields' in kwargs:
            pending_fields.append('ecmp_hashing_include_fields')
        if len(args) > 1 or 'virtual_network_category' in kwargs:
            pending_fields.append('virtual_network_category')
        if len(args) > 2 or 'virtual_network_properties' in kwargs:
            pending_fields.append('virtual_network_properties')
        if len(args) > 3 or 'virtual_network_routed_properties' in kwargs:
            pending_fields.append('virtual_network_routed_properties')
        if len(args) > 4 or 'provider_properties' in kwargs:
            pending_fields.append('provider_properties')
        if len(args) > 5 or 'virtual_network_network_id' in kwargs:
            pending_fields.append('virtual_network_network_id')
        if len(args) > 6 or 'is_provider_network' in kwargs:
            pending_fields.append('is_provider_network')
        if len(args) > 7 or 'port_security_enabled' in kwargs:
            pending_fields.append('port_security_enabled')
        if len(args) > 8 or 'fabric_snat' in kwargs:
            pending_fields.append('fabric_snat')
        if len(args) > 9 or 'route_target_list' in kwargs:
            pending_fields.append('route_target_list')
        if len(args) > 10 or 'import_route_target_list' in kwargs:
            pending_fields.append('import_route_target_list')
        if len(args) > 11 or 'export_route_target_list' in kwargs:
            pending_fields.append('export_route_target_list')
        if len(args) > 12 or 'router_external' in kwargs:
            pending_fields.append('router_external')
        if len(args) > 13 or 'is_shared' in kwargs:
            pending_fields.append('is_shared')
        if len(args) > 14 or 'external_ipam' in kwargs:
            pending_fields.append('external_ipam')
        if len(args) > 15 or 'flood_unknown_unicast' in kwargs:
            pending_fields.append('flood_unknown_unicast')
        if len(args) > 16 or 'multi_policy_service_chains_enabled' in kwargs:
            pending_fields.append('multi_policy_service_chains_enabled')
        if len(args) > 17 or 'address_allocation_mode' in kwargs:
            pending_fields.append('address_allocation_mode')
        if len(args) > 18 or 'virtual_network_fat_flow_protocols' in kwargs:
            pending_fields.append('virtual_network_fat_flow_protocols')
        if len(args) > 19 or 'mac_learning_enabled' in kwargs:
            pending_fields.append('mac_learning_enabled')
        if len(args) > 20 or 'mac_limit_control' in kwargs:
            pending_fields.append('mac_limit_control')
        if len(args) > 21 or 'mac_move_control' in kwargs:
            pending_fields.append('mac_move_control')
        if len(args) > 22 or 'mac_aging_time' in kwargs:
            pending_fields.append('mac_aging_time')
        if len(args) > 23 or 'pbb_evpn_enable' in kwargs:
            pending_fields.append('pbb_evpn_enable')
        if len(args) > 24 or 'pbb_etree_enable' in kwargs:
            pending_fields.append('pbb_etree_enable')
        if len(args) > 25 or 'layer2_control_word' in kwargs:
            pending_fields.append('layer2_control_word')
        if len(args) > 26 or 'igmp_enable' in kwargs:
            pending_fields.append('igmp_enable')
        if len(args) > 27 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 28 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 29 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 30 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(VirtualNetwork, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            if kwargs['ecmp_hashing_include_fields'] is None:
                props_dict['ecmp_hashing_include_fields'] = None
            else:
                props_dict['ecmp_hashing_include_fields'] = vnc_api.gen.resource_xsd.EcmpHashingIncludeFields(params_dict=kwargs[u'ecmp_hashing_include_fields'])
        except KeyError:
            pass

        try:
            props_dict['virtual_network_category'] = kwargs[u'virtual_network_category']
        except KeyError:
            pass

        try:
            if kwargs['virtual_network_properties'] is None:
                props_dict['virtual_network_properties'] = None
            else:
                props_dict['virtual_network_properties'] = vnc_api.gen.resource_xsd.VirtualNetworkType(params_dict=kwargs[u'virtual_network_properties'])
        except KeyError:
            pass

        try:
            if kwargs['virtual_network_routed_properties'] is None:
                props_dict['virtual_network_routed_properties'] = None
            else:
                props_dict['virtual_network_routed_properties'] = vnc_api.gen.resource_xsd.VirtualNetworkRoutedPropertiesType(params_dict=kwargs[u'virtual_network_routed_properties'])
        except KeyError:
            pass

        try:
            if kwargs['provider_properties'] is None:
                props_dict['provider_properties'] = None
            else:
                props_dict['provider_properties'] = vnc_api.gen.resource_xsd.ProviderDetails(params_dict=kwargs[u'provider_properties'])
        except KeyError:
            pass

        try:
            props_dict['virtual_network_network_id'] = kwargs[u'virtual_network_network_id']
        except KeyError:
            pass

        try:
            props_dict['is_provider_network'] = kwargs[u'is_provider_network']
        except KeyError:
            pass

        try:
            props_dict['port_security_enabled'] = kwargs[u'port_security_enabled']
        except KeyError:
            pass

        try:
            props_dict['fabric_snat'] = kwargs[u'fabric_snat']
        except KeyError:
            pass

        try:
            if kwargs['route_target_list'] is None:
                props_dict['route_target_list'] = None
            else:
                props_dict['route_target_list'] = vnc_api.gen.resource_xsd.RouteTargetList(params_dict=kwargs[u'route_target_list'])
        except KeyError:
            pass

        try:
            if kwargs['import_route_target_list'] is None:
                props_dict['import_route_target_list'] = None
            else:
                props_dict['import_route_target_list'] = vnc_api.gen.resource_xsd.RouteTargetList(params_dict=kwargs[u'import_route_target_list'])
        except KeyError:
            pass

        try:
            if kwargs['export_route_target_list'] is None:
                props_dict['export_route_target_list'] = None
            else:
                props_dict['export_route_target_list'] = vnc_api.gen.resource_xsd.RouteTargetList(params_dict=kwargs[u'export_route_target_list'])
        except KeyError:
            pass

        try:
            props_dict['router_external'] = kwargs[u'router_external']
        except KeyError:
            pass

        try:
            props_dict['is_shared'] = kwargs[u'is_shared']
        except KeyError:
            pass

        try:
            props_dict['external_ipam'] = kwargs[u'external_ipam']
        except KeyError:
            pass

        try:
            props_dict['flood_unknown_unicast'] = kwargs[u'flood_unknown_unicast']
        except KeyError:
            pass

        try:
            props_dict['multi_policy_service_chains_enabled'] = kwargs[u'multi_policy_service_chains_enabled']
        except KeyError:
            pass

        try:
            props_dict['address_allocation_mode'] = kwargs[u'address_allocation_mode']
        except KeyError:
            pass

        try:
            if kwargs['virtual_network_fat_flow_protocols'] is None:
                props_dict['virtual_network_fat_flow_protocols'] = None
            else:
                props_dict['virtual_network_fat_flow_protocols'] = vnc_api.gen.resource_xsd.FatFlowProtocols(params_dict=kwargs[u'virtual_network_fat_flow_protocols'])
        except KeyError:
            pass

        try:
            props_dict['mac_learning_enabled'] = kwargs[u'mac_learning_enabled']
        except KeyError:
            pass

        try:
            if kwargs['mac_limit_control'] is None:
                props_dict['mac_limit_control'] = None
            else:
                props_dict['mac_limit_control'] = vnc_api.gen.resource_xsd.MACLimitControlType(params_dict=kwargs[u'mac_limit_control'])
        except KeyError:
            pass

        try:
            if kwargs['mac_move_control'] is None:
                props_dict['mac_move_control'] = None
            else:
                props_dict['mac_move_control'] = vnc_api.gen.resource_xsd.MACMoveLimitControlType(params_dict=kwargs[u'mac_move_control'])
        except KeyError:
            pass

        try:
            props_dict['mac_aging_time'] = kwargs[u'mac_aging_time']
        except KeyError:
            pass

        try:
            props_dict['pbb_evpn_enable'] = kwargs[u'pbb_evpn_enable']
        except KeyError:
            pass

        try:
            props_dict['pbb_etree_enable'] = kwargs[u'pbb_etree_enable']
        except KeyError:
            pass

        try:
            props_dict['layer2_control_word'] = kwargs[u'layer2_control_word']
        except KeyError:
            pass

        try:
            props_dict['igmp_enable'] = kwargs[u'igmp_enable']
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = VirtualNetwork(**props_dict)
        else:
            obj = VirtualNetwork(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...
        try:
            obj.access_control_lists = kwargs[u'access_control_lists']
        except KeyError:
            pass
        try:
            obj.floating_ip_pools = kwargs[u'floating_ip_pools']
        except KeyError:
            pass
        try:
            obj.alias_ip_pools = kwargs[u'alias_ip_pools']
        except KeyError:
            pass
        try:
            obj.routing_instances = kwargs[u'routing_instances']
        except KeyError:
            pass
        try:
            obj.bridge_domains = kwargs[u'bridge_domains']
        except KeyError:
            pass

        # add any specified references...
        try:
            obj.security_logging_object_refs = kwargs[u'security_logging_object_refs']
        except KeyError:
            pass
        try:
            obj.qos_config_refs = kwargs[u'qos_config_refs']
        except KeyError:
            pass
        try:
            obj.network_ipam_refs = kwargs[u'network_ipam_refs']
            for ref in obj.network_ipam_refs:
                ref['attr'] = vnc_api.gen.resource_xsd.VnSubnetsType(params_dict=ref[u'attr'])
        except KeyError:
            pass
        try:
            obj.network_policy_refs = kwargs[u'network_policy_refs']
            for ref in obj.network_policy_refs:
                ref['attr'] = vnc_api.gen.resource_xsd.VirtualNetworkPolicyType(params_dict=ref[u'attr'])
        except KeyError:
            pass
        try:
            obj.virtual_network_refs = kwargs[u'virtual_network_refs']
        except KeyError:
            pass
        try:
            obj.route_table_refs = kwargs[u'route_table_refs']
        except KeyError:
            pass
        try:
            obj.multicast_policy_refs = kwargs[u'multicast_policy_refs']
        except KeyError:
            pass
        try:
            obj.bgpvpn_refs = kwargs[u'bgpvpn_refs']
        except KeyError:
            pass
        try:
            obj.intent_map_refs = kwargs[u'intent_map_refs']
        except KeyError:
            pass
        try:
            obj.routing_policy_refs = kwargs[u'routing_policy_refs']
            for ref in obj.routing_policy_refs:
                ref['attr'] = vnc_api.gen.resource_xsd.RoutingPolicyType(params_dict=ref[u'attr'])
        except KeyError:
            pass
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.virtual_network_back_refs = kwargs[u'virtual_network_back_refs']
        except KeyError:
            pass
        try:
            obj.virtual_machine_interface_back_refs = kwargs[u'virtual_machine_interface_back_refs']
        except KeyError:
            pass
        try:
            obj.instance_ip_back_refs = kwargs[u'instance_ip_back_refs']
        except KeyError:
            pass
        try:
            obj.physical_router_back_refs = kwargs[u'physical_router_back_refs']
        except KeyError:
            pass
        try:
            obj.port_tuple_back_refs = kwargs[u'port_tuple_back_refs']
        except KeyError:
            pass
        try:
            obj.logical_router_back_refs = kwargs[u'logical_router_back_refs']
        except KeyError:
            pass
        try:
            obj.flow_node_back_refs = kwargs[u'flow_node_back_refs']
        except KeyError:
            pass
        try:
            obj.firewall_rule_back_refs = kwargs[u'firewall_rule_back_refs']
        except KeyError:
            pass
        try:
            obj.data_center_interconnect_back_refs = kwargs[u'data_center_interconnect_back_refs']
        except KeyError:
            pass
        try:
            obj.fabric_back_refs = kwargs[u'fabric_back_refs']
        except KeyError:
            pass
        try:
            obj.host_based_service_back_refs = kwargs[u'host_based_service_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.VirtualNetwork.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.VirtualNetwork.ecmp_hashing_include_fields.setter
    def ecmp_hashing_include_fields(self, ecmp_hashing_include_fields):
        """Set ecmp-hashing-include-fields for virtual-network.
        
        :param ecmp_hashing_include_fields: EcmpHashingIncludeFields object
        
        """
        if 'ecmp_hashing_include_fields' not in self._pending_field_updates:
            self._pending_field_updates.add('ecmp_hashing_include_fields')

        self._ecmp_hashing_include_fields = ecmp_hashing_include_fields
    # end ecmp_hashing_include_fields

    def set_ecmp_hashing_include_fields(self, value):
        self.ecmp_hashing_include_fields = value
    # end set_ecmp_hashing_include_fields

    @vnc_api.gen.resource_common.VirtualNetwork.virtual_network_category.setter
    def virtual_network_category(self, virtual_network_category):
        """Set virtual-network-category for virtual-network.
        
        :param virtual_network_category: VirtualNetworkCategory object
        
        """
        if 'virtual_network_category' not in self._pending_field_updates:
            self._pending_field_updates.add('virtual_network_category')

        self._virtual_network_category = virtual_network_category
    # end virtual_network_category

    def set_virtual_network_category(self, value):
        self.virtual_network_category = value
    # end set_virtual_network_category

    @vnc_api.gen.resource_common.VirtualNetwork.virtual_network_properties.setter
    def virtual_network_properties(self, virtual_network_properties):
        """Set virtual-network-properties for virtual-network.
        
        :param virtual_network_properties: VirtualNetworkType object
        
        """
        if 'virtual_network_properties' not in self._pending_field_updates:
            self._pending_field_updates.add('virtual_network_properties')

        self._virtual_network_properties = virtual_network_properties
    # end virtual_network_properties

    def set_virtual_network_properties(self, value):
        self.virtual_network_properties = value
    # end set_virtual_network_properties

    @vnc_api.gen.resource_common.VirtualNetwork.virtual_network_routed_properties.setter
    def virtual_network_routed_properties(self, virtual_network_routed_properties):
        """Set virtual-network-routed-properties for virtual-network.
        
        :param virtual_network_routed_properties: VirtualNetworkRoutedPropertiesType object
        
        """
        if 'virtual_network_routed_properties' not in self._pending_field_updates:
            self._pending_field_updates.add('virtual_network_routed_properties')

        self._virtual_network_routed_properties = virtual_network_routed_properties
    # end virtual_network_routed_properties

    def set_virtual_network_routed_properties(self, value):
        self.virtual_network_routed_properties = value
    # end set_virtual_network_routed_properties

    @vnc_api.gen.resource_common.VirtualNetwork.provider_properties.setter
    def provider_properties(self, provider_properties):
        """Set provider-properties for virtual-network.
        
        :param provider_properties: ProviderDetails object
        
        """
        if 'provider_properties' not in self._pending_field_updates:
            self._pending_field_updates.add('provider_properties')

        self._provider_properties = provider_properties
    # end provider_properties

    def set_provider_properties(self, value):
        self.provider_properties = value
    # end set_provider_properties

    @vnc_api.gen.resource_common.VirtualNetwork.virtual_network_network_id.setter
    def virtual_network_network_id(self, virtual_network_network_id):
        """Set virtual-network-network-id for virtual-network.
        
        :param virtual_network_network_id: xsd:integer object
        
        """
        if 'virtual_network_network_id' not in self._pending_field_updates:
            self._pending_field_updates.add('virtual_network_network_id')

        self._virtual_network_network_id = virtual_network_network_id
    # end virtual_network_network_id

    def set_virtual_network_network_id(self, value):
        self.virtual_network_network_id = value
    # end set_virtual_network_network_id

    @vnc_api.gen.resource_common.VirtualNetwork.is_provider_network.setter
    def is_provider_network(self, is_provider_network):
        """Set is-provider-network for virtual-network.
        
        :param is_provider_network: xsd:boolean object
        
        """
        if 'is_provider_network' not in self._pending_field_updates:
            self._pending_field_updates.add('is_provider_network')

        self._is_provider_network = is_provider_network
    # end is_provider_network

    def set_is_provider_network(self, value):
        self.is_provider_network = value
    # end set_is_provider_network

    @vnc_api.gen.resource_common.VirtualNetwork.port_security_enabled.setter
    def port_security_enabled(self, port_security_enabled):
        """Set port-security-enabled for virtual-network.
        
        :param port_security_enabled: xsd:boolean object
        
        """
        if 'port_security_enabled' not in self._pending_field_updates:
            self._pending_field_updates.add('port_security_enabled')

        self._port_security_enabled = port_security_enabled
    # end port_security_enabled

    def set_port_security_enabled(self, value):
        self.port_security_enabled = value
    # end set_port_security_enabled

    @vnc_api.gen.resource_common.VirtualNetwork.fabric_snat.setter
    def fabric_snat(self, fabric_snat):
        """Set fabric-snat for virtual-network.
        
        :param fabric_snat: xsd:boolean object
        
        """
        if 'fabric_snat' not in self._pending_field_updates:
            self._pending_field_updates.add('fabric_snat')

        self._fabric_snat = fabric_snat
    # end fabric_snat

    def set_fabric_snat(self, value):
        self.fabric_snat = value
    # end set_fabric_snat

    @vnc_api.gen.resource_common.VirtualNetwork.route_target_list.setter
    def route_target_list(self, route_target_list):
        """Set route-target-list for virtual-network.
        
        :param route_target_list: RouteTargetList object
        
        """
        if 'route_target_list' not in self._pending_field_updates:
            self._pending_field_updates.add('route_target_list')

        self._route_target_list = route_target_list
    # end route_target_list

    def set_route_target_list(self, value):
        self.route_target_list = value
    # end set_route_target_list

    @vnc_api.gen.resource_common.VirtualNetwork.import_route_target_list.setter
    def import_route_target_list(self, import_route_target_list):
        """Set import-route-target-list for virtual-network.
        
        :param import_route_target_list: RouteTargetList object
        
        """
        if 'import_route_target_list' not in self._pending_field_updates:
            self._pending_field_updates.add('import_route_target_list')

        self._import_route_target_list = import_route_target_list
    # end import_route_target_list

    def set_import_route_target_list(self, value):
        self.import_route_target_list = value
    # end set_import_route_target_list

    @vnc_api.gen.resource_common.VirtualNetwork.export_route_target_list.setter
    def export_route_target_list(self, export_route_target_list):
        """Set export-route-target-list for virtual-network.
        
        :param export_route_target_list: RouteTargetList object
        
        """
        if 'export_route_target_list' not in self._pending_field_updates:
            self._pending_field_updates.add('export_route_target_list')

        self._export_route_target_list = export_route_target_list
    # end export_route_target_list

    def set_export_route_target_list(self, value):
        self.export_route_target_list = value
    # end set_export_route_target_list

    @vnc_api.gen.resource_common.VirtualNetwork.router_external.setter
    def router_external(self, router_external):
        """Set router-external for virtual-network.
        
        :param router_external: xsd:boolean object
        
        """
        if 'router_external' not in self._pending_field_updates:
            self._pending_field_updates.add('router_external')

        self._router_external = router_external
    # end router_external

    def set_router_external(self, value):
        self.router_external = value
    # end set_router_external

    @vnc_api.gen.resource_common.VirtualNetwork.is_shared.setter
    def is_shared(self, is_shared):
        """Set is-shared for virtual-network.
        
        :param is_shared: xsd:boolean object
        
        """
        if 'is_shared' not in self._pending_field_updates:
            self._pending_field_updates.add('is_shared')

        self._is_shared = is_shared
    # end is_shared

    def set_is_shared(self, value):
        self.is_shared = value
    # end set_is_shared

    @vnc_api.gen.resource_common.VirtualNetwork.external_ipam.setter
    def external_ipam(self, external_ipam):
        """Set external-ipam for virtual-network.
        
        :param external_ipam: xsd:boolean object
        
        """
        if 'external_ipam' not in self._pending_field_updates:
            self._pending_field_updates.add('external_ipam')

        self._external_ipam = external_ipam
    # end external_ipam

    def set_external_ipam(self, value):
        self.external_ipam = value
    # end set_external_ipam

    @vnc_api.gen.resource_common.VirtualNetwork.flood_unknown_unicast.setter
    def flood_unknown_unicast(self, flood_unknown_unicast):
        """Set flood-unknown-unicast for virtual-network.
        
        :param flood_unknown_unicast: xsd:boolean object
        
        """
        if 'flood_unknown_unicast' not in self._pending_field_updates:
            self._pending_field_updates.add('flood_unknown_unicast')

        self._flood_unknown_unicast = flood_unknown_unicast
    # end flood_unknown_unicast

    def set_flood_unknown_unicast(self, value):
        self.flood_unknown_unicast = value
    # end set_flood_unknown_unicast

    @vnc_api.gen.resource_common.VirtualNetwork.multi_policy_service_chains_enabled.setter
    def multi_policy_service_chains_enabled(self, multi_policy_service_chains_enabled):
        """Set multi-policy-service-chains-enabled for virtual-network.
        
        :param multi_policy_service_chains_enabled: xsd:boolean object
        
        """
        if 'multi_policy_service_chains_enabled' not in self._pending_field_updates:
            self._pending_field_updates.add('multi_policy_service_chains_enabled')

        self._multi_policy_service_chains_enabled = multi_policy_service_chains_enabled
    # end multi_policy_service_chains_enabled

    def set_multi_policy_service_chains_enabled(self, value):
        self.multi_policy_service_chains_enabled = value
    # end set_multi_policy_service_chains_enabled

    @vnc_api.gen.resource_common.VirtualNetwork.address_allocation_mode.setter
    def address_allocation_mode(self, address_allocation_mode):
        """Set address-allocation-mode for virtual-network.
        
        :param address_allocation_mode: AddressAllocationModeType object
        
        """
        if 'address_allocation_mode' not in self._pending_field_updates:
            self._pending_field_updates.add('address_allocation_mode')

        self._address_allocation_mode = address_allocation_mode
    # end address_allocation_mode

    def set_address_allocation_mode(self, value):
        self.address_allocation_mode = value
    # end set_address_allocation_mode

    @vnc_api.gen.resource_common.VirtualNetwork.virtual_network_fat_flow_protocols.setter
    def virtual_network_fat_flow_protocols(self, virtual_network_fat_flow_protocols):
        """Set virtual-network-fat-flow-protocols for virtual-network.
        
        :param virtual_network_fat_flow_protocols: FatFlowProtocols object
        
        """
        if 'virtual_network_fat_flow_protocols' not in self._pending_field_updates:
            self._pending_field_updates.add('virtual_network_fat_flow_protocols')

        if 'virtual_network_fat_flow_protocols' in self._pending_field_list_updates:
            # set clobbers earlier add/del on prop list elements
            del self._pending_field_list_updates['virtual_network_fat_flow_protocols']

        self._virtual_network_fat_flow_protocols = virtual_network_fat_flow_protocols
    # end virtual_network_fat_flow_protocols

    def set_virtual_network_fat_flow_protocols(self, value):
        self.virtual_network_fat_flow_protocols = value
    # end set_virtual_network_fat_flow_protocols

    @vnc_api.gen.resource_common.VirtualNetwork.mac_learning_enabled.setter
    def mac_learning_enabled(self, mac_learning_enabled):
        """Set mac-learning-enabled for virtual-network.
        
        :param mac_learning_enabled: xsd:boolean object
        
        """
        if 'mac_learning_enabled' not in self._pending_field_updates:
            self._pending_field_updates.add('mac_learning_enabled')

        self._mac_learning_enabled = mac_learning_enabled
    # end mac_learning_enabled

    def set_mac_learning_enabled(self, value):
        self.mac_learning_enabled = value
    # end set_mac_learning_enabled

    @vnc_api.gen.resource_common.VirtualNetwork.mac_limit_control.setter
    def mac_limit_control(self, mac_limit_control):
        """Set mac-limit-control for virtual-network.
        
        :param mac_limit_control: MACLimitControlType object
        
        """
        if 'mac_limit_control' not in self._pending_field_updates:
            self._pending_field_updates.add('mac_limit_control')

        self._mac_limit_control = mac_limit_control
    # end mac_limit_control

    def set_mac_limit_control(self, value):
        self.mac_limit_control = value
    # end set_mac_limit_control

    @vnc_api.gen.resource_common.VirtualNetwork.mac_move_control.setter
    def mac_move_control(self, mac_move_control):
        """Set mac-move-control for virtual-network.
        
        :param mac_move_control: MACMoveLimitControlType object
        
        """
        if 'mac_move_control' not in self._pending_field_updates:
            self._pending_field_updates.add('mac_move_control')

        self._mac_move_control = mac_move_control
    # end mac_move_control

    def set_mac_move_control(self, value):
        self.mac_move_control = value
    # end set_mac_move_control

    @vnc_api.gen.resource_common.VirtualNetwork.mac_aging_time.setter
    def mac_aging_time(self, mac_aging_time):
        """Set mac-aging-time for virtual-network.
        
        :param mac_aging_time: MACAgingTime object
        
        """
        if 'mac_aging_time' not in self._pending_field_updates:
            self._pending_field_updates.add('mac_aging_time')

        self._mac_aging_time = mac_aging_time
    # end mac_aging_time

    def set_mac_aging_time(self, value):
        self.mac_aging_time = value
    # end set_mac_aging_time

    @vnc_api.gen.resource_common.VirtualNetwork.pbb_evpn_enable.setter
    def pbb_evpn_enable(self, pbb_evpn_enable):
        """Set pbb-evpn-enable for virtual-network.
        
        :param pbb_evpn_enable: xsd:boolean object
        
        """
        if 'pbb_evpn_enable' not in self._pending_field_updates:
            self._pending_field_updates.add('pbb_evpn_enable')

        self._pbb_evpn_enable = pbb_evpn_enable
    # end pbb_evpn_enable

    def set_pbb_evpn_enable(self, value):
        self.pbb_evpn_enable = value
    # end set_pbb_evpn_enable

    @vnc_api.gen.resource_common.VirtualNetwork.pbb_etree_enable.setter
    def pbb_etree_enable(self, pbb_etree_enable):
        """Set pbb-etree-enable for virtual-network.
        
        :param pbb_etree_enable: xsd:boolean object
        
        """
        if 'pbb_etree_enable' not in self._pending_field_updates:
            self._pending_field_updates.add('pbb_etree_enable')

        self._pbb_etree_enable = pbb_etree_enable
    # end pbb_etree_enable

    def set_pbb_etree_enable(self, value):
        self.pbb_etree_enable = value
    # end set_pbb_etree_enable

    @vnc_api.gen.resource_common.VirtualNetwork.layer2_control_word.setter
    def layer2_control_word(self, layer2_control_word):
        """Set layer2-control-word for virtual-network.
        
        :param layer2_control_word: xsd:boolean object
        
        """
        if 'layer2_control_word' not in self._pending_field_updates:
            self._pending_field_updates.add('layer2_control_word')

        self._layer2_control_word = layer2_control_word
    # end layer2_control_word

    def set_layer2_control_word(self, value):
        self.layer2_control_word = value
    # end set_layer2_control_word

    @vnc_api.gen.resource_common.VirtualNetwork.igmp_enable.setter
    def igmp_enable(self, igmp_enable):
        """Set igmp-enable for virtual-network.
        
        :param igmp_enable: xsd:boolean object
        
        """
        if 'igmp_enable' not in self._pending_field_updates:
            self._pending_field_updates.add('igmp_enable')

        self._igmp_enable = igmp_enable
    # end igmp_enable

    def set_igmp_enable(self, value):
        self.igmp_enable = value
    # end set_igmp_enable

    @vnc_api.gen.resource_common.VirtualNetwork.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for virtual-network.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.VirtualNetwork.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for virtual-network.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.VirtualNetwork.annotations.setter
    def annotations(self, annotations):
        """Set annotations for virtual-network.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.VirtualNetwork.display_name.setter
    def display_name(self, display_name):
        """Set display-name for virtual-network.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_virtual_network_fat_flow_protocols(self, elem_value, elem_position=None):
        """Add element to virtual-network-fat-flow-protocols for virtual-network.
        
        :param elem_value: xsd:string object
        :param elem_position: optional string order-key
        
        """
        if 'virtual_network_fat_flow_protocols' not in self._pending_field_list_updates:
            self._pending_field_list_updates['virtual_network_fat_flow_protocols'] = [
                ('add', elem_value, elem_position)]
        else:
            self._pending_field_list_updates['virtual_network_fat_flow_protocols'].append(
                ('add', elem_value, elem_position))
    # end add_virtual_network_fat_flow_protocols

    def del_virtual_network_fat_flow_protocols(self, elem_position):
        """Delete element from virtual-network-fat-flow-protocols for virtual-network.
        
        :param elem_position: string indicating order-key
        
        """
        if 'virtual_network_fat_flow_protocols' not in self._pending_field_list_updates:
            self._pending_field_list_updates['virtual_network_fat_flow_protocols'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_list_updates['virtual_network_fat_flow_protocols'].append(
                ('delete', None, elem_position))
    # end del_virtual_network_fat_flow_protocols
    def add_annotations(self, elem):
        """Add element to annotations for virtual-network.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for virtual-network.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_security_logging_object(self, *args, **kwargs):
        """Set security-logging-object for virtual-network.
        
        :param ref_obj: SecurityLoggingObject object
        
        """
        self._pending_field_updates.add('security_logging_object_refs')
        self._pending_ref_updates.discard('security_logging_object_refs')
        super(VirtualNetwork, self).set_security_logging_object(*args, **kwargs)

    # end set_security_logging_object

    def add_security_logging_object(self, *args, **kwargs):
        """Add security-logging-object to virtual-network.
        
        :param ref_obj: SecurityLoggingObject object
        
        """
        if 'security_logging_object_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('security_logging_object_refs')
            self._original_security_logging_object_refs = copy.deepcopy(self.get_security_logging_object_refs() or [])
        super(VirtualNetwork, self).add_security_logging_object(*args, **kwargs)
    # end add_security_logging_object

    def del_security_logging_object(self, *args, **kwargs):
        if 'security_logging_object_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('security_logging_object_refs')
            self._original_security_logging_object_refs = copy.deepcopy(self.get_security_logging_object_refs() or [])
        super(VirtualNetwork, self).del_security_logging_object(*args, **kwargs)
    # end del_security_logging_object

    def set_security_logging_object_list(self, *args, **kwargs):
        """Set security-logging-object list for virtual-network.
        
        :param ref_obj_list: list of SecurityLoggingObject object
        
        """
        self._pending_field_updates.add('security_logging_object_refs')
        self._pending_ref_updates.discard('security_logging_object_refs')
        super(VirtualNetwork, self).set_security_logging_object_list(*args, **kwargs)
    # end set_security_logging_object_list

    def set_qos_config(self, *args, **kwargs):
        """Set qos-config for virtual-network.
        
        :param ref_obj: QosConfig object
        
        """
        self._pending_field_updates.add('qos_config_refs')
        self._pending_ref_updates.discard('qos_config_refs')
        super(VirtualNetwork, self).set_qos_config(*args, **kwargs)

    # end set_qos_config

    def add_qos_config(self, *args, **kwargs):
        """Add qos-config to virtual-network.
        
        :param ref_obj: QosConfig object
        
        """
        if 'qos_config_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('qos_config_refs')
            self._original_qos_config_refs = copy.deepcopy(self.get_qos_config_refs() or [])
        super(VirtualNetwork, self).add_qos_config(*args, **kwargs)
    # end add_qos_config

    def del_qos_config(self, *args, **kwargs):
        if 'qos_config_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('qos_config_refs')
            self._original_qos_config_refs = copy.deepcopy(self.get_qos_config_refs() or [])
        super(VirtualNetwork, self).del_qos_config(*args, **kwargs)
    # end del_qos_config

    def set_qos_config_list(self, *args, **kwargs):
        """Set qos-config list for virtual-network.
        
        :param ref_obj_list: list of QosConfig object
        
        """
        self._pending_field_updates.add('qos_config_refs')
        self._pending_ref_updates.discard('qos_config_refs')
        super(VirtualNetwork, self).set_qos_config_list(*args, **kwargs)
    # end set_qos_config_list

    def set_network_ipam(self, *args, **kwargs):
        """Set network-ipam for virtual-network.
        
        :param ref_obj: NetworkIpam object
        :param ref_data: VnSubnetsType object
        
        """
        self._pending_field_updates.add('network_ipam_refs')
        self._pending_ref_updates.discard('network_ipam_refs')
        super(VirtualNetwork, self).set_network_ipam(*args, **kwargs)

    # end set_network_ipam

    def add_network_ipam(self, *args, **kwargs):
        """Add network-ipam to virtual-network.
        
        :param ref_obj: NetworkIpam object
        :param ref_data: VnSubnetsType object
        
        """
        if 'network_ipam_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('network_ipam_refs')
            self._original_network_ipam_refs = copy.deepcopy(self.get_network_ipam_refs() or [])
        super(VirtualNetwork, self).add_network_ipam(*args, **kwargs)
    # end add_network_ipam

    def del_network_ipam(self, *args, **kwargs):
        if 'network_ipam_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('network_ipam_refs')
            self._original_network_ipam_refs = copy.deepcopy(self.get_network_ipam_refs() or [])
        super(VirtualNetwork, self).del_network_ipam(*args, **kwargs)
    # end del_network_ipam

    def set_network_ipam_list(self, *args, **kwargs):
        """Set network-ipam list for virtual-network.
        
        :param ref_obj_list: list of NetworkIpam object
        :param ref_data_list: list of VnSubnetsType summary
        
        """
        self._pending_field_updates.add('network_ipam_refs')
        self._pending_ref_updates.discard('network_ipam_refs')
        super(VirtualNetwork, self).set_network_ipam_list(*args, **kwargs)
    # end set_network_ipam_list

    def set_network_policy(self, *args, **kwargs):
        """Set network-policy for virtual-network.
        
        :param ref_obj: NetworkPolicy object
        :param ref_data: VirtualNetworkPolicyType object
        
        """
        self._pending_field_updates.add('network_policy_refs')
        self._pending_ref_updates.discard('network_policy_refs')
        super(VirtualNetwork, self).set_network_policy(*args, **kwargs)

    # end set_network_policy

    def add_network_policy(self, *args, **kwargs):
        """Add network-policy to virtual-network.
        
        :param ref_obj: NetworkPolicy object
        :param ref_data: VirtualNetworkPolicyType object
        
        """
        if 'network_policy_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('network_policy_refs')
            self._original_network_policy_refs = copy.deepcopy(self.get_network_policy_refs() or [])
        super(VirtualNetwork, self).add_network_policy(*args, **kwargs)
    # end add_network_policy

    def del_network_policy(self, *args, **kwargs):
        if 'network_policy_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('network_policy_refs')
            self._original_network_policy_refs = copy.deepcopy(self.get_network_policy_refs() or [])
        super(VirtualNetwork, self).del_network_policy(*args, **kwargs)
    # end del_network_policy

    def set_network_policy_list(self, *args, **kwargs):
        """Set network-policy list for virtual-network.
        
        :param ref_obj_list: list of NetworkPolicy object
        :param ref_data_list: list of VirtualNetworkPolicyType summary
        
        """
        self._pending_field_updates.add('network_policy_refs')
        self._pending_ref_updates.discard('network_policy_refs')
        super(VirtualNetwork, self).set_network_policy_list(*args, **kwargs)
    # end set_network_policy_list

    def set_virtual_network(self, *args, **kwargs):
        """Set virtual-network for virtual-network.
        
        :param ref_obj: VirtualNetwork object
        
        """
        self._pending_field_updates.add('virtual_network_refs')
        self._pending_ref_updates.discard('virtual_network_refs')
        super(VirtualNetwork, self).set_virtual_network(*args, **kwargs)

    # end set_virtual_network

    def add_virtual_network(self, *args, **kwargs):
        """Add virtual-network to virtual-network.
        
        :param ref_obj: VirtualNetwork object
        
        """
        if 'virtual_network_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('virtual_network_refs')
            self._original_virtual_network_refs = copy.deepcopy(self.get_virtual_network_refs() or [])
        super(VirtualNetwork, self).add_virtual_network(*args, **kwargs)
    # end add_virtual_network

    def del_virtual_network(self, *args, **kwargs):
        if 'virtual_network_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('virtual_network_refs')
            self._original_virtual_network_refs = copy.deepcopy(self.get_virtual_network_refs() or [])
        super(VirtualNetwork, self).del_virtual_network(*args, **kwargs)
    # end del_virtual_network

    def set_virtual_network_list(self, *args, **kwargs):
        """Set virtual-network list for virtual-network.
        
        :param ref_obj_list: list of VirtualNetwork object
        
        """
        self._pending_field_updates.add('virtual_network_refs')
        self._pending_ref_updates.discard('virtual_network_refs')
        super(VirtualNetwork, self).set_virtual_network_list(*args, **kwargs)
    # end set_virtual_network_list

    def set_route_table(self, *args, **kwargs):
        """Set route-table for virtual-network.
        
        :param ref_obj: RouteTable object
        
        """
        self._pending_field_updates.add('route_table_refs')
        self._pending_ref_updates.discard('route_table_refs')
        super(VirtualNetwork, self).set_route_table(*args, **kwargs)

    # end set_route_table

    def add_route_table(self, *args, **kwargs):
        """Add route-table to virtual-network.
        
        :param ref_obj: RouteTable object
        
        """
        if 'route_table_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('route_table_refs')
            self._original_route_table_refs = copy.deepcopy(self.get_route_table_refs() or [])
        super(VirtualNetwork, self).add_route_table(*args, **kwargs)
    # end add_route_table

    def del_route_table(self, *args, **kwargs):
        if 'route_table_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('route_table_refs')
            self._original_route_table_refs = copy.deepcopy(self.get_route_table_refs() or [])
        super(VirtualNetwork, self).del_route_table(*args, **kwargs)
    # end del_route_table

    def set_route_table_list(self, *args, **kwargs):
        """Set route-table list for virtual-network.
        
        :param ref_obj_list: list of RouteTable object
        
        """
        self._pending_field_updates.add('route_table_refs')
        self._pending_ref_updates.discard('route_table_refs')
        super(VirtualNetwork, self).set_route_table_list(*args, **kwargs)
    # end set_route_table_list

    def set_multicast_policy(self, *args, **kwargs):
        """Set multicast-policy for virtual-network.
        
        :param ref_obj: MulticastPolicy object
        
        """
        self._pending_field_updates.add('multicast_policy_refs')
        self._pending_ref_updates.discard('multicast_policy_refs')
        super(VirtualNetwork, self).set_multicast_policy(*args, **kwargs)

    # end set_multicast_policy

    def add_multicast_policy(self, *args, **kwargs):
        """Add multicast-policy to virtual-network.
        
        :param ref_obj: MulticastPolicy object
        
        """
        if 'multicast_policy_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('multicast_policy_refs')
            self._original_multicast_policy_refs = copy.deepcopy(self.get_multicast_policy_refs() or [])
        super(VirtualNetwork, self).add_multicast_policy(*args, **kwargs)
    # end add_multicast_policy

    def del_multicast_policy(self, *args, **kwargs):
        if 'multicast_policy_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('multicast_policy_refs')
            self._original_multicast_policy_refs = copy.deepcopy(self.get_multicast_policy_refs() or [])
        super(VirtualNetwork, self).del_multicast_policy(*args, **kwargs)
    # end del_multicast_policy

    def set_multicast_policy_list(self, *args, **kwargs):
        """Set multicast-policy list for virtual-network.
        
        :param ref_obj_list: list of MulticastPolicy object
        
        """
        self._pending_field_updates.add('multicast_policy_refs')
        self._pending_ref_updates.discard('multicast_policy_refs')
        super(VirtualNetwork, self).set_multicast_policy_list(*args, **kwargs)
    # end set_multicast_policy_list

    def set_bgpvpn(self, *args, **kwargs):
        """Set bgpvpn for virtual-network.
        
        :param ref_obj: Bgpvpn object
        
        """
        self._pending_field_updates.add('bgpvpn_refs')
        self._pending_ref_updates.discard('bgpvpn_refs')
        super(VirtualNetwork, self).set_bgpvpn(*args, **kwargs)

    # end set_bgpvpn

    def add_bgpvpn(self, *args, **kwargs):
        """Add bgpvpn to virtual-network.
        
        :param ref_obj: Bgpvpn object
        
        """
        if 'bgpvpn_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('bgpvpn_refs')
            self._original_bgpvpn_refs = copy.deepcopy(self.get_bgpvpn_refs() or [])
        super(VirtualNetwork, self).add_bgpvpn(*args, **kwargs)
    # end add_bgpvpn

    def del_bgpvpn(self, *args, **kwargs):
        if 'bgpvpn_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('bgpvpn_refs')
            self._original_bgpvpn_refs = copy.deepcopy(self.get_bgpvpn_refs() or [])
        super(VirtualNetwork, self).del_bgpvpn(*args, **kwargs)
    # end del_bgpvpn

    def set_bgpvpn_list(self, *args, **kwargs):
        """Set bgpvpn list for virtual-network.
        
        :param ref_obj_list: list of Bgpvpn object
        
        """
        self._pending_field_updates.add('bgpvpn_refs')
        self._pending_ref_updates.discard('bgpvpn_refs')
        super(VirtualNetwork, self).set_bgpvpn_list(*args, **kwargs)
    # end set_bgpvpn_list

    def set_intent_map(self, *args, **kwargs):
        """Set intent-map for virtual-network.
        
        :param ref_obj: IntentMap object
        
        """
        self._pending_field_updates.add('intent_map_refs')
        self._pending_ref_updates.discard('intent_map_refs')
        super(VirtualNetwork, self).set_intent_map(*args, **kwargs)

    # end set_intent_map

    def add_intent_map(self, *args, **kwargs):
        """Add intent-map to virtual-network.
        
        :param ref_obj: IntentMap object
        
        """
        if 'intent_map_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('intent_map_refs')
            self._original_intent_map_refs = copy.deepcopy(self.get_intent_map_refs() or [])
        super(VirtualNetwork, self).add_intent_map(*args, **kwargs)
    # end add_intent_map

    def del_intent_map(self, *args, **kwargs):
        if 'intent_map_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('intent_map_refs')
            self._original_intent_map_refs = copy.deepcopy(self.get_intent_map_refs() or [])
        super(VirtualNetwork, self).del_intent_map(*args, **kwargs)
    # end del_intent_map

    def set_intent_map_list(self, *args, **kwargs):
        """Set intent-map list for virtual-network.
        
        :param ref_obj_list: list of IntentMap object
        
        """
        self._pending_field_updates.add('intent_map_refs')
        self._pending_ref_updates.discard('intent_map_refs')
        super(VirtualNetwork, self).set_intent_map_list(*args, **kwargs)
    # end set_intent_map_list

    def set_routing_policy(self, *args, **kwargs):
        """Set routing-policy for virtual-network.
        
        :param ref_obj: RoutingPolicy object
        :param ref_data: RoutingPolicyType object
        
        """
        self._pending_field_updates.add('routing_policy_refs')
        self._pending_ref_updates.discard('routing_policy_refs')
        super(VirtualNetwork, self).set_routing_policy(*args, **kwargs)

    # end set_routing_policy

    def add_routing_policy(self, *args, **kwargs):
        """Add routing-policy to virtual-network.
        
        :param ref_obj: RoutingPolicy object
        :param ref_data: RoutingPolicyType object
        
        """
        if 'routing_policy_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('routing_policy_refs')
            self._original_routing_policy_refs = copy.deepcopy(self.get_routing_policy_refs() or [])
        super(VirtualNetwork, self).add_routing_policy(*args, **kwargs)
    # end add_routing_policy

    def del_routing_policy(self, *args, **kwargs):
        if 'routing_policy_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('routing_policy_refs')
            self._original_routing_policy_refs = copy.deepcopy(self.get_routing_policy_refs() or [])
        super(VirtualNetwork, self).del_routing_policy(*args, **kwargs)
    # end del_routing_policy

    def set_routing_policy_list(self, *args, **kwargs):
        """Set routing-policy list for virtual-network.
        
        :param ref_obj_list: list of RoutingPolicy object
        :param ref_data_list: list of RoutingPolicyType summary
        
        """
        self._pending_field_updates.add('routing_policy_refs')
        self._pending_ref_updates.discard('routing_policy_refs')
        super(VirtualNetwork, self).set_routing_policy_list(*args, **kwargs)
    # end set_routing_policy_list

    def set_tag(self, *args, **kwargs):
        """Set tag for virtual-network.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(VirtualNetwork, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to virtual-network.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(VirtualNetwork, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(VirtualNetwork, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for virtual-network.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(VirtualNetwork, self).set_tag_list(*args, **kwargs)
    # end set_tag_list

    def get_access_control_lists(self):
        if hasattr(self, 'access_control_lists'):
            return self.access_control_lists

        if hasattr(super(VirtualNetwork, self), 'access_control_lists'):
            return super(VirtualNetwork, self).get_access_control_lists()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.virtual_network_read(id = self.uuid, fields = ['access_control_lists'])
        except NoIdError:
            return None
        children = getattr(obj, 'access_control_lists', None)
        if not children:
            return None
        self.access_control_lists = children

        return children
    # end get_access_control_lists

    def get_floating_ip_pools(self):
        if hasattr(self, 'floating_ip_pools'):
            return self.floating_ip_pools

        if hasattr(super(VirtualNetwork, self), 'floating_ip_pools'):
            return super(VirtualNetwork, self).get_floating_ip_pools()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.virtual_network_read(id = self.uuid, fields = ['floating_ip_pools'])
        except NoIdError:
            return None
        children = getattr(obj, 'floating_ip_pools', None)
        if not children:
            return None
        self.floating_ip_pools = children

        return children
    # end get_floating_ip_pools

    def get_alias_ip_pools(self):
        if hasattr(self, 'alias_ip_pools'):
            return self.alias_ip_pools

        if hasattr(super(VirtualNetwork, self), 'alias_ip_pools'):
            return super(VirtualNetwork, self).get_alias_ip_pools()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.virtual_network_read(id = self.uuid, fields = ['alias_ip_pools'])
        except NoIdError:
            return None
        children = getattr(obj, 'alias_ip_pools', None)
        if not children:
            return None
        self.alias_ip_pools = children

        return children
    # end get_alias_ip_pools

    def get_routing_instances(self):
        if hasattr(self, 'routing_instances'):
            return self.routing_instances

        if hasattr(super(VirtualNetwork, self), 'routing_instances'):
            return super(VirtualNetwork, self).get_routing_instances()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.virtual_network_read(id = self.uuid, fields = ['routing_instances'])
        except NoIdError:
            return None
        children = getattr(obj, 'routing_instances', None)
        if not children:
            return None
        self.routing_instances = children

        return children
    # end get_routing_instances

    def get_bridge_domains(self):
        if hasattr(self, 'bridge_domains'):
            return self.bridge_domains

        if hasattr(super(VirtualNetwork, self), 'bridge_domains'):
            return super(VirtualNetwork, self).get_bridge_domains()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.virtual_network_read(id = self.uuid, fields = ['bridge_domains'])
        except NoIdError:
            return None
        children = getattr(obj, 'bridge_domains', None)
        if not children:
            return None
        self.bridge_domains = children

        return children
    # end get_bridge_domains


    def get_virtual_network_back_refs(self):
        """Return list of all virtual-networks using this virtual-network"""
        if hasattr(self, 'virtual_network_back_refs'):
            return self.virtual_network_back_refs

        if hasattr(super(VirtualNetwork, self), 'virtual_network_back_refs'):
            return super(VirtualNetwork, self).get_virtual_network_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.virtual_network_read(id = self.uuid, fields = ['virtual_network_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'virtual_network_back_refs', None)
        if not back_refs:
            return None
        self.virtual_network_back_refs = back_refs

        return back_refs
    # end get_virtual_network_back_refs

    def get_virtual_machine_interface_back_refs(self):
        """Return list of all virtual-machine-interfaces using this virtual-network"""
        if hasattr(self, 'virtual_machine_interface_back_refs'):
            return self.virtual_machine_interface_back_refs

        if hasattr(super(VirtualNetwork, self), 'virtual_machine_interface_back_refs'):
            return super(VirtualNetwork, self).get_virtual_machine_interface_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.virtual_network_read(id = self.uuid, fields = ['virtual_machine_interface_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'virtual_machine_interface_back_refs', None)
        if not back_refs:
            return None
        self.virtual_machine_interface_back_refs = back_refs

        return back_refs
    # end get_virtual_machine_interface_back_refs

    def get_instance_ip_back_refs(self):
        """Return list of all instance-ips using this virtual-network"""
        if hasattr(self, 'instance_ip_back_refs'):
            return self.instance_ip_back_refs

        if hasattr(super(VirtualNetwork, self), 'instance_ip_back_refs'):
            return super(VirtualNetwork, self).get_instance_ip_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.virtual_network_read(id = self.uuid, fields = ['instance_ip_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'instance_ip_back_refs', None)
        if not back_refs:
            return None
        self.instance_ip_back_refs = back_refs

        return back_refs
    # end get_instance_ip_back_refs

    def get_physical_router_back_refs(self):
        """Return list of all physical-routers using this virtual-network"""
        if hasattr(self, 'physical_router_back_refs'):
            return self.physical_router_back_refs

        if hasattr(super(VirtualNetwork, self), 'physical_router_back_refs'):
            return super(VirtualNetwork, self).get_physical_router_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.virtual_network_read(id = self.uuid, fields = ['physical_router_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'physical_router_back_refs', None)
        if not back_refs:
            return None
        self.physical_router_back_refs = back_refs

        return back_refs
    # end get_physical_router_back_refs

    def get_port_tuple_back_refs(self):
        """Return list of all port-tuples using this virtual-network"""
        if hasattr(self, 'port_tuple_back_refs'):
            return self.port_tuple_back_refs

        if hasattr(super(VirtualNetwork, self), 'port_tuple_back_refs'):
            return super(VirtualNetwork, self).get_port_tuple_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.virtual_network_read(id = self.uuid, fields = ['port_tuple_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'port_tuple_back_refs', None)
        if not back_refs:
            return None
        self.port_tuple_back_refs = back_refs

        return back_refs
    # end get_port_tuple_back_refs

    def get_logical_router_back_refs(self):
        """Return list of all logical-routers using this virtual-network"""
        if hasattr(self, 'logical_router_back_refs'):
            return self.logical_router_back_refs

        if hasattr(super(VirtualNetwork, self), 'logical_router_back_refs'):
            return super(VirtualNetwork, self).get_logical_router_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.virtual_network_read(id = self.uuid, fields = ['logical_router_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'logical_router_back_refs', None)
        if not back_refs:
            return None
        self.logical_router_back_refs = back_refs

        return back_refs
    # end get_logical_router_back_refs

    def get_flow_node_back_refs(self):
        """Return list of all flow-nodes using this virtual-network"""
        if hasattr(self, 'flow_node_back_refs'):
            return self.flow_node_back_refs

        if hasattr(super(VirtualNetwork, self), 'flow_node_back_refs'):
            return super(VirtualNetwork, self).get_flow_node_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.virtual_network_read(id = self.uuid, fields = ['flow_node_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'flow_node_back_refs', None)
        if not back_refs:
            return None
        self.flow_node_back_refs = back_refs

        return back_refs
    # end get_flow_node_back_refs

    def get_firewall_rule_back_refs(self):
        """Return list of all firewall-rules using this virtual-network"""
        if hasattr(self, 'firewall_rule_back_refs'):
            return self.firewall_rule_back_refs

        if hasattr(super(VirtualNetwork, self), 'firewall_rule_back_refs'):
            return super(VirtualNetwork, self).get_firewall_rule_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.virtual_network_read(id = self.uuid, fields = ['firewall_rule_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'firewall_rule_back_refs', None)
        if not back_refs:
            return None
        self.firewall_rule_back_refs = back_refs

        return back_refs
    # end get_firewall_rule_back_refs

    def get_data_center_interconnect_back_refs(self):
        """Return list of all data-center-interconnects using this virtual-network"""
        if hasattr(self, 'data_center_interconnect_back_refs'):
            return self.data_center_interconnect_back_refs

        if hasattr(super(VirtualNetwork, self), 'data_center_interconnect_back_refs'):
            return super(VirtualNetwork, self).get_data_center_interconnect_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.virtual_network_read(id = self.uuid, fields = ['data_center_interconnect_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'data_center_interconnect_back_refs', None)
        if not back_refs:
            return None
        self.data_center_interconnect_back_refs = back_refs

        return back_refs
    # end get_data_center_interconnect_back_refs

    def get_fabric_back_refs(self):
        """Return list of all fabrics using this virtual-network"""
        if hasattr(self, 'fabric_back_refs'):
            return self.fabric_back_refs

        if hasattr(super(VirtualNetwork, self), 'fabric_back_refs'):
            return super(VirtualNetwork, self).get_fabric_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.virtual_network_read(id = self.uuid, fields = ['fabric_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'fabric_back_refs', None)
        if not back_refs:
            return None
        self.fabric_back_refs = back_refs

        return back_refs
    # end get_fabric_back_refs

    def get_host_based_service_back_refs(self):
        """Return list of all host-based-services using this virtual-network"""
        if hasattr(self, 'host_based_service_back_refs'):
            return self.host_based_service_back_refs

        if hasattr(super(VirtualNetwork, self), 'host_based_service_back_refs'):
            return super(VirtualNetwork, self).get_host_based_service_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.virtual_network_read(id = self.uuid, fields = ['host_based_service_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'host_based_service_back_refs', None)
        if not back_refs:
            return None
        self.host_based_service_back_refs = back_refs

        return back_refs
    # end get_host_based_service_back_refs

# end class VirtualNetwork

class VirtualPortGroup(vnc_api.gen.resource_common.VirtualPortGroup):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'virtual_port_group_lacp_enabled' in kwargs:
            pending_fields.append('virtual_port_group_lacp_enabled')
        if len(args) > 1 or 'virtual_port_group_trunk_port_id' in kwargs:
            pending_fields.append('virtual_port_group_trunk_port_id')
        if len(args) > 2 or 'virtual_port_group_user_created' in kwargs:
            pending_fields.append('virtual_port_group_user_created')
        if len(args) > 3 or 'virtual_port_group_type' in kwargs:
            pending_fields.append('virtual_port_group_type')
        if len(args) > 4 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 5 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 6 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 7 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(VirtualPortGroup, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            props_dict['virtual_port_group_lacp_enabled'] = kwargs[u'virtual_port_group_lacp_enabled']
        except KeyError:
            pass

        try:
            props_dict['virtual_port_group_trunk_port_id'] = kwargs[u'virtual_port_group_trunk_port_id']
        except KeyError:
            pass

        try:
            props_dict['virtual_port_group_user_created'] = kwargs[u'virtual_port_group_user_created']
        except KeyError:
            pass

        try:
            props_dict['virtual_port_group_type'] = kwargs[u'virtual_port_group_type']
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = VirtualPortGroup(**props_dict)
        else:
            obj = VirtualPortGroup(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.physical_interface_refs = kwargs[u'physical_interface_refs']
            for ref in obj.physical_interface_refs:
                ref['attr'] = vnc_api.gen.resource_xsd.VpgInterfaceParametersType(params_dict=ref[u'attr'])
        except KeyError:
            pass
        try:
            obj.virtual_machine_interface_refs = kwargs[u'virtual_machine_interface_refs']
        except KeyError:
            pass
        try:
            obj.security_group_refs = kwargs[u'security_group_refs']
        except KeyError:
            pass
        try:
            obj.port_profile_refs = kwargs[u'port_profile_refs']
        except KeyError:
            pass
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.VirtualPortGroup.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.VirtualPortGroup.virtual_port_group_lacp_enabled.setter
    def virtual_port_group_lacp_enabled(self, virtual_port_group_lacp_enabled):
        """Set virtual-port-group-lacp-enabled for virtual-port-group.
        
        :param virtual_port_group_lacp_enabled: xsd:boolean object
        
        """
        if 'virtual_port_group_lacp_enabled' not in self._pending_field_updates:
            self._pending_field_updates.add('virtual_port_group_lacp_enabled')

        self._virtual_port_group_lacp_enabled = virtual_port_group_lacp_enabled
    # end virtual_port_group_lacp_enabled

    def set_virtual_port_group_lacp_enabled(self, value):
        self.virtual_port_group_lacp_enabled = value
    # end set_virtual_port_group_lacp_enabled

    @vnc_api.gen.resource_common.VirtualPortGroup.virtual_port_group_trunk_port_id.setter
    def virtual_port_group_trunk_port_id(self, virtual_port_group_trunk_port_id):
        """Set virtual-port-group-trunk-port-id for virtual-port-group.
        
        :param virtual_port_group_trunk_port_id: xsd:string object
        
        """
        if 'virtual_port_group_trunk_port_id' not in self._pending_field_updates:
            self._pending_field_updates.add('virtual_port_group_trunk_port_id')

        self._virtual_port_group_trunk_port_id = virtual_port_group_trunk_port_id
    # end virtual_port_group_trunk_port_id

    def set_virtual_port_group_trunk_port_id(self, value):
        self.virtual_port_group_trunk_port_id = value
    # end set_virtual_port_group_trunk_port_id

    @vnc_api.gen.resource_common.VirtualPortGroup.virtual_port_group_user_created.setter
    def virtual_port_group_user_created(self, virtual_port_group_user_created):
        """Set virtual-port-group-user-created for virtual-port-group.
        
        :param virtual_port_group_user_created: xsd:boolean object
        
        """
        if 'virtual_port_group_user_created' not in self._pending_field_updates:
            self._pending_field_updates.add('virtual_port_group_user_created')

        self._virtual_port_group_user_created = virtual_port_group_user_created
    # end virtual_port_group_user_created

    def set_virtual_port_group_user_created(self, value):
        self.virtual_port_group_user_created = value
    # end set_virtual_port_group_user_created

    @vnc_api.gen.resource_common.VirtualPortGroup.virtual_port_group_type.setter
    def virtual_port_group_type(self, virtual_port_group_type):
        """Set virtual-port-group-type for virtual-port-group.
        
        :param virtual_port_group_type: VpgType object
        
        """
        if 'virtual_port_group_type' not in self._pending_field_updates:
            self._pending_field_updates.add('virtual_port_group_type')

        self._virtual_port_group_type = virtual_port_group_type
    # end virtual_port_group_type

    def set_virtual_port_group_type(self, value):
        self.virtual_port_group_type = value
    # end set_virtual_port_group_type

    @vnc_api.gen.resource_common.VirtualPortGroup.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for virtual-port-group.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.VirtualPortGroup.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for virtual-port-group.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.VirtualPortGroup.annotations.setter
    def annotations(self, annotations):
        """Set annotations for virtual-port-group.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.VirtualPortGroup.display_name.setter
    def display_name(self, display_name):
        """Set display-name for virtual-port-group.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for virtual-port-group.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for virtual-port-group.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_physical_interface(self, *args, **kwargs):
        """Set physical-interface for virtual-port-group.
        
        :param ref_obj: PhysicalInterface object
        :param ref_data: VpgInterfaceParametersType object
        
        """
        self._pending_field_updates.add('physical_interface_refs')
        self._pending_ref_updates.discard('physical_interface_refs')
        super(VirtualPortGroup, self).set_physical_interface(*args, **kwargs)

    # end set_physical_interface

    def add_physical_interface(self, *args, **kwargs):
        """Add physical-interface to virtual-port-group.
        
        :param ref_obj: PhysicalInterface object
        :param ref_data: VpgInterfaceParametersType object
        
        """
        if 'physical_interface_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('physical_interface_refs')
            self._original_physical_interface_refs = copy.deepcopy(self.get_physical_interface_refs() or [])
        super(VirtualPortGroup, self).add_physical_interface(*args, **kwargs)
    # end add_physical_interface

    def del_physical_interface(self, *args, **kwargs):
        if 'physical_interface_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('physical_interface_refs')
            self._original_physical_interface_refs = copy.deepcopy(self.get_physical_interface_refs() or [])
        super(VirtualPortGroup, self).del_physical_interface(*args, **kwargs)
    # end del_physical_interface

    def set_physical_interface_list(self, *args, **kwargs):
        """Set physical-interface list for virtual-port-group.
        
        :param ref_obj_list: list of PhysicalInterface object
        :param ref_data_list: list of VpgInterfaceParametersType summary
        
        """
        self._pending_field_updates.add('physical_interface_refs')
        self._pending_ref_updates.discard('physical_interface_refs')
        super(VirtualPortGroup, self).set_physical_interface_list(*args, **kwargs)
    # end set_physical_interface_list

    def set_virtual_machine_interface(self, *args, **kwargs):
        """Set virtual-machine-interface for virtual-port-group.
        
        :param ref_obj: VirtualMachineInterface object
        
        """
        self._pending_field_updates.add('virtual_machine_interface_refs')
        self._pending_ref_updates.discard('virtual_machine_interface_refs')
        super(VirtualPortGroup, self).set_virtual_machine_interface(*args, **kwargs)

    # end set_virtual_machine_interface

    def add_virtual_machine_interface(self, *args, **kwargs):
        """Add virtual-machine-interface to virtual-port-group.
        
        :param ref_obj: VirtualMachineInterface object
        
        """
        if 'virtual_machine_interface_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('virtual_machine_interface_refs')
            self._original_virtual_machine_interface_refs = copy.deepcopy(self.get_virtual_machine_interface_refs() or [])
        super(VirtualPortGroup, self).add_virtual_machine_interface(*args, **kwargs)
    # end add_virtual_machine_interface

    def del_virtual_machine_interface(self, *args, **kwargs):
        if 'virtual_machine_interface_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('virtual_machine_interface_refs')
            self._original_virtual_machine_interface_refs = copy.deepcopy(self.get_virtual_machine_interface_refs() or [])
        super(VirtualPortGroup, self).del_virtual_machine_interface(*args, **kwargs)
    # end del_virtual_machine_interface

    def set_virtual_machine_interface_list(self, *args, **kwargs):
        """Set virtual-machine-interface list for virtual-port-group.
        
        :param ref_obj_list: list of VirtualMachineInterface object
        
        """
        self._pending_field_updates.add('virtual_machine_interface_refs')
        self._pending_ref_updates.discard('virtual_machine_interface_refs')
        super(VirtualPortGroup, self).set_virtual_machine_interface_list(*args, **kwargs)
    # end set_virtual_machine_interface_list

    def set_security_group(self, *args, **kwargs):
        """Set security-group for virtual-port-group.
        
        :param ref_obj: SecurityGroup object
        
        """
        self._pending_field_updates.add('security_group_refs')
        self._pending_ref_updates.discard('security_group_refs')
        super(VirtualPortGroup, self).set_security_group(*args, **kwargs)

    # end set_security_group

    def add_security_group(self, *args, **kwargs):
        """Add security-group to virtual-port-group.
        
        :param ref_obj: SecurityGroup object
        
        """
        if 'security_group_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('security_group_refs')
            self._original_security_group_refs = copy.deepcopy(self.get_security_group_refs() or [])
        super(VirtualPortGroup, self).add_security_group(*args, **kwargs)
    # end add_security_group

    def del_security_group(self, *args, **kwargs):
        if 'security_group_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('security_group_refs')
            self._original_security_group_refs = copy.deepcopy(self.get_security_group_refs() or [])
        super(VirtualPortGroup, self).del_security_group(*args, **kwargs)
    # end del_security_group

    def set_security_group_list(self, *args, **kwargs):
        """Set security-group list for virtual-port-group.
        
        :param ref_obj_list: list of SecurityGroup object
        
        """
        self._pending_field_updates.add('security_group_refs')
        self._pending_ref_updates.discard('security_group_refs')
        super(VirtualPortGroup, self).set_security_group_list(*args, **kwargs)
    # end set_security_group_list

    def set_port_profile(self, *args, **kwargs):
        """Set port-profile for virtual-port-group.
        
        :param ref_obj: PortProfile object
        
        """
        self._pending_field_updates.add('port_profile_refs')
        self._pending_ref_updates.discard('port_profile_refs')
        super(VirtualPortGroup, self).set_port_profile(*args, **kwargs)

    # end set_port_profile

    def add_port_profile(self, *args, **kwargs):
        """Add port-profile to virtual-port-group.
        
        :param ref_obj: PortProfile object
        
        """
        if 'port_profile_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('port_profile_refs')
            self._original_port_profile_refs = copy.deepcopy(self.get_port_profile_refs() or [])
        super(VirtualPortGroup, self).add_port_profile(*args, **kwargs)
    # end add_port_profile

    def del_port_profile(self, *args, **kwargs):
        if 'port_profile_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('port_profile_refs')
            self._original_port_profile_refs = copy.deepcopy(self.get_port_profile_refs() or [])
        super(VirtualPortGroup, self).del_port_profile(*args, **kwargs)
    # end del_port_profile

    def set_port_profile_list(self, *args, **kwargs):
        """Set port-profile list for virtual-port-group.
        
        :param ref_obj_list: list of PortProfile object
        
        """
        self._pending_field_updates.add('port_profile_refs')
        self._pending_ref_updates.discard('port_profile_refs')
        super(VirtualPortGroup, self).set_port_profile_list(*args, **kwargs)
    # end set_port_profile_list

    def set_tag(self, *args, **kwargs):
        """Set tag for virtual-port-group.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(VirtualPortGroup, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to virtual-port-group.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(VirtualPortGroup, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(VirtualPortGroup, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for virtual-port-group.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(VirtualPortGroup, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


# end class VirtualPortGroup

class ServiceAppliance(vnc_api.gen.resource_common.ServiceAppliance):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'service_appliance_user_credentials' in kwargs:
            pending_fields.append('service_appliance_user_credentials')
        if len(args) > 1 or 'service_appliance_ip_address' in kwargs:
            pending_fields.append('service_appliance_ip_address')
        if len(args) > 2 or 'service_appliance_virtualization_type' in kwargs:
            pending_fields.append('service_appliance_virtualization_type')
        if len(args) > 3 or 'service_appliance_properties' in kwargs:
            pending_fields.append('service_appliance_properties')
        if len(args) > 4 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 5 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 6 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 7 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(ServiceAppliance, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            if kwargs['service_appliance_user_credentials'] is None:
                props_dict['service_appliance_user_credentials'] = None
            else:
                props_dict['service_appliance_user_credentials'] = vnc_api.gen.resource_xsd.UserCredentials(params_dict=kwargs[u'service_appliance_user_credentials'])
        except KeyError:
            pass

        try:
            props_dict['service_appliance_ip_address'] = kwargs[u'service_appliance_ip_address']
        except KeyError:
            pass

        try:
            props_dict['service_appliance_virtualization_type'] = kwargs[u'service_appliance_virtualization_type']
        except KeyError:
            pass

        try:
            if kwargs['service_appliance_properties'] is None:
                props_dict['service_appliance_properties'] = None
            else:
                props_dict['service_appliance_properties'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'service_appliance_properties'])
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = ServiceAppliance(**props_dict)
        else:
            obj = ServiceAppliance(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.physical_interface_refs = kwargs[u'physical_interface_refs']
            for ref in obj.physical_interface_refs:
                ref['attr'] = vnc_api.gen.resource_xsd.ServiceApplianceInterfaceType(params_dict=ref[u'attr'])
        except KeyError:
            pass
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.ServiceAppliance.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.ServiceAppliance.service_appliance_user_credentials.setter
    def service_appliance_user_credentials(self, service_appliance_user_credentials):
        """Set service-appliance-user-credentials for service-appliance.
        
        :param service_appliance_user_credentials: UserCredentials object
        
        """
        if 'service_appliance_user_credentials' not in self._pending_field_updates:
            self._pending_field_updates.add('service_appliance_user_credentials')

        self._service_appliance_user_credentials = service_appliance_user_credentials
    # end service_appliance_user_credentials

    def set_service_appliance_user_credentials(self, value):
        self.service_appliance_user_credentials = value
    # end set_service_appliance_user_credentials

    @vnc_api.gen.resource_common.ServiceAppliance.service_appliance_ip_address.setter
    def service_appliance_ip_address(self, service_appliance_ip_address):
        """Set service-appliance-ip-address for service-appliance.
        
        :param service_appliance_ip_address: IpAddressType object
        
        """
        if 'service_appliance_ip_address' not in self._pending_field_updates:
            self._pending_field_updates.add('service_appliance_ip_address')

        self._service_appliance_ip_address = service_appliance_ip_address
    # end service_appliance_ip_address

    def set_service_appliance_ip_address(self, value):
        self.service_appliance_ip_address = value
    # end set_service_appliance_ip_address

    @vnc_api.gen.resource_common.ServiceAppliance.service_appliance_virtualization_type.setter
    def service_appliance_virtualization_type(self, service_appliance_virtualization_type):
        """Set service-appliance-virtualization-type for service-appliance.
        
        :param service_appliance_virtualization_type: ServiceVirtualizationType object
        
        """
        if 'service_appliance_virtualization_type' not in self._pending_field_updates:
            self._pending_field_updates.add('service_appliance_virtualization_type')

        self._service_appliance_virtualization_type = service_appliance_virtualization_type
    # end service_appliance_virtualization_type

    def set_service_appliance_virtualization_type(self, value):
        self.service_appliance_virtualization_type = value
    # end set_service_appliance_virtualization_type

    @vnc_api.gen.resource_common.ServiceAppliance.service_appliance_properties.setter
    def service_appliance_properties(self, service_appliance_properties):
        """Set service-appliance-properties for service-appliance.
        
        :param service_appliance_properties: KeyValuePairs object
        
        """
        if 'service_appliance_properties' not in self._pending_field_updates:
            self._pending_field_updates.add('service_appliance_properties')

        self._service_appliance_properties = service_appliance_properties
    # end service_appliance_properties

    def set_service_appliance_properties(self, value):
        self.service_appliance_properties = value
    # end set_service_appliance_properties

    @vnc_api.gen.resource_common.ServiceAppliance.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for service-appliance.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.ServiceAppliance.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for service-appliance.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.ServiceAppliance.annotations.setter
    def annotations(self, annotations):
        """Set annotations for service-appliance.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.ServiceAppliance.display_name.setter
    def display_name(self, display_name):
        """Set display-name for service-appliance.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for service-appliance.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for service-appliance.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_physical_interface(self, *args, **kwargs):
        """Set physical-interface for service-appliance.
        
        :param ref_obj: PhysicalInterface object
        :param ref_data: ServiceApplianceInterfaceType object
        
        """
        self._pending_field_updates.add('physical_interface_refs')
        self._pending_ref_updates.discard('physical_interface_refs')
        super(ServiceAppliance, self).set_physical_interface(*args, **kwargs)

    # end set_physical_interface

    def add_physical_interface(self, *args, **kwargs):
        """Add physical-interface to service-appliance.
        
        :param ref_obj: PhysicalInterface object
        :param ref_data: ServiceApplianceInterfaceType object
        
        """
        if 'physical_interface_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('physical_interface_refs')
            self._original_physical_interface_refs = copy.deepcopy(self.get_physical_interface_refs() or [])
        super(ServiceAppliance, self).add_physical_interface(*args, **kwargs)
    # end add_physical_interface

    def del_physical_interface(self, *args, **kwargs):
        if 'physical_interface_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('physical_interface_refs')
            self._original_physical_interface_refs = copy.deepcopy(self.get_physical_interface_refs() or [])
        super(ServiceAppliance, self).del_physical_interface(*args, **kwargs)
    # end del_physical_interface

    def set_physical_interface_list(self, *args, **kwargs):
        """Set physical-interface list for service-appliance.
        
        :param ref_obj_list: list of PhysicalInterface object
        :param ref_data_list: list of ServiceApplianceInterfaceType summary
        
        """
        self._pending_field_updates.add('physical_interface_refs')
        self._pending_ref_updates.discard('physical_interface_refs')
        super(ServiceAppliance, self).set_physical_interface_list(*args, **kwargs)
    # end set_physical_interface_list

    def set_tag(self, *args, **kwargs):
        """Set tag for service-appliance.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(ServiceAppliance, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to service-appliance.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(ServiceAppliance, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(ServiceAppliance, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for service-appliance.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(ServiceAppliance, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


# end class ServiceAppliance

class Namespace(vnc_api.gen.resource_common.Namespace):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'namespace_cidr' in kwargs:
            pending_fields.append('namespace_cidr')
        if len(args) > 1 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 2 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 3 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 4 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(Namespace, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            if kwargs['namespace_cidr'] is None:
                props_dict['namespace_cidr'] = None
            else:
                props_dict['namespace_cidr'] = vnc_api.gen.resource_xsd.SubnetType(params_dict=kwargs[u'namespace_cidr'])
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = Namespace(**props_dict)
        else:
            obj = Namespace(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.project_back_refs = kwargs[u'project_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.Namespace.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.Namespace.namespace_cidr.setter
    def namespace_cidr(self, namespace_cidr):
        """Set namespace-cidr for namespace.
        
        :param namespace_cidr: SubnetType object
        
        """
        if 'namespace_cidr' not in self._pending_field_updates:
            self._pending_field_updates.add('namespace_cidr')

        self._namespace_cidr = namespace_cidr
    # end namespace_cidr

    def set_namespace_cidr(self, value):
        self.namespace_cidr = value
    # end set_namespace_cidr

    @vnc_api.gen.resource_common.Namespace.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for namespace.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.Namespace.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for namespace.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.Namespace.annotations.setter
    def annotations(self, annotations):
        """Set annotations for namespace.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.Namespace.display_name.setter
    def display_name(self, display_name):
        """Set display-name for namespace.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for namespace.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for namespace.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_tag(self, *args, **kwargs):
        """Set tag for namespace.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(Namespace, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to namespace.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(Namespace, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(Namespace, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for namespace.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(Namespace, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


    def get_project_back_refs(self):
        """Return list of all projects using this namespace"""
        if hasattr(self, 'project_back_refs'):
            return self.project_back_refs

        if hasattr(super(Namespace, self), 'project_back_refs'):
            return super(Namespace, self).get_project_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.namespace_read(id = self.uuid, fields = ['project_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'project_back_refs', None)
        if not back_refs:
            return None
        self.project_back_refs = back_refs

        return back_refs
    # end get_project_back_refs

# end class Namespace

class Feature(vnc_api.gen.resource_common.Feature):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 1 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 2 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 3 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(Feature, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = Feature(**props_dict)
        else:
            obj = Feature(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.feature_refs = kwargs[u'feature_refs']
        except KeyError:
            pass
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.feature_back_refs = kwargs[u'feature_back_refs']
        except KeyError:
            pass
        try:
            obj.role_definition_back_refs = kwargs[u'role_definition_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.Feature.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.Feature.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for feature.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.Feature.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for feature.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.Feature.annotations.setter
    def annotations(self, annotations):
        """Set annotations for feature.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.Feature.display_name.setter
    def display_name(self, display_name):
        """Set display-name for feature.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for feature.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for feature.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_feature(self, *args, **kwargs):
        """Set feature for feature.
        
        :param ref_obj: Feature object
        
        """
        self._pending_field_updates.add('feature_refs')
        self._pending_ref_updates.discard('feature_refs')
        super(Feature, self).set_feature(*args, **kwargs)

    # end set_feature

    def add_feature(self, *args, **kwargs):
        """Add feature to feature.
        
        :param ref_obj: Feature object
        
        """
        if 'feature_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('feature_refs')
            self._original_feature_refs = copy.deepcopy(self.get_feature_refs() or [])
        super(Feature, self).add_feature(*args, **kwargs)
    # end add_feature

    def del_feature(self, *args, **kwargs):
        if 'feature_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('feature_refs')
            self._original_feature_refs = copy.deepcopy(self.get_feature_refs() or [])
        super(Feature, self).del_feature(*args, **kwargs)
    # end del_feature

    def set_feature_list(self, *args, **kwargs):
        """Set feature list for feature.
        
        :param ref_obj_list: list of Feature object
        
        """
        self._pending_field_updates.add('feature_refs')
        self._pending_ref_updates.discard('feature_refs')
        super(Feature, self).set_feature_list(*args, **kwargs)
    # end set_feature_list

    def set_tag(self, *args, **kwargs):
        """Set tag for feature.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(Feature, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to feature.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(Feature, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(Feature, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for feature.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(Feature, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


    def get_feature_back_refs(self):
        """Return list of all features using this feature"""
        if hasattr(self, 'feature_back_refs'):
            return self.feature_back_refs

        if hasattr(super(Feature, self), 'feature_back_refs'):
            return super(Feature, self).get_feature_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.feature_read(id = self.uuid, fields = ['feature_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'feature_back_refs', None)
        if not back_refs:
            return None
        self.feature_back_refs = back_refs

        return back_refs
    # end get_feature_back_refs

    def get_role_definition_back_refs(self):
        """Return list of all role-definitions using this feature"""
        if hasattr(self, 'role_definition_back_refs'):
            return self.role_definition_back_refs

        if hasattr(super(Feature, self), 'role_definition_back_refs'):
            return super(Feature, self).get_role_definition_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.feature_read(id = self.uuid, fields = ['role_definition_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'role_definition_back_refs', None)
        if not back_refs:
            return None
        self.role_definition_back_refs = back_refs

        return back_refs
    # end get_role_definition_back_refs

# end class Feature

class StormControlProfile(vnc_api.gen.resource_common.StormControlProfile):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'storm_control_parameters' in kwargs:
            pending_fields.append('storm_control_parameters')
        if len(args) > 1 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 2 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 3 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 4 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(StormControlProfile, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            if kwargs['storm_control_parameters'] is None:
                props_dict['storm_control_parameters'] = None
            else:
                props_dict['storm_control_parameters'] = vnc_api.gen.resource_xsd.StormControlParameters(params_dict=kwargs[u'storm_control_parameters'])
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = StormControlProfile(**props_dict)
        else:
            obj = StormControlProfile(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.port_profile_back_refs = kwargs[u'port_profile_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.StormControlProfile.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.StormControlProfile.storm_control_parameters.setter
    def storm_control_parameters(self, storm_control_parameters):
        """Set storm-control-parameters for storm-control-profile.
        
        :param storm_control_parameters: StormControlParameters object
        
        """
        if 'storm_control_parameters' not in self._pending_field_updates:
            self._pending_field_updates.add('storm_control_parameters')

        self._storm_control_parameters = storm_control_parameters
    # end storm_control_parameters

    def set_storm_control_parameters(self, value):
        self.storm_control_parameters = value
    # end set_storm_control_parameters

    @vnc_api.gen.resource_common.StormControlProfile.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for storm-control-profile.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.StormControlProfile.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for storm-control-profile.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.StormControlProfile.annotations.setter
    def annotations(self, annotations):
        """Set annotations for storm-control-profile.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.StormControlProfile.display_name.setter
    def display_name(self, display_name):
        """Set display-name for storm-control-profile.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for storm-control-profile.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for storm-control-profile.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_tag(self, *args, **kwargs):
        """Set tag for storm-control-profile.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(StormControlProfile, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to storm-control-profile.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(StormControlProfile, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(StormControlProfile, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for storm-control-profile.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(StormControlProfile, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


    def get_port_profile_back_refs(self):
        """Return list of all port-profiles using this storm-control-profile"""
        if hasattr(self, 'port_profile_back_refs'):
            return self.port_profile_back_refs

        if hasattr(super(StormControlProfile, self), 'port_profile_back_refs'):
            return super(StormControlProfile, self).get_port_profile_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.storm_control_profile_read(id = self.uuid, fields = ['port_profile_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'port_profile_back_refs', None)
        if not back_refs:
            return None
        self.port_profile_back_refs = back_refs

        return back_refs
    # end get_port_profile_back_refs

# end class StormControlProfile

class DeviceImage(vnc_api.gen.resource_common.DeviceImage):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'device_image_vendor_name' in kwargs:
            pending_fields.append('device_image_vendor_name')
        if len(args) > 1 or 'device_image_device_family' in kwargs:
            pending_fields.append('device_image_device_family')
        if len(args) > 2 or 'device_image_supported_platforms' in kwargs:
            pending_fields.append('device_image_supported_platforms')
        if len(args) > 3 or 'device_image_os_version' in kwargs:
            pending_fields.append('device_image_os_version')
        if len(args) > 4 or 'device_image_file_uri' in kwargs:
            pending_fields.append('device_image_file_uri')
        if len(args) > 5 or 'device_image_size' in kwargs:
            pending_fields.append('device_image_size')
        if len(args) > 6 or 'device_image_md5' in kwargs:
            pending_fields.append('device_image_md5')
        if len(args) > 7 or 'device_image_sha1' in kwargs:
            pending_fields.append('device_image_sha1')
        if len(args) > 8 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 9 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 10 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 11 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(DeviceImage, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            props_dict['device_image_vendor_name'] = kwargs[u'device_image_vendor_name']
        except KeyError:
            pass

        try:
            props_dict['device_image_device_family'] = kwargs[u'device_image_device_family']
        except KeyError:
            pass

        try:
            if kwargs['device_image_supported_platforms'] is None:
                props_dict['device_image_supported_platforms'] = None
            else:
                props_dict['device_image_supported_platforms'] = vnc_api.gen.resource_xsd.DevicePlatformListType(params_dict=kwargs[u'device_image_supported_platforms'])
        except KeyError:
            pass

        try:
            props_dict['device_image_os_version'] = kwargs[u'device_image_os_version']
        except KeyError:
            pass

        try:
            props_dict['device_image_file_uri'] = kwargs[u'device_image_file_uri']
        except KeyError:
            pass

        try:
            props_dict['device_image_size'] = kwargs[u'device_image_size']
        except KeyError:
            pass

        try:
            props_dict['device_image_md5'] = kwargs[u'device_image_md5']
        except KeyError:
            pass

        try:
            props_dict['device_image_sha1'] = kwargs[u'device_image_sha1']
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = DeviceImage(**props_dict)
        else:
            obj = DeviceImage(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.hardware_refs = kwargs[u'hardware_refs']
        except KeyError:
            pass
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.physical_router_back_refs = kwargs[u'physical_router_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.DeviceImage.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.DeviceImage.device_image_vendor_name.setter
    def device_image_vendor_name(self, device_image_vendor_name):
        """Set device-image-vendor-name for device-image.
        
        :param device_image_vendor_name: xsd:string object
        
        """
        if 'device_image_vendor_name' not in self._pending_field_updates:
            self._pending_field_updates.add('device_image_vendor_name')

        self._device_image_vendor_name = device_image_vendor_name
    # end device_image_vendor_name

    def set_device_image_vendor_name(self, value):
        self.device_image_vendor_name = value
    # end set_device_image_vendor_name

    @vnc_api.gen.resource_common.DeviceImage.device_image_device_family.setter
    def device_image_device_family(self, device_image_device_family):
        """Set device-image-device-family for device-image.
        
        :param device_image_device_family: xsd:string object
        
        """
        if 'device_image_device_family' not in self._pending_field_updates:
            self._pending_field_updates.add('device_image_device_family')

        self._device_image_device_family = device_image_device_family
    # end device_image_device_family

    def set_device_image_device_family(self, value):
        self.device_image_device_family = value
    # end set_device_image_device_family

    @vnc_api.gen.resource_common.DeviceImage.device_image_supported_platforms.setter
    def device_image_supported_platforms(self, device_image_supported_platforms):
        """Set device-image-supported-platforms for device-image.
        
        :param device_image_supported_platforms: DevicePlatformListType object
        
        """
        if 'device_image_supported_platforms' not in self._pending_field_updates:
            self._pending_field_updates.add('device_image_supported_platforms')

        self._device_image_supported_platforms = device_image_supported_platforms
    # end device_image_supported_platforms

    def set_device_image_supported_platforms(self, value):
        self.device_image_supported_platforms = value
    # end set_device_image_supported_platforms

    @vnc_api.gen.resource_common.DeviceImage.device_image_os_version.setter
    def device_image_os_version(self, device_image_os_version):
        """Set device-image-os-version for device-image.
        
        :param device_image_os_version: xsd:string object
        
        """
        if 'device_image_os_version' not in self._pending_field_updates:
            self._pending_field_updates.add('device_image_os_version')

        self._device_image_os_version = device_image_os_version
    # end device_image_os_version

    def set_device_image_os_version(self, value):
        self.device_image_os_version = value
    # end set_device_image_os_version

    @vnc_api.gen.resource_common.DeviceImage.device_image_file_uri.setter
    def device_image_file_uri(self, device_image_file_uri):
        """Set device-image-file-uri for device-image.
        
        :param device_image_file_uri: xsd:string object
        
        """
        if 'device_image_file_uri' not in self._pending_field_updates:
            self._pending_field_updates.add('device_image_file_uri')

        self._device_image_file_uri = device_image_file_uri
    # end device_image_file_uri

    def set_device_image_file_uri(self, value):
        self.device_image_file_uri = value
    # end set_device_image_file_uri

    @vnc_api.gen.resource_common.DeviceImage.device_image_size.setter
    def device_image_size(self, device_image_size):
        """Set device-image-size for device-image.
        
        :param device_image_size: xsd:integer object
        
        """
        if 'device_image_size' not in self._pending_field_updates:
            self._pending_field_updates.add('device_image_size')

        self._device_image_size = device_image_size
    # end device_image_size

    def set_device_image_size(self, value):
        self.device_image_size = value
    # end set_device_image_size

    @vnc_api.gen.resource_common.DeviceImage.device_image_md5.setter
    def device_image_md5(self, device_image_md5):
        """Set device-image-md5 for device-image.
        
        :param device_image_md5: xsd:string object
        
        """
        if 'device_image_md5' not in self._pending_field_updates:
            self._pending_field_updates.add('device_image_md5')

        self._device_image_md5 = device_image_md5
    # end device_image_md5

    def set_device_image_md5(self, value):
        self.device_image_md5 = value
    # end set_device_image_md5

    @vnc_api.gen.resource_common.DeviceImage.device_image_sha1.setter
    def device_image_sha1(self, device_image_sha1):
        """Set device-image-sha1 for device-image.
        
        :param device_image_sha1: xsd:string object
        
        """
        if 'device_image_sha1' not in self._pending_field_updates:
            self._pending_field_updates.add('device_image_sha1')

        self._device_image_sha1 = device_image_sha1
    # end device_image_sha1

    def set_device_image_sha1(self, value):
        self.device_image_sha1 = value
    # end set_device_image_sha1

    @vnc_api.gen.resource_common.DeviceImage.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for device-image.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.DeviceImage.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for device-image.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.DeviceImage.annotations.setter
    def annotations(self, annotations):
        """Set annotations for device-image.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.DeviceImage.display_name.setter
    def display_name(self, display_name):
        """Set display-name for device-image.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for device-image.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for device-image.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_hardware(self, *args, **kwargs):
        """Set hardware for device-image.
        
        :param ref_obj: Hardware object
        
        """
        self._pending_field_updates.add('hardware_refs')
        self._pending_ref_updates.discard('hardware_refs')
        super(DeviceImage, self).set_hardware(*args, **kwargs)

    # end set_hardware

    def add_hardware(self, *args, **kwargs):
        """Add hardware to device-image.
        
        :param ref_obj: Hardware object
        
        """
        if 'hardware_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('hardware_refs')
            self._original_hardware_refs = copy.deepcopy(self.get_hardware_refs() or [])
        super(DeviceImage, self).add_hardware(*args, **kwargs)
    # end add_hardware

    def del_hardware(self, *args, **kwargs):
        if 'hardware_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('hardware_refs')
            self._original_hardware_refs = copy.deepcopy(self.get_hardware_refs() or [])
        super(DeviceImage, self).del_hardware(*args, **kwargs)
    # end del_hardware

    def set_hardware_list(self, *args, **kwargs):
        """Set hardware list for device-image.
        
        :param ref_obj_list: list of Hardware object
        
        """
        self._pending_field_updates.add('hardware_refs')
        self._pending_ref_updates.discard('hardware_refs')
        super(DeviceImage, self).set_hardware_list(*args, **kwargs)
    # end set_hardware_list

    def set_tag(self, *args, **kwargs):
        """Set tag for device-image.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(DeviceImage, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to device-image.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(DeviceImage, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(DeviceImage, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for device-image.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(DeviceImage, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


    def get_physical_router_back_refs(self):
        """Return list of all physical-routers using this device-image"""
        if hasattr(self, 'physical_router_back_refs'):
            return self.physical_router_back_refs

        if hasattr(super(DeviceImage, self), 'physical_router_back_refs'):
            return super(DeviceImage, self).get_physical_router_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.device_image_read(id = self.uuid, fields = ['physical_router_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'physical_router_back_refs', None)
        if not back_refs:
            return None
        self.physical_router_back_refs = back_refs

        return back_refs
    # end get_physical_router_back_refs

# end class DeviceImage

class PhysicalInterface(vnc_api.gen.resource_common.PhysicalInterface):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'ethernet_segment_identifier' in kwargs:
            pending_fields.append('ethernet_segment_identifier')
        if len(args) > 1 or 'physical_interface_type' in kwargs:
            pending_fields.append('physical_interface_type')
        if len(args) > 2 or 'physical_interface_mac_addresses' in kwargs:
            pending_fields.append('physical_interface_mac_addresses')
        if len(args) > 3 or 'physical_interface_port_id' in kwargs:
            pending_fields.append('physical_interface_port_id')
        if len(args) > 4 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 5 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 6 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 7 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(PhysicalInterface, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            props_dict['ethernet_segment_identifier'] = kwargs[u'ethernet_segment_identifier']
        except KeyError:
            pass

        try:
            props_dict['physical_interface_type'] = kwargs[u'physical_interface_type']
        except KeyError:
            pass

        try:
            if kwargs['physical_interface_mac_addresses'] is None:
                props_dict['physical_interface_mac_addresses'] = None
            else:
                props_dict['physical_interface_mac_addresses'] = vnc_api.gen.resource_xsd.MacAddressesType(params_dict=kwargs[u'physical_interface_mac_addresses'])
        except KeyError:
            pass

        try:
            props_dict['physical_interface_port_id'] = kwargs[u'physical_interface_port_id']
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = PhysicalInterface(**props_dict)
        else:
            obj = PhysicalInterface(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...
        try:
            obj.logical_interfaces = kwargs[u'logical_interfaces']
        except KeyError:
            pass

        # add any specified references...
        try:
            obj.physical_interface_refs = kwargs[u'physical_interface_refs']
        except KeyError:
            pass
        try:
            obj.port_refs = kwargs[u'port_refs']
        except KeyError:
            pass
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.service_appliance_back_refs = kwargs[u'service_appliance_back_refs']
        except KeyError:
            pass
        try:
            obj.virtual_machine_interface_back_refs = kwargs[u'virtual_machine_interface_back_refs']
        except KeyError:
            pass
        try:
            obj.physical_interface_back_refs = kwargs[u'physical_interface_back_refs']
        except KeyError:
            pass
        try:
            obj.link_aggregation_group_back_refs = kwargs[u'link_aggregation_group_back_refs']
        except KeyError:
            pass
        try:
            obj.virtual_port_group_back_refs = kwargs[u'virtual_port_group_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.PhysicalInterface.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.PhysicalInterface.ethernet_segment_identifier.setter
    def ethernet_segment_identifier(self, ethernet_segment_identifier):
        """Set ethernet-segment-identifier for physical-interface.
        
        :param ethernet_segment_identifier: xsd:string object
        
        """
        if 'ethernet_segment_identifier' not in self._pending_field_updates:
            self._pending_field_updates.add('ethernet_segment_identifier')

        self._ethernet_segment_identifier = ethernet_segment_identifier
    # end ethernet_segment_identifier

    def set_ethernet_segment_identifier(self, value):
        self.ethernet_segment_identifier = value
    # end set_ethernet_segment_identifier

    @vnc_api.gen.resource_common.PhysicalInterface.physical_interface_type.setter
    def physical_interface_type(self, physical_interface_type):
        """Set physical-interface-type for physical-interface.
        
        :param physical_interface_type: PhysicalInterfaceType object
        
        """
        if 'physical_interface_type' not in self._pending_field_updates:
            self._pending_field_updates.add('physical_interface_type')

        self._physical_interface_type = physical_interface_type
    # end physical_interface_type

    def set_physical_interface_type(self, value):
        self.physical_interface_type = value
    # end set_physical_interface_type

    @vnc_api.gen.resource_common.PhysicalInterface.physical_interface_mac_addresses.setter
    def physical_interface_mac_addresses(self, physical_interface_mac_addresses):
        """Set physical-interface-mac-addresses for physical-interface.
        
        :param physical_interface_mac_addresses: MacAddressesType object
        
        """
        if 'physical_interface_mac_addresses' not in self._pending_field_updates:
            self._pending_field_updates.add('physical_interface_mac_addresses')

        self._physical_interface_mac_addresses = physical_interface_mac_addresses
    # end physical_interface_mac_addresses

    def set_physical_interface_mac_addresses(self, value):
        self.physical_interface_mac_addresses = value
    # end set_physical_interface_mac_addresses

    @vnc_api.gen.resource_common.PhysicalInterface.physical_interface_port_id.setter
    def physical_interface_port_id(self, physical_interface_port_id):
        """Set physical-interface-port-id for physical-interface.
        
        :param physical_interface_port_id: xsd:string object
        
        """
        if 'physical_interface_port_id' not in self._pending_field_updates:
            self._pending_field_updates.add('physical_interface_port_id')

        self._physical_interface_port_id = physical_interface_port_id
    # end physical_interface_port_id

    def set_physical_interface_port_id(self, value):
        self.physical_interface_port_id = value
    # end set_physical_interface_port_id

    @vnc_api.gen.resource_common.PhysicalInterface.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for physical-interface.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.PhysicalInterface.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for physical-interface.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.PhysicalInterface.annotations.setter
    def annotations(self, annotations):
        """Set annotations for physical-interface.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.PhysicalInterface.display_name.setter
    def display_name(self, display_name):
        """Set display-name for physical-interface.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for physical-interface.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for physical-interface.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_physical_interface(self, *args, **kwargs):
        """Set physical-interface for physical-interface.
        
        :param ref_obj: PhysicalInterface object
        
        """
        self._pending_field_updates.add('physical_interface_refs')
        self._pending_ref_updates.discard('physical_interface_refs')
        super(PhysicalInterface, self).set_physical_interface(*args, **kwargs)

    # end set_physical_interface

    def add_physical_interface(self, *args, **kwargs):
        """Add physical-interface to physical-interface.
        
        :param ref_obj: PhysicalInterface object
        
        """
        if 'physical_interface_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('physical_interface_refs')
            self._original_physical_interface_refs = copy.deepcopy(self.get_physical_interface_refs() or [])
        super(PhysicalInterface, self).add_physical_interface(*args, **kwargs)
    # end add_physical_interface

    def del_physical_interface(self, *args, **kwargs):
        if 'physical_interface_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('physical_interface_refs')
            self._original_physical_interface_refs = copy.deepcopy(self.get_physical_interface_refs() or [])
        super(PhysicalInterface, self).del_physical_interface(*args, **kwargs)
    # end del_physical_interface

    def set_physical_interface_list(self, *args, **kwargs):
        """Set physical-interface list for physical-interface.
        
        :param ref_obj_list: list of PhysicalInterface object
        
        """
        self._pending_field_updates.add('physical_interface_refs')
        self._pending_ref_updates.discard('physical_interface_refs')
        super(PhysicalInterface, self).set_physical_interface_list(*args, **kwargs)
    # end set_physical_interface_list

    def set_port(self, *args, **kwargs):
        """Set port for physical-interface.
        
        :param ref_obj: Port object
        
        """
        self._pending_field_updates.add('port_refs')
        self._pending_ref_updates.discard('port_refs')
        super(PhysicalInterface, self).set_port(*args, **kwargs)

    # end set_port

    def add_port(self, *args, **kwargs):
        """Add port to physical-interface.
        
        :param ref_obj: Port object
        
        """
        if 'port_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('port_refs')
            self._original_port_refs = copy.deepcopy(self.get_port_refs() or [])
        super(PhysicalInterface, self).add_port(*args, **kwargs)
    # end add_port

    def del_port(self, *args, **kwargs):
        if 'port_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('port_refs')
            self._original_port_refs = copy.deepcopy(self.get_port_refs() or [])
        super(PhysicalInterface, self).del_port(*args, **kwargs)
    # end del_port

    def set_port_list(self, *args, **kwargs):
        """Set port list for physical-interface.
        
        :param ref_obj_list: list of Port object
        
        """
        self._pending_field_updates.add('port_refs')
        self._pending_ref_updates.discard('port_refs')
        super(PhysicalInterface, self).set_port_list(*args, **kwargs)
    # end set_port_list

    def set_tag(self, *args, **kwargs):
        """Set tag for physical-interface.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(PhysicalInterface, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to physical-interface.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(PhysicalInterface, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(PhysicalInterface, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for physical-interface.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(PhysicalInterface, self).set_tag_list(*args, **kwargs)
    # end set_tag_list

    def get_logical_interfaces(self):
        if hasattr(self, 'logical_interfaces'):
            return self.logical_interfaces

        if hasattr(super(PhysicalInterface, self), 'logical_interfaces'):
            return super(PhysicalInterface, self).get_logical_interfaces()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.physical_interface_read(id = self.uuid, fields = ['logical_interfaces'])
        except NoIdError:
            return None
        children = getattr(obj, 'logical_interfaces', None)
        if not children:
            return None
        self.logical_interfaces = children

        return children
    # end get_logical_interfaces


    def get_service_appliance_back_refs(self):
        """Return list of all service-appliances using this physical-interface"""
        if hasattr(self, 'service_appliance_back_refs'):
            return self.service_appliance_back_refs

        if hasattr(super(PhysicalInterface, self), 'service_appliance_back_refs'):
            return super(PhysicalInterface, self).get_service_appliance_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.physical_interface_read(id = self.uuid, fields = ['service_appliance_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'service_appliance_back_refs', None)
        if not back_refs:
            return None
        self.service_appliance_back_refs = back_refs

        return back_refs
    # end get_service_appliance_back_refs

    def get_virtual_machine_interface_back_refs(self):
        """Return list of all virtual-machine-interfaces using this physical-interface"""
        if hasattr(self, 'virtual_machine_interface_back_refs'):
            return self.virtual_machine_interface_back_refs

        if hasattr(super(PhysicalInterface, self), 'virtual_machine_interface_back_refs'):
            return super(PhysicalInterface, self).get_virtual_machine_interface_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.physical_interface_read(id = self.uuid, fields = ['virtual_machine_interface_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'virtual_machine_interface_back_refs', None)
        if not back_refs:
            return None
        self.virtual_machine_interface_back_refs = back_refs

        return back_refs
    # end get_virtual_machine_interface_back_refs

    def get_physical_interface_back_refs(self):
        """Return list of all physical-interfaces using this physical-interface"""
        if hasattr(self, 'physical_interface_back_refs'):
            return self.physical_interface_back_refs

        if hasattr(super(PhysicalInterface, self), 'physical_interface_back_refs'):
            return super(PhysicalInterface, self).get_physical_interface_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.physical_interface_read(id = self.uuid, fields = ['physical_interface_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'physical_interface_back_refs', None)
        if not back_refs:
            return None
        self.physical_interface_back_refs = back_refs

        return back_refs
    # end get_physical_interface_back_refs

    def get_link_aggregation_group_back_refs(self):
        """Return list of all link-aggregation-groups using this physical-interface"""
        if hasattr(self, 'link_aggregation_group_back_refs'):
            return self.link_aggregation_group_back_refs

        if hasattr(super(PhysicalInterface, self), 'link_aggregation_group_back_refs'):
            return super(PhysicalInterface, self).get_link_aggregation_group_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.physical_interface_read(id = self.uuid, fields = ['link_aggregation_group_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'link_aggregation_group_back_refs', None)
        if not back_refs:
            return None
        self.link_aggregation_group_back_refs = back_refs

        return back_refs
    # end get_link_aggregation_group_back_refs

    def get_virtual_port_group_back_refs(self):
        """Return list of all virtual-port-groups using this physical-interface"""
        if hasattr(self, 'virtual_port_group_back_refs'):
            return self.virtual_port_group_back_refs

        if hasattr(super(PhysicalInterface, self), 'virtual_port_group_back_refs'):
            return super(PhysicalInterface, self).get_virtual_port_group_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.physical_interface_read(id = self.uuid, fields = ['virtual_port_group_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'virtual_port_group_back_refs', None)
        if not back_refs:
            return None
        self.virtual_port_group_back_refs = back_refs

        return back_refs
    # end get_virtual_port_group_back_refs

# end class PhysicalInterface

class AccessControlList(vnc_api.gen.resource_common.AccessControlList):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'access_control_list_entries' in kwargs:
            pending_fields.append('access_control_list_entries')
        if len(args) > 1 or 'access_control_list_hash' in kwargs:
            pending_fields.append('access_control_list_hash')
        if len(args) > 2 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 3 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 4 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 5 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(AccessControlList, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            if kwargs['access_control_list_entries'] is None:
                props_dict['access_control_list_entries'] = None
            else:
                props_dict['access_control_list_entries'] = vnc_api.gen.resource_xsd.AclEntriesType(params_dict=kwargs[u'access_control_list_entries'])
        except KeyError:
            pass

        try:
            props_dict['access_control_list_hash'] = kwargs[u'access_control_list_hash']
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = AccessControlList(**props_dict)
        else:
            obj = AccessControlList(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.AccessControlList.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.AccessControlList.access_control_list_entries.setter
    def access_control_list_entries(self, access_control_list_entries):
        """Set access-control-list-entries for access-control-list.
        
        :param access_control_list_entries: AclEntriesType object
        
        """
        if 'access_control_list_entries' not in self._pending_field_updates:
            self._pending_field_updates.add('access_control_list_entries')

        self._access_control_list_entries = access_control_list_entries
    # end access_control_list_entries

    def set_access_control_list_entries(self, value):
        self.access_control_list_entries = value
    # end set_access_control_list_entries

    @vnc_api.gen.resource_common.AccessControlList.access_control_list_hash.setter
    def access_control_list_hash(self, access_control_list_hash):
        """Set access-control-list-hash for access-control-list.
        
        :param access_control_list_hash: xsd:unsignedLong object
        
        """
        if 'access_control_list_hash' not in self._pending_field_updates:
            self._pending_field_updates.add('access_control_list_hash')

        self._access_control_list_hash = access_control_list_hash
    # end access_control_list_hash

    def set_access_control_list_hash(self, value):
        self.access_control_list_hash = value
    # end set_access_control_list_hash

    @vnc_api.gen.resource_common.AccessControlList.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for access-control-list.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.AccessControlList.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for access-control-list.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.AccessControlList.annotations.setter
    def annotations(self, annotations):
        """Set annotations for access-control-list.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.AccessControlList.display_name.setter
    def display_name(self, display_name):
        """Set display-name for access-control-list.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for access-control-list.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for access-control-list.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_tag(self, *args, **kwargs):
        """Set tag for access-control-list.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(AccessControlList, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to access-control-list.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(AccessControlList, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(AccessControlList, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for access-control-list.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(AccessControlList, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


# end class AccessControlList

class Node(vnc_api.gen.resource_common.Node):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'node_type' in kwargs:
            pending_fields.append('node_type')
        if len(args) > 1 or 'esxi_info' in kwargs:
            pending_fields.append('esxi_info')
        if len(args) > 2 or 'ip_address' in kwargs:
            pending_fields.append('ip_address')
        if len(args) > 3 or 'hostname' in kwargs:
            pending_fields.append('hostname')
        if len(args) > 4 or 'bms_info' in kwargs:
            pending_fields.append('bms_info')
        if len(args) > 5 or 'mac_address' in kwargs:
            pending_fields.append('mac_address')
        if len(args) > 6 or 'disk_partition' in kwargs:
            pending_fields.append('disk_partition')
        if len(args) > 7 or 'interface_name' in kwargs:
            pending_fields.append('interface_name')
        if len(args) > 8 or 'cloud_info' in kwargs:
            pending_fields.append('cloud_info')
        if len(args) > 9 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 10 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 11 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 12 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(Node, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            props_dict['node_type'] = kwargs[u'node_type']
        except KeyError:
            pass

        try:
            if kwargs['esxi_info'] is None:
                props_dict['esxi_info'] = None
            else:
                props_dict['esxi_info'] = vnc_api.gen.resource_xsd.ESXIHostInfo(params_dict=kwargs[u'esxi_info'])
        except KeyError:
            pass

        try:
            props_dict['ip_address'] = kwargs[u'ip_address']
        except KeyError:
            pass

        try:
            props_dict['hostname'] = kwargs[u'hostname']
        except KeyError:
            pass

        try:
            if kwargs['bms_info'] is None:
                props_dict['bms_info'] = None
            else:
                props_dict['bms_info'] = vnc_api.gen.resource_xsd.BaremetalServerInfo(params_dict=kwargs[u'bms_info'])
        except KeyError:
            pass

        try:
            props_dict['mac_address'] = kwargs[u'mac_address']
        except KeyError:
            pass

        try:
            props_dict['disk_partition'] = kwargs[u'disk_partition']
        except KeyError:
            pass

        try:
            props_dict['interface_name'] = kwargs[u'interface_name']
        except KeyError:
            pass

        try:
            if kwargs['cloud_info'] is None:
                props_dict['cloud_info'] = None
            else:
                props_dict['cloud_info'] = vnc_api.gen.resource_xsd.CloudInstanceInfo(params_dict=kwargs[u'cloud_info'])
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = Node(**props_dict)
        else:
            obj = Node(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...
        try:
            obj.ports = kwargs[u'ports']
        except KeyError:
            pass
        try:
            obj.port_groups = kwargs[u'port_groups']
        except KeyError:
            pass

        # add any specified references...
        try:
            obj.node_profile_refs = kwargs[u'node_profile_refs']
        except KeyError:
            pass
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.Node.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.Node.node_type.setter
    def node_type(self, node_type):
        """Set node_type for node.
        
        :param node_type: NodeType object
        
        """
        if 'node_type' not in self._pending_field_updates:
            self._pending_field_updates.add('node_type')

        self._node_type = node_type
    # end node_type

    def set_node_type(self, value):
        self.node_type = value
    # end set_node_type

    @vnc_api.gen.resource_common.Node.esxi_info.setter
    def esxi_info(self, esxi_info):
        """Set esxi-info for node.
        
        :param esxi_info: ESXIHostInfo object
        
        """
        if 'esxi_info' not in self._pending_field_updates:
            self._pending_field_updates.add('esxi_info')

        self._esxi_info = esxi_info
    # end esxi_info

    def set_esxi_info(self, value):
        self.esxi_info = value
    # end set_esxi_info

    @vnc_api.gen.resource_common.Node.ip_address.setter
    def ip_address(self, ip_address):
        """Set ip-address for node.
        
        :param ip_address: xsd:string object
        
        """
        if 'ip_address' not in self._pending_field_updates:
            self._pending_field_updates.add('ip_address')

        self._ip_address = ip_address
    # end ip_address

    def set_ip_address(self, value):
        self.ip_address = value
    # end set_ip_address

    @vnc_api.gen.resource_common.Node.hostname.setter
    def hostname(self, hostname):
        """Set hostname for node.
        
        :param hostname: xsd:string object
        
        """
        if 'hostname' not in self._pending_field_updates:
            self._pending_field_updates.add('hostname')

        self._hostname = hostname
    # end hostname

    def set_hostname(self, value):
        self.hostname = value
    # end set_hostname

    @vnc_api.gen.resource_common.Node.bms_info.setter
    def bms_info(self, bms_info):
        """Set bms-info for node.
        
        :param bms_info: BaremetalServerInfo object
        
        """
        if 'bms_info' not in self._pending_field_updates:
            self._pending_field_updates.add('bms_info')

        self._bms_info = bms_info
    # end bms_info

    def set_bms_info(self, value):
        self.bms_info = value
    # end set_bms_info

    @vnc_api.gen.resource_common.Node.mac_address.setter
    def mac_address(self, mac_address):
        """Set mac-address for node.
        
        :param mac_address: xsd:string object
        
        """
        if 'mac_address' not in self._pending_field_updates:
            self._pending_field_updates.add('mac_address')

        self._mac_address = mac_address
    # end mac_address

    def set_mac_address(self, value):
        self.mac_address = value
    # end set_mac_address

    @vnc_api.gen.resource_common.Node.disk_partition.setter
    def disk_partition(self, disk_partition):
        """Set disk-partition for node.
        
        :param disk_partition: xsd:string object
        
        """
        if 'disk_partition' not in self._pending_field_updates:
            self._pending_field_updates.add('disk_partition')

        self._disk_partition = disk_partition
    # end disk_partition

    def set_disk_partition(self, value):
        self.disk_partition = value
    # end set_disk_partition

    @vnc_api.gen.resource_common.Node.interface_name.setter
    def interface_name(self, interface_name):
        """Set interface-name for node.
        
        :param interface_name: xsd:string object
        
        """
        if 'interface_name' not in self._pending_field_updates:
            self._pending_field_updates.add('interface_name')

        self._interface_name = interface_name
    # end interface_name

    def set_interface_name(self, value):
        self.interface_name = value
    # end set_interface_name

    @vnc_api.gen.resource_common.Node.cloud_info.setter
    def cloud_info(self, cloud_info):
        """Set cloud-info for node.
        
        :param cloud_info: CloudInstanceInfo object
        
        """
        if 'cloud_info' not in self._pending_field_updates:
            self._pending_field_updates.add('cloud_info')

        self._cloud_info = cloud_info
    # end cloud_info

    def set_cloud_info(self, value):
        self.cloud_info = value
    # end set_cloud_info

    @vnc_api.gen.resource_common.Node.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for node.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.Node.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for node.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.Node.annotations.setter
    def annotations(self, annotations):
        """Set annotations for node.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.Node.display_name.setter
    def display_name(self, display_name):
        """Set display-name for node.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for node.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for node.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_node_profile(self, *args, **kwargs):
        """Set node-profile for node.
        
        :param ref_obj: NodeProfile object
        
        """
        self._pending_field_updates.add('node_profile_refs')
        self._pending_ref_updates.discard('node_profile_refs')
        super(Node, self).set_node_profile(*args, **kwargs)

    # end set_node_profile

    def add_node_profile(self, *args, **kwargs):
        """Add node-profile to node.
        
        :param ref_obj: NodeProfile object
        
        """
        if 'node_profile_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('node_profile_refs')
            self._original_node_profile_refs = copy.deepcopy(self.get_node_profile_refs() or [])
        super(Node, self).add_node_profile(*args, **kwargs)
    # end add_node_profile

    def del_node_profile(self, *args, **kwargs):
        if 'node_profile_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('node_profile_refs')
            self._original_node_profile_refs = copy.deepcopy(self.get_node_profile_refs() or [])
        super(Node, self).del_node_profile(*args, **kwargs)
    # end del_node_profile

    def set_node_profile_list(self, *args, **kwargs):
        """Set node-profile list for node.
        
        :param ref_obj_list: list of NodeProfile object
        
        """
        self._pending_field_updates.add('node_profile_refs')
        self._pending_ref_updates.discard('node_profile_refs')
        super(Node, self).set_node_profile_list(*args, **kwargs)
    # end set_node_profile_list

    def set_tag(self, *args, **kwargs):
        """Set tag for node.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(Node, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to node.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(Node, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(Node, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for node.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(Node, self).set_tag_list(*args, **kwargs)
    # end set_tag_list

    def get_ports(self):
        if hasattr(self, 'ports'):
            return self.ports

        if hasattr(super(Node, self), 'ports'):
            return super(Node, self).get_ports()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.node_read(id = self.uuid, fields = ['ports'])
        except NoIdError:
            return None
        children = getattr(obj, 'ports', None)
        if not children:
            return None
        self.ports = children

        return children
    # end get_ports

    def get_port_groups(self):
        if hasattr(self, 'port_groups'):
            return self.port_groups

        if hasattr(super(Node, self), 'port_groups'):
            return super(Node, self).get_port_groups()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.node_read(id = self.uuid, fields = ['port_groups'])
        except NoIdError:
            return None
        children = getattr(obj, 'port_groups', None)
        if not children:
            return None
        self.port_groups = children

        return children
    # end get_port_groups


# end class Node

class CustomerAttachment(vnc_api.gen.resource_common.CustomerAttachment):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, *args, **kwargs):
        pending_fields = ['fq_name']

        self._server_conn = None

        if len(args) > 0 or 'attachment_address' in kwargs:
            pending_fields.append('attachment_address')
        if len(args) > 1 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 2 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 3 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 4 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(CustomerAttachment, self).__init__(name, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            if kwargs['attachment_address'] is None:
                props_dict['attachment_address'] = None
            else:
                props_dict['attachment_address'] = vnc_api.gen.resource_xsd.AttachmentAddressType(params_dict=kwargs[u'attachment_address'])
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = CustomerAttachment(**props_dict)
        else:
            obj = CustomerAttachment(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.virtual_machine_interface_refs = kwargs[u'virtual_machine_interface_refs']
        except KeyError:
            pass
        try:
            obj.floating_ip_refs = kwargs[u'floating_ip_refs']
        except KeyError:
            pass
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.CustomerAttachment.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.CustomerAttachment.attachment_address.setter
    def attachment_address(self, attachment_address):
        """Set attachment-address for customer-attachment.
        
        :param attachment_address: AttachmentAddressType object
        
        """
        if 'attachment_address' not in self._pending_field_updates:
            self._pending_field_updates.add('attachment_address')

        self._attachment_address = attachment_address
    # end attachment_address

    def set_attachment_address(self, value):
        self.attachment_address = value
    # end set_attachment_address

    @vnc_api.gen.resource_common.CustomerAttachment.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for customer-attachment.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.CustomerAttachment.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for customer-attachment.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.CustomerAttachment.annotations.setter
    def annotations(self, annotations):
        """Set annotations for customer-attachment.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.CustomerAttachment.display_name.setter
    def display_name(self, display_name):
        """Set display-name for customer-attachment.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for customer-attachment.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for customer-attachment.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_virtual_machine_interface(self, *args, **kwargs):
        """Set virtual-machine-interface for customer-attachment.
        
        :param ref_obj: VirtualMachineInterface object
        
        """
        self._pending_field_updates.add('virtual_machine_interface_refs')
        self._pending_ref_updates.discard('virtual_machine_interface_refs')
        super(CustomerAttachment, self).set_virtual_machine_interface(*args, **kwargs)

    # end set_virtual_machine_interface

    def add_virtual_machine_interface(self, *args, **kwargs):
        """Add virtual-machine-interface to customer-attachment.
        
        :param ref_obj: VirtualMachineInterface object
        
        """
        if 'virtual_machine_interface_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('virtual_machine_interface_refs')
            self._original_virtual_machine_interface_refs = copy.deepcopy(self.get_virtual_machine_interface_refs() or [])
        super(CustomerAttachment, self).add_virtual_machine_interface(*args, **kwargs)
    # end add_virtual_machine_interface

    def del_virtual_machine_interface(self, *args, **kwargs):
        if 'virtual_machine_interface_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('virtual_machine_interface_refs')
            self._original_virtual_machine_interface_refs = copy.deepcopy(self.get_virtual_machine_interface_refs() or [])
        super(CustomerAttachment, self).del_virtual_machine_interface(*args, **kwargs)
    # end del_virtual_machine_interface

    def set_virtual_machine_interface_list(self, *args, **kwargs):
        """Set virtual-machine-interface list for customer-attachment.
        
        :param ref_obj_list: list of VirtualMachineInterface object
        
        """
        self._pending_field_updates.add('virtual_machine_interface_refs')
        self._pending_ref_updates.discard('virtual_machine_interface_refs')
        super(CustomerAttachment, self).set_virtual_machine_interface_list(*args, **kwargs)
    # end set_virtual_machine_interface_list

    def set_floating_ip(self, *args, **kwargs):
        """Set floating-ip for customer-attachment.
        
        :param ref_obj: FloatingIp object
        
        """
        self._pending_field_updates.add('floating_ip_refs')
        self._pending_ref_updates.discard('floating_ip_refs')
        super(CustomerAttachment, self).set_floating_ip(*args, **kwargs)

    # end set_floating_ip

    def add_floating_ip(self, *args, **kwargs):
        """Add floating-ip to customer-attachment.
        
        :param ref_obj: FloatingIp object
        
        """
        if 'floating_ip_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('floating_ip_refs')
            self._original_floating_ip_refs = copy.deepcopy(self.get_floating_ip_refs() or [])
        super(CustomerAttachment, self).add_floating_ip(*args, **kwargs)
    # end add_floating_ip

    def del_floating_ip(self, *args, **kwargs):
        if 'floating_ip_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('floating_ip_refs')
            self._original_floating_ip_refs = copy.deepcopy(self.get_floating_ip_refs() or [])
        super(CustomerAttachment, self).del_floating_ip(*args, **kwargs)
    # end del_floating_ip

    def set_floating_ip_list(self, *args, **kwargs):
        """Set floating-ip list for customer-attachment.
        
        :param ref_obj_list: list of FloatingIp object
        
        """
        self._pending_field_updates.add('floating_ip_refs')
        self._pending_ref_updates.discard('floating_ip_refs')
        super(CustomerAttachment, self).set_floating_ip_list(*args, **kwargs)
    # end set_floating_ip_list

    def set_tag(self, *args, **kwargs):
        """Set tag for customer-attachment.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(CustomerAttachment, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to customer-attachment.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(CustomerAttachment, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(CustomerAttachment, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for customer-attachment.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(CustomerAttachment, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


# end class CustomerAttachment

class StructuredSyslogSlaProfile(vnc_api.gen.resource_common.StructuredSyslogSlaProfile):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'structured_syslog_sla_params' in kwargs:
            pending_fields.append('structured_syslog_sla_params')
        if len(args) > 1 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 2 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 3 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 4 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(StructuredSyslogSlaProfile, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            props_dict['structured_syslog_sla_params'] = kwargs[u'structured_syslog_sla_params']
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = StructuredSyslogSlaProfile(**props_dict)
        else:
            obj = StructuredSyslogSlaProfile(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.StructuredSyslogSlaProfile.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.StructuredSyslogSlaProfile.structured_syslog_sla_params.setter
    def structured_syslog_sla_params(self, structured_syslog_sla_params):
        """Set structured-syslog-sla-params for structured-syslog-sla-profile.
        
        :param structured_syslog_sla_params: xsd:string object
        
        """
        if 'structured_syslog_sla_params' not in self._pending_field_updates:
            self._pending_field_updates.add('structured_syslog_sla_params')

        self._structured_syslog_sla_params = structured_syslog_sla_params
    # end structured_syslog_sla_params

    def set_structured_syslog_sla_params(self, value):
        self.structured_syslog_sla_params = value
    # end set_structured_syslog_sla_params

    @vnc_api.gen.resource_common.StructuredSyslogSlaProfile.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for structured-syslog-sla-profile.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.StructuredSyslogSlaProfile.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for structured-syslog-sla-profile.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.StructuredSyslogSlaProfile.annotations.setter
    def annotations(self, annotations):
        """Set annotations for structured-syslog-sla-profile.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.StructuredSyslogSlaProfile.display_name.setter
    def display_name(self, display_name):
        """Set display-name for structured-syslog-sla-profile.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for structured-syslog-sla-profile.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for structured-syslog-sla-profile.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_tag(self, *args, **kwargs):
        """Set tag for structured-syslog-sla-profile.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(StructuredSyslogSlaProfile, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to structured-syslog-sla-profile.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(StructuredSyslogSlaProfile, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(StructuredSyslogSlaProfile, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for structured-syslog-sla-profile.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(StructuredSyslogSlaProfile, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


# end class StructuredSyslogSlaProfile

class HostBasedService(vnc_api.gen.resource_common.HostBasedService):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'host_based_service_type' in kwargs:
            pending_fields.append('host_based_service_type')
        if len(args) > 1 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 2 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 3 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 4 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(HostBasedService, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            props_dict['host_based_service_type'] = kwargs[u'host_based_service_type']
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = HostBasedService(**props_dict)
        else:
            obj = HostBasedService(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.virtual_network_refs = kwargs[u'virtual_network_refs']
            for ref in obj.virtual_network_refs:
                ref['attr'] = vnc_api.gen.resource_xsd.ServiceVirtualNetworkType(params_dict=ref[u'attr'])
        except KeyError:
            pass
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.HostBasedService.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.HostBasedService.host_based_service_type.setter
    def host_based_service_type(self, host_based_service_type):
        """Set host-based-service-type for host-based-service.
        
        :param host_based_service_type: HostBasedServiceType object
        
        """
        if 'host_based_service_type' not in self._pending_field_updates:
            self._pending_field_updates.add('host_based_service_type')

        self._host_based_service_type = host_based_service_type
    # end host_based_service_type

    def set_host_based_service_type(self, value):
        self.host_based_service_type = value
    # end set_host_based_service_type

    @vnc_api.gen.resource_common.HostBasedService.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for host-based-service.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.HostBasedService.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for host-based-service.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.HostBasedService.annotations.setter
    def annotations(self, annotations):
        """Set annotations for host-based-service.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.HostBasedService.display_name.setter
    def display_name(self, display_name):
        """Set display-name for host-based-service.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for host-based-service.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for host-based-service.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_virtual_network(self, *args, **kwargs):
        """Set virtual-network for host-based-service.
        
        :param ref_obj: VirtualNetwork object
        :param ref_data: ServiceVirtualNetworkType object
        
        """
        self._pending_field_updates.add('virtual_network_refs')
        self._pending_ref_updates.discard('virtual_network_refs')
        super(HostBasedService, self).set_virtual_network(*args, **kwargs)

    # end set_virtual_network

    def add_virtual_network(self, *args, **kwargs):
        """Add virtual-network to host-based-service.
        
        :param ref_obj: VirtualNetwork object
        :param ref_data: ServiceVirtualNetworkType object
        
        """
        if 'virtual_network_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('virtual_network_refs')
            self._original_virtual_network_refs = copy.deepcopy(self.get_virtual_network_refs() or [])
        super(HostBasedService, self).add_virtual_network(*args, **kwargs)
    # end add_virtual_network

    def del_virtual_network(self, *args, **kwargs):
        if 'virtual_network_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('virtual_network_refs')
            self._original_virtual_network_refs = copy.deepcopy(self.get_virtual_network_refs() or [])
        super(HostBasedService, self).del_virtual_network(*args, **kwargs)
    # end del_virtual_network

    def set_virtual_network_list(self, *args, **kwargs):
        """Set virtual-network list for host-based-service.
        
        :param ref_obj_list: list of VirtualNetwork object
        :param ref_data_list: list of ServiceVirtualNetworkType summary
        
        """
        self._pending_field_updates.add('virtual_network_refs')
        self._pending_ref_updates.discard('virtual_network_refs')
        super(HostBasedService, self).set_virtual_network_list(*args, **kwargs)
    # end set_virtual_network_list

    def set_tag(self, *args, **kwargs):
        """Set tag for host-based-service.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(HostBasedService, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to host-based-service.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(HostBasedService, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(HostBasedService, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for host-based-service.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(HostBasedService, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


# end class HostBasedService

class VirtualMachine(vnc_api.gen.resource_common.VirtualMachine):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, *args, **kwargs):
        pending_fields = ['fq_name']

        self._server_conn = None

        if len(args) > 0 or 'server_type' in kwargs:
            pending_fields.append('server_type')
        if len(args) > 1 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 2 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 3 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 4 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(VirtualMachine, self).__init__(name, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            props_dict['server_type'] = kwargs[u'server_type']
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = VirtualMachine(**props_dict)
        else:
            obj = VirtualMachine(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...
        try:
            obj.virtual_machine_interfaces = kwargs[u'virtual_machine_interfaces']
        except KeyError:
            pass

        # add any specified references...
        try:
            obj.service_instance_refs = kwargs[u'service_instance_refs']
        except KeyError:
            pass
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.virtual_machine_interface_back_refs = kwargs[u'virtual_machine_interface_back_refs']
        except KeyError:
            pass
        try:
            obj.virtual_router_back_refs = kwargs[u'virtual_router_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.VirtualMachine.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.VirtualMachine.server_type.setter
    def server_type(self, server_type):
        """Set server-type for virtual-machine.
        
        :param server_type: ServerType object
        
        """
        if 'server_type' not in self._pending_field_updates:
            self._pending_field_updates.add('server_type')

        self._server_type = server_type
    # end server_type

    def set_server_type(self, value):
        self.server_type = value
    # end set_server_type

    @vnc_api.gen.resource_common.VirtualMachine.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for virtual-machine.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.VirtualMachine.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for virtual-machine.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.VirtualMachine.annotations.setter
    def annotations(self, annotations):
        """Set annotations for virtual-machine.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.VirtualMachine.display_name.setter
    def display_name(self, display_name):
        """Set display-name for virtual-machine.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for virtual-machine.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for virtual-machine.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_service_instance(self, *args, **kwargs):
        """Set service-instance for virtual-machine.
        
        :param ref_obj: ServiceInstance object
        
        """
        self._pending_field_updates.add('service_instance_refs')
        self._pending_ref_updates.discard('service_instance_refs')
        super(VirtualMachine, self).set_service_instance(*args, **kwargs)

    # end set_service_instance

    def add_service_instance(self, *args, **kwargs):
        """Add service-instance to virtual-machine.
        
        :param ref_obj: ServiceInstance object
        
        """
        if 'service_instance_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('service_instance_refs')
            self._original_service_instance_refs = copy.deepcopy(self.get_service_instance_refs() or [])
        super(VirtualMachine, self).add_service_instance(*args, **kwargs)
    # end add_service_instance

    def del_service_instance(self, *args, **kwargs):
        if 'service_instance_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('service_instance_refs')
            self._original_service_instance_refs = copy.deepcopy(self.get_service_instance_refs() or [])
        super(VirtualMachine, self).del_service_instance(*args, **kwargs)
    # end del_service_instance

    def set_service_instance_list(self, *args, **kwargs):
        """Set service-instance list for virtual-machine.
        
        :param ref_obj_list: list of ServiceInstance object
        
        """
        self._pending_field_updates.add('service_instance_refs')
        self._pending_ref_updates.discard('service_instance_refs')
        super(VirtualMachine, self).set_service_instance_list(*args, **kwargs)
    # end set_service_instance_list

    def set_tag(self, *args, **kwargs):
        """Set tag for virtual-machine.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(VirtualMachine, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to virtual-machine.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(VirtualMachine, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(VirtualMachine, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for virtual-machine.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(VirtualMachine, self).set_tag_list(*args, **kwargs)
    # end set_tag_list

    def get_virtual_machine_interfaces(self):
        if hasattr(self, 'virtual_machine_interfaces'):
            return self.virtual_machine_interfaces

        if hasattr(super(VirtualMachine, self), 'virtual_machine_interfaces'):
            return super(VirtualMachine, self).get_virtual_machine_interfaces()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.virtual_machine_read(id = self.uuid, fields = ['virtual_machine_interfaces'])
        except NoIdError:
            return None
        children = getattr(obj, 'virtual_machine_interfaces', None)
        if not children:
            return None
        self.virtual_machine_interfaces = children

        return children
    # end get_virtual_machine_interfaces


    def get_virtual_machine_interface_back_refs(self):
        """Return list of all virtual-machine-interfaces using this virtual-machine"""
        if hasattr(self, 'virtual_machine_interface_back_refs'):
            return self.virtual_machine_interface_back_refs

        if hasattr(super(VirtualMachine, self), 'virtual_machine_interface_back_refs'):
            return super(VirtualMachine, self).get_virtual_machine_interface_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.virtual_machine_read(id = self.uuid, fields = ['virtual_machine_interface_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'virtual_machine_interface_back_refs', None)
        if not back_refs:
            return None
        self.virtual_machine_interface_back_refs = back_refs

        return back_refs
    # end get_virtual_machine_interface_back_refs

    def get_virtual_router_back_refs(self):
        """Return list of all virtual-routers using this virtual-machine"""
        if hasattr(self, 'virtual_router_back_refs'):
            return self.virtual_router_back_refs

        if hasattr(super(VirtualMachine, self), 'virtual_router_back_refs'):
            return super(VirtualMachine, self).get_virtual_router_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.virtual_machine_read(id = self.uuid, fields = ['virtual_router_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'virtual_router_back_refs', None)
        if not back_refs:
            return None
        self.virtual_router_back_refs = back_refs

        return back_refs
    # end get_virtual_router_back_refs

# end class VirtualMachine

class InterfaceRouteTable(vnc_api.gen.resource_common.InterfaceRouteTable):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'interface_route_table_routes' in kwargs:
            pending_fields.append('interface_route_table_routes')
        if len(args) > 1 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 2 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 3 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 4 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(InterfaceRouteTable, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            if kwargs['interface_route_table_routes'] is None:
                props_dict['interface_route_table_routes'] = None
            else:
                props_dict['interface_route_table_routes'] = vnc_api.gen.resource_xsd.RouteTableType(params_dict=kwargs[u'interface_route_table_routes'])
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = InterfaceRouteTable(**props_dict)
        else:
            obj = InterfaceRouteTable(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.service_instance_refs = kwargs[u'service_instance_refs']
            for ref in obj.service_instance_refs:
                ref['attr'] = vnc_api.gen.resource_xsd.ServiceInterfaceTag(params_dict=ref[u'attr'])
        except KeyError:
            pass
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.virtual_machine_interface_back_refs = kwargs[u'virtual_machine_interface_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.InterfaceRouteTable.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.InterfaceRouteTable.interface_route_table_routes.setter
    def interface_route_table_routes(self, interface_route_table_routes):
        """Set interface-route-table-routes for interface-route-table.
        
        :param interface_route_table_routes: RouteTableType object
        
        """
        if 'interface_route_table_routes' not in self._pending_field_updates:
            self._pending_field_updates.add('interface_route_table_routes')

        self._interface_route_table_routes = interface_route_table_routes
    # end interface_route_table_routes

    def set_interface_route_table_routes(self, value):
        self.interface_route_table_routes = value
    # end set_interface_route_table_routes

    @vnc_api.gen.resource_common.InterfaceRouteTable.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for interface-route-table.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.InterfaceRouteTable.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for interface-route-table.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.InterfaceRouteTable.annotations.setter
    def annotations(self, annotations):
        """Set annotations for interface-route-table.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.InterfaceRouteTable.display_name.setter
    def display_name(self, display_name):
        """Set display-name for interface-route-table.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for interface-route-table.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for interface-route-table.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_service_instance(self, *args, **kwargs):
        """Set service-instance for interface-route-table.
        
        :param ref_obj: ServiceInstance object
        :param ref_data: ServiceInterfaceTag object
        
        """
        self._pending_field_updates.add('service_instance_refs')
        self._pending_ref_updates.discard('service_instance_refs')
        super(InterfaceRouteTable, self).set_service_instance(*args, **kwargs)

    # end set_service_instance

    def add_service_instance(self, *args, **kwargs):
        """Add service-instance to interface-route-table.
        
        :param ref_obj: ServiceInstance object
        :param ref_data: ServiceInterfaceTag object
        
        """
        if 'service_instance_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('service_instance_refs')
            self._original_service_instance_refs = copy.deepcopy(self.get_service_instance_refs() or [])
        super(InterfaceRouteTable, self).add_service_instance(*args, **kwargs)
    # end add_service_instance

    def del_service_instance(self, *args, **kwargs):
        if 'service_instance_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('service_instance_refs')
            self._original_service_instance_refs = copy.deepcopy(self.get_service_instance_refs() or [])
        super(InterfaceRouteTable, self).del_service_instance(*args, **kwargs)
    # end del_service_instance

    def set_service_instance_list(self, *args, **kwargs):
        """Set service-instance list for interface-route-table.
        
        :param ref_obj_list: list of ServiceInstance object
        :param ref_data_list: list of ServiceInterfaceTag summary
        
        """
        self._pending_field_updates.add('service_instance_refs')
        self._pending_ref_updates.discard('service_instance_refs')
        super(InterfaceRouteTable, self).set_service_instance_list(*args, **kwargs)
    # end set_service_instance_list

    def set_tag(self, *args, **kwargs):
        """Set tag for interface-route-table.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(InterfaceRouteTable, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to interface-route-table.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(InterfaceRouteTable, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(InterfaceRouteTable, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for interface-route-table.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(InterfaceRouteTable, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


    def get_virtual_machine_interface_back_refs(self):
        """Return list of all virtual-machine-interfaces using this interface-route-table"""
        if hasattr(self, 'virtual_machine_interface_back_refs'):
            return self.virtual_machine_interface_back_refs

        if hasattr(super(InterfaceRouteTable, self), 'virtual_machine_interface_back_refs'):
            return super(InterfaceRouteTable, self).get_virtual_machine_interface_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.interface_route_table_read(id = self.uuid, fields = ['virtual_machine_interface_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'virtual_machine_interface_back_refs', None)
        if not back_refs:
            return None
        self.virtual_machine_interface_back_refs = back_refs

        return back_refs
    # end get_virtual_machine_interface_back_refs

# end class InterfaceRouteTable

class LoadbalancerMember(vnc_api.gen.resource_common.LoadbalancerMember):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'loadbalancer_member_properties' in kwargs:
            pending_fields.append('loadbalancer_member_properties')
        if len(args) > 1 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 2 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 3 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 4 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(LoadbalancerMember, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            if kwargs['loadbalancer_member_properties'] is None:
                props_dict['loadbalancer_member_properties'] = None
            else:
                props_dict['loadbalancer_member_properties'] = vnc_api.gen.resource_xsd.LoadbalancerMemberType(params_dict=kwargs[u'loadbalancer_member_properties'])
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = LoadbalancerMember(**props_dict)
        else:
            obj = LoadbalancerMember(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.LoadbalancerMember.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.LoadbalancerMember.loadbalancer_member_properties.setter
    def loadbalancer_member_properties(self, loadbalancer_member_properties):
        """Set loadbalancer-member-properties for loadbalancer-member.
        
        :param loadbalancer_member_properties: LoadbalancerMemberType object
        
        """
        if 'loadbalancer_member_properties' not in self._pending_field_updates:
            self._pending_field_updates.add('loadbalancer_member_properties')

        self._loadbalancer_member_properties = loadbalancer_member_properties
    # end loadbalancer_member_properties

    def set_loadbalancer_member_properties(self, value):
        self.loadbalancer_member_properties = value
    # end set_loadbalancer_member_properties

    @vnc_api.gen.resource_common.LoadbalancerMember.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for loadbalancer-member.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.LoadbalancerMember.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for loadbalancer-member.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.LoadbalancerMember.annotations.setter
    def annotations(self, annotations):
        """Set annotations for loadbalancer-member.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.LoadbalancerMember.display_name.setter
    def display_name(self, display_name):
        """Set display-name for loadbalancer-member.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for loadbalancer-member.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for loadbalancer-member.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_tag(self, *args, **kwargs):
        """Set tag for loadbalancer-member.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(LoadbalancerMember, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to loadbalancer-member.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(LoadbalancerMember, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(LoadbalancerMember, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for loadbalancer-member.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(LoadbalancerMember, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


# end class LoadbalancerMember

class ServiceHealthCheck(vnc_api.gen.resource_common.ServiceHealthCheck):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'service_health_check_properties' in kwargs:
            pending_fields.append('service_health_check_properties')
        if len(args) > 1 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 2 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 3 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 4 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(ServiceHealthCheck, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            if kwargs['service_health_check_properties'] is None:
                props_dict['service_health_check_properties'] = None
            else:
                props_dict['service_health_check_properties'] = vnc_api.gen.resource_xsd.ServiceHealthCheckType(params_dict=kwargs[u'service_health_check_properties'])
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = ServiceHealthCheck(**props_dict)
        else:
            obj = ServiceHealthCheck(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.service_instance_refs = kwargs[u'service_instance_refs']
            for ref in obj.service_instance_refs:
                ref['attr'] = vnc_api.gen.resource_xsd.ServiceInterfaceTag(params_dict=ref[u'attr'])
        except KeyError:
            pass
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.virtual_machine_interface_back_refs = kwargs[u'virtual_machine_interface_back_refs']
        except KeyError:
            pass
        try:
            obj.bgp_as_a_service_back_refs = kwargs[u'bgp_as_a_service_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.ServiceHealthCheck.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.ServiceHealthCheck.service_health_check_properties.setter
    def service_health_check_properties(self, service_health_check_properties):
        """Set service-health-check-properties for service-health-check.
        
        :param service_health_check_properties: ServiceHealthCheckType object
        
        """
        if 'service_health_check_properties' not in self._pending_field_updates:
            self._pending_field_updates.add('service_health_check_properties')

        self._service_health_check_properties = service_health_check_properties
    # end service_health_check_properties

    def set_service_health_check_properties(self, value):
        self.service_health_check_properties = value
    # end set_service_health_check_properties

    @vnc_api.gen.resource_common.ServiceHealthCheck.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for service-health-check.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.ServiceHealthCheck.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for service-health-check.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.ServiceHealthCheck.annotations.setter
    def annotations(self, annotations):
        """Set annotations for service-health-check.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.ServiceHealthCheck.display_name.setter
    def display_name(self, display_name):
        """Set display-name for service-health-check.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for service-health-check.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for service-health-check.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_service_instance(self, *args, **kwargs):
        """Set service-instance for service-health-check.
        
        :param ref_obj: ServiceInstance object
        :param ref_data: ServiceInterfaceTag object
        
        """
        self._pending_field_updates.add('service_instance_refs')
        self._pending_ref_updates.discard('service_instance_refs')
        super(ServiceHealthCheck, self).set_service_instance(*args, **kwargs)

    # end set_service_instance

    def add_service_instance(self, *args, **kwargs):
        """Add service-instance to service-health-check.
        
        :param ref_obj: ServiceInstance object
        :param ref_data: ServiceInterfaceTag object
        
        """
        if 'service_instance_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('service_instance_refs')
            self._original_service_instance_refs = copy.deepcopy(self.get_service_instance_refs() or [])
        super(ServiceHealthCheck, self).add_service_instance(*args, **kwargs)
    # end add_service_instance

    def del_service_instance(self, *args, **kwargs):
        if 'service_instance_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('service_instance_refs')
            self._original_service_instance_refs = copy.deepcopy(self.get_service_instance_refs() or [])
        super(ServiceHealthCheck, self).del_service_instance(*args, **kwargs)
    # end del_service_instance

    def set_service_instance_list(self, *args, **kwargs):
        """Set service-instance list for service-health-check.
        
        :param ref_obj_list: list of ServiceInstance object
        :param ref_data_list: list of ServiceInterfaceTag summary
        
        """
        self._pending_field_updates.add('service_instance_refs')
        self._pending_ref_updates.discard('service_instance_refs')
        super(ServiceHealthCheck, self).set_service_instance_list(*args, **kwargs)
    # end set_service_instance_list

    def set_tag(self, *args, **kwargs):
        """Set tag for service-health-check.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(ServiceHealthCheck, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to service-health-check.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(ServiceHealthCheck, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(ServiceHealthCheck, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for service-health-check.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(ServiceHealthCheck, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


    def get_virtual_machine_interface_back_refs(self):
        """Return list of all virtual-machine-interfaces using this service-health-check"""
        if hasattr(self, 'virtual_machine_interface_back_refs'):
            return self.virtual_machine_interface_back_refs

        if hasattr(super(ServiceHealthCheck, self), 'virtual_machine_interface_back_refs'):
            return super(ServiceHealthCheck, self).get_virtual_machine_interface_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.service_health_check_read(id = self.uuid, fields = ['virtual_machine_interface_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'virtual_machine_interface_back_refs', None)
        if not back_refs:
            return None
        self.virtual_machine_interface_back_refs = back_refs

        return back_refs
    # end get_virtual_machine_interface_back_refs

    def get_bgp_as_a_service_back_refs(self):
        """Return list of all bgp-as-a-services using this service-health-check"""
        if hasattr(self, 'bgp_as_a_service_back_refs'):
            return self.bgp_as_a_service_back_refs

        if hasattr(super(ServiceHealthCheck, self), 'bgp_as_a_service_back_refs'):
            return super(ServiceHealthCheck, self).get_bgp_as_a_service_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.service_health_check_read(id = self.uuid, fields = ['bgp_as_a_service_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'bgp_as_a_service_back_refs', None)
        if not back_refs:
            return None
        self.bgp_as_a_service_back_refs = back_refs

        return back_refs
    # end get_bgp_as_a_service_back_refs

# end class ServiceHealthCheck

class Alarm(vnc_api.gen.resource_common.Alarm):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'uve_keys' in kwargs:
            pending_fields.append('uve_keys')
        if len(args) > 1 or 'alarm_severity' in kwargs:
            pending_fields.append('alarm_severity')
        if len(args) > 2 or 'alarm_rules' in kwargs:
            pending_fields.append('alarm_rules')
        if len(args) > 3 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 4 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 5 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 6 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(Alarm, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            if kwargs['uve_keys'] is None:
                props_dict['uve_keys'] = None
            else:
                props_dict['uve_keys'] = vnc_api.gen.resource_xsd.UveKeysType(params_dict=kwargs[u'uve_keys'])
        except KeyError:
            pass

        try:
            props_dict['alarm_severity'] = kwargs[u'alarm_severity']
        except KeyError:
            pass

        try:
            if kwargs['alarm_rules'] is None:
                props_dict['alarm_rules'] = None
            else:
                props_dict['alarm_rules'] = vnc_api.gen.resource_xsd.AlarmOrList(params_dict=kwargs[u'alarm_rules'])
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = Alarm(**props_dict)
        else:
            obj = Alarm(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.Alarm.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.Alarm.uve_keys.setter
    def uve_keys(self, uve_keys):
        """Set uve-keys for alarm.
        
        :param uve_keys: UveKeysType object
        
        """
        if 'uve_keys' not in self._pending_field_updates:
            self._pending_field_updates.add('uve_keys')

        self._uve_keys = uve_keys
    # end uve_keys

    def set_uve_keys(self, value):
        self.uve_keys = value
    # end set_uve_keys

    @vnc_api.gen.resource_common.Alarm.alarm_severity.setter
    def alarm_severity(self, alarm_severity):
        """Set alarm-severity for alarm.
        
        :param alarm_severity: AlarmSeverity object
        
        """
        if 'alarm_severity' not in self._pending_field_updates:
            self._pending_field_updates.add('alarm_severity')

        self._alarm_severity = alarm_severity
    # end alarm_severity

    def set_alarm_severity(self, value):
        self.alarm_severity = value
    # end set_alarm_severity

    @vnc_api.gen.resource_common.Alarm.alarm_rules.setter
    def alarm_rules(self, alarm_rules):
        """Set alarm-rules for alarm.
        
        :param alarm_rules: AlarmOrList object
        
        """
        if 'alarm_rules' not in self._pending_field_updates:
            self._pending_field_updates.add('alarm_rules')

        if 'alarm_rules' in self._pending_field_list_updates:
            # set clobbers earlier add/del on prop list elements
            del self._pending_field_list_updates['alarm_rules']

        self._alarm_rules = alarm_rules
    # end alarm_rules

    def set_alarm_rules(self, value):
        self.alarm_rules = value
    # end set_alarm_rules

    @vnc_api.gen.resource_common.Alarm.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for alarm.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.Alarm.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for alarm.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.Alarm.annotations.setter
    def annotations(self, annotations):
        """Set annotations for alarm.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.Alarm.display_name.setter
    def display_name(self, display_name):
        """Set display-name for alarm.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_alarm_rules(self, elem_value, elem_position=None):
        """Add element to alarm-rules for alarm.
        
        :param elem_value: xsd:string object
        :param elem_position: optional string order-key
        
        """
        if 'alarm_rules' not in self._pending_field_list_updates:
            self._pending_field_list_updates['alarm_rules'] = [
                ('add', elem_value, elem_position)]
        else:
            self._pending_field_list_updates['alarm_rules'].append(
                ('add', elem_value, elem_position))
    # end add_alarm_rules

    def del_alarm_rules(self, elem_position):
        """Delete element from alarm-rules for alarm.
        
        :param elem_position: string indicating order-key
        
        """
        if 'alarm_rules' not in self._pending_field_list_updates:
            self._pending_field_list_updates['alarm_rules'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_list_updates['alarm_rules'].append(
                ('delete', None, elem_position))
    # end del_alarm_rules
    def add_annotations(self, elem):
        """Add element to annotations for alarm.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for alarm.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_tag(self, *args, **kwargs):
        """Set tag for alarm.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(Alarm, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to alarm.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(Alarm, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(Alarm, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for alarm.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(Alarm, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


# end class Alarm

class ApiAccessList(vnc_api.gen.resource_common.ApiAccessList):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'api_access_list_entries' in kwargs:
            pending_fields.append('api_access_list_entries')
        if len(args) > 1 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 2 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 3 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 4 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(ApiAccessList, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            if kwargs['api_access_list_entries'] is None:
                props_dict['api_access_list_entries'] = None
            else:
                props_dict['api_access_list_entries'] = vnc_api.gen.resource_xsd.RbacRuleEntriesType(params_dict=kwargs[u'api_access_list_entries'])
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = ApiAccessList(**props_dict)
        else:
            obj = ApiAccessList(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.ApiAccessList.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.ApiAccessList.api_access_list_entries.setter
    def api_access_list_entries(self, api_access_list_entries):
        """Set api-access-list-entries for api-access-list.
        
        :param api_access_list_entries: RbacRuleEntriesType object
        
        """
        if 'api_access_list_entries' not in self._pending_field_updates:
            self._pending_field_updates.add('api_access_list_entries')

        self._api_access_list_entries = api_access_list_entries
    # end api_access_list_entries

    def set_api_access_list_entries(self, value):
        self.api_access_list_entries = value
    # end set_api_access_list_entries

    @vnc_api.gen.resource_common.ApiAccessList.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for api-access-list.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.ApiAccessList.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for api-access-list.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.ApiAccessList.annotations.setter
    def annotations(self, annotations):
        """Set annotations for api-access-list.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.ApiAccessList.display_name.setter
    def display_name(self, display_name):
        """Set display-name for api-access-list.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for api-access-list.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for api-access-list.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_tag(self, *args, **kwargs):
        """Set tag for api-access-list.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(ApiAccessList, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to api-access-list.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(ApiAccessList, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(ApiAccessList, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for api-access-list.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(ApiAccessList, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


# end class ApiAccessList

class RoutingInstance(vnc_api.gen.resource_common.RoutingInstance):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'service_chain_information' in kwargs:
            pending_fields.append('service_chain_information')
        if len(args) > 1 or 'ipv6_service_chain_information' in kwargs:
            pending_fields.append('ipv6_service_chain_information')
        if len(args) > 2 or 'evpn_service_chain_information' in kwargs:
            pending_fields.append('evpn_service_chain_information')
        if len(args) > 3 or 'evpn_ipv6_service_chain_information' in kwargs:
            pending_fields.append('evpn_ipv6_service_chain_information')
        if len(args) > 4 or 'routing_instance_is_default' in kwargs:
            pending_fields.append('routing_instance_is_default')
        if len(args) > 5 or 'routing_instance_has_pnf' in kwargs:
            pending_fields.append('routing_instance_has_pnf')
        if len(args) > 6 or 'static_route_entries' in kwargs:
            pending_fields.append('static_route_entries')
        if len(args) > 7 or 'routing_instance_fabric_snat' in kwargs:
            pending_fields.append('routing_instance_fabric_snat')
        if len(args) > 8 or 'default_ce_protocol' in kwargs:
            pending_fields.append('default_ce_protocol')
        if len(args) > 9 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 10 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 11 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 12 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(RoutingInstance, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            if kwargs['service_chain_information'] is None:
                props_dict['service_chain_information'] = None
            else:
                props_dict['service_chain_information'] = vnc_api.gen.resource_xsd.ServiceChainInfo(params_dict=kwargs[u'service_chain_information'])
        except KeyError:
            pass

        try:
            if kwargs['ipv6_service_chain_information'] is None:
                props_dict['ipv6_service_chain_information'] = None
            else:
                props_dict['ipv6_service_chain_information'] = vnc_api.gen.resource_xsd.ServiceChainInfo(params_dict=kwargs[u'ipv6_service_chain_information'])
        except KeyError:
            pass

        try:
            if kwargs['evpn_service_chain_information'] is None:
                props_dict['evpn_service_chain_information'] = None
            else:
                props_dict['evpn_service_chain_information'] = vnc_api.gen.resource_xsd.ServiceChainInfo(params_dict=kwargs[u'evpn_service_chain_information'])
        except KeyError:
            pass

        try:
            if kwargs['evpn_ipv6_service_chain_information'] is None:
                props_dict['evpn_ipv6_service_chain_information'] = None
            else:
                props_dict['evpn_ipv6_service_chain_information'] = vnc_api.gen.resource_xsd.ServiceChainInfo(params_dict=kwargs[u'evpn_ipv6_service_chain_information'])
        except KeyError:
            pass

        try:
            props_dict['routing_instance_is_default'] = kwargs[u'routing_instance_is_default']
        except KeyError:
            pass

        try:
            props_dict['routing_instance_has_pnf'] = kwargs[u'routing_instance_has_pnf']
        except KeyError:
            pass

        try:
            if kwargs['static_route_entries'] is None:
                props_dict['static_route_entries'] = None
            else:
                props_dict['static_route_entries'] = vnc_api.gen.resource_xsd.StaticRouteEntriesType(params_dict=kwargs[u'static_route_entries'])
        except KeyError:
            pass

        try:
            props_dict['routing_instance_fabric_snat'] = kwargs[u'routing_instance_fabric_snat']
        except KeyError:
            pass

        try:
            if kwargs['default_ce_protocol'] is None:
                props_dict['default_ce_protocol'] = None
            else:
                props_dict['default_ce_protocol'] = vnc_api.gen.resource_xsd.DefaultProtocolType(params_dict=kwargs[u'default_ce_protocol'])
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = RoutingInstance(**props_dict)
        else:
            obj = RoutingInstance(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...
        try:
            obj.bgp_routers = kwargs[u'bgp_routers']
        except KeyError:
            pass

        # add any specified references...
        try:
            obj.routing_instance_refs = kwargs[u'routing_instance_refs']
            for ref in obj.routing_instance_refs:
                ref['attr'] = vnc_api.gen.resource_xsd.ConnectionType(params_dict=ref[u'attr'])
        except KeyError:
            pass
        try:
            obj.route_target_refs = kwargs[u'route_target_refs']
            for ref in obj.route_target_refs:
                ref['attr'] = vnc_api.gen.resource_xsd.InstanceTargetType(params_dict=ref[u'attr'])
        except KeyError:
            pass
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.virtual_machine_interface_back_refs = kwargs[u'virtual_machine_interface_back_refs']
        except KeyError:
            pass
        try:
            obj.route_aggregate_back_refs = kwargs[u'route_aggregate_back_refs']
        except KeyError:
            pass
        try:
            obj.routing_policy_back_refs = kwargs[u'routing_policy_back_refs']
        except KeyError:
            pass
        try:
            obj.routing_instance_back_refs = kwargs[u'routing_instance_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.RoutingInstance.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.RoutingInstance.service_chain_information.setter
    def service_chain_information(self, service_chain_information):
        """Set service-chain-information for routing-instance.
        
        :param service_chain_information: ServiceChainInfo object
        
        """
        if 'service_chain_information' not in self._pending_field_updates:
            self._pending_field_updates.add('service_chain_information')

        self._service_chain_information = service_chain_information
    # end service_chain_information

    def set_service_chain_information(self, value):
        self.service_chain_information = value
    # end set_service_chain_information

    @vnc_api.gen.resource_common.RoutingInstance.ipv6_service_chain_information.setter
    def ipv6_service_chain_information(self, ipv6_service_chain_information):
        """Set ipv6-service-chain-information for routing-instance.
        
        :param ipv6_service_chain_information: ServiceChainInfo object
        
        """
        if 'ipv6_service_chain_information' not in self._pending_field_updates:
            self._pending_field_updates.add('ipv6_service_chain_information')

        self._ipv6_service_chain_information = ipv6_service_chain_information
    # end ipv6_service_chain_information

    def set_ipv6_service_chain_information(self, value):
        self.ipv6_service_chain_information = value
    # end set_ipv6_service_chain_information

    @vnc_api.gen.resource_common.RoutingInstance.evpn_service_chain_information.setter
    def evpn_service_chain_information(self, evpn_service_chain_information):
        """Set evpn-service-chain-information for routing-instance.
        
        :param evpn_service_chain_information: ServiceChainInfo object
        
        """
        if 'evpn_service_chain_information' not in self._pending_field_updates:
            self._pending_field_updates.add('evpn_service_chain_information')

        self._evpn_service_chain_information = evpn_service_chain_information
    # end evpn_service_chain_information

    def set_evpn_service_chain_information(self, value):
        self.evpn_service_chain_information = value
    # end set_evpn_service_chain_information

    @vnc_api.gen.resource_common.RoutingInstance.evpn_ipv6_service_chain_information.setter
    def evpn_ipv6_service_chain_information(self, evpn_ipv6_service_chain_information):
        """Set evpn-ipv6-service-chain-information for routing-instance.
        
        :param evpn_ipv6_service_chain_information: ServiceChainInfo object
        
        """
        if 'evpn_ipv6_service_chain_information' not in self._pending_field_updates:
            self._pending_field_updates.add('evpn_ipv6_service_chain_information')

        self._evpn_ipv6_service_chain_information = evpn_ipv6_service_chain_information
    # end evpn_ipv6_service_chain_information

    def set_evpn_ipv6_service_chain_information(self, value):
        self.evpn_ipv6_service_chain_information = value
    # end set_evpn_ipv6_service_chain_information

    @vnc_api.gen.resource_common.RoutingInstance.routing_instance_is_default.setter
    def routing_instance_is_default(self, routing_instance_is_default):
        """Set routing-instance-is-default for routing-instance.
        
        :param routing_instance_is_default: xsd:boolean object
        
        """
        if 'routing_instance_is_default' not in self._pending_field_updates:
            self._pending_field_updates.add('routing_instance_is_default')

        self._routing_instance_is_default = routing_instance_is_default
    # end routing_instance_is_default

    def set_routing_instance_is_default(self, value):
        self.routing_instance_is_default = value
    # end set_routing_instance_is_default

    @vnc_api.gen.resource_common.RoutingInstance.routing_instance_has_pnf.setter
    def routing_instance_has_pnf(self, routing_instance_has_pnf):
        """Set routing-instance-has-pnf for routing-instance.
        
        :param routing_instance_has_pnf: xsd:boolean object
        
        """
        if 'routing_instance_has_pnf' not in self._pending_field_updates:
            self._pending_field_updates.add('routing_instance_has_pnf')

        self._routing_instance_has_pnf = routing_instance_has_pnf
    # end routing_instance_has_pnf

    def set_routing_instance_has_pnf(self, value):
        self.routing_instance_has_pnf = value
    # end set_routing_instance_has_pnf

    @vnc_api.gen.resource_common.RoutingInstance.static_route_entries.setter
    def static_route_entries(self, static_route_entries):
        """Set static-route-entries for routing-instance.
        
        :param static_route_entries: StaticRouteEntriesType object
        
        """
        if 'static_route_entries' not in self._pending_field_updates:
            self._pending_field_updates.add('static_route_entries')

        self._static_route_entries = static_route_entries
    # end static_route_entries

    def set_static_route_entries(self, value):
        self.static_route_entries = value
    # end set_static_route_entries

    @vnc_api.gen.resource_common.RoutingInstance.routing_instance_fabric_snat.setter
    def routing_instance_fabric_snat(self, routing_instance_fabric_snat):
        """Set routing-instance-fabric-snat for routing-instance.
        
        :param routing_instance_fabric_snat: xsd:boolean object
        
        """
        if 'routing_instance_fabric_snat' not in self._pending_field_updates:
            self._pending_field_updates.add('routing_instance_fabric_snat')

        self._routing_instance_fabric_snat = routing_instance_fabric_snat
    # end routing_instance_fabric_snat

    def set_routing_instance_fabric_snat(self, value):
        self.routing_instance_fabric_snat = value
    # end set_routing_instance_fabric_snat

    @vnc_api.gen.resource_common.RoutingInstance.default_ce_protocol.setter
    def default_ce_protocol(self, default_ce_protocol):
        """Set default-ce-protocol for routing-instance.
        
        :param default_ce_protocol: DefaultProtocolType object
        
        """
        if 'default_ce_protocol' not in self._pending_field_updates:
            self._pending_field_updates.add('default_ce_protocol')

        self._default_ce_protocol = default_ce_protocol
    # end default_ce_protocol

    def set_default_ce_protocol(self, value):
        self.default_ce_protocol = value
    # end set_default_ce_protocol

    @vnc_api.gen.resource_common.RoutingInstance.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for routing-instance.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.RoutingInstance.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for routing-instance.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.RoutingInstance.annotations.setter
    def annotations(self, annotations):
        """Set annotations for routing-instance.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.RoutingInstance.display_name.setter
    def display_name(self, display_name):
        """Set display-name for routing-instance.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for routing-instance.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for routing-instance.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_routing_instance(self, *args, **kwargs):
        """Set routing-instance for routing-instance.
        
        :param ref_obj: RoutingInstance object
        :param ref_data: ConnectionType object
        
        """
        self._pending_field_updates.add('routing_instance_refs')
        self._pending_ref_updates.discard('routing_instance_refs')
        super(RoutingInstance, self).set_routing_instance(*args, **kwargs)

    # end set_routing_instance

    def add_routing_instance(self, *args, **kwargs):
        """Add routing-instance to routing-instance.
        
        :param ref_obj: RoutingInstance object
        :param ref_data: ConnectionType object
        
        """
        if 'routing_instance_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('routing_instance_refs')
            self._original_routing_instance_refs = copy.deepcopy(self.get_routing_instance_refs() or [])
        super(RoutingInstance, self).add_routing_instance(*args, **kwargs)
    # end add_routing_instance

    def del_routing_instance(self, *args, **kwargs):
        if 'routing_instance_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('routing_instance_refs')
            self._original_routing_instance_refs = copy.deepcopy(self.get_routing_instance_refs() or [])
        super(RoutingInstance, self).del_routing_instance(*args, **kwargs)
    # end del_routing_instance

    def set_routing_instance_list(self, *args, **kwargs):
        """Set routing-instance list for routing-instance.
        
        :param ref_obj_list: list of RoutingInstance object
        :param ref_data_list: list of ConnectionType summary
        
        """
        self._pending_field_updates.add('routing_instance_refs')
        self._pending_ref_updates.discard('routing_instance_refs')
        super(RoutingInstance, self).set_routing_instance_list(*args, **kwargs)
    # end set_routing_instance_list

    def set_route_target(self, *args, **kwargs):
        """Set route-target for routing-instance.
        
        :param ref_obj: RouteTarget object
        :param ref_data: InstanceTargetType object
        
        """
        self._pending_field_updates.add('route_target_refs')
        self._pending_ref_updates.discard('route_target_refs')
        super(RoutingInstance, self).set_route_target(*args, **kwargs)

    # end set_route_target

    def add_route_target(self, *args, **kwargs):
        """Add route-target to routing-instance.
        
        :param ref_obj: RouteTarget object
        :param ref_data: InstanceTargetType object
        
        """
        if 'route_target_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('route_target_refs')
            self._original_route_target_refs = copy.deepcopy(self.get_route_target_refs() or [])
        super(RoutingInstance, self).add_route_target(*args, **kwargs)
    # end add_route_target

    def del_route_target(self, *args, **kwargs):
        if 'route_target_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('route_target_refs')
            self._original_route_target_refs = copy.deepcopy(self.get_route_target_refs() or [])
        super(RoutingInstance, self).del_route_target(*args, **kwargs)
    # end del_route_target

    def set_route_target_list(self, *args, **kwargs):
        """Set route-target list for routing-instance.
        
        :param ref_obj_list: list of RouteTarget object
        :param ref_data_list: list of InstanceTargetType summary
        
        """
        self._pending_field_updates.add('route_target_refs')
        self._pending_ref_updates.discard('route_target_refs')
        super(RoutingInstance, self).set_route_target_list(*args, **kwargs)
    # end set_route_target_list

    def set_tag(self, *args, **kwargs):
        """Set tag for routing-instance.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(RoutingInstance, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to routing-instance.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(RoutingInstance, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(RoutingInstance, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for routing-instance.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(RoutingInstance, self).set_tag_list(*args, **kwargs)
    # end set_tag_list

    def get_bgp_routers(self):
        if hasattr(self, 'bgp_routers'):
            return self.bgp_routers

        if hasattr(super(RoutingInstance, self), 'bgp_routers'):
            return super(RoutingInstance, self).get_bgp_routers()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.routing_instance_read(id = self.uuid, fields = ['bgp_routers'])
        except NoIdError:
            return None
        children = getattr(obj, 'bgp_routers', None)
        if not children:
            return None
        self.bgp_routers = children

        return children
    # end get_bgp_routers


    def get_virtual_machine_interface_back_refs(self):
        """Return list of all virtual-machine-interfaces using this routing-instance"""
        if hasattr(self, 'virtual_machine_interface_back_refs'):
            return self.virtual_machine_interface_back_refs

        if hasattr(super(RoutingInstance, self), 'virtual_machine_interface_back_refs'):
            return super(RoutingInstance, self).get_virtual_machine_interface_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.routing_instance_read(id = self.uuid, fields = ['virtual_machine_interface_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'virtual_machine_interface_back_refs', None)
        if not back_refs:
            return None
        self.virtual_machine_interface_back_refs = back_refs

        return back_refs
    # end get_virtual_machine_interface_back_refs

    def get_route_aggregate_back_refs(self):
        """Return list of all route-aggregates using this routing-instance"""
        if hasattr(self, 'route_aggregate_back_refs'):
            return self.route_aggregate_back_refs

        if hasattr(super(RoutingInstance, self), 'route_aggregate_back_refs'):
            return super(RoutingInstance, self).get_route_aggregate_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.routing_instance_read(id = self.uuid, fields = ['route_aggregate_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'route_aggregate_back_refs', None)
        if not back_refs:
            return None
        self.route_aggregate_back_refs = back_refs

        return back_refs
    # end get_route_aggregate_back_refs

    def get_routing_policy_back_refs(self):
        """Return list of all routing-policys using this routing-instance"""
        if hasattr(self, 'routing_policy_back_refs'):
            return self.routing_policy_back_refs

        if hasattr(super(RoutingInstance, self), 'routing_policy_back_refs'):
            return super(RoutingInstance, self).get_routing_policy_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.routing_instance_read(id = self.uuid, fields = ['routing_policy_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'routing_policy_back_refs', None)
        if not back_refs:
            return None
        self.routing_policy_back_refs = back_refs

        return back_refs
    # end get_routing_policy_back_refs

    def get_routing_instance_back_refs(self):
        """Return list of all routing-instances using this routing-instance"""
        if hasattr(self, 'routing_instance_back_refs'):
            return self.routing_instance_back_refs

        if hasattr(super(RoutingInstance, self), 'routing_instance_back_refs'):
            return super(RoutingInstance, self).get_routing_instance_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.routing_instance_read(id = self.uuid, fields = ['routing_instance_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'routing_instance_back_refs', None)
        if not back_refs:
            return None
        self.routing_instance_back_refs = back_refs

        return back_refs
    # end get_routing_instance_back_refs

# end class RoutingInstance

class AliasIpPool(vnc_api.gen.resource_common.AliasIpPool):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 1 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 2 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 3 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(AliasIpPool, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = AliasIpPool(**props_dict)
        else:
            obj = AliasIpPool(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...
        try:
            obj.alias_ips = kwargs[u'alias_ips']
        except KeyError:
            pass

        # add any specified references...
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...
        try:
            obj.project_back_refs = kwargs[u'project_back_refs']
        except KeyError:
            pass

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.AliasIpPool.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.AliasIpPool.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for alias-ip-pool.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.AliasIpPool.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for alias-ip-pool.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.AliasIpPool.annotations.setter
    def annotations(self, annotations):
        """Set annotations for alias-ip-pool.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.AliasIpPool.display_name.setter
    def display_name(self, display_name):
        """Set display-name for alias-ip-pool.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for alias-ip-pool.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for alias-ip-pool.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_tag(self, *args, **kwargs):
        """Set tag for alias-ip-pool.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(AliasIpPool, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to alias-ip-pool.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(AliasIpPool, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(AliasIpPool, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for alias-ip-pool.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(AliasIpPool, self).set_tag_list(*args, **kwargs)
    # end set_tag_list

    def get_alias_ips(self):
        if hasattr(self, 'alias_ips'):
            return self.alias_ips

        if hasattr(super(AliasIpPool, self), 'alias_ips'):
            return super(AliasIpPool, self).get_alias_ips()

        # read it for first time
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.alias_ip_pool_read(id = self.uuid, fields = ['alias_ips'])
        except NoIdError:
            return None
        children = getattr(obj, 'alias_ips', None)
        if not children:
            return None
        self.alias_ips = children

        return children
    # end get_alias_ips


    def get_project_back_refs(self):
        """Return list of all projects using this alias-ip-pool"""
        if hasattr(self, 'project_back_refs'):
            return self.project_back_refs

        if hasattr(super(AliasIpPool, self), 'project_back_refs'):
            return super(AliasIpPool, self).get_project_back_refs()
        # if object not created/read from lib can't service
        svr_conn = self._server_conn
        if not svr_conn:
            return None

        try:
            obj = svr_conn.alias_ip_pool_read(id = self.uuid, fields = ['project_back_refs'])
        except NoIdError:
            return None
        back_refs = getattr(obj, 'project_back_refs', None)
        if not back_refs:
            return None
        self.project_back_refs = back_refs

        return back_refs
    # end get_project_back_refs

# end class AliasIpPool

class DataCenterInterconnect(vnc_api.gen.resource_common.DataCenterInterconnect):
    create_uri = ''
    resource_uri_base = {}
    def __init__(self, name=None, parent_obj=None, *args, **kwargs):
        pending_fields = ['fq_name', 'parent_type']

        self._server_conn = None

        if len(args) > 0 or 'data_center_interconnect_bgp_hold_time' in kwargs:
            pending_fields.append('data_center_interconnect_bgp_hold_time')
        if len(args) > 1 or 'data_center_interconnect_mode' in kwargs:
            pending_fields.append('data_center_interconnect_mode')
        if len(args) > 2 or 'data_center_interconnect_bgp_address_families' in kwargs:
            pending_fields.append('data_center_interconnect_bgp_address_families')
        if len(args) > 3 or 'data_center_interconnect_configured_route_target_list' in kwargs:
            pending_fields.append('data_center_interconnect_configured_route_target_list')
        if len(args) > 4 or 'data_center_interconnect_type' in kwargs:
            pending_fields.append('data_center_interconnect_type')
        if len(args) > 5 or 'destination_physical_router_list' in kwargs:
            pending_fields.append('destination_physical_router_list')
        if len(args) > 6 or 'id_perms' in kwargs:
            pending_fields.append('id_perms')
        if len(args) > 7 or 'perms2' in kwargs:
            pending_fields.append('perms2')
        if len(args) > 8 or 'annotations' in kwargs:
            pending_fields.append('annotations')
        if len(args) > 9 or 'display_name' in kwargs:
            pending_fields.append('display_name')

        self._pending_field_updates = set(pending_fields)
        # dict of prop-list-fields with list of opers
        self._pending_field_list_updates = {}
        # dict of prop-map-fields with list of opers
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])

        super(DataCenterInterconnect, self).__init__(name, parent_obj, *args, **kwargs)
    # end __init__

    def get_pending_updates(self):
        return self._pending_field_updates
    # end get_pending_updates

    def get_ref_updates(self):
        return self._pending_ref_updates
    # end get_ref_updates

    def clear_pending_updates(self):
        self._pending_field_updates = set([])
        self._pending_field_list_updates = {}
        self._pending_field_map_updates = {}
        self._pending_ref_updates = set([])
    # end clear_pending_updates

    def set_server_conn(self, vnc_api_handle):
        self._server_conn = vnc_api_handle
    # end set_server_conn

    @classmethod
    def from_dict(cls, **kwargs):
        props_dict = {}
        try:
            props_dict['data_center_interconnect_bgp_hold_time'] = kwargs[u'data_center_interconnect_bgp_hold_time']
        except KeyError:
            pass

        try:
            props_dict['data_center_interconnect_mode'] = kwargs[u'data_center_interconnect_mode']
        except KeyError:
            pass

        try:
            if kwargs['data_center_interconnect_bgp_address_families'] is None:
                props_dict['data_center_interconnect_bgp_address_families'] = None
            else:
                props_dict['data_center_interconnect_bgp_address_families'] = vnc_api.gen.resource_xsd.AddressFamilies(params_dict=kwargs[u'data_center_interconnect_bgp_address_families'])
        except KeyError:
            pass

        try:
            if kwargs['data_center_interconnect_configured_route_target_list'] is None:
                props_dict['data_center_interconnect_configured_route_target_list'] = None
            else:
                props_dict['data_center_interconnect_configured_route_target_list'] = vnc_api.gen.resource_xsd.RouteTargetList(params_dict=kwargs[u'data_center_interconnect_configured_route_target_list'])
        except KeyError:
            pass

        try:
            props_dict['data_center_interconnect_type'] = kwargs[u'data_center_interconnect_type']
        except KeyError:
            pass

        try:
            if kwargs['destination_physical_router_list'] is None:
                props_dict['destination_physical_router_list'] = None
            else:
                props_dict['destination_physical_router_list'] = vnc_api.gen.resource_xsd.LogicalRouterPRListType(params_dict=kwargs[u'destination_physical_router_list'])
        except KeyError:
            pass

        try:
            if kwargs['id_perms'] is None:
                props_dict['id_perms'] = None
            else:
                props_dict['id_perms'] = vnc_api.gen.resource_xsd.IdPermsType(params_dict=kwargs[u'id_perms'])
        except KeyError:
            pass

        try:
            if kwargs['perms2'] is None:
                props_dict['perms2'] = None
            else:
                props_dict['perms2'] = vnc_api.gen.resource_xsd.PermType2(params_dict=kwargs[u'perms2'])
        except KeyError:
            pass

        try:
            if kwargs['annotations'] is None:
                props_dict['annotations'] = None
            else:
                props_dict['annotations'] = vnc_api.gen.resource_xsd.KeyValuePairs(params_dict=kwargs[u'annotations'])
        except KeyError:
            pass

        try:
            props_dict['display_name'] = kwargs[u'display_name']
        except KeyError:
            pass


        # obj constructor takes only props
        parent_type = kwargs.get(u'parent_type', None)
        fq_name = kwargs.get(u'fq_name')
        props_dict.update({'parent_type': parent_type, 'fq_name': fq_name})
        if fq_name == None:
            obj = DataCenterInterconnect(**props_dict)
        else:
            obj = DataCenterInterconnect(fq_name[-1], **props_dict)
        obj.uuid = kwargs.get(u'uuid')
        try:
            obj.parent_uuid = kwargs[u'parent_uuid']
        except KeyError:
            pass

        # add summary of any children...

        # add any specified references...
        try:
            obj.logical_router_refs = kwargs[u'logical_router_refs']
        except KeyError:
            pass
        try:
            obj.virtual_network_refs = kwargs[u'virtual_network_refs']
        except KeyError:
            pass
        try:
            obj.routing_policy_refs = kwargs[u'routing_policy_refs']
        except KeyError:
            pass
        try:
            obj.tag_refs = kwargs[u'tag_refs']
        except KeyError:
            pass

        # and back references but no obj api for it...

        return obj
    # end from_dict

    @vnc_api.gen.resource_common.DataCenterInterconnect.uuid.setter
    def uuid(self, uuid_val):
        self._uuid = uuid_val
        if 'uuid' not in self._pending_field_updates:
            self._pending_field_updates.add('uuid')
    # end uuid

    def set_uuid(self, uuid_val):
        self.uuid = uuid_val
    # end set_uuid

    @vnc_api.gen.resource_common.DataCenterInterconnect.data_center_interconnect_bgp_hold_time.setter
    def data_center_interconnect_bgp_hold_time(self, data_center_interconnect_bgp_hold_time):
        """Set data-center-interconnect-bgp-hold-time for data-center-interconnect.
        
        :param data_center_interconnect_bgp_hold_time: BgpHoldTime object
        
        """
        if 'data_center_interconnect_bgp_hold_time' not in self._pending_field_updates:
            self._pending_field_updates.add('data_center_interconnect_bgp_hold_time')

        self._data_center_interconnect_bgp_hold_time = data_center_interconnect_bgp_hold_time
    # end data_center_interconnect_bgp_hold_time

    def set_data_center_interconnect_bgp_hold_time(self, value):
        self.data_center_interconnect_bgp_hold_time = value
    # end set_data_center_interconnect_bgp_hold_time

    @vnc_api.gen.resource_common.DataCenterInterconnect.data_center_interconnect_mode.setter
    def data_center_interconnect_mode(self, data_center_interconnect_mode):
        """Set data-center-interconnect-mode for data-center-interconnect.
        
        :param data_center_interconnect_mode: DataCenterInterconnectModes object
        
        """
        if 'data_center_interconnect_mode' not in self._pending_field_updates:
            self._pending_field_updates.add('data_center_interconnect_mode')

        self._data_center_interconnect_mode = data_center_interconnect_mode
    # end data_center_interconnect_mode

    def set_data_center_interconnect_mode(self, value):
        self.data_center_interconnect_mode = value
    # end set_data_center_interconnect_mode

    @vnc_api.gen.resource_common.DataCenterInterconnect.data_center_interconnect_bgp_address_families.setter
    def data_center_interconnect_bgp_address_families(self, data_center_interconnect_bgp_address_families):
        """Set data-center-interconnect-bgp-address-families for data-center-interconnect.
        
        :param data_center_interconnect_bgp_address_families: AddressFamilies object
        
        """
        if 'data_center_interconnect_bgp_address_families' not in self._pending_field_updates:
            self._pending_field_updates.add('data_center_interconnect_bgp_address_families')

        self._data_center_interconnect_bgp_address_families = data_center_interconnect_bgp_address_families
    # end data_center_interconnect_bgp_address_families

    def set_data_center_interconnect_bgp_address_families(self, value):
        self.data_center_interconnect_bgp_address_families = value
    # end set_data_center_interconnect_bgp_address_families

    @vnc_api.gen.resource_common.DataCenterInterconnect.data_center_interconnect_configured_route_target_list.setter
    def data_center_interconnect_configured_route_target_list(self, data_center_interconnect_configured_route_target_list):
        """Set data-center-interconnect-configured-route-target-list for data-center-interconnect.
        
        :param data_center_interconnect_configured_route_target_list: RouteTargetList object
        
        """
        if 'data_center_interconnect_configured_route_target_list' not in self._pending_field_updates:
            self._pending_field_updates.add('data_center_interconnect_configured_route_target_list')

        self._data_center_interconnect_configured_route_target_list = data_center_interconnect_configured_route_target_list
    # end data_center_interconnect_configured_route_target_list

    def set_data_center_interconnect_configured_route_target_list(self, value):
        self.data_center_interconnect_configured_route_target_list = value
    # end set_data_center_interconnect_configured_route_target_list

    @vnc_api.gen.resource_common.DataCenterInterconnect.data_center_interconnect_type.setter
    def data_center_interconnect_type(self, data_center_interconnect_type):
        """Set data-center-interconnect-type for data-center-interconnect.
        
        :param data_center_interconnect_type: DataCenterInterConnectType object
        
        """
        if 'data_center_interconnect_type' not in self._pending_field_updates:
            self._pending_field_updates.add('data_center_interconnect_type')

        self._data_center_interconnect_type = data_center_interconnect_type
    # end data_center_interconnect_type

    def set_data_center_interconnect_type(self, value):
        self.data_center_interconnect_type = value
    # end set_data_center_interconnect_type

    @vnc_api.gen.resource_common.DataCenterInterconnect.destination_physical_router_list.setter
    def destination_physical_router_list(self, destination_physical_router_list):
        """Set destination-physical-router-list for data-center-interconnect.
        
        :param destination_physical_router_list: LogicalRouterPRListType object
        
        """
        if 'destination_physical_router_list' not in self._pending_field_updates:
            self._pending_field_updates.add('destination_physical_router_list')

        self._destination_physical_router_list = destination_physical_router_list
    # end destination_physical_router_list

    def set_destination_physical_router_list(self, value):
        self.destination_physical_router_list = value
    # end set_destination_physical_router_list

    @vnc_api.gen.resource_common.DataCenterInterconnect.id_perms.setter
    def id_perms(self, id_perms):
        """Set id-perms for data-center-interconnect.
        
        :param id_perms: IdPermsType object
        
        """
        if 'id_perms' not in self._pending_field_updates:
            self._pending_field_updates.add('id_perms')

        self._id_perms = id_perms
    # end id_perms

    def set_id_perms(self, value):
        self.id_perms = value
    # end set_id_perms

    @vnc_api.gen.resource_common.DataCenterInterconnect.perms2.setter
    def perms2(self, perms2):
        """Set perms2 for data-center-interconnect.
        
        :param perms2: PermType2 object
        
        """
        if 'perms2' not in self._pending_field_updates:
            self._pending_field_updates.add('perms2')

        self._perms2 = perms2
    # end perms2

    def set_perms2(self, value):
        self.perms2 = value
    # end set_perms2

    @vnc_api.gen.resource_common.DataCenterInterconnect.annotations.setter
    def annotations(self, annotations):
        """Set annotations for data-center-interconnect.
        
        :param annotations: KeyValuePairs object
        
        """
        if 'annotations' not in self._pending_field_updates:
            self._pending_field_updates.add('annotations')

        if 'annotations' in self._pending_field_map_updates:
            # set clobbers earlier add/del on prop map elements
            del self._pending_field_map_updates['annotations']

        self._annotations = annotations
    # end annotations

    def set_annotations(self, value):
        self.annotations = value
    # end set_annotations

    @vnc_api.gen.resource_common.DataCenterInterconnect.display_name.setter
    def display_name(self, display_name):
        """Set display-name for data-center-interconnect.
        
        :param display_name: xsd:string object
        
        """
        if 'display_name' not in self._pending_field_updates:
            self._pending_field_updates.add('display_name')

        self._display_name = display_name
    # end display_name

    def set_display_name(self, value):
        self.display_name = value
    # end set_display_name

    def add_annotations(self, elem):
        """Add element to annotations for data-center-interconnect.
        
        :param elem: xsd:string object
        
        """
        elem_position = getattr(elem, 'key')
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('set', elem, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('set', elem, elem_position))
    # end set_annotations

    def del_annotations(self, elem_position):
        """Delete element from annotations for data-center-interconnect.
        
        :param elem_position: string indicating map-key
        
        """
        if 'annotations' not in self._pending_field_map_updates:
            self._pending_field_map_updates['annotations'] = [
                ('delete', None, elem_position)]
        else:
            self._pending_field_map_updates['annotations'].append(
                ('delete', None, elem_position))
    # end del_annotations
    def set_logical_router(self, *args, **kwargs):
        """Set logical-router for data-center-interconnect.
        
        :param ref_obj: LogicalRouter object
        
        """
        self._pending_field_updates.add('logical_router_refs')
        self._pending_ref_updates.discard('logical_router_refs')
        super(DataCenterInterconnect, self).set_logical_router(*args, **kwargs)

    # end set_logical_router

    def add_logical_router(self, *args, **kwargs):
        """Add logical-router to data-center-interconnect.
        
        :param ref_obj: LogicalRouter object
        
        """
        if 'logical_router_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('logical_router_refs')
            self._original_logical_router_refs = copy.deepcopy(self.get_logical_router_refs() or [])
        super(DataCenterInterconnect, self).add_logical_router(*args, **kwargs)
    # end add_logical_router

    def del_logical_router(self, *args, **kwargs):
        if 'logical_router_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('logical_router_refs')
            self._original_logical_router_refs = copy.deepcopy(self.get_logical_router_refs() or [])
        super(DataCenterInterconnect, self).del_logical_router(*args, **kwargs)
    # end del_logical_router

    def set_logical_router_list(self, *args, **kwargs):
        """Set logical-router list for data-center-interconnect.
        
        :param ref_obj_list: list of LogicalRouter object
        
        """
        self._pending_field_updates.add('logical_router_refs')
        self._pending_ref_updates.discard('logical_router_refs')
        super(DataCenterInterconnect, self).set_logical_router_list(*args, **kwargs)
    # end set_logical_router_list

    def set_virtual_network(self, *args, **kwargs):
        """Set virtual-network for data-center-interconnect.
        
        :param ref_obj: VirtualNetwork object
        
        """
        self._pending_field_updates.add('virtual_network_refs')
        self._pending_ref_updates.discard('virtual_network_refs')
        super(DataCenterInterconnect, self).set_virtual_network(*args, **kwargs)

    # end set_virtual_network

    def add_virtual_network(self, *args, **kwargs):
        """Add virtual-network to data-center-interconnect.
        
        :param ref_obj: VirtualNetwork object
        
        """
        if 'virtual_network_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('virtual_network_refs')
            self._original_virtual_network_refs = copy.deepcopy(self.get_virtual_network_refs() or [])
        super(DataCenterInterconnect, self).add_virtual_network(*args, **kwargs)
    # end add_virtual_network

    def del_virtual_network(self, *args, **kwargs):
        if 'virtual_network_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('virtual_network_refs')
            self._original_virtual_network_refs = copy.deepcopy(self.get_virtual_network_refs() or [])
        super(DataCenterInterconnect, self).del_virtual_network(*args, **kwargs)
    # end del_virtual_network

    def set_virtual_network_list(self, *args, **kwargs):
        """Set virtual-network list for data-center-interconnect.
        
        :param ref_obj_list: list of VirtualNetwork object
        
        """
        self._pending_field_updates.add('virtual_network_refs')
        self._pending_ref_updates.discard('virtual_network_refs')
        super(DataCenterInterconnect, self).set_virtual_network_list(*args, **kwargs)
    # end set_virtual_network_list

    def set_routing_policy(self, *args, **kwargs):
        """Set routing-policy for data-center-interconnect.
        
        :param ref_obj: RoutingPolicy object
        
        """
        self._pending_field_updates.add('routing_policy_refs')
        self._pending_ref_updates.discard('routing_policy_refs')
        super(DataCenterInterconnect, self).set_routing_policy(*args, **kwargs)

    # end set_routing_policy

    def add_routing_policy(self, *args, **kwargs):
        """Add routing-policy to data-center-interconnect.
        
        :param ref_obj: RoutingPolicy object
        
        """
        if 'routing_policy_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('routing_policy_refs')
            self._original_routing_policy_refs = copy.deepcopy(self.get_routing_policy_refs() or [])
        super(DataCenterInterconnect, self).add_routing_policy(*args, **kwargs)
    # end add_routing_policy

    def del_routing_policy(self, *args, **kwargs):
        if 'routing_policy_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('routing_policy_refs')
            self._original_routing_policy_refs = copy.deepcopy(self.get_routing_policy_refs() or [])
        super(DataCenterInterconnect, self).del_routing_policy(*args, **kwargs)
    # end del_routing_policy

    def set_routing_policy_list(self, *args, **kwargs):
        """Set routing-policy list for data-center-interconnect.
        
        :param ref_obj_list: list of RoutingPolicy object
        
        """
        self._pending_field_updates.add('routing_policy_refs')
        self._pending_ref_updates.discard('routing_policy_refs')
        super(DataCenterInterconnect, self).set_routing_policy_list(*args, **kwargs)
    # end set_routing_policy_list

    def set_tag(self, *args, **kwargs):
        """Set tag for data-center-interconnect.
        
        :param ref_obj: Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(DataCenterInterconnect, self).set_tag(*args, **kwargs)

    # end set_tag

    def add_tag(self, *args, **kwargs):
        """Add tag to data-center-interconnect.
        
        :param ref_obj: Tag object
        
        """
        if 'tag_refs' not in self._pending_ref_updates|self._pending_field_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(DataCenterInterconnect, self).add_tag(*args, **kwargs)
    # end add_tag

    def del_tag(self, *args, **kwargs):
        if 'tag_refs' not in self._pending_ref_updates:
            self._pending_ref_updates.add('tag_refs')
            self._original_tag_refs = copy.deepcopy(self.get_tag_refs() or [])
        super(DataCenterInterconnect, self).del_tag(*args, **kwargs)
    # end del_tag

    def set_tag_list(self, *args, **kwargs):
        """Set tag list for data-center-interconnect.
        
        :param ref_obj_list: list of Tag object
        
        """
        self._pending_field_updates.add('tag_refs')
        self._pending_ref_updates.discard('tag_refs')
        super(DataCenterInterconnect, self).set_tag_list(*args, **kwargs)
    # end set_tag_list


# end class DataCenterInterconnect

