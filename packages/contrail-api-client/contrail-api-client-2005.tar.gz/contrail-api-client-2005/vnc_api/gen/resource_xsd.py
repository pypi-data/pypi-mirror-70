"""
This module defines the classes for types defined in :doc:`vnc_cfg.xsd`
"""
from __future__ import absolute_import
from builtins import map
from builtins import str
import json
from .generatedssuper import *
class MacAddressesType(GeneratedsSuper):
    """
    Attributes:
    * mac_address
        Type:           :class:`.None`

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'mac_address']
    attr_field_type_vals = {u'mac_address': {'restrictions': None, 'description': [], 'simple_type': None, 'is_complex': 0, 'restriction_type': None, 'is_array': True, 'required': None, 'attr_type': u'string'}}
    def __init__(self, mac_address=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _mac_address = params_dict[u"mac_address"]
        except KeyError:
            _mac_address = mac_address
        if not _mac_address:
            self.mac_address = []
        else:
            self.mac_address = _mac_address
    def factory(*args_, **kwargs_):
        if MacAddressesType.subclass:
            return MacAddressesType.subclass(*args_, **kwargs_)
        else:
            return MacAddressesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_mac_address(self): return self.mac_address
    def set_mac_address(self, mac_address): self.mac_address = mac_address
    def add_mac_address(self, value): self.mac_address.append(value)
    def insert_mac_address(self, index, value): self.mac_address[index] = value
    def delete_mac_address(self, value): self.mac_address.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.mac_address == other.mac_address)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.mac_address or [])))

    def __repr__(self):
        return ("mac_address = " + str(self.mac_address))

    def copy(self):
        cp = MacAddressesType()
        if self.mac_address is not None:
            cp.mac_address = list(self.mac_address)
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_mac_address ([obj.populate_string ("mac_address")])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='MacAddressesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MacAddressesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MacAddressesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='MacAddressesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for mac_address_ in self.mac_address:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smac-address>%s</%smac-address>%s' % (namespace_, self.gds_format_string(quote_xml(mac_address_).encode(ExternalEncoding), input_name='mac-address'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.mac_address
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MacAddressesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('mac_address=[\n')
        level += 1
        for mac_address_ in self.mac_address:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(mac_address_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='MacAddressesType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'mac-address':
            mac_address_ = child_.text
            mac_address_ = self.gds_validate_string(mac_address_, node, 'mac_address')
            self.mac_address.append(mac_address_)
# end class MacAddressesType


class IpAddressesType(GeneratedsSuper):
    """
    Attributes:
    * ip_address
        Type:           str, *one-of* xsd:string

        Description:
          String of standard notation of ipv4 or ipv6 address

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'ip_address']
    attr_field_type_vals = {u'ip_address': {'restrictions': [], 'description': [], 'simple_type': u'IpAddressType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': True, 'required': None, 'attr_type': u'string'}}
    def __init__(self, ip_address=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _ip_address = params_dict[u"ip_address"]
        except KeyError:
            _ip_address = ip_address
        if not _ip_address:
            self.ip_address = []
        else:
            self.ip_address = _ip_address
    def factory(*args_, **kwargs_):
        if IpAddressesType.subclass:
            return IpAddressesType.subclass(*args_, **kwargs_)
        else:
            return IpAddressesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ip_address(self): return self.ip_address
    def set_ip_address(self, ip_address): self.ip_address = ip_address
    def add_ip_address(self, value): self.ip_address.append(value)
    def insert_ip_address(self, index, value): self.ip_address[index] = value
    def delete_ip_address(self, value): self.ip_address.remove(value)
    def validate_IpAddressType(self, value):
        # Validate type IpAddressType, a restriction on xsd:string.
        pass
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.ip_address == other.ip_address)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.ip_address or [])))

    def __repr__(self):
        return ("ip_address = " + str(self.ip_address))

    def copy(self):
        cp = IpAddressesType()
        if self.ip_address is not None:
            cp.ip_address = list(self.ip_address)
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_ip_address ([obj.populate_string ("ip_address")])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='IpAddressesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IpAddressesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IpAddressesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='IpAddressesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ip_address_ in self.ip_address:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sip-address>%s</%sip-address>%s' % (namespace_, self.gds_format_string(quote_xml(ip_address_).encode(ExternalEncoding), input_name='ip-address'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.ip_address
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='IpAddressesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ip_address=[\n')
        level += 1
        for ip_address_ in self.ip_address:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ip_address_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='IpAddressesType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ip-address':
            ip_address_ = child_.text
            ip_address_ = self.gds_validate_string(ip_address_, node, 'ip_address')
            self.ip_address.append(ip_address_)
            self.validate_IpAddressType(self.ip_address)    # validate type IpAddressType
# end class IpAddressesType


class AllocationPoolType(GeneratedsSuper):
    """
    Attributes:
    * start
        Type:           str

    * end
        Type:           str

    * vrouter_specific_pool
        Type:           bool

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'start', u'end', u'vrouter_specific_pool']
    attr_field_type_vals = {u'vrouter_specific_pool': {'restrictions': None, 'description': [], 'simple_type': u'xsd:boolean', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'boolean'}, u'start': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'end': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}}
    def __init__(self, start=None, end=None, vrouter_specific_pool=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _start = params_dict[u"start"]
        except KeyError:
            _start = start
        self.start = _start
        try:
            _end = params_dict[u"end"]
        except KeyError:
            _end = end
        self.end = _end
        try:
            _vrouter_specific_pool = params_dict[u"vrouter_specific_pool"]
        except KeyError:
            _vrouter_specific_pool = vrouter_specific_pool
        self.vrouter_specific_pool = _vrouter_specific_pool
    def factory(*args_, **kwargs_):
        if AllocationPoolType.subclass:
            return AllocationPoolType.subclass(*args_, **kwargs_)
        else:
            return AllocationPoolType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_start(self): return self.start
    def set_start(self, start): self.start = start
    def get_end(self): return self.end
    def set_end(self, end): self.end = end
    def get_vrouter_specific_pool(self): return self.vrouter_specific_pool
    def set_vrouter_specific_pool(self, vrouter_specific_pool): self.vrouter_specific_pool = vrouter_specific_pool
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.start == other.start and
                    self.end == other.end and
                    self.vrouter_specific_pool == other.vrouter_specific_pool)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.start if self.start is not None else -7985492147856592190,
                     self.end if self.end is not None else -7985492147856592190,
                     self.vrouter_specific_pool if self.vrouter_specific_pool is not None else -7985492147856592190))

    def __repr__(self):
        return ("start = " + str(self.start) + ", " +
                "end = " + str(self.end) + ", " +
                "vrouter_specific_pool = " + str(self.vrouter_specific_pool))

    def copy(self):
        cp = AllocationPoolType()
        if self.start is not None:
            cp.start = self.start
        if self.end is not None:
            cp.end = self.end
        if self.vrouter_specific_pool is not None:
            cp.vrouter_specific_pool = self.vrouter_specific_pool
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_start (obj.populate_string ("start"))
        obj.set_end (obj.populate_string ("end"))
        obj.set_vrouter_specific_pool (obj.populate_boolean ("vrouter_specific_pool"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='AllocationPoolType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AllocationPoolType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AllocationPoolType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AllocationPoolType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.start is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstart>%s</%sstart>%s' % (namespace_, self.gds_format_string(quote_xml(self.start).encode(ExternalEncoding), input_name='start'), namespace_, eol_))
        if self.end is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%send>%s</%send>%s' % (namespace_, self.gds_format_string(quote_xml(self.end).encode(ExternalEncoding), input_name='end'), namespace_, eol_))
        if self.vrouter_specific_pool is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svrouter-specific-pool>%s</%svrouter-specific-pool>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.vrouter_specific_pool)), input_name='vrouter-specific-pool'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.start is not None or
            self.end is not None or
            self.vrouter_specific_pool is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AllocationPoolType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.start is not None:
            showIndent(outfile, level)
            outfile.write('start=%s,\n' % quote_python(self.start).encode(ExternalEncoding))
        if self.end is not None:
            showIndent(outfile, level)
            outfile.write('end=%s,\n' % quote_python(self.end).encode(ExternalEncoding))
        if self.vrouter_specific_pool is not None:
            showIndent(outfile, level)
            outfile.write('vrouter_specific_pool=%s,\n' % self.vrouter_specific_pool)
    def exportDict(self, name_='AllocationPoolType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'start':
            start_ = child_.text
            start_ = self.gds_validate_string(start_, node, 'start')
            self.start = start_
        elif nodeName_ == 'end':
            end_ = child_.text
            end_ = self.gds_validate_string(end_, node, 'end')
            self.end = end_
        elif nodeName_ == 'vrouter-specific-pool':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'vrouter_specific_pool')
            self.vrouter_specific_pool = ival_
# end class AllocationPoolType


class SubnetType(GeneratedsSuper):
    """
    Attributes:
    * ip_prefix
        Type:           str

    * ip_prefix_len
        Type:           int

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'ip_prefix', u'ip_prefix_len']
    attr_field_type_vals = {u'ip_prefix': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'ip_prefix_len': {'restrictions': None, 'description': [], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'integer'}}
    def __init__(self, ip_prefix=None, ip_prefix_len=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _ip_prefix = params_dict[u"ip_prefix"]
        except KeyError:
            _ip_prefix = ip_prefix
        self.ip_prefix = _ip_prefix
        try:
            _ip_prefix_len = params_dict[u"ip_prefix_len"]
        except KeyError:
            _ip_prefix_len = ip_prefix_len
        self.ip_prefix_len = _ip_prefix_len
    def factory(*args_, **kwargs_):
        if SubnetType.subclass:
            return SubnetType.subclass(*args_, **kwargs_)
        else:
            return SubnetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ip_prefix(self): return self.ip_prefix
    def set_ip_prefix(self, ip_prefix): self.ip_prefix = ip_prefix
    def get_ip_prefix_len(self): return self.ip_prefix_len
    def set_ip_prefix_len(self, ip_prefix_len): self.ip_prefix_len = ip_prefix_len
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.ip_prefix == other.ip_prefix and
                    self.ip_prefix_len == other.ip_prefix_len)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.ip_prefix if self.ip_prefix is not None else -7985492147856592190,
                     self.ip_prefix_len if self.ip_prefix_len is not None else -7985492147856592190))

    def __repr__(self):
        return ("ip_prefix = " + str(self.ip_prefix) + ", " +
                "ip_prefix_len = " + str(self.ip_prefix_len))

    def copy(self):
        cp = SubnetType()
        if self.ip_prefix is not None:
            cp.ip_prefix = self.ip_prefix
        if self.ip_prefix_len is not None:
            cp.ip_prefix_len = self.ip_prefix_len
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_ip_prefix (obj.populate_string ("ip_prefix"))
        obj.set_ip_prefix_len (obj.populate_integer ("ip_prefix_len"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='SubnetType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SubnetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SubnetType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SubnetType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ip_prefix is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sip-prefix>%s</%sip-prefix>%s' % (namespace_, self.gds_format_string(quote_xml(self.ip_prefix).encode(ExternalEncoding), input_name='ip-prefix'), namespace_, eol_))
        if self.ip_prefix_len is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sip-prefix-len>%s</%sip-prefix-len>%s' % (namespace_, self.gds_format_integer(self.ip_prefix_len, input_name='ip-prefix-len'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.ip_prefix is not None or
            self.ip_prefix_len is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SubnetType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ip_prefix is not None:
            showIndent(outfile, level)
            outfile.write('ip_prefix=%s,\n' % quote_python(self.ip_prefix).encode(ExternalEncoding))
        if self.ip_prefix_len is not None:
            showIndent(outfile, level)
            outfile.write('ip_prefix_len=%d,\n' % self.ip_prefix_len)
    def exportDict(self, name_='SubnetType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ip-prefix':
            ip_prefix_ = child_.text
            ip_prefix_ = self.gds_validate_string(ip_prefix_, node, 'ip_prefix')
            self.ip_prefix = ip_prefix_
        elif nodeName_ == 'ip-prefix-len':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ip_prefix_len')
            self.ip_prefix_len = ival_
# end class SubnetType


class VirtualRouterNetworkIpamType(GeneratedsSuper):
    """
    Attributes:
    * allocation_pools
        Type:           :class:`.AllocationPoolType`

        Created By:           User (optional)

        Description:
          List of ranges of ip address for vrouter specific allocation

    * subnet
        Type:           :class:`.SubnetType`

        Created By:           User (optional)

        Description:
          List of ip prefix and length for vrouter specific subnets

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'allocation_pools', u'subnet']
    attr_field_type_vals = {u'subnet': {'restrictions': None, 'description': [u'List of ip prefix and length for vrouter specific subnets'], 'simple_type': u'SubnetType', 'is_complex': 1, 'restriction_type': None, 'is_array': True, 'required': u'optional', 'attr_type': u'SubnetType'}, u'allocation_pools': {'restrictions': None, 'description': [u'List of ranges of ip address for vrouter specific allocation'], 'simple_type': u'AllocationPoolType', 'is_complex': 1, 'restriction_type': None, 'is_array': True, 'required': u'optional', 'attr_type': u'AllocationPoolType'}}
    def __init__(self, allocation_pools=None, subnet=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _allocation_pools = params_dict[u"allocation_pools"]
        except KeyError:
            _allocation_pools = allocation_pools
        if not _allocation_pools:
            self.allocation_pools = []
        else:
            if isinstance(_allocation_pools[0], dict):
                objs = [AllocationPoolType(params_dict=elem) for elem in _allocation_pools]
                self.allocation_pools = objs
            else:
                self.allocation_pools = _allocation_pools
        try:
            _subnet = params_dict[u"subnet"]
        except KeyError:
            _subnet = subnet
        if not _subnet:
            self.subnet = []
        else:
            if isinstance(_subnet[0], dict):
                objs = [SubnetType(params_dict=elem) for elem in _subnet]
                self.subnet = objs
            else:
                self.subnet = _subnet
    def factory(*args_, **kwargs_):
        if VirtualRouterNetworkIpamType.subclass:
            return VirtualRouterNetworkIpamType.subclass(*args_, **kwargs_)
        else:
            return VirtualRouterNetworkIpamType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_allocation_pools(self): return self.allocation_pools
    def set_allocation_pools(self, allocation_pools): self.allocation_pools = allocation_pools
    def add_allocation_pools(self, value): self.allocation_pools.append(value)
    def insert_allocation_pools(self, index, value): self.allocation_pools[index] = value
    def delete_allocation_pools(self, value): self.allocation_pools.remove(value)
    def get_subnet(self): return self.subnet
    def set_subnet(self, subnet): self.subnet = subnet
    def add_subnet(self, value): self.subnet.append(value)
    def insert_subnet(self, index, value): self.subnet[index] = value
    def delete_subnet(self, value): self.subnet.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.allocation_pools == other.allocation_pools and
                    self.subnet == other.subnet)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.allocation_pools or []),
                     tuple(self.subnet or [])))

    def __repr__(self):
        return ("allocation_pools = " + str(self.allocation_pools) + ", " +
                "subnet = " + str(self.subnet))

    def copy(self):
        cp = VirtualRouterNetworkIpamType()
        if self.allocation_pools is not None:
            cp.allocation_pools = [x.copy() for x in self.allocation_pools]
        if self.subnet is not None:
            cp.subnet = [x.copy() for x in self.subnet]
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_allocation_pools ([AllocationPoolType.populate ()])
        obj.set_subnet ([SubnetType.populate ()])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='VirtualRouterNetworkIpamType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VirtualRouterNetworkIpamType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VirtualRouterNetworkIpamType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VirtualRouterNetworkIpamType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for allocation_pools_ in self.allocation_pools:
            if isinstance(allocation_pools_, dict):
                allocation_pools_ = AllocationPoolType(**allocation_pools_)
            allocation_pools_.export_xml(outfile, level, namespace_, name_='allocation-pools', pretty_print=pretty_print)
        for subnet_ in self.subnet:
            if isinstance(subnet_, dict):
                subnet_ = SubnetType(**subnet_)
            subnet_.export_xml(outfile, level, namespace_, name_='subnet', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.allocation_pools or
            self.subnet
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='VirtualRouterNetworkIpamType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('allocation_pools=[\n')
        level += 1
        for allocation_pools_ in self.allocation_pools:
            showIndent(outfile, level)
            outfile.write('model_.AllocationPoolType(\n')
            allocation_pools_.exportLiteral(outfile, level, name_='AllocationPoolType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('subnet=[\n')
        level += 1
        for subnet_ in self.subnet:
            showIndent(outfile, level)
            outfile.write('model_.SubnetType(\n')
            subnet_.exportLiteral(outfile, level, name_='SubnetType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='VirtualRouterNetworkIpamType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'allocation-pools':
            obj_ = AllocationPoolType.factory()
            obj_.build(child_)
            self.allocation_pools.append(obj_)
        elif nodeName_ == 'subnet':
            obj_ = SubnetType.factory()
            obj_.build(child_)
            self.subnet.append(obj_)
# end class VirtualRouterNetworkIpamType


class AllowedAddressPair(GeneratedsSuper):
    """
    Attributes:
    * ip
        Type:           :class:`.SubnetType`

    * mac
        Type:           str

        Created By:           User (optional)

    * address_mode
        Type:           str, *one-of* [u'active-active', u'active-standby']

        Created By:           User (optional)

        Description:
          Address-mode active-backup is used for VRRP address.

          Address-mode active-active is used for ECMP.

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'ip', u'mac', u'address_mode']
    attr_field_type_vals = {u'ip': {'restrictions': None, 'description': [], 'simple_type': u'SubnetType', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'SubnetType'}, u'mac': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'address_mode': {'restrictions': [u'active-active', u'active-standby'], 'description': [u'Address-mode active-backup is used for VRRP address.                           Address-mode active-active is used for ECMP.'], 'simple_type': u'AddressMode', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'optional', 'attr_type': u'string'}}
    def __init__(self, ip=None, mac=None, address_mode=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _ip = params_dict[u"ip"]
        except KeyError:
            _ip = ip
        if isinstance(_ip, dict):
            obj = SubnetType(params_dict=_ip)
            self.ip = obj
        else:
            self.ip = _ip
        try:
            _mac = params_dict[u"mac"]
        except KeyError:
            _mac = mac
        self.mac = _mac
        try:
            _address_mode = params_dict[u"address_mode"]
        except KeyError:
            _address_mode = address_mode
        self.address_mode = _address_mode
    def factory(*args_, **kwargs_):
        if AllowedAddressPair.subclass:
            return AllowedAddressPair.subclass(*args_, **kwargs_)
        else:
            return AllowedAddressPair(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ip(self): return self.ip
    def set_ip(self, ip): self.ip = ip
    def get_mac(self): return self.mac
    def set_mac(self, mac): self.mac = mac
    def get_address_mode(self): return self.address_mode
    def set_address_mode(self, address_mode): self.address_mode = address_mode
    def validate_AddressMode(self, value):
        # Validate type AddressMode, a restriction on xsd:string.
        error = False
        if isinstance(value, list):
            error = set(value) - set([u'active-active', u'active-standby'])
        else:
            error = value not in [u'active-active', u'active-standby']
        if error:
            raise ValueError("AddressMode must be one of [u'active-active', u'active-standby']")
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.ip == other.ip and
                    self.mac == other.mac and
                    self.address_mode == other.address_mode)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.ip if self.ip is not None else -7985492147856592190,
                     self.mac if self.mac is not None else -7985492147856592190,
                     self.address_mode if self.address_mode is not None else -7985492147856592190))

    def __repr__(self):
        return ("ip = " + str(self.ip) + ", " +
                "mac = " + str(self.mac) + ", " +
                "address_mode = " + str(self.address_mode))

    def copy(self):
        cp = AllowedAddressPair()
        if self.ip is not None:
            cp.ip = self.ip.copy()
        if self.mac is not None:
            cp.mac = self.mac
        if self.address_mode is not None:
            cp.address_mode = self.address_mode
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_ip (SubnetType.populate ())
        obj.set_mac (obj.populate_string ("mac"))
        obj.set_address_mode (obj.populate_string ("address_mode"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='AllowedAddressPair', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AllowedAddressPair')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AllowedAddressPair'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AllowedAddressPair', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ip is not None:
            self.ip.export_xml(outfile, level, namespace_, name_='ip', pretty_print=pretty_print)
        if self.mac is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smac>%s</%smac>%s' % (namespace_, self.gds_format_string(quote_xml(self.mac).encode(ExternalEncoding), input_name='mac'), namespace_, eol_))
        if self.address_mode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saddress-mode>%s</%saddress-mode>%s' % (namespace_, self.gds_format_string(quote_xml(self.address_mode).encode(ExternalEncoding), input_name='address-mode'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.ip is not None or
            self.mac is not None or
            self.address_mode is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AllowedAddressPair'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ip is not None:
            showIndent(outfile, level)
            outfile.write('ip=model_.SubnetType(\n')
            self.ip.exportLiteral(outfile, level, name_='ip')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.mac is not None:
            showIndent(outfile, level)
            outfile.write('mac=%s,\n' % quote_python(self.mac).encode(ExternalEncoding))
        if self.address_mode is not None:
            showIndent(outfile, level)
            outfile.write('address_mode=%s,\n' % quote_python(self.address_mode).encode(ExternalEncoding))
    def exportDict(self, name_='AllowedAddressPair'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ip':
            obj_ = SubnetType.factory()
            obj_.build(child_)
            self.set_ip(obj_)
        elif nodeName_ == 'mac':
            mac_ = child_.text
            mac_ = self.gds_validate_string(mac_, node, 'mac')
            self.mac = mac_
        elif nodeName_ == 'address-mode':
            address_mode_ = child_.text
            address_mode_ = self.gds_validate_string(address_mode_, node, 'address_mode')
            self.address_mode = address_mode_
            self.validate_AddressMode(self.address_mode)    # validate type AddressMode
# end class AllowedAddressPair


class AllowedAddressPairs(GeneratedsSuper):
    """
    Attributes:
    * allowed_address_pair
        Type:           :class:`.AllowedAddressPair`

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'allowed_address_pair']
    attr_field_type_vals = {u'allowed_address_pair': {'restrictions': None, 'description': [], 'simple_type': u'AllowedAddressPair', 'is_complex': 1, 'restriction_type': None, 'is_array': True, 'required': None, 'attr_type': u'AllowedAddressPair'}}
    def __init__(self, allowed_address_pair=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _allowed_address_pair = params_dict[u"allowed_address_pair"]
        except KeyError:
            _allowed_address_pair = allowed_address_pair
        if not _allowed_address_pair:
            self.allowed_address_pair = []
        else:
            if isinstance(_allowed_address_pair[0], dict):
                objs = [AllowedAddressPair(params_dict=elem) for elem in _allowed_address_pair]
                self.allowed_address_pair = objs
            else:
                self.allowed_address_pair = _allowed_address_pair
    def factory(*args_, **kwargs_):
        if AllowedAddressPairs.subclass:
            return AllowedAddressPairs.subclass(*args_, **kwargs_)
        else:
            return AllowedAddressPairs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_allowed_address_pair(self): return self.allowed_address_pair
    def set_allowed_address_pair(self, allowed_address_pair): self.allowed_address_pair = allowed_address_pair
    def add_allowed_address_pair(self, value): self.allowed_address_pair.append(value)
    def insert_allowed_address_pair(self, index, value): self.allowed_address_pair[index] = value
    def delete_allowed_address_pair(self, value): self.allowed_address_pair.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.allowed_address_pair == other.allowed_address_pair)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.allowed_address_pair or [])))

    def __repr__(self):
        return ("allowed_address_pair = " + str(self.allowed_address_pair))

    def copy(self):
        cp = AllowedAddressPairs()
        if self.allowed_address_pair is not None:
            cp.allowed_address_pair = [x.copy() for x in self.allowed_address_pair]
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_allowed_address_pair ([AllowedAddressPair.populate ()])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='AllowedAddressPairs', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AllowedAddressPairs')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AllowedAddressPairs'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AllowedAddressPairs', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for allowed_address_pair_ in self.allowed_address_pair:
            if isinstance(allowed_address_pair_, dict):
                allowed_address_pair_ = AllowedAddressPair(**allowed_address_pair_)
            allowed_address_pair_.export_xml(outfile, level, namespace_, name_='allowed-address-pair', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.allowed_address_pair
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AllowedAddressPairs'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('allowed_address_pair=[\n')
        level += 1
        for allowed_address_pair_ in self.allowed_address_pair:
            showIndent(outfile, level)
            outfile.write('model_.AllowedAddressPair(\n')
            allowed_address_pair_.exportLiteral(outfile, level, name_='AllowedAddressPair')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='AllowedAddressPairs'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'allowed-address-pair':
            obj_ = AllowedAddressPair.factory()
            obj_.build(child_)
            self.allowed_address_pair.append(obj_)
# end class AllowedAddressPairs


class UuidType(GeneratedsSuper):
    """
    Attributes:
    * uuid_mslong
        Type:           int

    * uuid_lslong
        Type:           int

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'uuid_mslong', u'uuid_lslong']
    attr_field_type_vals = {u'uuid_mslong': {'restrictions': None, 'description': [], 'simple_type': u'xsd:unsignedLong', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'unsignedLong'}, u'uuid_lslong': {'restrictions': None, 'description': [], 'simple_type': u'xsd:unsignedLong', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'unsignedLong'}}
    def __init__(self, uuid_mslong=None, uuid_lslong=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _uuid_mslong = params_dict[u"uuid_mslong"]
        except KeyError:
            _uuid_mslong = uuid_mslong
        self.uuid_mslong = _uuid_mslong
        try:
            _uuid_lslong = params_dict[u"uuid_lslong"]
        except KeyError:
            _uuid_lslong = uuid_lslong
        self.uuid_lslong = _uuid_lslong
    def factory(*args_, **kwargs_):
        if UuidType.subclass:
            return UuidType.subclass(*args_, **kwargs_)
        else:
            return UuidType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uuid_mslong(self): return self.uuid_mslong
    def set_uuid_mslong(self, uuid_mslong): self.uuid_mslong = uuid_mslong
    def get_uuid_lslong(self): return self.uuid_lslong
    def set_uuid_lslong(self, uuid_lslong): self.uuid_lslong = uuid_lslong
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.uuid_mslong == other.uuid_mslong and
                    self.uuid_lslong == other.uuid_lslong)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.uuid_mslong if self.uuid_mslong is not None else -7985492147856592190,
                     self.uuid_lslong if self.uuid_lslong is not None else -7985492147856592190))

    def __repr__(self):
        return ("uuid_mslong = " + str(self.uuid_mslong) + ", " +
                "uuid_lslong = " + str(self.uuid_lslong))

    def copy(self):
        cp = UuidType()
        if self.uuid_mslong is not None:
            cp.uuid_mslong = self.uuid_mslong
        if self.uuid_lslong is not None:
            cp.uuid_lslong = self.uuid_lslong
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_uuid_mslong (obj.populate_unsignedLong ("uuid_mslong"))
        obj.set_uuid_lslong (obj.populate_unsignedLong ("uuid_lslong"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='UuidType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UuidType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='UuidType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='UuidType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.uuid_mslong is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%suuid-mslong>%s</%suuid-mslong>%s' % (namespace_, self.gds_format_integer(self.uuid_mslong, input_name='uuid-mslong'), namespace_, eol_))
        if self.uuid_lslong is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%suuid-lslong>%s</%suuid-lslong>%s' % (namespace_, self.gds_format_integer(self.uuid_lslong, input_name='uuid-lslong'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.uuid_mslong is not None or
            self.uuid_lslong is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='UuidType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.uuid_mslong is not None:
            showIndent(outfile, level)
            outfile.write('uuid_mslong=%d,\n' % self.uuid_mslong)
        if self.uuid_lslong is not None:
            showIndent(outfile, level)
            outfile.write('uuid_lslong=%d,\n' % self.uuid_lslong)
    def exportDict(self, name_='UuidType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'uuid-mslong':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'uuid_mslong')
            self.uuid_mslong = ival_
        elif nodeName_ == 'uuid-lslong':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'uuid_lslong')
            self.uuid_lslong = ival_
# end class UuidType


class SequenceType(GeneratedsSuper):
    """
    Attributes:
    * major
        Type:           int

        Created By:           User (required)

    * minor
        Type:           int

        Created By:           User (required)

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'major', u'minor']
    attr_field_type_vals = {u'major': {'restrictions': None, 'description': [], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'true', 'attr_type': u'integer'}, u'minor': {'restrictions': None, 'description': [], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'true', 'attr_type': u'integer'}}
    def __init__(self, major=None, minor=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _major = params_dict[u"major"]
        except KeyError:
            _major = major
        self.major = _major
        try:
            _minor = params_dict[u"minor"]
        except KeyError:
            _minor = minor
        self.minor = _minor
    def factory(*args_, **kwargs_):
        if SequenceType.subclass:
            return SequenceType.subclass(*args_, **kwargs_)
        else:
            return SequenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_major(self): return self.major
    def set_major(self, major): self.major = major
    def get_minor(self): return self.minor
    def set_minor(self, minor): self.minor = minor
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.major == other.major and
                    self.minor == other.minor)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.major if self.major is not None else -7985492147856592190,
                     self.minor if self.minor is not None else -7985492147856592190))

    def __repr__(self):
        return ("major = " + str(self.major) + ", " +
                "minor = " + str(self.minor))

    def copy(self):
        cp = SequenceType()
        if self.major is not None:
            cp.major = self.major
        if self.minor is not None:
            cp.minor = self.minor
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_major (obj.populate_integer ("major"))
        obj.set_minor (obj.populate_integer ("minor"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='SequenceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SequenceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SequenceType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SequenceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.major is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smajor>%s</%smajor>%s' % (namespace_, self.gds_format_integer(self.major, input_name='major'), namespace_, eol_))
        if self.minor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sminor>%s</%sminor>%s' % (namespace_, self.gds_format_integer(self.minor, input_name='minor'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.major is not None or
            self.minor is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SequenceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.major is not None:
            showIndent(outfile, level)
            outfile.write('major=%d,\n' % self.major)
        if self.minor is not None:
            showIndent(outfile, level)
            outfile.write('minor=%d,\n' % self.minor)
    def exportDict(self, name_='SequenceType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'major':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'major')
            self.major = ival_
        elif nodeName_ == 'minor':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'minor')
            self.minor = ival_
# end class SequenceType


class TimerType(GeneratedsSuper):
    """
    Attributes:
    * start_time
        Type:           :class:`.xsd:dateTime`

        Created By:           User (required)

    * on_interval
        Type:           str

        Created By:           User (required)

    * off_interval
        Type:           str

        Created By:           User (required)

    * end_time
        Type:           :class:`.xsd:dateTime`

        Created By:           User (required)

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'start_time', u'on_interval', u'off_interval', u'end_time']
    attr_field_type_vals = {u'start_time': {'restrictions': None, 'description': [], 'simple_type': u'xsd:dateTime', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'true', 'attr_type': u'dateTime'}, u'off_interval': {'restrictions': None, 'description': [], 'simple_type': u'xsd:time', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'true', 'attr_type': u'time'}, u'on_interval': {'restrictions': None, 'description': [], 'simple_type': u'xsd:time', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'true', 'attr_type': u'time'}, u'end_time': {'restrictions': None, 'description': [], 'simple_type': u'xsd:dateTime', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'true', 'attr_type': u'dateTime'}}
    def __init__(self, start_time=None, on_interval=None, off_interval=None, end_time=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _start_time = params_dict[u"start_time"]
        except KeyError:
            _start_time = start_time
        self.start_time = _start_time
        try:
            _on_interval = params_dict[u"on_interval"]
        except KeyError:
            _on_interval = on_interval
        self.on_interval = _on_interval
        try:
            _off_interval = params_dict[u"off_interval"]
        except KeyError:
            _off_interval = off_interval
        self.off_interval = _off_interval
        try:
            _end_time = params_dict[u"end_time"]
        except KeyError:
            _end_time = end_time
        self.end_time = _end_time
    def factory(*args_, **kwargs_):
        if TimerType.subclass:
            return TimerType.subclass(*args_, **kwargs_)
        else:
            return TimerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_start_time(self): return self.start_time
    def set_start_time(self, start_time): self.start_time = start_time
    def get_on_interval(self): return self.on_interval
    def set_on_interval(self, on_interval): self.on_interval = on_interval
    def get_off_interval(self): return self.off_interval
    def set_off_interval(self, off_interval): self.off_interval = off_interval
    def get_end_time(self): return self.end_time
    def set_end_time(self, end_time): self.end_time = end_time
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.start_time == other.start_time and
                    self.on_interval == other.on_interval and
                    self.off_interval == other.off_interval and
                    self.end_time == other.end_time)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.start_time if self.start_time is not None else -7985492147856592190,
                     self.on_interval if self.on_interval is not None else -7985492147856592190,
                     self.off_interval if self.off_interval is not None else -7985492147856592190,
                     self.end_time if self.end_time is not None else -7985492147856592190))

    def __repr__(self):
        return ("start_time = " + str(self.start_time) + ", " +
                "on_interval = " + str(self.on_interval) + ", " +
                "off_interval = " + str(self.off_interval) + ", " +
                "end_time = " + str(self.end_time))

    def copy(self):
        cp = TimerType()
        if self.start_time is not None:
            cp.start_time = self.start_time
        if self.on_interval is not None:
            cp.on_interval = self.on_interval
        if self.off_interval is not None:
            cp.off_interval = self.off_interval
        if self.end_time is not None:
            cp.end_time = self.end_time
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_start_time (obj.populate_dateTime ("start_time"))
        obj.set_on_interval (obj.populate_time ("on_interval"))
        obj.set_off_interval (obj.populate_time ("off_interval"))
        obj.set_end_time (obj.populate_dateTime ("end_time"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='TimerType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimerType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TimerType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TimerType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.start_time is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstart-time>%s</%sstart-time>%s' % (namespace_, self.gds_format_string(quote_xml(self.start_time).encode(ExternalEncoding), input_name='start-time'), namespace_, eol_))
        if self.on_interval is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%son-interval>%s</%son-interval>%s' % (namespace_, self.gds_format_string(quote_xml(self.on_interval).encode(ExternalEncoding), input_name='on-interval'), namespace_, eol_))
        if self.off_interval is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soff-interval>%s</%soff-interval>%s' % (namespace_, self.gds_format_string(quote_xml(self.off_interval).encode(ExternalEncoding), input_name='off-interval'), namespace_, eol_))
        if self.end_time is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%send-time>%s</%send-time>%s' % (namespace_, self.gds_format_string(quote_xml(self.end_time).encode(ExternalEncoding), input_name='end-time'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.start_time is not None or
            self.on_interval is not None or
            self.off_interval is not None or
            self.end_time is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TimerType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.start_time is not None:
            showIndent(outfile, level)
            outfile.write('start_time=%s,\n' % quote_python(self.start_time).encode(ExternalEncoding))
        if self.on_interval is not None:
            showIndent(outfile, level)
            outfile.write('on_interval=%s,\n' % quote_python(self.on_interval).encode(ExternalEncoding))
        if self.off_interval is not None:
            showIndent(outfile, level)
            outfile.write('off_interval=%s,\n' % quote_python(self.off_interval).encode(ExternalEncoding))
        if self.end_time is not None:
            showIndent(outfile, level)
            outfile.write('end_time=%s,\n' % quote_python(self.end_time).encode(ExternalEncoding))
    def exportDict(self, name_='TimerType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'start-time':
            start_time_ = child_.text
            start_time_ = self.gds_validate_string(start_time_, node, 'start_time')
            self.start_time = start_time_
        elif nodeName_ == 'on-interval':
            on_interval_ = child_.text
            on_interval_ = self.gds_validate_string(on_interval_, node, 'on_interval')
            self.on_interval = on_interval_
        elif nodeName_ == 'off-interval':
            off_interval_ = child_.text
            off_interval_ = self.gds_validate_string(off_interval_, node, 'off_interval')
            self.off_interval = off_interval_
        elif nodeName_ == 'end-time':
            end_time_ = child_.text
            end_time_ = self.gds_validate_string(end_time_, node, 'end_time')
            self.end_time = end_time_
# end class TimerType


class VirtualNetworkPolicyType(GeneratedsSuper):
    """
    Attributes:
    * sequence
        Type:           :class:`.SequenceType`

        Created By:           User (optional)

        Description:
          Sequence number to specify order of policy attachment to network

    * timer
        Type:           :class:`.TimerType`

        Created By:           User (optional)

        Description:
          Timer to specify when the policy can be active

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'sequence', u'timer']
    attr_field_type_vals = {u'timer': {'restrictions': None, 'description': [u'Timer to specify when the policy can be active'], 'simple_type': u'TimerType', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'TimerType'}, u'sequence': {'restrictions': None, 'description': [u'Sequence number to specify order of policy attachment to network'], 'simple_type': u'SequenceType', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'SequenceType'}}
    def __init__(self, sequence=None, timer=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _sequence = params_dict[u"sequence"]
        except KeyError:
            _sequence = sequence
        if isinstance(_sequence, dict):
            obj = SequenceType(params_dict=_sequence)
            self.sequence = obj
        else:
            self.sequence = _sequence
        try:
            _timer = params_dict[u"timer"]
        except KeyError:
            _timer = timer
        if isinstance(_timer, dict):
            obj = TimerType(params_dict=_timer)
            self.timer = obj
        else:
            self.timer = _timer
    def factory(*args_, **kwargs_):
        if VirtualNetworkPolicyType.subclass:
            return VirtualNetworkPolicyType.subclass(*args_, **kwargs_)
        else:
            return VirtualNetworkPolicyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_sequence(self): return self.sequence
    def set_sequence(self, sequence): self.sequence = sequence
    def get_timer(self): return self.timer
    def set_timer(self, timer): self.timer = timer
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.sequence == other.sequence and
                    self.timer == other.timer)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.sequence if self.sequence is not None else -7985492147856592190,
                     self.timer if self.timer is not None else -7985492147856592190))

    def __repr__(self):
        return ("sequence = " + str(self.sequence) + ", " +
                "timer = " + str(self.timer))

    def copy(self):
        cp = VirtualNetworkPolicyType()
        if self.sequence is not None:
            cp.sequence = self.sequence.copy()
        if self.timer is not None:
            cp.timer = self.timer.copy()
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_sequence (SequenceType.populate ())
        obj.set_timer (TimerType.populate ())
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='VirtualNetworkPolicyType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VirtualNetworkPolicyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VirtualNetworkPolicyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VirtualNetworkPolicyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.sequence is not None:
            self.sequence.export_xml(outfile, level, namespace_, name_='sequence', pretty_print=pretty_print)
        if self.timer is not None:
            self.timer.export_xml(outfile, level, namespace_, name_='timer', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.sequence is not None or
            self.timer is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='VirtualNetworkPolicyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.sequence is not None:
            showIndent(outfile, level)
            outfile.write('sequence=model_.SequenceType(\n')
            self.sequence.exportLiteral(outfile, level, name_='sequence')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.timer is not None:
            showIndent(outfile, level)
            outfile.write('timer=model_.TimerType(\n')
            self.timer.exportLiteral(outfile, level, name_='timer')
            showIndent(outfile, level)
            outfile.write('),\n')
    def exportDict(self, name_='VirtualNetworkPolicyType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'sequence':
            obj_ = SequenceType.factory()
            obj_.build(child_)
            self.set_sequence(obj_)
        elif nodeName_ == 'timer':
            obj_ = TimerType.factory()
            obj_.build(child_)
            self.set_timer(obj_)
# end class VirtualNetworkPolicyType


class AddressType(GeneratedsSuper):
    """
    Attributes:
    * subnet
        Type:           :class:`.SubnetType`

        Created By:           User (optional)

        Description:
          Any address that belongs to this subnet

    * virtual_network
        Type:           str

        Created By:           User (optional)

        Description:
          Any address that belongs to this virtual network

    * security_group
        Type:           str

        Created By:           User (optional)

        Description:
          Any address that belongs to interface with this security-group

    * network_policy
        Type:           str

        Created By:           User (optional)

        Description:
          Any address that belongs to virtual network which has this policy attached

    * subnet_list
        Type:           :class:`.SubnetType`

        Created By:           User (optional)

        Description:
          Any address that belongs to any one of subnet in this list

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'subnet', u'virtual_network', u'security_group', u'network_policy', u'subnet_list']
    attr_field_type_vals = {u'security_group': {'restrictions': None, 'description': [u'Any address that belongs to interface with this security-group'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'exclusive', 'attr_type': u'string'}, u'subnet': {'restrictions': None, 'description': [u'Any address that belongs to this subnet'], 'simple_type': u'SubnetType', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': u'exclusive', 'attr_type': u'SubnetType'}, u'network_policy': {'restrictions': None, 'description': [u'Any address that belongs to virtual network which has this policy attached'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'exclusive', 'attr_type': u'string'}, u'subnet_list': {'restrictions': None, 'description': [u'Any address that belongs to any one of subnet in this list'], 'simple_type': u'SubnetType', 'is_complex': 1, 'restriction_type': None, 'is_array': True, 'required': u'exclusive', 'attr_type': u'SubnetType'}, u'virtual_network': {'restrictions': None, 'description': [u'Any address that belongs to this virtual network '], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'exclusive', 'attr_type': u'string'}}
    def __init__(self, subnet=None, virtual_network=None, security_group=None, network_policy=None, subnet_list=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _subnet = params_dict[u"subnet"]
        except KeyError:
            _subnet = subnet
        if isinstance(_subnet, dict):
            obj = SubnetType(params_dict=_subnet)
            self.subnet = obj
        else:
            self.subnet = _subnet
        try:
            _virtual_network = params_dict[u"virtual_network"]
        except KeyError:
            _virtual_network = virtual_network
        self.virtual_network = _virtual_network
        try:
            _security_group = params_dict[u"security_group"]
        except KeyError:
            _security_group = security_group
        self.security_group = _security_group
        try:
            _network_policy = params_dict[u"network_policy"]
        except KeyError:
            _network_policy = network_policy
        self.network_policy = _network_policy
        try:
            _subnet_list = params_dict[u"subnet_list"]
        except KeyError:
            _subnet_list = subnet_list
        if not _subnet_list:
            self.subnet_list = []
        else:
            if isinstance(_subnet_list[0], dict):
                objs = [SubnetType(params_dict=elem) for elem in _subnet_list]
                self.subnet_list = objs
            else:
                self.subnet_list = _subnet_list
    def factory(*args_, **kwargs_):
        if AddressType.subclass:
            return AddressType.subclass(*args_, **kwargs_)
        else:
            return AddressType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_subnet(self): return self.subnet
    def set_subnet(self, subnet): self.subnet = subnet
    def get_virtual_network(self): return self.virtual_network
    def set_virtual_network(self, virtual_network): self.virtual_network = virtual_network
    def get_security_group(self): return self.security_group
    def set_security_group(self, security_group): self.security_group = security_group
    def get_network_policy(self): return self.network_policy
    def set_network_policy(self, network_policy): self.network_policy = network_policy
    def get_subnet_list(self): return self.subnet_list
    def set_subnet_list(self, subnet_list): self.subnet_list = subnet_list
    def add_subnet_list(self, value): self.subnet_list.append(value)
    def insert_subnet_list(self, index, value): self.subnet_list[index] = value
    def delete_subnet_list(self, value): self.subnet_list.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.subnet == other.subnet and
                    self.virtual_network == other.virtual_network and
                    self.security_group == other.security_group and
                    self.network_policy == other.network_policy and
                    self.subnet_list == other.subnet_list)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.subnet if self.subnet is not None else -7985492147856592190,
                     self.virtual_network if self.virtual_network is not None else -7985492147856592190,
                     self.security_group if self.security_group is not None else -7985492147856592190,
                     self.network_policy if self.network_policy is not None else -7985492147856592190,
                     tuple(self.subnet_list or [])))

    def __repr__(self):
        return ("subnet = " + str(self.subnet) + ", " +
                "virtual_network = " + str(self.virtual_network) + ", " +
                "security_group = " + str(self.security_group) + ", " +
                "network_policy = " + str(self.network_policy) + ", " +
                "subnet_list = " + str(self.subnet_list))

    def copy(self):
        cp = AddressType()
        if self.subnet is not None:
            cp.subnet = self.subnet.copy()
        if self.virtual_network is not None:
            cp.virtual_network = self.virtual_network
        if self.security_group is not None:
            cp.security_group = self.security_group
        if self.network_policy is not None:
            cp.network_policy = self.network_policy
        if self.subnet_list is not None:
            cp.subnet_list = [x.copy() for x in self.subnet_list]
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_subnet (SubnetType.populate ())
        obj.set_virtual_network (obj.populate_string ("virtual_network"))
        obj.set_security_group (obj.populate_string ("security_group"))
        obj.set_network_policy (obj.populate_string ("network_policy"))
        obj.set_subnet_list ([SubnetType.populate ()])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='AddressType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AddressType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AddressType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AddressType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.subnet is not None:
            self.subnet.export_xml(outfile, level, namespace_, name_='subnet', pretty_print=pretty_print)
        if self.virtual_network is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svirtual-network>%s</%svirtual-network>%s' % (namespace_, self.gds_format_string(quote_xml(self.virtual_network).encode(ExternalEncoding), input_name='virtual-network'), namespace_, eol_))
        if self.security_group is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssecurity-group>%s</%ssecurity-group>%s' % (namespace_, self.gds_format_string(quote_xml(self.security_group).encode(ExternalEncoding), input_name='security-group'), namespace_, eol_))
        if self.network_policy is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snetwork-policy>%s</%snetwork-policy>%s' % (namespace_, self.gds_format_string(quote_xml(self.network_policy).encode(ExternalEncoding), input_name='network-policy'), namespace_, eol_))
        for subnet_list_ in self.subnet_list:
            if isinstance(subnet_list_, dict):
                subnet_list_ = SubnetType(**subnet_list_)
            subnet_list_.export_xml(outfile, level, namespace_, name_='subnet-list', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.subnet is not None or
            self.virtual_network is not None or
            self.security_group is not None or
            self.network_policy is not None or
            self.subnet_list
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AddressType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.subnet is not None:
            showIndent(outfile, level)
            outfile.write('subnet=model_.SubnetType(\n')
            self.subnet.exportLiteral(outfile, level, name_='subnet')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.virtual_network is not None:
            showIndent(outfile, level)
            outfile.write('virtual_network=%s,\n' % quote_python(self.virtual_network).encode(ExternalEncoding))
        if self.security_group is not None:
            showIndent(outfile, level)
            outfile.write('security_group=%s,\n' % quote_python(self.security_group).encode(ExternalEncoding))
        if self.network_policy is not None:
            showIndent(outfile, level)
            outfile.write('network_policy=%s,\n' % quote_python(self.network_policy).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('subnet_list=[\n')
        level += 1
        for subnet_list_ in self.subnet_list:
            showIndent(outfile, level)
            outfile.write('model_.SubnetType(\n')
            subnet_list_.exportLiteral(outfile, level, name_='SubnetType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='AddressType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'subnet':
            obj_ = SubnetType.factory()
            obj_.build(child_)
            self.set_subnet(obj_)
        elif nodeName_ == 'virtual-network':
            virtual_network_ = child_.text
            virtual_network_ = self.gds_validate_string(virtual_network_, node, 'virtual_network')
            self.virtual_network = virtual_network_
        elif nodeName_ == 'security-group':
            security_group_ = child_.text
            security_group_ = self.gds_validate_string(security_group_, node, 'security_group')
            self.security_group = security_group_
        elif nodeName_ == 'network-policy':
            network_policy_ = child_.text
            network_policy_ = self.gds_validate_string(network_policy_, node, 'network_policy')
            self.network_policy = network_policy_
        elif nodeName_ == 'subnet-list':
            obj_ = SubnetType.factory()
            obj_.build(child_)
            self.subnet_list.append(obj_)
# end class AddressType


class PortType(GeneratedsSuper):
    """
    Attributes:
    * start_port
        Type:           int, *within* [-1, 65535]

        Created By:           User (required)

    * end_port
        Type:           int, *within* [-1, 65535]

        Created By:           User (required)

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'start_port', u'end_port']
    attr_field_type_vals = {u'end_port': {'restrictions': [-1, 65535], 'description': [], 'simple_type': u'L4PortType', 'is_complex': 0, 'restriction_type': 'range', 'is_array': False, 'required': u'true', 'attr_type': u'integer'}, u'start_port': {'restrictions': [-1, 65535], 'description': [], 'simple_type': u'L4PortType', 'is_complex': 0, 'restriction_type': 'range', 'is_array': False, 'required': u'true', 'attr_type': u'integer'}}
    def __init__(self, start_port=0, end_port=65535, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _start_port = params_dict[u"start_port"]
        except KeyError:
            _start_port = start_port
        self.start_port = _start_port
        try:
            _end_port = params_dict[u"end_port"]
        except KeyError:
            _end_port = end_port
        self.end_port = _end_port
    def factory(*args_, **kwargs_):
        if PortType.subclass:
            return PortType.subclass(*args_, **kwargs_)
        else:
            return PortType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_start_port(self): return self.start_port
    def set_start_port(self, start_port): self.start_port = start_port
    def validate_L4PortType(self, value):
        # Validate type L4PortType, a restriction on xsd:integer.
        error = False
        if isinstance(value, list):
            v_int = list(map(int, value))
            v1, v2 = min(v_int), max(v_int)
        else:
            v1, v2 = int(value), int(value)
        error = (-1 > v1)
        error |= (v2 > 65535)
        if error:
            raise ValueError("L4PortType must be in the range {'minimum': -1}-{'maximum': 65535}")
    def get_end_port(self): return self.end_port
    def set_end_port(self, end_port): self.end_port = end_port
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.start_port == other.start_port and
                    self.end_port == other.end_port)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.start_port if self.start_port is not None else -7985492147856592190,
                     self.end_port if self.end_port is not None else -7985492147856592190))

    def __repr__(self):
        return ("start_port = " + str(self.start_port) + ", " +
                "end_port = " + str(self.end_port))

    def copy(self):
        cp = PortType()
        if self.start_port is not None:
            cp.start_port = self.start_port
        if self.end_port is not None:
            cp.end_port = self.end_port
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_start_port (obj.populate_integer ("start_port"))
        obj.set_end_port (obj.populate_integer ("end_port"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='PortType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PortType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PortType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PortType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.start_port is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstart-port>%s</%sstart-port>%s' % (namespace_, self.gds_format_integer(self.start_port, input_name='start-port'), namespace_, eol_))
        if self.end_port is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%send-port>%s</%send-port>%s' % (namespace_, self.gds_format_integer(self.end_port, input_name='end-port'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.start_port is not None or
            self.end_port is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PortType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.start_port is not None:
            showIndent(outfile, level)
            outfile.write('start_port=%d,\n' % self.start_port)
        if self.end_port is not None:
            showIndent(outfile, level)
            outfile.write('end_port=%d,\n' % self.end_port)
    def exportDict(self, name_='PortType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'start-port':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'start_port')
            self.start_port = ival_
            self.validate_L4PortType(self.start_port)    # validate type L4PortType
        elif nodeName_ == 'end-port':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'end_port')
            self.end_port = ival_
            self.validate_L4PortType(self.end_port)    # validate type L4PortType
# end class PortType


class PortMap(GeneratedsSuper):
    """
    Attributes:
    * protocol
        Type:           str

    * src_port
        Type:           int

    * dst_port
        Type:           int

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'protocol', u'src_port', u'dst_port']
    attr_field_type_vals = {u'src_port': {'restrictions': None, 'description': [], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'integer'}, u'protocol': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'dst_port': {'restrictions': None, 'description': [], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'integer'}}
    def __init__(self, protocol=None, src_port=None, dst_port=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _protocol = params_dict[u"protocol"]
        except KeyError:
            _protocol = protocol
        self.protocol = _protocol
        try:
            _src_port = params_dict[u"src_port"]
        except KeyError:
            _src_port = src_port
        self.src_port = _src_port
        try:
            _dst_port = params_dict[u"dst_port"]
        except KeyError:
            _dst_port = dst_port
        self.dst_port = _dst_port
    def factory(*args_, **kwargs_):
        if PortMap.subclass:
            return PortMap.subclass(*args_, **kwargs_)
        else:
            return PortMap(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_protocol(self): return self.protocol
    def set_protocol(self, protocol): self.protocol = protocol
    def get_src_port(self): return self.src_port
    def set_src_port(self, src_port): self.src_port = src_port
    def get_dst_port(self): return self.dst_port
    def set_dst_port(self, dst_port): self.dst_port = dst_port
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.protocol == other.protocol and
                    self.src_port == other.src_port and
                    self.dst_port == other.dst_port)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.protocol if self.protocol is not None else -7985492147856592190,
                     self.src_port if self.src_port is not None else -7985492147856592190,
                     self.dst_port if self.dst_port is not None else -7985492147856592190))

    def __repr__(self):
        return ("protocol = " + str(self.protocol) + ", " +
                "src_port = " + str(self.src_port) + ", " +
                "dst_port = " + str(self.dst_port))

    def copy(self):
        cp = PortMap()
        if self.protocol is not None:
            cp.protocol = self.protocol
        if self.src_port is not None:
            cp.src_port = self.src_port
        if self.dst_port is not None:
            cp.dst_port = self.dst_port
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_protocol (obj.populate_string ("protocol"))
        obj.set_src_port (obj.populate_integer ("src_port"))
        obj.set_dst_port (obj.populate_integer ("dst_port"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='PortMap', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PortMap')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PortMap'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PortMap', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.protocol is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprotocol>%s</%sprotocol>%s' % (namespace_, self.gds_format_string(quote_xml(self.protocol).encode(ExternalEncoding), input_name='protocol'), namespace_, eol_))
        if self.src_port is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssrc-port>%s</%ssrc-port>%s' % (namespace_, self.gds_format_integer(self.src_port, input_name='src-port'), namespace_, eol_))
        if self.dst_port is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdst-port>%s</%sdst-port>%s' % (namespace_, self.gds_format_integer(self.dst_port, input_name='dst-port'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.protocol is not None or
            self.src_port is not None or
            self.dst_port is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PortMap'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.protocol is not None:
            showIndent(outfile, level)
            outfile.write('protocol=%s,\n' % quote_python(self.protocol).encode(ExternalEncoding))
        if self.src_port is not None:
            showIndent(outfile, level)
            outfile.write('src_port=%d,\n' % self.src_port)
        if self.dst_port is not None:
            showIndent(outfile, level)
            outfile.write('dst_port=%d,\n' % self.dst_port)
    def exportDict(self, name_='PortMap'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'protocol':
            protocol_ = child_.text
            protocol_ = self.gds_validate_string(protocol_, node, 'protocol')
            self.protocol = protocol_
        elif nodeName_ == 'src-port':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'src_port')
            self.src_port = ival_
        elif nodeName_ == 'dst-port':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'dst_port')
            self.dst_port = ival_
# end class PortMap


class PortMappings(GeneratedsSuper):
    """
    Attributes:
    * port_mappings
        Type:           :class:`.PortMap`

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'port_mappings']
    attr_field_type_vals = {u'port_mappings': {'restrictions': None, 'description': [], 'simple_type': u'PortMap', 'is_complex': 1, 'restriction_type': None, 'is_array': True, 'required': None, 'attr_type': u'PortMap'}}
    def __init__(self, port_mappings=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _port_mappings = params_dict[u"port_mappings"]
        except KeyError:
            _port_mappings = port_mappings
        if not _port_mappings:
            self.port_mappings = []
        else:
            if isinstance(_port_mappings[0], dict):
                objs = [PortMap(params_dict=elem) for elem in _port_mappings]
                self.port_mappings = objs
            else:
                self.port_mappings = _port_mappings
    def factory(*args_, **kwargs_):
        if PortMappings.subclass:
            return PortMappings.subclass(*args_, **kwargs_)
        else:
            return PortMappings(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_port_mappings(self): return self.port_mappings
    def set_port_mappings(self, port_mappings): self.port_mappings = port_mappings
    def add_port_mappings(self, value): self.port_mappings.append(value)
    def insert_port_mappings(self, index, value): self.port_mappings[index] = value
    def delete_port_mappings(self, value): self.port_mappings.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.port_mappings == other.port_mappings)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.port_mappings or [])))

    def __repr__(self):
        return ("port_mappings = " + str(self.port_mappings))

    def copy(self):
        cp = PortMappings()
        if self.port_mappings is not None:
            cp.port_mappings = [x.copy() for x in self.port_mappings]
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_port_mappings ([PortMap.populate ()])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='PortMappings', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PortMappings')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PortMappings'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PortMappings', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for port_mappings_ in self.port_mappings:
            if isinstance(port_mappings_, dict):
                port_mappings_ = PortMap(**port_mappings_)
            port_mappings_.export_xml(outfile, level, namespace_, name_='port-mappings', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.port_mappings
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PortMappings'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('port_mappings=[\n')
        level += 1
        for port_mappings_ in self.port_mappings:
            showIndent(outfile, level)
            outfile.write('model_.PortMap(\n')
            port_mappings_.exportLiteral(outfile, level, name_='PortMap')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='PortMappings'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'port-mappings':
            obj_ = PortMap.factory()
            obj_.build(child_)
            self.port_mappings.append(obj_)
# end class PortMappings


class MatchConditionType(GeneratedsSuper):
    """
    Attributes:
    * protocol
        Type:           str

        Created By:           User (required)

        Description:
          Layer 4 protocol in ip packet

    * src_address
        Type:           :class:`.AddressType`

        Created By:           User (required)

        Description:
          Source ip matching criteria

    * src_port
        Type:           :class:`.PortType`

        Created By:           User (required)

        Description:
          Range of source port for layer 4 protocol

    * dst_address
        Type:           :class:`.AddressType`

        Created By:           User (required)

        Description:
          Destination ip matching criteria

    * dst_port
        Type:           :class:`.PortType`

        Created By:           User (required)

        Description:
          Range of destination  port for layer 4 protocol

    * ethertype
        Type:           str, *one-of* [u'IPv4', u'IPv6']

        Created By:           User (required)

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'protocol', u'src_address', u'src_port', u'dst_address', u'dst_port', u'ethertype']
    attr_field_type_vals = {u'src_port': {'restrictions': None, 'description': [u'Range of source port for layer 4 protocol'], 'simple_type': u'PortType', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': u'true', 'attr_type': u'PortType'}, u'src_address': {'restrictions': None, 'description': [u'Source ip matching criteria'], 'simple_type': u'AddressType', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': u'true', 'attr_type': u'AddressType'}, u'ethertype': {'restrictions': [u'IPv4', u'IPv6'], 'description': [], 'simple_type': u'EtherType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'true', 'attr_type': u'string'}, u'dst_address': {'restrictions': None, 'description': [u'Destination ip matching criteria'], 'simple_type': u'AddressType', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': u'true', 'attr_type': u'AddressType'}, u'dst_port': {'restrictions': None, 'description': [u'Range of destination  port for layer 4 protocol'], 'simple_type': u'PortType', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': u'true', 'attr_type': u'PortType'}, u'protocol': {'restrictions': None, 'description': [u'Layer 4 protocol in ip packet'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'true', 'attr_type': u'string'}}
    def __init__(self, protocol=None, src_address=None, src_port=None, dst_address=None, dst_port=None, ethertype=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _protocol = params_dict[u"protocol"]
        except KeyError:
            _protocol = protocol
        self.protocol = _protocol
        try:
            _src_address = params_dict[u"src_address"]
        except KeyError:
            _src_address = src_address
        if isinstance(_src_address, dict):
            obj = AddressType(params_dict=_src_address)
            self.src_address = obj
        else:
            self.src_address = _src_address
        try:
            _src_port = params_dict[u"src_port"]
        except KeyError:
            _src_port = src_port
        if isinstance(_src_port, dict):
            obj = PortType(params_dict=_src_port)
            self.src_port = obj
        else:
            self.src_port = _src_port
        try:
            _dst_address = params_dict[u"dst_address"]
        except KeyError:
            _dst_address = dst_address
        if isinstance(_dst_address, dict):
            obj = AddressType(params_dict=_dst_address)
            self.dst_address = obj
        else:
            self.dst_address = _dst_address
        try:
            _dst_port = params_dict[u"dst_port"]
        except KeyError:
            _dst_port = dst_port
        if isinstance(_dst_port, dict):
            obj = PortType(params_dict=_dst_port)
            self.dst_port = obj
        else:
            self.dst_port = _dst_port
        try:
            _ethertype = params_dict[u"ethertype"]
        except KeyError:
            _ethertype = ethertype
        self.ethertype = _ethertype
    def factory(*args_, **kwargs_):
        if MatchConditionType.subclass:
            return MatchConditionType.subclass(*args_, **kwargs_)
        else:
            return MatchConditionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_protocol(self): return self.protocol
    def set_protocol(self, protocol): self.protocol = protocol
    def get_src_address(self): return self.src_address
    def set_src_address(self, src_address): self.src_address = src_address
    def get_src_port(self): return self.src_port
    def set_src_port(self, src_port): self.src_port = src_port
    def get_dst_address(self): return self.dst_address
    def set_dst_address(self, dst_address): self.dst_address = dst_address
    def get_dst_port(self): return self.dst_port
    def set_dst_port(self, dst_port): self.dst_port = dst_port
    def get_ethertype(self): return self.ethertype
    def set_ethertype(self, ethertype): self.ethertype = ethertype
    def validate_EtherType(self, value):
        # Validate type EtherType, a restriction on xsd:string.
        error = False
        if isinstance(value, list):
            error = set(value) - set([u'IPv4', u'IPv6'])
        else:
            error = value not in [u'IPv4', u'IPv6']
        if error:
            raise ValueError("EtherType must be one of [u'IPv4', u'IPv6']")
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.protocol == other.protocol and
                    self.src_address == other.src_address and
                    self.src_port == other.src_port and
                    self.dst_address == other.dst_address and
                    self.dst_port == other.dst_port and
                    self.ethertype == other.ethertype)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.protocol if self.protocol is not None else -7985492147856592190,
                     self.src_address if self.src_address is not None else -7985492147856592190,
                     self.src_port if self.src_port is not None else -7985492147856592190,
                     self.dst_address if self.dst_address is not None else -7985492147856592190,
                     self.dst_port if self.dst_port is not None else -7985492147856592190,
                     self.ethertype if self.ethertype is not None else -7985492147856592190))

    def __repr__(self):
        return ("protocol = " + str(self.protocol) + ", " +
                "src_address = " + str(self.src_address) + ", " +
                "src_port = " + str(self.src_port) + ", " +
                "dst_address = " + str(self.dst_address) + ", " +
                "dst_port = " + str(self.dst_port) + ", " +
                "ethertype = " + str(self.ethertype))

    def copy(self):
        cp = MatchConditionType()
        if self.protocol is not None:
            cp.protocol = self.protocol
        if self.src_address is not None:
            cp.src_address = self.src_address.copy()
        if self.src_port is not None:
            cp.src_port = self.src_port.copy()
        if self.dst_address is not None:
            cp.dst_address = self.dst_address.copy()
        if self.dst_port is not None:
            cp.dst_port = self.dst_port.copy()
        if self.ethertype is not None:
            cp.ethertype = self.ethertype
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_protocol (obj.populate_string ("protocol"))
        obj.set_src_address (AddressType.populate ())
        obj.set_src_port (PortType.populate ())
        obj.set_dst_address (AddressType.populate ())
        obj.set_dst_port (PortType.populate ())
        obj.set_ethertype (obj.populate_string ("ethertype"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='MatchConditionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MatchConditionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MatchConditionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='MatchConditionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.protocol is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprotocol>%s</%sprotocol>%s' % (namespace_, self.gds_format_string(quote_xml(self.protocol).encode(ExternalEncoding), input_name='protocol'), namespace_, eol_))
        if self.src_address is not None:
            self.src_address.export_xml(outfile, level, namespace_, name_='src-address', pretty_print=pretty_print)
        if self.src_port is not None:
            self.src_port.export_xml(outfile, level, namespace_, name_='src-port', pretty_print=pretty_print)
        if self.dst_address is not None:
            self.dst_address.export_xml(outfile, level, namespace_, name_='dst-address', pretty_print=pretty_print)
        if self.dst_port is not None:
            self.dst_port.export_xml(outfile, level, namespace_, name_='dst-port', pretty_print=pretty_print)
        if self.ethertype is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sethertype>%s</%sethertype>%s' % (namespace_, self.gds_format_string(quote_xml(self.ethertype).encode(ExternalEncoding), input_name='ethertype'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.protocol is not None or
            self.src_address is not None or
            self.src_port is not None or
            self.dst_address is not None or
            self.dst_port is not None or
            self.ethertype is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MatchConditionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.protocol is not None:
            showIndent(outfile, level)
            outfile.write('protocol=%s,\n' % quote_python(self.protocol).encode(ExternalEncoding))
        if self.src_address is not None:
            showIndent(outfile, level)
            outfile.write('src_address=model_.AddressType(\n')
            self.src_address.exportLiteral(outfile, level, name_='src_address')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.src_port is not None:
            showIndent(outfile, level)
            outfile.write('src_port=model_.PortType(\n')
            self.src_port.exportLiteral(outfile, level, name_='src_port')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.dst_address is not None:
            showIndent(outfile, level)
            outfile.write('dst_address=model_.AddressType(\n')
            self.dst_address.exportLiteral(outfile, level, name_='dst_address')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.dst_port is not None:
            showIndent(outfile, level)
            outfile.write('dst_port=model_.PortType(\n')
            self.dst_port.exportLiteral(outfile, level, name_='dst_port')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ethertype is not None:
            showIndent(outfile, level)
            outfile.write('ethertype=%s,\n' % quote_python(self.ethertype).encode(ExternalEncoding))
    def exportDict(self, name_='MatchConditionType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'protocol':
            protocol_ = child_.text
            protocol_ = self.gds_validate_string(protocol_, node, 'protocol')
            self.protocol = protocol_
        elif nodeName_ == 'src-address':
            obj_ = AddressType.factory()
            obj_.build(child_)
            self.set_src_address(obj_)
        elif nodeName_ == 'src-port':
            obj_ = PortType.factory()
            obj_.build(child_)
            self.set_src_port(obj_)
        elif nodeName_ == 'dst-address':
            obj_ = AddressType.factory()
            obj_.build(child_)
            self.set_dst_address(obj_)
        elif nodeName_ == 'dst-port':
            obj_ = PortType.factory()
            obj_.build(child_)
            self.set_dst_port(obj_)
        elif nodeName_ == 'ethertype':
            ethertype_ = child_.text
            ethertype_ = self.gds_validate_string(ethertype_, node, 'ethertype')
            self.ethertype = ethertype_
            self.validate_EtherType(self.ethertype)    # validate type EtherType
# end class MatchConditionType


class StaticMirrorNhType(GeneratedsSuper):
    """
    Attributes:
    * vtep_dst_ip_address
        Type:           str, *one-of* xsd:string

        Created By:           User (required)

        Description:
          ip address of destination vtep

    * vtep_dst_mac_address
        Type:           str

        Created By:           User (optional)

        Description:
          mac address of destination vtep

    * vni
        Type:           int, *within* [1, 16777215]

        Created By:           User (required)

        Description:
          Vni of vtep

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'vtep_dst_ip_address', u'vtep_dst_mac_address', u'vni']
    attr_field_type_vals = {u'vtep_dst_ip_address': {'restrictions': [], 'description': [u'ip address of destination vtep'], 'simple_type': u'IpAddress', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'true', 'attr_type': u'string'}, u'vtep_dst_mac_address': {'restrictions': None, 'description': [u'mac address of destination vtep'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'vni': {'restrictions': [1, 16777215], 'description': [u'Vni of vtep'], 'simple_type': u'VxlanNetworkIdentifierType', 'is_complex': 0, 'restriction_type': 'range', 'is_array': False, 'required': u'true', 'attr_type': u'integer'}}
    def __init__(self, vtep_dst_ip_address=None, vtep_dst_mac_address=None, vni=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _vtep_dst_ip_address = params_dict[u"vtep_dst_ip_address"]
        except KeyError:
            _vtep_dst_ip_address = vtep_dst_ip_address
        self.vtep_dst_ip_address = _vtep_dst_ip_address
        try:
            _vtep_dst_mac_address = params_dict[u"vtep_dst_mac_address"]
        except KeyError:
            _vtep_dst_mac_address = vtep_dst_mac_address
        self.vtep_dst_mac_address = _vtep_dst_mac_address
        try:
            _vni = params_dict[u"vni"]
        except KeyError:
            _vni = vni
        self.vni = _vni
    def factory(*args_, **kwargs_):
        if StaticMirrorNhType.subclass:
            return StaticMirrorNhType.subclass(*args_, **kwargs_)
        else:
            return StaticMirrorNhType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vtep_dst_ip_address(self): return self.vtep_dst_ip_address
    def set_vtep_dst_ip_address(self, vtep_dst_ip_address): self.vtep_dst_ip_address = vtep_dst_ip_address
    def validate_IpAddress(self, value):
        # Validate type IpAddress, a restriction on xsd:string.
        pass
    def get_vtep_dst_mac_address(self): return self.vtep_dst_mac_address
    def set_vtep_dst_mac_address(self, vtep_dst_mac_address): self.vtep_dst_mac_address = vtep_dst_mac_address
    def get_vni(self): return self.vni
    def set_vni(self, vni): self.vni = vni
    def validate_VxlanNetworkIdentifierType(self, value):
        # Validate type VxlanNetworkIdentifierType, a restriction on xsd:integer.
        error = False
        if isinstance(value, list):
            v_int = list(map(int, value))
            v1, v2 = min(v_int), max(v_int)
        else:
            v1, v2 = int(value), int(value)
        error = (1 > v1)
        error |= (v2 > 16777215)
        if error:
            raise ValueError("VxlanNetworkIdentifierType must be in the range {'minimum': 1}-{'maximum': 16777215}")
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.vtep_dst_ip_address == other.vtep_dst_ip_address and
                    self.vtep_dst_mac_address == other.vtep_dst_mac_address and
                    self.vni == other.vni)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.vtep_dst_ip_address if self.vtep_dst_ip_address is not None else -7985492147856592190,
                     self.vtep_dst_mac_address if self.vtep_dst_mac_address is not None else -7985492147856592190,
                     self.vni if self.vni is not None else -7985492147856592190))

    def __repr__(self):
        return ("vtep_dst_ip_address = " + str(self.vtep_dst_ip_address) + ", " +
                "vtep_dst_mac_address = " + str(self.vtep_dst_mac_address) + ", " +
                "vni = " + str(self.vni))

    def copy(self):
        cp = StaticMirrorNhType()
        if self.vtep_dst_ip_address is not None:
            cp.vtep_dst_ip_address = self.vtep_dst_ip_address
        if self.vtep_dst_mac_address is not None:
            cp.vtep_dst_mac_address = self.vtep_dst_mac_address
        if self.vni is not None:
            cp.vni = self.vni
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_vtep_dst_ip_address (obj.populate_string ("vtep_dst_ip_address"))
        obj.set_vtep_dst_mac_address (obj.populate_string ("vtep_dst_mac_address"))
        obj.set_vni (obj.populate_integer ("vni"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='StaticMirrorNhType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StaticMirrorNhType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StaticMirrorNhType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='StaticMirrorNhType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vtep_dst_ip_address is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svtep-dst-ip-address>%s</%svtep-dst-ip-address>%s' % (namespace_, self.gds_format_string(quote_xml(self.vtep_dst_ip_address).encode(ExternalEncoding), input_name='vtep-dst-ip-address'), namespace_, eol_))
        if self.vtep_dst_mac_address is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svtep-dst-mac-address>%s</%svtep-dst-mac-address>%s' % (namespace_, self.gds_format_string(quote_xml(self.vtep_dst_mac_address).encode(ExternalEncoding), input_name='vtep-dst-mac-address'), namespace_, eol_))
        if self.vni is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svni>%s</%svni>%s' % (namespace_, self.gds_format_integer(self.vni, input_name='vni'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.vtep_dst_ip_address is not None or
            self.vtep_dst_mac_address is not None or
            self.vni is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StaticMirrorNhType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.vtep_dst_ip_address is not None:
            showIndent(outfile, level)
            outfile.write('vtep_dst_ip_address=%s,\n' % quote_python(self.vtep_dst_ip_address).encode(ExternalEncoding))
        if self.vtep_dst_mac_address is not None:
            showIndent(outfile, level)
            outfile.write('vtep_dst_mac_address=%s,\n' % quote_python(self.vtep_dst_mac_address).encode(ExternalEncoding))
        if self.vni is not None:
            showIndent(outfile, level)
            outfile.write('vni=%d,\n' % self.vni)
    def exportDict(self, name_='StaticMirrorNhType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vtep-dst-ip-address':
            vtep_dst_ip_address_ = child_.text
            vtep_dst_ip_address_ = self.gds_validate_string(vtep_dst_ip_address_, node, 'vtep_dst_ip_address')
            self.vtep_dst_ip_address = vtep_dst_ip_address_
            self.validate_IpAddress(self.vtep_dst_ip_address)    # validate type IpAddress
        elif nodeName_ == 'vtep-dst-mac-address':
            vtep_dst_mac_address_ = child_.text
            vtep_dst_mac_address_ = self.gds_validate_string(vtep_dst_mac_address_, node, 'vtep_dst_mac_address')
            self.vtep_dst_mac_address = vtep_dst_mac_address_
        elif nodeName_ == 'vni':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'vni')
            self.vni = ival_
            self.validate_VxlanNetworkIdentifierType(self.vni)    # validate type VxlanNetworkIdentifierType
# end class StaticMirrorNhType


class MirrorActionType(GeneratedsSuper):
    """
    Attributes:
    * analyzer_name
        Type:           str

        Created By:           User (optional)

        Description:
          Name of service instance used as analyzer

    * encapsulation
        Type:           str

        Created By:           User (optional)

        Description:
          Encapsulation for Mirrored packet, not used currently

    * analyzer_ip_address
        Type:           str, *one-of* xsd:string

        Created By:           User (required)

        Description:
          ip address of interface to which mirrored packets are sent

    * analyzer_mac_address
        Type:           str

        Created By:           User (optional)

        Description:
          mac address of interface to which mirrored packets are sent

    * routing_instance
        Type:           str

        Created By:           User (required)

        Description:
          Routing instance for the virtual network which analyzer is in

    * udp_port
        Type:           int

        Created By:           User (optional)

        Description:
          ip udp port used in contrail default encapsulation for mirroring

    * juniper_header
        Type:           bool

        Created By:           User (optional)

        Description:
          This flag is used to determine with/without juniper-header

    * nh_mode
        Type:           str, *one-of* [u'dynamic', u'static']

        Created By:           User (optional)

        Description:
          This mode used to determine static or dynamic nh

    * static_nh_header
        Type:           :class:`.StaticMirrorNhType`

        Created By:           User (optional)

        Description:
          vtep details required if static nh enabled

    * nic_assisted_mirroring
        Type:           bool

        Created By:           User (optional)

        Description:
          This flag is used to select nic assisted mirroring

    * nic_assisted_mirroring_vlan
        Type:           int, *within* [0, 4094]

        Created By:           User (optional)

        Description:
          The VLAN to be tagged on the traffic for NIC to Mirror

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'analyzer_name', u'encapsulation', u'analyzer_ip_address', u'analyzer_mac_address', u'routing_instance', u'udp_port', u'juniper_header', u'nh_mode', u'static_nh_header', u'nic_assisted_mirroring', u'nic_assisted_mirroring_vlan']
    attr_field_type_vals = {u'nic_assisted_mirroring_vlan': {'restrictions': [0, 4094], 'description': [u'The VLAN to be tagged on the traffic for NIC to Mirror'], 'simple_type': u'VlanIdType', 'is_complex': 0, 'restriction_type': 'range', 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'analyzer_name': {'restrictions': None, 'description': [u'Name of service instance used as analyzer'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'nh_mode': {'restrictions': [u'dynamic', u'static'], 'description': [u'This mode used to determine static or dynamic nh '], 'simple_type': u'NHModeType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'juniper_header': {'restrictions': None, 'description': [u'This flag is used to determine with/without juniper-header'], 'simple_type': u'xsd:boolean', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'boolean'}, u'udp_port': {'restrictions': None, 'description': [u'ip udp port used in contrail default encapsulation for mirroring'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'routing_instance': {'restrictions': None, 'description': [u'Routing instance for the virtual network which analyzer is in'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'true', 'attr_type': u'string'}, u'static_nh_header': {'restrictions': None, 'description': [u'vtep details required if static nh enabled'], 'simple_type': u'StaticMirrorNhType', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'StaticMirrorNhType'}, u'analyzer_ip_address': {'restrictions': [], 'description': [u'ip address of interface to which mirrored packets are sent'], 'simple_type': u'IpAddress', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'true', 'attr_type': u'string'}, u'encapsulation': {'restrictions': None, 'description': [u'Encapsulation for Mirrored packet, not used currently'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'analyzer_mac_address': {'restrictions': None, 'description': [u'mac address of interface to which mirrored packets are sent '], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'nic_assisted_mirroring': {'restrictions': None, 'description': [u'This flag is used to select nic assisted mirroring'], 'simple_type': u'xsd:boolean', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'boolean'}}
    def __init__(self, analyzer_name=None, encapsulation=None, analyzer_ip_address=None, analyzer_mac_address=None, routing_instance=None, udp_port=None, juniper_header=True, nh_mode=None, static_nh_header=None, nic_assisted_mirroring=False, nic_assisted_mirroring_vlan=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _analyzer_name = params_dict[u"analyzer_name"]
        except KeyError:
            _analyzer_name = analyzer_name
        self.analyzer_name = _analyzer_name
        try:
            _encapsulation = params_dict[u"encapsulation"]
        except KeyError:
            _encapsulation = encapsulation
        self.encapsulation = _encapsulation
        try:
            _analyzer_ip_address = params_dict[u"analyzer_ip_address"]
        except KeyError:
            _analyzer_ip_address = analyzer_ip_address
        self.analyzer_ip_address = _analyzer_ip_address
        try:
            _analyzer_mac_address = params_dict[u"analyzer_mac_address"]
        except KeyError:
            _analyzer_mac_address = analyzer_mac_address
        self.analyzer_mac_address = _analyzer_mac_address
        try:
            _routing_instance = params_dict[u"routing_instance"]
        except KeyError:
            _routing_instance = routing_instance
        self.routing_instance = _routing_instance
        try:
            _udp_port = params_dict[u"udp_port"]
        except KeyError:
            _udp_port = udp_port
        self.udp_port = _udp_port
        try:
            _juniper_header = params_dict[u"juniper_header"]
        except KeyError:
            _juniper_header = juniper_header
        self.juniper_header = _juniper_header
        try:
            _nh_mode = params_dict[u"nh_mode"]
        except KeyError:
            _nh_mode = nh_mode
        self.nh_mode = _nh_mode
        try:
            _static_nh_header = params_dict[u"static_nh_header"]
        except KeyError:
            _static_nh_header = static_nh_header
        if isinstance(_static_nh_header, dict):
            obj = StaticMirrorNhType(params_dict=_static_nh_header)
            self.static_nh_header = obj
        else:
            self.static_nh_header = _static_nh_header
        try:
            _nic_assisted_mirroring = params_dict[u"nic_assisted_mirroring"]
        except KeyError:
            _nic_assisted_mirroring = nic_assisted_mirroring
        self.nic_assisted_mirroring = _nic_assisted_mirroring
        try:
            _nic_assisted_mirroring_vlan = params_dict[u"nic_assisted_mirroring_vlan"]
        except KeyError:
            _nic_assisted_mirroring_vlan = nic_assisted_mirroring_vlan
        self.nic_assisted_mirroring_vlan = _nic_assisted_mirroring_vlan
    def factory(*args_, **kwargs_):
        if MirrorActionType.subclass:
            return MirrorActionType.subclass(*args_, **kwargs_)
        else:
            return MirrorActionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_analyzer_name(self): return self.analyzer_name
    def set_analyzer_name(self, analyzer_name): self.analyzer_name = analyzer_name
    def get_encapsulation(self): return self.encapsulation
    def set_encapsulation(self, encapsulation): self.encapsulation = encapsulation
    def get_analyzer_ip_address(self): return self.analyzer_ip_address
    def set_analyzer_ip_address(self, analyzer_ip_address): self.analyzer_ip_address = analyzer_ip_address
    def validate_IpAddress(self, value):
        # Validate type IpAddress, a restriction on xsd:string.
        pass
    def get_analyzer_mac_address(self): return self.analyzer_mac_address
    def set_analyzer_mac_address(self, analyzer_mac_address): self.analyzer_mac_address = analyzer_mac_address
    def get_routing_instance(self): return self.routing_instance
    def set_routing_instance(self, routing_instance): self.routing_instance = routing_instance
    def get_udp_port(self): return self.udp_port
    def set_udp_port(self, udp_port): self.udp_port = udp_port
    def get_juniper_header(self): return self.juniper_header
    def set_juniper_header(self, juniper_header): self.juniper_header = juniper_header
    def get_nh_mode(self): return self.nh_mode
    def set_nh_mode(self, nh_mode): self.nh_mode = nh_mode
    def validate_NHModeType(self, value):
        # Validate type NHModeType, a restriction on xsd:string.
        error = False
        if isinstance(value, list):
            error = set(value) - set([u'dynamic', u'static'])
        else:
            error = value not in [u'dynamic', u'static']
        if error:
            raise ValueError("NHModeType must be one of [u'dynamic', u'static']")
    def get_static_nh_header(self): return self.static_nh_header
    def set_static_nh_header(self, static_nh_header): self.static_nh_header = static_nh_header
    def get_nic_assisted_mirroring(self): return self.nic_assisted_mirroring
    def set_nic_assisted_mirroring(self, nic_assisted_mirroring): self.nic_assisted_mirroring = nic_assisted_mirroring
    def get_nic_assisted_mirroring_vlan(self): return self.nic_assisted_mirroring_vlan
    def set_nic_assisted_mirroring_vlan(self, nic_assisted_mirroring_vlan): self.nic_assisted_mirroring_vlan = nic_assisted_mirroring_vlan
    def validate_VlanIdType(self, value):
        # Validate type VlanIdType, a restriction on xsd:integer.
        error = False
        if isinstance(value, list):
            v_int = list(map(int, value))
            v1, v2 = min(v_int), max(v_int)
        else:
            v1, v2 = int(value), int(value)
        error |= (v2 > 4094)
        if error:
            raise ValueError("VlanIdType must be in the range {'minimum': 0}-{'maximum': 4094}")
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.analyzer_name == other.analyzer_name and
                    self.encapsulation == other.encapsulation and
                    self.analyzer_ip_address == other.analyzer_ip_address and
                    self.analyzer_mac_address == other.analyzer_mac_address and
                    self.routing_instance == other.routing_instance and
                    self.udp_port == other.udp_port and
                    self.juniper_header == other.juniper_header and
                    self.nh_mode == other.nh_mode and
                    self.static_nh_header == other.static_nh_header and
                    self.nic_assisted_mirroring == other.nic_assisted_mirroring and
                    self.nic_assisted_mirroring_vlan == other.nic_assisted_mirroring_vlan)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.analyzer_name if self.analyzer_name is not None else -7985492147856592190,
                     self.encapsulation if self.encapsulation is not None else -7985492147856592190,
                     self.analyzer_ip_address if self.analyzer_ip_address is not None else -7985492147856592190,
                     self.analyzer_mac_address if self.analyzer_mac_address is not None else -7985492147856592190,
                     self.routing_instance if self.routing_instance is not None else -7985492147856592190,
                     self.udp_port if self.udp_port is not None else -7985492147856592190,
                     self.juniper_header if self.juniper_header is not None else -7985492147856592190,
                     self.nh_mode if self.nh_mode is not None else -7985492147856592190,
                     self.static_nh_header if self.static_nh_header is not None else -7985492147856592190,
                     self.nic_assisted_mirroring if self.nic_assisted_mirroring is not None else -7985492147856592190,
                     self.nic_assisted_mirroring_vlan if self.nic_assisted_mirroring_vlan is not None else -7985492147856592190))

    def __repr__(self):
        return ("analyzer_name = " + str(self.analyzer_name) + ", " +
                "encapsulation = " + str(self.encapsulation) + ", " +
                "analyzer_ip_address = " + str(self.analyzer_ip_address) + ", " +
                "analyzer_mac_address = " + str(self.analyzer_mac_address) + ", " +
                "routing_instance = " + str(self.routing_instance) + ", " +
                "udp_port = " + str(self.udp_port) + ", " +
                "juniper_header = " + str(self.juniper_header) + ", " +
                "nh_mode = " + str(self.nh_mode) + ", " +
                "static_nh_header = " + str(self.static_nh_header) + ", " +
                "nic_assisted_mirroring = " + str(self.nic_assisted_mirroring) + ", " +
                "nic_assisted_mirroring_vlan = " + str(self.nic_assisted_mirroring_vlan))

    def copy(self):
        cp = MirrorActionType()
        if self.analyzer_name is not None:
            cp.analyzer_name = self.analyzer_name
        if self.encapsulation is not None:
            cp.encapsulation = self.encapsulation
        if self.analyzer_ip_address is not None:
            cp.analyzer_ip_address = self.analyzer_ip_address
        if self.analyzer_mac_address is not None:
            cp.analyzer_mac_address = self.analyzer_mac_address
        if self.routing_instance is not None:
            cp.routing_instance = self.routing_instance
        if self.udp_port is not None:
            cp.udp_port = self.udp_port
        if self.juniper_header is not None:
            cp.juniper_header = self.juniper_header
        if self.nh_mode is not None:
            cp.nh_mode = self.nh_mode
        if self.static_nh_header is not None:
            cp.static_nh_header = self.static_nh_header.copy()
        if self.nic_assisted_mirroring is not None:
            cp.nic_assisted_mirroring = self.nic_assisted_mirroring
        if self.nic_assisted_mirroring_vlan is not None:
            cp.nic_assisted_mirroring_vlan = self.nic_assisted_mirroring_vlan
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_analyzer_name (obj.populate_string ("analyzer_name"))
        obj.set_encapsulation (obj.populate_string ("encapsulation"))
        obj.set_analyzer_ip_address (obj.populate_string ("analyzer_ip_address"))
        obj.set_analyzer_mac_address (obj.populate_string ("analyzer_mac_address"))
        obj.set_routing_instance (obj.populate_string ("routing_instance"))
        obj.set_udp_port (obj.populate_integer ("udp_port"))
        obj.set_juniper_header (obj.populate_boolean ("juniper_header"))
        obj.set_nh_mode (obj.populate_string ("nh_mode"))
        obj.set_static_nh_header (StaticMirrorNhType.populate ())
        obj.set_nic_assisted_mirroring (obj.populate_boolean ("nic_assisted_mirroring"))
        obj.set_nic_assisted_mirroring_vlan (obj.populate_integer ("nic_assisted_mirroring_vlan"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='MirrorActionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MirrorActionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MirrorActionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='MirrorActionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.analyzer_name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sanalyzer-name>%s</%sanalyzer-name>%s' % (namespace_, self.gds_format_string(quote_xml(self.analyzer_name).encode(ExternalEncoding), input_name='analyzer-name'), namespace_, eol_))
        if self.encapsulation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sencapsulation>%s</%sencapsulation>%s' % (namespace_, self.gds_format_string(quote_xml(self.encapsulation).encode(ExternalEncoding), input_name='encapsulation'), namespace_, eol_))
        if self.analyzer_ip_address is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sanalyzer-ip-address>%s</%sanalyzer-ip-address>%s' % (namespace_, self.gds_format_string(quote_xml(self.analyzer_ip_address).encode(ExternalEncoding), input_name='analyzer-ip-address'), namespace_, eol_))
        if self.analyzer_mac_address is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sanalyzer-mac-address>%s</%sanalyzer-mac-address>%s' % (namespace_, self.gds_format_string(quote_xml(self.analyzer_mac_address).encode(ExternalEncoding), input_name='analyzer-mac-address'), namespace_, eol_))
        if self.routing_instance is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srouting-instance>%s</%srouting-instance>%s' % (namespace_, self.gds_format_string(quote_xml(self.routing_instance).encode(ExternalEncoding), input_name='routing-instance'), namespace_, eol_))
        if self.udp_port is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sudp-port>%s</%sudp-port>%s' % (namespace_, self.gds_format_integer(self.udp_port, input_name='udp-port'), namespace_, eol_))
        if self.juniper_header is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sjuniper-header>%s</%sjuniper-header>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.juniper_header)), input_name='juniper-header'), namespace_, eol_))
        if self.nh_mode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snh-mode>%s</%snh-mode>%s' % (namespace_, self.gds_format_string(quote_xml(self.nh_mode).encode(ExternalEncoding), input_name='nh-mode'), namespace_, eol_))
        if self.static_nh_header is not None:
            self.static_nh_header.export_xml(outfile, level, namespace_, name_='static-nh-header', pretty_print=pretty_print)
        if self.nic_assisted_mirroring is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snic-assisted-mirroring>%s</%snic-assisted-mirroring>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.nic_assisted_mirroring)), input_name='nic-assisted-mirroring'), namespace_, eol_))
        if self.nic_assisted_mirroring_vlan is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snic-assisted-mirroring-vlan>%s</%snic-assisted-mirroring-vlan>%s' % (namespace_, self.gds_format_integer(self.nic_assisted_mirroring_vlan, input_name='nic-assisted-mirroring-vlan'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.analyzer_name is not None or
            self.encapsulation is not None or
            self.analyzer_ip_address is not None or
            self.analyzer_mac_address is not None or
            self.routing_instance is not None or
            self.udp_port is not None or
            self.juniper_header is not None or
            self.nh_mode is not None or
            self.static_nh_header is not None or
            self.nic_assisted_mirroring is not None or
            self.nic_assisted_mirroring_vlan is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MirrorActionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.analyzer_name is not None:
            showIndent(outfile, level)
            outfile.write('analyzer_name=%s,\n' % quote_python(self.analyzer_name).encode(ExternalEncoding))
        if self.encapsulation is not None:
            showIndent(outfile, level)
            outfile.write('encapsulation=%s,\n' % quote_python(self.encapsulation).encode(ExternalEncoding))
        if self.analyzer_ip_address is not None:
            showIndent(outfile, level)
            outfile.write('analyzer_ip_address=%s,\n' % quote_python(self.analyzer_ip_address).encode(ExternalEncoding))
        if self.analyzer_mac_address is not None:
            showIndent(outfile, level)
            outfile.write('analyzer_mac_address=%s,\n' % quote_python(self.analyzer_mac_address).encode(ExternalEncoding))
        if self.routing_instance is not None:
            showIndent(outfile, level)
            outfile.write('routing_instance=%s,\n' % quote_python(self.routing_instance).encode(ExternalEncoding))
        if self.udp_port is not None:
            showIndent(outfile, level)
            outfile.write('udp_port=%d,\n' % self.udp_port)
        if self.juniper_header is not None:
            showIndent(outfile, level)
            outfile.write('juniper_header=%s,\n' % self.juniper_header)
        if self.nh_mode is not None:
            showIndent(outfile, level)
            outfile.write('nh_mode=%s,\n' % quote_python(self.nh_mode).encode(ExternalEncoding))
        if self.static_nh_header is not None:
            showIndent(outfile, level)
            outfile.write('static_nh_header=model_.StaticMirrorNhType(\n')
            self.static_nh_header.exportLiteral(outfile, level, name_='static_nh_header')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.nic_assisted_mirroring is not None:
            showIndent(outfile, level)
            outfile.write('nic_assisted_mirroring=%s,\n' % self.nic_assisted_mirroring)
        if self.nic_assisted_mirroring_vlan is not None:
            showIndent(outfile, level)
            outfile.write('nic_assisted_mirroring_vlan=%d,\n' % self.nic_assisted_mirroring_vlan)
    def exportDict(self, name_='MirrorActionType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'analyzer-name':
            analyzer_name_ = child_.text
            analyzer_name_ = self.gds_validate_string(analyzer_name_, node, 'analyzer_name')
            self.analyzer_name = analyzer_name_
        elif nodeName_ == 'encapsulation':
            encapsulation_ = child_.text
            encapsulation_ = self.gds_validate_string(encapsulation_, node, 'encapsulation')
            self.encapsulation = encapsulation_
        elif nodeName_ == 'analyzer-ip-address':
            analyzer_ip_address_ = child_.text
            analyzer_ip_address_ = self.gds_validate_string(analyzer_ip_address_, node, 'analyzer_ip_address')
            self.analyzer_ip_address = analyzer_ip_address_
            self.validate_IpAddress(self.analyzer_ip_address)    # validate type IpAddress
        elif nodeName_ == 'analyzer-mac-address':
            analyzer_mac_address_ = child_.text
            analyzer_mac_address_ = self.gds_validate_string(analyzer_mac_address_, node, 'analyzer_mac_address')
            self.analyzer_mac_address = analyzer_mac_address_
        elif nodeName_ == 'routing-instance':
            routing_instance_ = child_.text
            routing_instance_ = self.gds_validate_string(routing_instance_, node, 'routing_instance')
            self.routing_instance = routing_instance_
        elif nodeName_ == 'udp-port':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'udp_port')
            self.udp_port = ival_
        elif nodeName_ == 'juniper-header':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'juniper_header')
            self.juniper_header = ival_
        elif nodeName_ == 'nh-mode':
            nh_mode_ = child_.text
            nh_mode_ = self.gds_validate_string(nh_mode_, node, 'nh_mode')
            self.nh_mode = nh_mode_
            self.validate_NHModeType(self.nh_mode)    # validate type NHModeType
        elif nodeName_ == 'static-nh-header':
            obj_ = StaticMirrorNhType.factory()
            obj_.build(child_)
            self.set_static_nh_header(obj_)
        elif nodeName_ == 'nic-assisted-mirroring':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'nic_assisted_mirroring')
            self.nic_assisted_mirroring = ival_
        elif nodeName_ == 'nic-assisted-mirroring-vlan':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'nic_assisted_mirroring_vlan')
            self.nic_assisted_mirroring_vlan = ival_
            self.validate_VlanIdType(self.nic_assisted_mirroring_vlan)    # validate type VlanIdType
# end class MirrorActionType


class ActionListType(GeneratedsSuper):
    """
    Attributes:
    * simple_action
        Type:           str, *one-of* [u'deny', u'pass']

        Created By:           User (required)

        Description:
          Simple allow(pass) or deny action for traffic matching this rule

    * gateway_name
        Type:           str

        Created By:           User (optional)

        Description:
          For internal use only

    * apply_service
        Type:           str

        Created By:           User (optional)

        Description:
          Ordered list of service instances in service chain applied to traffic matching

          the rule

    * mirror_to
        Type:           :class:`.MirrorActionType`

        Created By:           User (optional)

        Description:
          Mirror traffic matching this rule

    * assign_routing_instance
        Type:           str

        Created By:           User (optional)

        Description:
          For internal use only

    * log
        Type:           bool

        Created By:           User (optional)

        Description:
          Flow records for traffic matching this rule are sent at higher priority

    * alert
        Type:           bool

        Created By:           User (optional)

        Description:
          For internal use only

    * qos_action
        Type:           str

        Created By:           User (optional)

        Description:
          FQN of Qos configuration object for QoS marking

    * host_based_service
        Type:           bool

        Description:
          Forward traffic matching this rule to the project's host based service

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'simple_action', u'gateway_name', u'apply_service', u'mirror_to', u'assign_routing_instance', u'log', u'alert', u'qos_action', u'host_based_service']
    attr_field_type_vals = {u'gateway_name': {'restrictions': None, 'description': [u'For internal use only'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'log': {'restrictions': None, 'description': [u'Flow records for traffic matching this rule are sent at higher priority'], 'simple_type': u'xsd:boolean', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'boolean'}, u'alert': {'restrictions': None, 'description': [u'For internal use only'], 'simple_type': u'xsd:boolean', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'boolean'}, u'qos_action': {'restrictions': None, 'description': [u'FQN of Qos configuration object for QoS marking'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'host_based_service': {'restrictions': None, 'description': [u"Forward traffic matching this rule to the project's host based service"], 'simple_type': u'xsd:boolean', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'boolean'}, u'assign_routing_instance': {'restrictions': None, 'description': [u'For internal use only'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'mirror_to': {'restrictions': None, 'description': [u'Mirror traffic matching this rule'], 'simple_type': u'MirrorActionType', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'MirrorActionType'}, u'simple_action': {'restrictions': [u'deny', u'pass'], 'description': [u'Simple allow(pass) or deny action for traffic matching this rule'], 'simple_type': u'SimpleActionType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'true', 'attr_type': u'string'}, u'apply_service': {'restrictions': None, 'description': [u'Ordered list of service instances in service chain applied to traffic matching the rule'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': True, 'required': u'optional', 'attr_type': u'string'}}
    def __init__(self, simple_action=None, gateway_name=None, apply_service=None, mirror_to=None, assign_routing_instance=None, log=False, alert=False, qos_action=None, host_based_service=False, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _simple_action = params_dict[u"simple_action"]
        except KeyError:
            _simple_action = simple_action
        self.simple_action = _simple_action
        try:
            _gateway_name = params_dict[u"gateway_name"]
        except KeyError:
            _gateway_name = gateway_name
        self.gateway_name = _gateway_name
        try:
            _apply_service = params_dict[u"apply_service"]
        except KeyError:
            _apply_service = apply_service
        if not _apply_service:
            self.apply_service = []
        else:
            self.apply_service = _apply_service
        try:
            _mirror_to = params_dict[u"mirror_to"]
        except KeyError:
            _mirror_to = mirror_to
        if isinstance(_mirror_to, dict):
            obj = MirrorActionType(params_dict=_mirror_to)
            self.mirror_to = obj
        else:
            self.mirror_to = _mirror_to
        try:
            _assign_routing_instance = params_dict[u"assign_routing_instance"]
        except KeyError:
            _assign_routing_instance = assign_routing_instance
        self.assign_routing_instance = _assign_routing_instance
        try:
            _log = params_dict[u"log"]
        except KeyError:
            _log = log
        self.log = _log
        try:
            _alert = params_dict[u"alert"]
        except KeyError:
            _alert = alert
        self.alert = _alert
        try:
            _qos_action = params_dict[u"qos_action"]
        except KeyError:
            _qos_action = qos_action
        self.qos_action = _qos_action
        try:
            _host_based_service = params_dict[u"host_based_service"]
        except KeyError:
            _host_based_service = host_based_service
        self.host_based_service = _host_based_service
    def factory(*args_, **kwargs_):
        if ActionListType.subclass:
            return ActionListType.subclass(*args_, **kwargs_)
        else:
            return ActionListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_simple_action(self): return self.simple_action
    def set_simple_action(self, simple_action): self.simple_action = simple_action
    def validate_SimpleActionType(self, value):
        # Validate type SimpleActionType, a restriction on xsd:string.
        error = False
        if isinstance(value, list):
            error = set(value) - set([u'deny', u'pass'])
        else:
            error = value not in [u'deny', u'pass']
        if error:
            raise ValueError("SimpleActionType must be one of [u'deny', u'pass']")
    def get_gateway_name(self): return self.gateway_name
    def set_gateway_name(self, gateway_name): self.gateway_name = gateway_name
    def get_apply_service(self): return self.apply_service
    def set_apply_service(self, apply_service): self.apply_service = apply_service
    def add_apply_service(self, value): self.apply_service.append(value)
    def insert_apply_service(self, index, value): self.apply_service[index] = value
    def delete_apply_service(self, value): self.apply_service.remove(value)
    def get_mirror_to(self): return self.mirror_to
    def set_mirror_to(self, mirror_to): self.mirror_to = mirror_to
    def get_assign_routing_instance(self): return self.assign_routing_instance
    def set_assign_routing_instance(self, assign_routing_instance): self.assign_routing_instance = assign_routing_instance
    def get_log(self): return self.log
    def set_log(self, log): self.log = log
    def get_alert(self): return self.alert
    def set_alert(self, alert): self.alert = alert
    def get_qos_action(self): return self.qos_action
    def set_qos_action(self, qos_action): self.qos_action = qos_action
    def get_host_based_service(self): return self.host_based_service
    def set_host_based_service(self, host_based_service): self.host_based_service = host_based_service
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.simple_action == other.simple_action and
                    self.gateway_name == other.gateway_name and
                    self.apply_service == other.apply_service and
                    self.mirror_to == other.mirror_to and
                    self.assign_routing_instance == other.assign_routing_instance and
                    self.log == other.log and
                    self.alert == other.alert and
                    self.qos_action == other.qos_action and
                    self.host_based_service == other.host_based_service)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.simple_action if self.simple_action is not None else -7985492147856592190,
                     self.gateway_name if self.gateway_name is not None else -7985492147856592190,
                     tuple(self.apply_service or []),
                     self.mirror_to if self.mirror_to is not None else -7985492147856592190,
                     self.assign_routing_instance if self.assign_routing_instance is not None else -7985492147856592190,
                     self.log if self.log is not None else -7985492147856592190,
                     self.alert if self.alert is not None else -7985492147856592190,
                     self.qos_action if self.qos_action is not None else -7985492147856592190,
                     self.host_based_service if self.host_based_service is not None else -7985492147856592190))

    def __repr__(self):
        return ("simple_action = " + str(self.simple_action) + ", " +
                "gateway_name = " + str(self.gateway_name) + ", " +
                "apply_service = " + str(self.apply_service) + ", " +
                "mirror_to = " + str(self.mirror_to) + ", " +
                "assign_routing_instance = " + str(self.assign_routing_instance) + ", " +
                "log = " + str(self.log) + ", " +
                "alert = " + str(self.alert) + ", " +
                "qos_action = " + str(self.qos_action) + ", " +
                "host_based_service = " + str(self.host_based_service))

    def copy(self):
        cp = ActionListType()
        if self.simple_action is not None:
            cp.simple_action = self.simple_action
        if self.gateway_name is not None:
            cp.gateway_name = self.gateway_name
        if self.apply_service is not None:
            cp.apply_service = list(self.apply_service)
        if self.mirror_to is not None:
            cp.mirror_to = self.mirror_to.copy()
        if self.assign_routing_instance is not None:
            cp.assign_routing_instance = self.assign_routing_instance
        if self.log is not None:
            cp.log = self.log
        if self.alert is not None:
            cp.alert = self.alert
        if self.qos_action is not None:
            cp.qos_action = self.qos_action
        if self.host_based_service is not None:
            cp.host_based_service = self.host_based_service
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_simple_action (obj.populate_string ("simple_action"))
        obj.set_gateway_name (obj.populate_string ("gateway_name"))
        obj.set_apply_service ([obj.populate_string ("apply_service")])
        obj.set_mirror_to (MirrorActionType.populate ())
        obj.set_assign_routing_instance (obj.populate_string ("assign_routing_instance"))
        obj.set_log (obj.populate_boolean ("log"))
        obj.set_alert (obj.populate_boolean ("alert"))
        obj.set_qos_action (obj.populate_string ("qos_action"))
        obj.set_host_based_service (obj.populate_boolean ("host_based_service"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='ActionListType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActionListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ActionListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ActionListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.simple_action is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssimple-action>%s</%ssimple-action>%s' % (namespace_, self.gds_format_string(quote_xml(self.simple_action).encode(ExternalEncoding), input_name='simple-action'), namespace_, eol_))
        if self.gateway_name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgateway-name>%s</%sgateway-name>%s' % (namespace_, self.gds_format_string(quote_xml(self.gateway_name).encode(ExternalEncoding), input_name='gateway-name'), namespace_, eol_))
        for apply_service_ in self.apply_service:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sapply-service>%s</%sapply-service>%s' % (namespace_, self.gds_format_string(quote_xml(apply_service_).encode(ExternalEncoding), input_name='apply-service'), namespace_, eol_))
        if self.mirror_to is not None:
            self.mirror_to.export_xml(outfile, level, namespace_, name_='mirror-to', pretty_print=pretty_print)
        if self.assign_routing_instance is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sassign-routing-instance>%s</%sassign-routing-instance>%s' % (namespace_, self.gds_format_string(quote_xml(self.assign_routing_instance).encode(ExternalEncoding), input_name='assign-routing-instance'), namespace_, eol_))
        if self.log is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slog>%s</%slog>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.log)), input_name='log'), namespace_, eol_))
        if self.alert is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%salert>%s</%salert>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.alert)), input_name='alert'), namespace_, eol_))
        if self.qos_action is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sqos-action>%s</%sqos-action>%s' % (namespace_, self.gds_format_string(quote_xml(self.qos_action).encode(ExternalEncoding), input_name='qos-action'), namespace_, eol_))
        if self.host_based_service is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shost-based-service>%s</%shost-based-service>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.host_based_service)), input_name='host-based-service'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.simple_action is not None or
            self.gateway_name is not None or
            self.apply_service or
            self.mirror_to is not None or
            self.assign_routing_instance is not None or
            self.log is not None or
            self.alert is not None or
            self.qos_action is not None or
            self.host_based_service is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ActionListType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.simple_action is not None:
            showIndent(outfile, level)
            outfile.write('simple_action=%s,\n' % quote_python(self.simple_action).encode(ExternalEncoding))
        if self.gateway_name is not None:
            showIndent(outfile, level)
            outfile.write('gateway_name=%s,\n' % quote_python(self.gateway_name).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('apply_service=[\n')
        level += 1
        for apply_service_ in self.apply_service:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(apply_service_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.mirror_to is not None:
            showIndent(outfile, level)
            outfile.write('mirror_to=model_.MirrorActionType(\n')
            self.mirror_to.exportLiteral(outfile, level, name_='mirror_to')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.assign_routing_instance is not None:
            showIndent(outfile, level)
            outfile.write('assign_routing_instance=%s,\n' % quote_python(self.assign_routing_instance).encode(ExternalEncoding))
        if self.log is not None:
            showIndent(outfile, level)
            outfile.write('log=%s,\n' % self.log)
        if self.alert is not None:
            showIndent(outfile, level)
            outfile.write('alert=%s,\n' % self.alert)
        if self.qos_action is not None:
            showIndent(outfile, level)
            outfile.write('qos_action=%s,\n' % quote_python(self.qos_action).encode(ExternalEncoding))
        if self.host_based_service is not None:
            showIndent(outfile, level)
            outfile.write('host_based_service=%s,\n' % self.host_based_service)
    def exportDict(self, name_='ActionListType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'simple-action':
            simple_action_ = child_.text
            simple_action_ = self.gds_validate_string(simple_action_, node, 'simple_action')
            self.simple_action = simple_action_
            self.validate_SimpleActionType(self.simple_action)    # validate type SimpleActionType
        elif nodeName_ == 'gateway-name':
            gateway_name_ = child_.text
            gateway_name_ = self.gds_validate_string(gateway_name_, node, 'gateway_name')
            self.gateway_name = gateway_name_
        elif nodeName_ == 'apply-service':
            apply_service_ = child_.text
            apply_service_ = self.gds_validate_string(apply_service_, node, 'apply_service')
            self.apply_service.append(apply_service_)
        elif nodeName_ == 'mirror-to':
            obj_ = MirrorActionType.factory()
            obj_.build(child_)
            self.set_mirror_to(obj_)
        elif nodeName_ == 'assign-routing-instance':
            assign_routing_instance_ = child_.text
            assign_routing_instance_ = self.gds_validate_string(assign_routing_instance_, node, 'assign_routing_instance')
            self.assign_routing_instance = assign_routing_instance_
        elif nodeName_ == 'log':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'log')
            self.log = ival_
        elif nodeName_ == 'alert':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'alert')
            self.alert = ival_
        elif nodeName_ == 'qos-action':
            qos_action_ = child_.text
            qos_action_ = self.gds_validate_string(qos_action_, node, 'qos_action')
            self.qos_action = qos_action_
        elif nodeName_ == 'host-based-service':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'host_based_service')
            self.host_based_service = ival_
# end class ActionListType


class AclRuleType(GeneratedsSuper):
    """
    Attributes:
    * match_condition
        Type:           :class:`.MatchConditionType`

        Created By:           User (required)

        Description:
          Match condition for packets

    * action_list
        Type:           :class:`.ActionListType`

        Created By:           User (required)

        Description:
          Actions to be performed if packets match condition

    * rule_uuid
        Type:           str

        Created By:           User (optional)

        Description:
          Rule UUID is identifier used in flow records to identify rule

    * direction
        Type:           str, *one-of* [u'>', u'<>']

        Created By:           User (optional)

        Description:
          Direction in the rule

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'match_condition', u'action_list', u'rule_uuid', u'direction']
    attr_field_type_vals = {u'rule_uuid': {'restrictions': None, 'description': [u'Rule UUID is identifier used in flow records to identify rule'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'match_condition': {'restrictions': None, 'description': [u'Match condition for packets'], 'simple_type': u'MatchConditionType', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': u'true', 'attr_type': u'MatchConditionType'}, u'direction': {'restrictions': [u'>', u'<>'], 'description': [u'Direction in the rule'], 'simple_type': u'DirectionType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'action_list': {'restrictions': None, 'description': [u'Actions to be performed if packets match condition'], 'simple_type': u'ActionListType', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': u'true', 'attr_type': u'ActionListType'}}
    def __init__(self, match_condition=None, action_list=None, rule_uuid=None, direction=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _match_condition = params_dict[u"match_condition"]
        except KeyError:
            _match_condition = match_condition
        if isinstance(_match_condition, dict):
            obj = MatchConditionType(params_dict=_match_condition)
            self.match_condition = obj
        else:
            self.match_condition = _match_condition
        try:
            _action_list = params_dict[u"action_list"]
        except KeyError:
            _action_list = action_list
        if isinstance(_action_list, dict):
            obj = ActionListType(params_dict=_action_list)
            self.action_list = obj
        else:
            self.action_list = _action_list
        try:
            _rule_uuid = params_dict[u"rule_uuid"]
        except KeyError:
            _rule_uuid = rule_uuid
        self.rule_uuid = _rule_uuid
        try:
            _direction = params_dict[u"direction"]
        except KeyError:
            _direction = direction
        self.direction = _direction
    def factory(*args_, **kwargs_):
        if AclRuleType.subclass:
            return AclRuleType.subclass(*args_, **kwargs_)
        else:
            return AclRuleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_match_condition(self): return self.match_condition
    def set_match_condition(self, match_condition): self.match_condition = match_condition
    def get_action_list(self): return self.action_list
    def set_action_list(self, action_list): self.action_list = action_list
    def get_rule_uuid(self): return self.rule_uuid
    def set_rule_uuid(self, rule_uuid): self.rule_uuid = rule_uuid
    def get_direction(self): return self.direction
    def set_direction(self, direction): self.direction = direction
    def validate_DirectionType(self, value):
        # Validate type DirectionType, a restriction on xsd:string.
        error = False
        if isinstance(value, list):
            error = set(value) - set([u'>', u'<>'])
        else:
            error = value not in [u'>', u'<>']
        if error:
            raise ValueError("DirectionType must be one of [u'>', u'<>']")
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.match_condition == other.match_condition and
                    self.action_list == other.action_list and
                    self.rule_uuid == other.rule_uuid and
                    self.direction == other.direction)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.match_condition if self.match_condition is not None else -7985492147856592190,
                     self.action_list if self.action_list is not None else -7985492147856592190,
                     self.rule_uuid if self.rule_uuid is not None else -7985492147856592190,
                     self.direction if self.direction is not None else -7985492147856592190))

    def __repr__(self):
        return ("match_condition = " + str(self.match_condition) + ", " +
                "action_list = " + str(self.action_list) + ", " +
                "rule_uuid = " + str(self.rule_uuid) + ", " +
                "direction = " + str(self.direction))

    def copy(self):
        cp = AclRuleType()
        if self.match_condition is not None:
            cp.match_condition = self.match_condition.copy()
        if self.action_list is not None:
            cp.action_list = self.action_list.copy()
        if self.rule_uuid is not None:
            cp.rule_uuid = self.rule_uuid
        if self.direction is not None:
            cp.direction = self.direction
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_match_condition (MatchConditionType.populate ())
        obj.set_action_list (ActionListType.populate ())
        obj.set_rule_uuid (obj.populate_string ("rule_uuid"))
        obj.set_direction (obj.populate_string ("direction"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='AclRuleType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AclRuleType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AclRuleType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AclRuleType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.match_condition is not None:
            self.match_condition.export_xml(outfile, level, namespace_, name_='match-condition', pretty_print=pretty_print)
        if self.action_list is not None:
            self.action_list.export_xml(outfile, level, namespace_, name_='action-list', pretty_print=pretty_print)
        if self.rule_uuid is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srule-uuid>%s</%srule-uuid>%s' % (namespace_, self.gds_format_string(quote_xml(self.rule_uuid).encode(ExternalEncoding), input_name='rule-uuid'), namespace_, eol_))
        if self.direction is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdirection>%s</%sdirection>%s' % (namespace_, self.gds_format_string(quote_xml(self.direction).encode(ExternalEncoding), input_name='direction'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.match_condition is not None or
            self.action_list is not None or
            self.rule_uuid is not None or
            self.direction is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AclRuleType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.match_condition is not None:
            showIndent(outfile, level)
            outfile.write('match_condition=model_.MatchConditionType(\n')
            self.match_condition.exportLiteral(outfile, level, name_='match_condition')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.action_list is not None:
            showIndent(outfile, level)
            outfile.write('action_list=model_.ActionListType(\n')
            self.action_list.exportLiteral(outfile, level, name_='action_list')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.rule_uuid is not None:
            showIndent(outfile, level)
            outfile.write('rule_uuid=%s,\n' % quote_python(self.rule_uuid).encode(ExternalEncoding))
        if self.direction is not None:
            showIndent(outfile, level)
            outfile.write('direction=%s,\n' % quote_python(self.direction).encode(ExternalEncoding))
    def exportDict(self, name_='AclRuleType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'match-condition':
            obj_ = MatchConditionType.factory()
            obj_.build(child_)
            self.set_match_condition(obj_)
        elif nodeName_ == 'action-list':
            obj_ = ActionListType.factory()
            obj_.build(child_)
            self.set_action_list(obj_)
        elif nodeName_ == 'rule-uuid':
            rule_uuid_ = child_.text
            rule_uuid_ = self.gds_validate_string(rule_uuid_, node, 'rule_uuid')
            self.rule_uuid = rule_uuid_
        elif nodeName_ == 'direction':
            direction_ = child_.text
            direction_ = self.gds_validate_string(direction_, node, 'direction')
            self.direction = direction_
            self.validate_DirectionType(self.direction)    # validate type DirectionType
# end class AclRuleType


class AclEntriesType(GeneratedsSuper):
    """
    Attributes:
    * dynamic
        Type:           bool

        Created By:           User (optional)

        Description:
          For Internal use only

    * acl_rule
        Type:           :class:`.AclRuleType`

        Created By:           User (required)

        Description:
          For Internal use only

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'dynamic', u'acl_rule']
    attr_field_type_vals = {u'dynamic': {'restrictions': None, 'description': [u'For Internal use only'], 'simple_type': u'xsd:boolean', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'boolean'}, u'acl_rule': {'restrictions': None, 'description': [u'For Internal use only'], 'simple_type': u'AclRuleType', 'is_complex': 1, 'restriction_type': None, 'is_array': True, 'required': u'true', 'attr_type': u'AclRuleType'}}
    def __init__(self, dynamic=None, acl_rule=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _dynamic = params_dict[u"dynamic"]
        except KeyError:
            _dynamic = dynamic
        self.dynamic = _dynamic
        try:
            _acl_rule = params_dict[u"acl_rule"]
        except KeyError:
            _acl_rule = acl_rule
        if not _acl_rule:
            self.acl_rule = []
        else:
            if isinstance(_acl_rule[0], dict):
                objs = [AclRuleType(params_dict=elem) for elem in _acl_rule]
                self.acl_rule = objs
            else:
                self.acl_rule = _acl_rule
    def factory(*args_, **kwargs_):
        if AclEntriesType.subclass:
            return AclEntriesType.subclass(*args_, **kwargs_)
        else:
            return AclEntriesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dynamic(self): return self.dynamic
    def set_dynamic(self, dynamic): self.dynamic = dynamic
    def get_acl_rule(self): return self.acl_rule
    def set_acl_rule(self, acl_rule): self.acl_rule = acl_rule
    def add_acl_rule(self, value): self.acl_rule.append(value)
    def insert_acl_rule(self, index, value): self.acl_rule[index] = value
    def delete_acl_rule(self, value): self.acl_rule.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.dynamic == other.dynamic and
                    self.acl_rule == other.acl_rule)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.dynamic if self.dynamic is not None else -7985492147856592190,
                     tuple(self.acl_rule or [])))

    def __repr__(self):
        return ("dynamic = " + str(self.dynamic) + ", " +
                "acl_rule = " + str(self.acl_rule))

    def copy(self):
        cp = AclEntriesType()
        if self.dynamic is not None:
            cp.dynamic = self.dynamic
        if self.acl_rule is not None:
            cp.acl_rule = [x.copy() for x in self.acl_rule]
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_dynamic (obj.populate_boolean ("dynamic"))
        obj.set_acl_rule ([AclRuleType.populate ()])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='AclEntriesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AclEntriesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AclEntriesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AclEntriesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.dynamic is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdynamic>%s</%sdynamic>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.dynamic)), input_name='dynamic'), namespace_, eol_))
        for acl_rule_ in self.acl_rule:
            if isinstance(acl_rule_, dict):
                acl_rule_ = AclRuleType(**acl_rule_)
            acl_rule_.export_xml(outfile, level, namespace_, name_='acl-rule', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.dynamic is not None or
            self.acl_rule
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AclEntriesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.dynamic is not None:
            showIndent(outfile, level)
            outfile.write('dynamic=%s,\n' % self.dynamic)
        showIndent(outfile, level)
        outfile.write('acl_rule=[\n')
        level += 1
        for acl_rule_ in self.acl_rule:
            showIndent(outfile, level)
            outfile.write('model_.AclRuleType(\n')
            acl_rule_.exportLiteral(outfile, level, name_='AclRuleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='AclEntriesType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dynamic':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'dynamic')
            self.dynamic = ival_
        elif nodeName_ == 'acl-rule':
            obj_ = AclRuleType.factory()
            obj_.build(child_)
            self.acl_rule.append(obj_)
# end class AclEntriesType


class PolicyRuleType(GeneratedsSuper):
    """
    Attributes:
    * rule_sequence
        Type:           :class:`.SequenceType`

        Created By:           User (optional)

        Description:
          Deprecated, Will be removed because rules themselves are already an ordered list

    * rule_uuid
        Type:           str

        Created By:           User (optional)

        Description:
          Rule UUID is identifier used in flow records to identify rule

    * direction
        Type:           str, *one-of* [u'>', u'<>']

        Created By:           User (required)

    * protocol
        Type:           str

        Created By:           User (required)

        Description:
          Layer 4 protocol in ip packet

    * src_addresses
        Type:           :class:`.AddressType`

        Created By:           User (required)

        Description:
          Source ip matching criteria

    * src_ports
        Type:           :class:`.PortType`

        Created By:           User (required)

        Description:
          Range of source port for layer 4 protocol

    * application
        Type:           str

        Created By:           User (optional)

        Description:
          Optionally application can be specified instead of protocol and port. not

          currently implemented

    * dst_addresses
        Type:           :class:`.AddressType`

        Created By:           User (required)

        Description:
          Destination ip matching criteria

    * dst_ports
        Type:           :class:`.PortType`

        Created By:           User (required)

        Description:
          Range of destination  port for layer 4 protocol

    * action_list
        Type:           :class:`.ActionListType`

        Created By:           User (required)

        Description:
          Actions to be performed if packets match condition

    * ethertype
        Type:           str, *one-of* [u'IPv4', u'IPv6']

        Created By:           User (required)

    * created
        Type:           :class:`.xsd:dateTime`

        Created By:           User (optional)

        Description:
          timestamp when security group rule object gets created

    * last_modified
        Type:           :class:`.xsd:dateTime`

        Created By:           User (optional)

        Description:
          timestamp when security group rule object gets updated

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'rule_sequence', u'rule_uuid', u'direction', u'protocol', u'src_addresses', u'src_ports', u'application', u'dst_addresses', u'dst_ports', u'action_list', u'ethertype', u'created', u'last_modified']
    attr_field_type_vals = {u'direction': {'restrictions': [u'>', u'<>'], 'description': [], 'simple_type': u'DirectionType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'true', 'attr_type': u'string'}, u'protocol': {'restrictions': None, 'description': [u'Layer 4 protocol in ip packet'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'true', 'attr_type': u'string'}, u'dst_addresses': {'restrictions': None, 'description': [u'Destination ip matching criteria'], 'simple_type': u'AddressType', 'is_complex': 1, 'restriction_type': None, 'is_array': True, 'required': u'true', 'attr_type': u'AddressType'}, u'action_list': {'restrictions': None, 'description': [u'Actions to be performed if packets match condition'], 'simple_type': u'ActionListType', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': u'true', 'attr_type': u'ActionListType'}, u'created': {'restrictions': None, 'description': [u'timestamp when security group rule object gets created'], 'simple_type': u'xsd:dateTime', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'dateTime'}, u'rule_uuid': {'restrictions': None, 'description': [u'Rule UUID is identifier used in flow records to identify rule'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'dst_ports': {'restrictions': None, 'description': [u'Range of destination  port for layer 4 protocol'], 'simple_type': u'PortType', 'is_complex': 1, 'restriction_type': None, 'is_array': True, 'required': u'true', 'attr_type': u'PortType'}, u'application': {'restrictions': None, 'description': [u'Optionally application can be specified instead of protocol and port. not currently implemented'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': True, 'required': u'optional', 'attr_type': u'string'}, u'last_modified': {'restrictions': None, 'description': [u'timestamp when security group rule object gets updated'], 'simple_type': u'xsd:dateTime', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'dateTime'}, u'ethertype': {'restrictions': [u'IPv4', u'IPv6'], 'description': [], 'simple_type': u'EtherType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'true', 'attr_type': u'string'}, u'src_addresses': {'restrictions': None, 'description': [u'Source ip matching criteria'], 'simple_type': u'AddressType', 'is_complex': 1, 'restriction_type': None, 'is_array': True, 'required': u'true', 'attr_type': u'AddressType'}, u'rule_sequence': {'restrictions': None, 'description': [u'Deprecated, Will be removed because rules themselves are already an ordered list'], 'simple_type': u'SequenceType', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'SequenceType'}, u'src_ports': {'restrictions': None, 'description': [u'Range of source port for layer 4 protocol'], 'simple_type': u'PortType', 'is_complex': 1, 'restriction_type': None, 'is_array': True, 'required': u'true', 'attr_type': u'PortType'}}
    def __init__(self, rule_sequence=None, rule_uuid=None, direction=None, protocol=None, src_addresses=None, src_ports=None, application=None, dst_addresses=None, dst_ports=None, action_list=None, ethertype=None, created=None, last_modified=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _rule_sequence = params_dict[u"rule_sequence"]
        except KeyError:
            _rule_sequence = rule_sequence
        if isinstance(_rule_sequence, dict):
            obj = SequenceType(params_dict=_rule_sequence)
            self.rule_sequence = obj
        else:
            self.rule_sequence = _rule_sequence
        try:
            _rule_uuid = params_dict[u"rule_uuid"]
        except KeyError:
            _rule_uuid = rule_uuid
        self.rule_uuid = _rule_uuid
        try:
            _direction = params_dict[u"direction"]
        except KeyError:
            _direction = direction
        self.direction = _direction
        try:
            _protocol = params_dict[u"protocol"]
        except KeyError:
            _protocol = protocol
        self.protocol = _protocol
        try:
            _src_addresses = params_dict[u"src_addresses"]
        except KeyError:
            _src_addresses = src_addresses
        if not _src_addresses:
            self.src_addresses = []
        else:
            if isinstance(_src_addresses[0], dict):
                objs = [AddressType(params_dict=elem) for elem in _src_addresses]
                self.src_addresses = objs
            else:
                self.src_addresses = _src_addresses
        try:
            _src_ports = params_dict[u"src_ports"]
        except KeyError:
            _src_ports = src_ports
        if not _src_ports:
            self.src_ports = []
        else:
            if isinstance(_src_ports[0], dict):
                objs = [PortType(params_dict=elem) for elem in _src_ports]
                self.src_ports = objs
            else:
                self.src_ports = _src_ports
        try:
            _application = params_dict[u"application"]
        except KeyError:
            _application = application
        if not _application:
            self.application = []
        else:
            self.application = _application
        try:
            _dst_addresses = params_dict[u"dst_addresses"]
        except KeyError:
            _dst_addresses = dst_addresses
        if not _dst_addresses:
            self.dst_addresses = []
        else:
            if isinstance(_dst_addresses[0], dict):
                objs = [AddressType(params_dict=elem) for elem in _dst_addresses]
                self.dst_addresses = objs
            else:
                self.dst_addresses = _dst_addresses
        try:
            _dst_ports = params_dict[u"dst_ports"]
        except KeyError:
            _dst_ports = dst_ports
        if not _dst_ports:
            self.dst_ports = []
        else:
            if isinstance(_dst_ports[0], dict):
                objs = [PortType(params_dict=elem) for elem in _dst_ports]
                self.dst_ports = objs
            else:
                self.dst_ports = _dst_ports
        try:
            _action_list = params_dict[u"action_list"]
        except KeyError:
            _action_list = action_list
        if isinstance(_action_list, dict):
            obj = ActionListType(params_dict=_action_list)
            self.action_list = obj
        else:
            self.action_list = _action_list
        try:
            _ethertype = params_dict[u"ethertype"]
        except KeyError:
            _ethertype = ethertype
        self.ethertype = _ethertype
        try:
            _created = params_dict[u"created"]
        except KeyError:
            _created = created
        self.created = _created
        try:
            _last_modified = params_dict[u"last_modified"]
        except KeyError:
            _last_modified = last_modified
        self.last_modified = _last_modified
    def factory(*args_, **kwargs_):
        if PolicyRuleType.subclass:
            return PolicyRuleType.subclass(*args_, **kwargs_)
        else:
            return PolicyRuleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rule_sequence(self): return self.rule_sequence
    def set_rule_sequence(self, rule_sequence): self.rule_sequence = rule_sequence
    def get_rule_uuid(self): return self.rule_uuid
    def set_rule_uuid(self, rule_uuid): self.rule_uuid = rule_uuid
    def get_direction(self): return self.direction
    def set_direction(self, direction): self.direction = direction
    def validate_DirectionType(self, value):
        # Validate type DirectionType, a restriction on xsd:string.
        error = False
        if isinstance(value, list):
            error = set(value) - set([u'>', u'<>'])
        else:
            error = value not in [u'>', u'<>']
        if error:
            raise ValueError("DirectionType must be one of [u'>', u'<>']")
    def get_protocol(self): return self.protocol
    def set_protocol(self, protocol): self.protocol = protocol
    def get_src_addresses(self): return self.src_addresses
    def set_src_addresses(self, src_addresses): self.src_addresses = src_addresses
    def add_src_addresses(self, value): self.src_addresses.append(value)
    def insert_src_addresses(self, index, value): self.src_addresses[index] = value
    def delete_src_addresses(self, value): self.src_addresses.remove(value)
    def get_src_ports(self): return self.src_ports
    def set_src_ports(self, src_ports): self.src_ports = src_ports
    def add_src_ports(self, value): self.src_ports.append(value)
    def insert_src_ports(self, index, value): self.src_ports[index] = value
    def delete_src_ports(self, value): self.src_ports.remove(value)
    def get_application(self): return self.application
    def set_application(self, application): self.application = application
    def add_application(self, value): self.application.append(value)
    def insert_application(self, index, value): self.application[index] = value
    def delete_application(self, value): self.application.remove(value)
    def get_dst_addresses(self): return self.dst_addresses
    def set_dst_addresses(self, dst_addresses): self.dst_addresses = dst_addresses
    def add_dst_addresses(self, value): self.dst_addresses.append(value)
    def insert_dst_addresses(self, index, value): self.dst_addresses[index] = value
    def delete_dst_addresses(self, value): self.dst_addresses.remove(value)
    def get_dst_ports(self): return self.dst_ports
    def set_dst_ports(self, dst_ports): self.dst_ports = dst_ports
    def add_dst_ports(self, value): self.dst_ports.append(value)
    def insert_dst_ports(self, index, value): self.dst_ports[index] = value
    def delete_dst_ports(self, value): self.dst_ports.remove(value)
    def get_action_list(self): return self.action_list
    def set_action_list(self, action_list): self.action_list = action_list
    def get_ethertype(self): return self.ethertype
    def set_ethertype(self, ethertype): self.ethertype = ethertype
    def validate_EtherType(self, value):
        # Validate type EtherType, a restriction on xsd:string.
        error = False
        if isinstance(value, list):
            error = set(value) - set([u'IPv4', u'IPv6'])
        else:
            error = value not in [u'IPv4', u'IPv6']
        if error:
            raise ValueError("EtherType must be one of [u'IPv4', u'IPv6']")
    def get_created(self): return self.created
    def set_created(self, created): self.created = created
    def get_last_modified(self): return self.last_modified
    def set_last_modified(self, last_modified): self.last_modified = last_modified
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.rule_sequence == other.rule_sequence and
                    self.rule_uuid == other.rule_uuid and
                    self.direction == other.direction and
                    self.protocol == other.protocol and
                    self.src_addresses == other.src_addresses and
                    self.src_ports == other.src_ports and
                    self.application == other.application and
                    self.dst_addresses == other.dst_addresses and
                    self.dst_ports == other.dst_ports and
                    self.action_list == other.action_list and
                    self.ethertype == other.ethertype and
                    self.created == other.created and
                    self.last_modified == other.last_modified)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.rule_sequence if self.rule_sequence is not None else -7985492147856592190,
                     self.rule_uuid if self.rule_uuid is not None else -7985492147856592190,
                     self.direction if self.direction is not None else -7985492147856592190,
                     self.protocol if self.protocol is not None else -7985492147856592190,
                     tuple(self.src_addresses or []),
                     tuple(self.src_ports or []),
                     tuple(self.application or []),
                     tuple(self.dst_addresses or []),
                     tuple(self.dst_ports or []),
                     self.action_list if self.action_list is not None else -7985492147856592190,
                     self.ethertype if self.ethertype is not None else -7985492147856592190,
                     self.created if self.created is not None else -7985492147856592190,
                     self.last_modified if self.last_modified is not None else -7985492147856592190))

    def __repr__(self):
        return ("rule_sequence = " + str(self.rule_sequence) + ", " +
                "rule_uuid = " + str(self.rule_uuid) + ", " +
                "direction = " + str(self.direction) + ", " +
                "protocol = " + str(self.protocol) + ", " +
                "src_addresses = " + str(self.src_addresses) + ", " +
                "src_ports = " + str(self.src_ports) + ", " +
                "application = " + str(self.application) + ", " +
                "dst_addresses = " + str(self.dst_addresses) + ", " +
                "dst_ports = " + str(self.dst_ports) + ", " +
                "action_list = " + str(self.action_list) + ", " +
                "ethertype = " + str(self.ethertype) + ", " +
                "created = " + str(self.created) + ", " +
                "last_modified = " + str(self.last_modified))

    def copy(self):
        cp = PolicyRuleType()
        if self.rule_sequence is not None:
            cp.rule_sequence = self.rule_sequence.copy()
        if self.rule_uuid is not None:
            cp.rule_uuid = self.rule_uuid
        if self.direction is not None:
            cp.direction = self.direction
        if self.protocol is not None:
            cp.protocol = self.protocol
        if self.src_addresses is not None:
            cp.src_addresses = [x.copy() for x in self.src_addresses]
        if self.src_ports is not None:
            cp.src_ports = [x.copy() for x in self.src_ports]
        if self.application is not None:
            cp.application = list(self.application)
        if self.dst_addresses is not None:
            cp.dst_addresses = [x.copy() for x in self.dst_addresses]
        if self.dst_ports is not None:
            cp.dst_ports = [x.copy() for x in self.dst_ports]
        if self.action_list is not None:
            cp.action_list = self.action_list.copy()
        if self.ethertype is not None:
            cp.ethertype = self.ethertype
        if self.created is not None:
            cp.created = self.created
        if self.last_modified is not None:
            cp.last_modified = self.last_modified
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_rule_sequence (SequenceType.populate ())
        obj.set_rule_uuid (obj.populate_string ("rule_uuid"))
        obj.set_direction (obj.populate_string ("direction"))
        obj.set_protocol (obj.populate_string ("protocol"))
        obj.set_src_addresses ([AddressType.populate ()])
        obj.set_src_ports ([PortType.populate ()])
        obj.set_application ([obj.populate_string ("application")])
        obj.set_dst_addresses ([AddressType.populate ()])
        obj.set_dst_ports ([PortType.populate ()])
        obj.set_action_list (ActionListType.populate ())
        obj.set_ethertype (obj.populate_string ("ethertype"))
        obj.set_created (obj.populate_dateTime ("created"))
        obj.set_last_modified (obj.populate_dateTime ("last_modified"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='PolicyRuleType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PolicyRuleType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PolicyRuleType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PolicyRuleType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.rule_sequence is not None:
            self.rule_sequence.export_xml(outfile, level, namespace_, name_='rule-sequence', pretty_print=pretty_print)
        if self.rule_uuid is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srule-uuid>%s</%srule-uuid>%s' % (namespace_, self.gds_format_string(quote_xml(self.rule_uuid).encode(ExternalEncoding), input_name='rule-uuid'), namespace_, eol_))
        if self.direction is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdirection>%s</%sdirection>%s' % (namespace_, self.gds_format_string(quote_xml(self.direction).encode(ExternalEncoding), input_name='direction'), namespace_, eol_))
        if self.protocol is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprotocol>%s</%sprotocol>%s' % (namespace_, self.gds_format_string(quote_xml(self.protocol).encode(ExternalEncoding), input_name='protocol'), namespace_, eol_))
        for src_addresses_ in self.src_addresses:
            if isinstance(src_addresses_, dict):
                src_addresses_ = AddressType(**src_addresses_)
            src_addresses_.export_xml(outfile, level, namespace_, name_='src-addresses', pretty_print=pretty_print)
        for src_ports_ in self.src_ports:
            if isinstance(src_ports_, dict):
                src_ports_ = PortType(**src_ports_)
            src_ports_.export_xml(outfile, level, namespace_, name_='src-ports', pretty_print=pretty_print)
        for application_ in self.application:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sapplication>%s</%sapplication>%s' % (namespace_, self.gds_format_string(quote_xml(application_).encode(ExternalEncoding), input_name='application'), namespace_, eol_))
        for dst_addresses_ in self.dst_addresses:
            if isinstance(dst_addresses_, dict):
                dst_addresses_ = AddressType(**dst_addresses_)
            dst_addresses_.export_xml(outfile, level, namespace_, name_='dst-addresses', pretty_print=pretty_print)
        for dst_ports_ in self.dst_ports:
            if isinstance(dst_ports_, dict):
                dst_ports_ = PortType(**dst_ports_)
            dst_ports_.export_xml(outfile, level, namespace_, name_='dst-ports', pretty_print=pretty_print)
        if self.action_list is not None:
            self.action_list.export_xml(outfile, level, namespace_, name_='action-list', pretty_print=pretty_print)
        if self.ethertype is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sethertype>%s</%sethertype>%s' % (namespace_, self.gds_format_string(quote_xml(self.ethertype).encode(ExternalEncoding), input_name='ethertype'), namespace_, eol_))
        if self.created is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%screated>%s</%screated>%s' % (namespace_, self.gds_format_string(quote_xml(self.created).encode(ExternalEncoding), input_name='created'), namespace_, eol_))
        if self.last_modified is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slast-modified>%s</%slast-modified>%s' % (namespace_, self.gds_format_string(quote_xml(self.last_modified).encode(ExternalEncoding), input_name='last-modified'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.rule_sequence is not None or
            self.rule_uuid is not None or
            self.direction is not None or
            self.protocol is not None or
            self.src_addresses or
            self.src_ports or
            self.application or
            self.dst_addresses or
            self.dst_ports or
            self.action_list is not None or
            self.ethertype is not None or
            self.created is not None or
            self.last_modified is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PolicyRuleType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.rule_sequence is not None:
            showIndent(outfile, level)
            outfile.write('rule_sequence=model_.SequenceType(\n')
            self.rule_sequence.exportLiteral(outfile, level, name_='rule_sequence')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.rule_uuid is not None:
            showIndent(outfile, level)
            outfile.write('rule_uuid=%s,\n' % quote_python(self.rule_uuid).encode(ExternalEncoding))
        if self.direction is not None:
            showIndent(outfile, level)
            outfile.write('direction=%s,\n' % quote_python(self.direction).encode(ExternalEncoding))
        if self.protocol is not None:
            showIndent(outfile, level)
            outfile.write('protocol=%s,\n' % quote_python(self.protocol).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('src_addresses=[\n')
        level += 1
        for src_addresses_ in self.src_addresses:
            showIndent(outfile, level)
            outfile.write('model_.AddressType(\n')
            src_addresses_.exportLiteral(outfile, level, name_='AddressType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('src_ports=[\n')
        level += 1
        for src_ports_ in self.src_ports:
            showIndent(outfile, level)
            outfile.write('model_.PortType(\n')
            src_ports_.exportLiteral(outfile, level, name_='PortType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('application=[\n')
        level += 1
        for application_ in self.application:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(application_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('dst_addresses=[\n')
        level += 1
        for dst_addresses_ in self.dst_addresses:
            showIndent(outfile, level)
            outfile.write('model_.AddressType(\n')
            dst_addresses_.exportLiteral(outfile, level, name_='AddressType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('dst_ports=[\n')
        level += 1
        for dst_ports_ in self.dst_ports:
            showIndent(outfile, level)
            outfile.write('model_.PortType(\n')
            dst_ports_.exportLiteral(outfile, level, name_='PortType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.action_list is not None:
            showIndent(outfile, level)
            outfile.write('action_list=model_.ActionListType(\n')
            self.action_list.exportLiteral(outfile, level, name_='action_list')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ethertype is not None:
            showIndent(outfile, level)
            outfile.write('ethertype=%s,\n' % quote_python(self.ethertype).encode(ExternalEncoding))
        if self.created is not None:
            showIndent(outfile, level)
            outfile.write('created=%s,\n' % quote_python(self.created).encode(ExternalEncoding))
        if self.last_modified is not None:
            showIndent(outfile, level)
            outfile.write('last_modified=%s,\n' % quote_python(self.last_modified).encode(ExternalEncoding))
    def exportDict(self, name_='PolicyRuleType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'rule-sequence':
            obj_ = SequenceType.factory()
            obj_.build(child_)
            self.set_rule_sequence(obj_)
        elif nodeName_ == 'rule-uuid':
            rule_uuid_ = child_.text
            rule_uuid_ = self.gds_validate_string(rule_uuid_, node, 'rule_uuid')
            self.rule_uuid = rule_uuid_
        elif nodeName_ == 'direction':
            direction_ = child_.text
            direction_ = self.gds_validate_string(direction_, node, 'direction')
            self.direction = direction_
            self.validate_DirectionType(self.direction)    # validate type DirectionType
        elif nodeName_ == 'protocol':
            protocol_ = child_.text
            protocol_ = self.gds_validate_string(protocol_, node, 'protocol')
            self.protocol = protocol_
        elif nodeName_ == 'src-addresses':
            obj_ = AddressType.factory()
            obj_.build(child_)
            self.src_addresses.append(obj_)
        elif nodeName_ == 'src-ports':
            obj_ = PortType.factory()
            obj_.build(child_)
            self.src_ports.append(obj_)
        elif nodeName_ == 'application':
            application_ = child_.text
            application_ = self.gds_validate_string(application_, node, 'application')
            self.application.append(application_)
        elif nodeName_ == 'dst-addresses':
            obj_ = AddressType.factory()
            obj_.build(child_)
            self.dst_addresses.append(obj_)
        elif nodeName_ == 'dst-ports':
            obj_ = PortType.factory()
            obj_.build(child_)
            self.dst_ports.append(obj_)
        elif nodeName_ == 'action-list':
            obj_ = ActionListType.factory()
            obj_.build(child_)
            self.set_action_list(obj_)
        elif nodeName_ == 'ethertype':
            ethertype_ = child_.text
            ethertype_ = self.gds_validate_string(ethertype_, node, 'ethertype')
            self.ethertype = ethertype_
            self.validate_EtherType(self.ethertype)    # validate type EtherType
        elif nodeName_ == 'created':
            created_ = child_.text
            created_ = self.gds_validate_string(created_, node, 'created')
            self.created = created_
        elif nodeName_ == 'last-modified':
            last_modified_ = child_.text
            last_modified_ = self.gds_validate_string(last_modified_, node, 'last_modified')
            self.last_modified = last_modified_
# end class PolicyRuleType


class PolicyEntriesType(GeneratedsSuper):
    """
    Attributes:
    * policy_rule
        Type:           :class:`.PolicyRuleType`

        Created By:           User (required)

        Description:
          List of policy rules

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'policy_rule']
    attr_field_type_vals = {u'policy_rule': {'restrictions': None, 'description': [u'List of policy rules'], 'simple_type': u'PolicyRuleType', 'is_complex': 1, 'restriction_type': None, 'is_array': True, 'required': u'true', 'attr_type': u'PolicyRuleType'}}
    def __init__(self, policy_rule=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _policy_rule = params_dict[u"policy_rule"]
        except KeyError:
            _policy_rule = policy_rule
        if not _policy_rule:
            self.policy_rule = []
        else:
            if isinstance(_policy_rule[0], dict):
                objs = [PolicyRuleType(params_dict=elem) for elem in _policy_rule]
                self.policy_rule = objs
            else:
                self.policy_rule = _policy_rule
    def factory(*args_, **kwargs_):
        if PolicyEntriesType.subclass:
            return PolicyEntriesType.subclass(*args_, **kwargs_)
        else:
            return PolicyEntriesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_policy_rule(self): return self.policy_rule
    def set_policy_rule(self, policy_rule): self.policy_rule = policy_rule
    def add_policy_rule(self, value): self.policy_rule.append(value)
    def insert_policy_rule(self, index, value): self.policy_rule[index] = value
    def delete_policy_rule(self, value): self.policy_rule.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.policy_rule == other.policy_rule)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.policy_rule or [])))

    def __repr__(self):
        return ("policy_rule = " + str(self.policy_rule))

    def copy(self):
        cp = PolicyEntriesType()
        if self.policy_rule is not None:
            cp.policy_rule = [x.copy() for x in self.policy_rule]
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_policy_rule ([PolicyRuleType.populate ()])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='PolicyEntriesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PolicyEntriesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PolicyEntriesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PolicyEntriesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for policy_rule_ in self.policy_rule:
            if isinstance(policy_rule_, dict):
                policy_rule_ = PolicyRuleType(**policy_rule_)
            policy_rule_.export_xml(outfile, level, namespace_, name_='policy-rule', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.policy_rule
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PolicyEntriesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('policy_rule=[\n')
        level += 1
        for policy_rule_ in self.policy_rule:
            showIndent(outfile, level)
            outfile.write('model_.PolicyRuleType(\n')
            policy_rule_.exportLiteral(outfile, level, name_='PolicyRuleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='PolicyEntriesType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'policy-rule':
            obj_ = PolicyRuleType.factory()
            obj_.build(child_)
            self.policy_rule.append(obj_)
# end class PolicyEntriesType


class ApiAccessType(GeneratedsSuper):
    """
    Attributes:
    * api_name
        Type:           str

        Created By:           User (required)

    * permissions
        Type:           :class:`.PermType`

        Created By:           User (required)

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'api_name', u'permissions']
    attr_field_type_vals = {u'api_name': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'true', 'attr_type': u'string'}, u'permissions': {'restrictions': None, 'description': [], 'simple_type': u'PermType', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': u'true', 'attr_type': u'PermType'}}
    def __init__(self, api_name=None, permissions=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _api_name = params_dict[u"api_name"]
        except KeyError:
            _api_name = api_name
        self.api_name = _api_name
        try:
            _permissions = params_dict[u"permissions"]
        except KeyError:
            _permissions = permissions
        if isinstance(_permissions, dict):
            obj = PermType(params_dict=_permissions)
            self.permissions = obj
        else:
            self.permissions = _permissions
    def factory(*args_, **kwargs_):
        if ApiAccessType.subclass:
            return ApiAccessType.subclass(*args_, **kwargs_)
        else:
            return ApiAccessType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_api_name(self): return self.api_name
    def set_api_name(self, api_name): self.api_name = api_name
    def get_permissions(self): return self.permissions
    def set_permissions(self, permissions): self.permissions = permissions
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.api_name == other.api_name and
                    self.permissions == other.permissions)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.api_name if self.api_name is not None else -7985492147856592190,
                     self.permissions if self.permissions is not None else -7985492147856592190))

    def __repr__(self):
        return ("api_name = " + str(self.api_name) + ", " +
                "permissions = " + str(self.permissions))

    def copy(self):
        cp = ApiAccessType()
        if self.api_name is not None:
            cp.api_name = self.api_name
        if self.permissions is not None:
            cp.permissions = self.permissions.copy()
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_api_name (obj.populate_string ("api_name"))
        obj.set_permissions (PermType.populate ())
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='ApiAccessType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ApiAccessType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ApiAccessType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ApiAccessType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.api_name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sapi-name>%s</%sapi-name>%s' % (namespace_, self.gds_format_string(quote_xml(self.api_name).encode(ExternalEncoding), input_name='api-name'), namespace_, eol_))
        if self.permissions is not None:
            self.permissions.export_xml(outfile, level, namespace_, name_='permissions', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.api_name is not None or
            self.permissions is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ApiAccessType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.api_name is not None:
            showIndent(outfile, level)
            outfile.write('api_name=%s,\n' % quote_python(self.api_name).encode(ExternalEncoding))
        if self.permissions is not None:
            showIndent(outfile, level)
            outfile.write('permissions=model_.PermType(\n')
            self.permissions.exportLiteral(outfile, level, name_='permissions')
            showIndent(outfile, level)
            outfile.write('),\n')
    def exportDict(self, name_='ApiAccessType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'api-name':
            api_name_ = child_.text
            api_name_ = self.gds_validate_string(api_name_, node, 'api_name')
            self.api_name = api_name_
        elif nodeName_ == 'permissions':
            obj_ = PermType.factory()
            obj_.build(child_)
            self.set_permissions(obj_)
# end class ApiAccessType


class ApiAccessListType(GeneratedsSuper):
    """
    Attributes:
    * api_access
        Type:           :class:`.ApiAccessType`

        Created By:           User (required)

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'api_access']
    attr_field_type_vals = {u'api_access': {'restrictions': None, 'description': [], 'simple_type': u'ApiAccessType', 'is_complex': 1, 'restriction_type': None, 'is_array': True, 'required': u'true', 'attr_type': u'ApiAccessType'}}
    def __init__(self, api_access=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _api_access = params_dict[u"api_access"]
        except KeyError:
            _api_access = api_access
        if not _api_access:
            self.api_access = []
        else:
            if isinstance(_api_access[0], dict):
                objs = [ApiAccessType(params_dict=elem) for elem in _api_access]
                self.api_access = objs
            else:
                self.api_access = _api_access
    def factory(*args_, **kwargs_):
        if ApiAccessListType.subclass:
            return ApiAccessListType.subclass(*args_, **kwargs_)
        else:
            return ApiAccessListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_api_access(self): return self.api_access
    def set_api_access(self, api_access): self.api_access = api_access
    def add_api_access(self, value): self.api_access.append(value)
    def insert_api_access(self, index, value): self.api_access[index] = value
    def delete_api_access(self, value): self.api_access.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.api_access == other.api_access)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.api_access or [])))

    def __repr__(self):
        return ("api_access = " + str(self.api_access))

    def copy(self):
        cp = ApiAccessListType()
        if self.api_access is not None:
            cp.api_access = [x.copy() for x in self.api_access]
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_api_access ([ApiAccessType.populate ()])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='ApiAccessListType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ApiAccessListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ApiAccessListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ApiAccessListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for api_access_ in self.api_access:
            if isinstance(api_access_, dict):
                api_access_ = ApiAccessType(**api_access_)
            api_access_.export_xml(outfile, level, namespace_, name_='api-access', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.api_access
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ApiAccessListType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('api_access=[\n')
        level += 1
        for api_access_ in self.api_access:
            showIndent(outfile, level)
            outfile.write('model_.ApiAccessType(\n')
            api_access_.exportLiteral(outfile, level, name_='ApiAccessType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='ApiAccessListType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'api-access':
            obj_ = ApiAccessType.factory()
            obj_.build(child_)
            self.api_access.append(obj_)
# end class ApiAccessListType


class DhcpOptionType(GeneratedsSuper):
    """
    Attributes:
    * dhcp_option_name
        Type:           str

        Created By:           User (required)

        Description:
          Name of the DHCP option

    * dhcp_option_value
        Type:           str

        Created By:           User (required)

        Description:
          Encoded DHCP option value (decimal)

    * dhcp_option_value_bytes
        Type:           str

        Created By:           User (required)

        Description:
          Value of the DHCP option to be copied byte by byte

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'dhcp_option_name', u'dhcp_option_value', u'dhcp_option_value_bytes']
    attr_field_type_vals = {u'dhcp_option_value': {'restrictions': None, 'description': [u'Encoded DHCP option value (decimal)'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'true', 'attr_type': u'string'}, u'dhcp_option_value_bytes': {'restrictions': None, 'description': [u'Value of the DHCP option to be copied byte by byte'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'true', 'attr_type': u'string'}, u'dhcp_option_name': {'restrictions': None, 'description': [u'Name of the DHCP option'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'true', 'attr_type': u'string'}}
    def __init__(self, dhcp_option_name=None, dhcp_option_value=None, dhcp_option_value_bytes=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _dhcp_option_name = params_dict[u"dhcp_option_name"]
        except KeyError:
            _dhcp_option_name = dhcp_option_name
        self.dhcp_option_name = _dhcp_option_name
        try:
            _dhcp_option_value = params_dict[u"dhcp_option_value"]
        except KeyError:
            _dhcp_option_value = dhcp_option_value
        self.dhcp_option_value = _dhcp_option_value
        try:
            _dhcp_option_value_bytes = params_dict[u"dhcp_option_value_bytes"]
        except KeyError:
            _dhcp_option_value_bytes = dhcp_option_value_bytes
        self.dhcp_option_value_bytes = _dhcp_option_value_bytes
    def factory(*args_, **kwargs_):
        if DhcpOptionType.subclass:
            return DhcpOptionType.subclass(*args_, **kwargs_)
        else:
            return DhcpOptionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dhcp_option_name(self): return self.dhcp_option_name
    def set_dhcp_option_name(self, dhcp_option_name): self.dhcp_option_name = dhcp_option_name
    def get_dhcp_option_value(self): return self.dhcp_option_value
    def set_dhcp_option_value(self, dhcp_option_value): self.dhcp_option_value = dhcp_option_value
    def get_dhcp_option_value_bytes(self): return self.dhcp_option_value_bytes
    def set_dhcp_option_value_bytes(self, dhcp_option_value_bytes): self.dhcp_option_value_bytes = dhcp_option_value_bytes
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.dhcp_option_name == other.dhcp_option_name and
                    self.dhcp_option_value == other.dhcp_option_value and
                    self.dhcp_option_value_bytes == other.dhcp_option_value_bytes)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.dhcp_option_name if self.dhcp_option_name is not None else -7985492147856592190,
                     self.dhcp_option_value if self.dhcp_option_value is not None else -7985492147856592190,
                     self.dhcp_option_value_bytes if self.dhcp_option_value_bytes is not None else -7985492147856592190))

    def __repr__(self):
        return ("dhcp_option_name = " + str(self.dhcp_option_name) + ", " +
                "dhcp_option_value = " + str(self.dhcp_option_value) + ", " +
                "dhcp_option_value_bytes = " + str(self.dhcp_option_value_bytes))

    def copy(self):
        cp = DhcpOptionType()
        if self.dhcp_option_name is not None:
            cp.dhcp_option_name = self.dhcp_option_name
        if self.dhcp_option_value is not None:
            cp.dhcp_option_value = self.dhcp_option_value
        if self.dhcp_option_value_bytes is not None:
            cp.dhcp_option_value_bytes = self.dhcp_option_value_bytes
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_dhcp_option_name (obj.populate_string ("dhcp_option_name"))
        obj.set_dhcp_option_value (obj.populate_string ("dhcp_option_value"))
        obj.set_dhcp_option_value_bytes (obj.populate_string ("dhcp_option_value_bytes"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='DhcpOptionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DhcpOptionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DhcpOptionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DhcpOptionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.dhcp_option_name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdhcp-option-name>%s</%sdhcp-option-name>%s' % (namespace_, self.gds_format_string(quote_xml(self.dhcp_option_name).encode(ExternalEncoding), input_name='dhcp-option-name'), namespace_, eol_))
        if self.dhcp_option_value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdhcp-option-value>%s</%sdhcp-option-value>%s' % (namespace_, self.gds_format_string(quote_xml(self.dhcp_option_value).encode(ExternalEncoding), input_name='dhcp-option-value'), namespace_, eol_))
        if self.dhcp_option_value_bytes is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdhcp-option-value-bytes>%s</%sdhcp-option-value-bytes>%s' % (namespace_, self.gds_format_string(quote_xml(self.dhcp_option_value_bytes).encode(ExternalEncoding), input_name='dhcp-option-value-bytes'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.dhcp_option_name is not None or
            self.dhcp_option_value is not None or
            self.dhcp_option_value_bytes is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DhcpOptionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.dhcp_option_name is not None:
            showIndent(outfile, level)
            outfile.write('dhcp_option_name=%s,\n' % quote_python(self.dhcp_option_name).encode(ExternalEncoding))
        if self.dhcp_option_value is not None:
            showIndent(outfile, level)
            outfile.write('dhcp_option_value=%s,\n' % quote_python(self.dhcp_option_value).encode(ExternalEncoding))
        if self.dhcp_option_value_bytes is not None:
            showIndent(outfile, level)
            outfile.write('dhcp_option_value_bytes=%s,\n' % quote_python(self.dhcp_option_value_bytes).encode(ExternalEncoding))
    def exportDict(self, name_='DhcpOptionType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dhcp-option-name':
            dhcp_option_name_ = child_.text
            dhcp_option_name_ = self.gds_validate_string(dhcp_option_name_, node, 'dhcp_option_name')
            self.dhcp_option_name = dhcp_option_name_
        elif nodeName_ == 'dhcp-option-value':
            dhcp_option_value_ = child_.text
            dhcp_option_value_ = self.gds_validate_string(dhcp_option_value_, node, 'dhcp_option_value')
            self.dhcp_option_value = dhcp_option_value_
        elif nodeName_ == 'dhcp-option-value-bytes':
            dhcp_option_value_bytes_ = child_.text
            dhcp_option_value_bytes_ = self.gds_validate_string(dhcp_option_value_bytes_, node, 'dhcp_option_value_bytes')
            self.dhcp_option_value_bytes = dhcp_option_value_bytes_
# end class DhcpOptionType


class DhcpOptionsListType(GeneratedsSuper):
    """
    Attributes:
    * dhcp_option
        Type:           :class:`.DhcpOptionType`

        Description:
          List of DHCP options

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'dhcp_option']
    attr_field_type_vals = {u'dhcp_option': {'restrictions': None, 'description': [u'List of DHCP options'], 'simple_type': u'DhcpOptionType', 'is_complex': 1, 'restriction_type': None, 'is_array': True, 'required': None, 'attr_type': u'DhcpOptionType'}}
    def __init__(self, dhcp_option=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _dhcp_option = params_dict[u"dhcp_option"]
        except KeyError:
            _dhcp_option = dhcp_option
        if not _dhcp_option:
            self.dhcp_option = []
        else:
            if isinstance(_dhcp_option[0], dict):
                objs = [DhcpOptionType(params_dict=elem) for elem in _dhcp_option]
                self.dhcp_option = objs
            else:
                self.dhcp_option = _dhcp_option
    def factory(*args_, **kwargs_):
        if DhcpOptionsListType.subclass:
            return DhcpOptionsListType.subclass(*args_, **kwargs_)
        else:
            return DhcpOptionsListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dhcp_option(self): return self.dhcp_option
    def set_dhcp_option(self, dhcp_option): self.dhcp_option = dhcp_option
    def add_dhcp_option(self, value): self.dhcp_option.append(value)
    def insert_dhcp_option(self, index, value): self.dhcp_option[index] = value
    def delete_dhcp_option(self, value): self.dhcp_option.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.dhcp_option == other.dhcp_option)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.dhcp_option or [])))

    def __repr__(self):
        return ("dhcp_option = " + str(self.dhcp_option))

    def copy(self):
        cp = DhcpOptionsListType()
        if self.dhcp_option is not None:
            cp.dhcp_option = [x.copy() for x in self.dhcp_option]
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_dhcp_option ([DhcpOptionType.populate ()])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='DhcpOptionsListType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DhcpOptionsListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DhcpOptionsListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DhcpOptionsListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for dhcp_option_ in self.dhcp_option:
            if isinstance(dhcp_option_, dict):
                dhcp_option_ = DhcpOptionType(**dhcp_option_)
            dhcp_option_.export_xml(outfile, level, namespace_, name_='dhcp-option', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.dhcp_option
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DhcpOptionsListType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('dhcp_option=[\n')
        level += 1
        for dhcp_option_ in self.dhcp_option:
            showIndent(outfile, level)
            outfile.write('model_.DhcpOptionType(\n')
            dhcp_option_.exportLiteral(outfile, level, name_='DhcpOptionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='DhcpOptionsListType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dhcp-option':
            obj_ = DhcpOptionType.factory()
            obj_.build(child_)
            self.dhcp_option.append(obj_)
# end class DhcpOptionsListType


class DeviceFamilyListType(GeneratedsSuper):
    """
    Attributes:
    * device_family
        Type:           str

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'device_family']
    attr_field_type_vals = {u'device_family': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': True, 'required': None, 'attr_type': u'string'}}
    def __init__(self, device_family=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _device_family = params_dict[u"device_family"]
        except KeyError:
            _device_family = device_family
        if not _device_family:
            self.device_family = []
        else:
            self.device_family = _device_family
    def factory(*args_, **kwargs_):
        if DeviceFamilyListType.subclass:
            return DeviceFamilyListType.subclass(*args_, **kwargs_)
        else:
            return DeviceFamilyListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_device_family(self): return self.device_family
    def set_device_family(self, device_family): self.device_family = device_family
    def add_device_family(self, value): self.device_family.append(value)
    def insert_device_family(self, index, value): self.device_family[index] = value
    def delete_device_family(self, value): self.device_family.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.device_family == other.device_family)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.device_family or [])))

    def __repr__(self):
        return ("device_family = " + str(self.device_family))

    def copy(self):
        cp = DeviceFamilyListType()
        if self.device_family is not None:
            cp.device_family = list(self.device_family)
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_device_family ([obj.populate_string ("device_family")])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='DeviceFamilyListType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DeviceFamilyListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DeviceFamilyListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DeviceFamilyListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for device_family_ in self.device_family:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdevice-family>%s</%sdevice-family>%s' % (namespace_, self.gds_format_string(quote_xml(device_family_).encode(ExternalEncoding), input_name='device-family'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.device_family
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DeviceFamilyListType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('device_family=[\n')
        level += 1
        for device_family_ in self.device_family:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(device_family_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='DeviceFamilyListType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'device-family':
            device_family_ = child_.text
            device_family_ = self.gds_validate_string(device_family_, node, 'device_family')
            self.device_family.append(device_family_)
# end class DeviceFamilyListType


class VendorHardwaresType(GeneratedsSuper):
    """
    Attributes:
    * vendor_hardware
        Type:           str

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'vendor_hardware']
    attr_field_type_vals = {u'vendor_hardware': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': True, 'required': None, 'attr_type': u'string'}}
    def __init__(self, vendor_hardware=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _vendor_hardware = params_dict[u"vendor_hardware"]
        except KeyError:
            _vendor_hardware = vendor_hardware
        if not _vendor_hardware:
            self.vendor_hardware = []
        else:
            self.vendor_hardware = _vendor_hardware
    def factory(*args_, **kwargs_):
        if VendorHardwaresType.subclass:
            return VendorHardwaresType.subclass(*args_, **kwargs_)
        else:
            return VendorHardwaresType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vendor_hardware(self): return self.vendor_hardware
    def set_vendor_hardware(self, vendor_hardware): self.vendor_hardware = vendor_hardware
    def add_vendor_hardware(self, value): self.vendor_hardware.append(value)
    def insert_vendor_hardware(self, index, value): self.vendor_hardware[index] = value
    def delete_vendor_hardware(self, value): self.vendor_hardware.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.vendor_hardware == other.vendor_hardware)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.vendor_hardware or [])))

    def __repr__(self):
        return ("vendor_hardware = " + str(self.vendor_hardware))

    def copy(self):
        cp = VendorHardwaresType()
        if self.vendor_hardware is not None:
            cp.vendor_hardware = list(self.vendor_hardware)
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_vendor_hardware ([obj.populate_string ("vendor_hardware")])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='VendorHardwaresType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VendorHardwaresType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VendorHardwaresType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VendorHardwaresType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for vendor_hardware_ in self.vendor_hardware:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svendor-hardware>%s</%svendor-hardware>%s' % (namespace_, self.gds_format_string(quote_xml(vendor_hardware_).encode(ExternalEncoding), input_name='vendor-hardware'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.vendor_hardware
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='VendorHardwaresType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('vendor_hardware=[\n')
        level += 1
        for vendor_hardware_ in self.vendor_hardware:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(vendor_hardware_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='VendorHardwaresType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vendor-hardware':
            vendor_hardware_ = child_.text
            vendor_hardware_ = self.gds_validate_string(vendor_hardware_, node, 'vendor_hardware')
            self.vendor_hardware.append(vendor_hardware_)
# end class VendorHardwaresType


class IpamDnsAddressType(GeneratedsSuper):
    """
    Attributes:
    * tenant_dns_server_address
        Type:           :class:`.IpAddressesType`

        Created By:           User (optional)

        Description:
          In case of tenant DNS server method, Ip address of DNS server. This will be

          given in DHCP

    * virtual_dns_server_name
        Type:           str

        Created By:           User (optional)

        Description:
          In case of virtual DNS server, name of virtual DNS server

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'tenant_dns_server_address', u'virtual_dns_server_name']
    attr_field_type_vals = {u'tenant_dns_server_address': {'restrictions': None, 'description': [u'In case of tenant DNS server method, Ip address of DNS server. This will be given in DHCP'], 'simple_type': u'IpAddressesType', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'IpAddressesType'}, u'virtual_dns_server_name': {'restrictions': None, 'description': [u'In case of virtual DNS server, name of virtual DNS server'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'string'}}
    def __init__(self, tenant_dns_server_address=None, virtual_dns_server_name=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _tenant_dns_server_address = params_dict[u"tenant_dns_server_address"]
        except KeyError:
            _tenant_dns_server_address = tenant_dns_server_address
        if isinstance(_tenant_dns_server_address, dict):
            obj = IpAddressesType(params_dict=_tenant_dns_server_address)
            self.tenant_dns_server_address = obj
        else:
            self.tenant_dns_server_address = _tenant_dns_server_address
        try:
            _virtual_dns_server_name = params_dict[u"virtual_dns_server_name"]
        except KeyError:
            _virtual_dns_server_name = virtual_dns_server_name
        self.virtual_dns_server_name = _virtual_dns_server_name
    def factory(*args_, **kwargs_):
        if IpamDnsAddressType.subclass:
            return IpamDnsAddressType.subclass(*args_, **kwargs_)
        else:
            return IpamDnsAddressType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tenant_dns_server_address(self): return self.tenant_dns_server_address
    def set_tenant_dns_server_address(self, tenant_dns_server_address): self.tenant_dns_server_address = tenant_dns_server_address
    def get_virtual_dns_server_name(self): return self.virtual_dns_server_name
    def set_virtual_dns_server_name(self, virtual_dns_server_name): self.virtual_dns_server_name = virtual_dns_server_name
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.tenant_dns_server_address == other.tenant_dns_server_address and
                    self.virtual_dns_server_name == other.virtual_dns_server_name)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.tenant_dns_server_address if self.tenant_dns_server_address is not None else -7985492147856592190,
                     self.virtual_dns_server_name if self.virtual_dns_server_name is not None else -7985492147856592190))

    def __repr__(self):
        return ("tenant_dns_server_address = " + str(self.tenant_dns_server_address) + ", " +
                "virtual_dns_server_name = " + str(self.virtual_dns_server_name))

    def copy(self):
        cp = IpamDnsAddressType()
        if self.tenant_dns_server_address is not None:
            cp.tenant_dns_server_address = self.tenant_dns_server_address.copy()
        if self.virtual_dns_server_name is not None:
            cp.virtual_dns_server_name = self.virtual_dns_server_name
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_tenant_dns_server_address (IpAddressesType.populate ())
        obj.set_virtual_dns_server_name (obj.populate_string ("virtual_dns_server_name"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='IpamDnsAddressType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IpamDnsAddressType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IpamDnsAddressType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='IpamDnsAddressType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tenant_dns_server_address is not None:
            self.tenant_dns_server_address.export_xml(outfile, level, namespace_, name_='tenant-dns-server-address', pretty_print=pretty_print)
        if self.virtual_dns_server_name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svirtual-dns-server-name>%s</%svirtual-dns-server-name>%s' % (namespace_, self.gds_format_string(quote_xml(self.virtual_dns_server_name).encode(ExternalEncoding), input_name='virtual-dns-server-name'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.tenant_dns_server_address is not None or
            self.virtual_dns_server_name is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='IpamDnsAddressType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.tenant_dns_server_address is not None:
            showIndent(outfile, level)
            outfile.write('tenant_dns_server_address=model_.IpAddressesType(\n')
            self.tenant_dns_server_address.exportLiteral(outfile, level, name_='tenant_dns_server_address')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.virtual_dns_server_name is not None:
            showIndent(outfile, level)
            outfile.write('virtual_dns_server_name=%s,\n' % quote_python(self.virtual_dns_server_name).encode(ExternalEncoding))
    def exportDict(self, name_='IpamDnsAddressType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tenant-dns-server-address':
            obj_ = IpAddressesType.factory()
            obj_.build(child_)
            self.set_tenant_dns_server_address(obj_)
        elif nodeName_ == 'virtual-dns-server-name':
            virtual_dns_server_name_ = child_.text
            virtual_dns_server_name_ = self.gds_validate_string(virtual_dns_server_name_, node, 'virtual_dns_server_name')
            self.virtual_dns_server_name = virtual_dns_server_name_
# end class IpamDnsAddressType


class IpamType(GeneratedsSuper):
    """
    Attributes:
    * ipam_method
        Type:           str, *one-of* [u'dhcp', u'fixed']

        Created By:           User (optional)

    * ipam_dns_method
        Type:           str, *one-of* [u'none', u'default-dns-server', u'tenant-dns-server', u'virtual-dns-server']

        Created By:           User (optional)

    * ipam_dns_server
        Type:           :class:`.IpamDnsAddressType`

        Created By:           User (optional)

    * dhcp_option_list
        Type:           :class:`.DhcpOptionsListType`

        Created By:           User (optional)

    * cidr_block
        Type:           :class:`.SubnetType`

        Created By:           User (optional)

    * host_routes
        Type:           :class:`.RouteTableType`

        Created By:           User (optional)

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'ipam_method', u'ipam_dns_method', u'ipam_dns_server', u'dhcp_option_list', u'cidr_block', u'host_routes']
    attr_field_type_vals = {u'ipam_method': {'restrictions': [u'dhcp', u'fixed'], 'description': [], 'simple_type': u'IpamMethodType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'ipam_dns_method': {'restrictions': [u'none', u'default-dns-server', u'tenant-dns-server', u'virtual-dns-server'], 'description': [], 'simple_type': u'IpamDnsMethodType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'ipam_dns_server': {'restrictions': None, 'description': [], 'simple_type': u'IpamDnsAddressType', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'IpamDnsAddressType'}, u'dhcp_option_list': {'restrictions': None, 'description': [], 'simple_type': u'DhcpOptionsListType', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'DhcpOptionsListType'}, u'host_routes': {'restrictions': None, 'description': [], 'simple_type': u'RouteTableType', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'RouteTableType'}, u'cidr_block': {'restrictions': None, 'description': [], 'simple_type': u'SubnetType', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'SubnetType'}}
    def __init__(self, ipam_method=None, ipam_dns_method=None, ipam_dns_server=None, dhcp_option_list=None, cidr_block=None, host_routes=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _ipam_method = params_dict[u"ipam_method"]
        except KeyError:
            _ipam_method = ipam_method
        self.ipam_method = _ipam_method
        try:
            _ipam_dns_method = params_dict[u"ipam_dns_method"]
        except KeyError:
            _ipam_dns_method = ipam_dns_method
        self.ipam_dns_method = _ipam_dns_method
        try:
            _ipam_dns_server = params_dict[u"ipam_dns_server"]
        except KeyError:
            _ipam_dns_server = ipam_dns_server
        if isinstance(_ipam_dns_server, dict):
            obj = IpamDnsAddressType(params_dict=_ipam_dns_server)
            self.ipam_dns_server = obj
        else:
            self.ipam_dns_server = _ipam_dns_server
        try:
            _dhcp_option_list = params_dict[u"dhcp_option_list"]
        except KeyError:
            _dhcp_option_list = dhcp_option_list
        if isinstance(_dhcp_option_list, dict):
            obj = DhcpOptionsListType(params_dict=_dhcp_option_list)
            self.dhcp_option_list = obj
        else:
            self.dhcp_option_list = _dhcp_option_list
        try:
            _cidr_block = params_dict[u"cidr_block"]
        except KeyError:
            _cidr_block = cidr_block
        if isinstance(_cidr_block, dict):
            obj = SubnetType(params_dict=_cidr_block)
            self.cidr_block = obj
        else:
            self.cidr_block = _cidr_block
        try:
            _host_routes = params_dict[u"host_routes"]
        except KeyError:
            _host_routes = host_routes
        if isinstance(_host_routes, dict):
            obj = RouteTableType(params_dict=_host_routes)
            self.host_routes = obj
        else:
            self.host_routes = _host_routes
    def factory(*args_, **kwargs_):
        if IpamType.subclass:
            return IpamType.subclass(*args_, **kwargs_)
        else:
            return IpamType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ipam_method(self): return self.ipam_method
    def set_ipam_method(self, ipam_method): self.ipam_method = ipam_method
    def validate_IpamMethodType(self, value):
        # Validate type IpamMethodType, a restriction on xsd:string.
        error = False
        if isinstance(value, list):
            error = set(value) - set([u'dhcp', u'fixed'])
        else:
            error = value not in [u'dhcp', u'fixed']
        if error:
            raise ValueError("IpamMethodType must be one of [u'dhcp', u'fixed']")
    def get_ipam_dns_method(self): return self.ipam_dns_method
    def set_ipam_dns_method(self, ipam_dns_method): self.ipam_dns_method = ipam_dns_method
    def validate_IpamDnsMethodType(self, value):
        # Validate type IpamDnsMethodType, a restriction on xsd:string.
        error = False
        if isinstance(value, list):
            error = set(value) - set([u'none', u'default-dns-server', u'tenant-dns-server', u'virtual-dns-server'])
        else:
            error = value not in [u'none', u'default-dns-server', u'tenant-dns-server', u'virtual-dns-server']
        if error:
            raise ValueError("IpamDnsMethodType must be one of [u'none', u'default-dns-server', u'tenant-dns-server', u'virtual-dns-server']")
    def get_ipam_dns_server(self): return self.ipam_dns_server
    def set_ipam_dns_server(self, ipam_dns_server): self.ipam_dns_server = ipam_dns_server
    def get_dhcp_option_list(self): return self.dhcp_option_list
    def set_dhcp_option_list(self, dhcp_option_list): self.dhcp_option_list = dhcp_option_list
    def get_cidr_block(self): return self.cidr_block
    def set_cidr_block(self, cidr_block): self.cidr_block = cidr_block
    def get_host_routes(self): return self.host_routes
    def set_host_routes(self, host_routes): self.host_routes = host_routes
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.ipam_method == other.ipam_method and
                    self.ipam_dns_method == other.ipam_dns_method and
                    self.ipam_dns_server == other.ipam_dns_server and
                    self.dhcp_option_list == other.dhcp_option_list and
                    self.cidr_block == other.cidr_block and
                    self.host_routes == other.host_routes)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.ipam_method if self.ipam_method is not None else -7985492147856592190,
                     self.ipam_dns_method if self.ipam_dns_method is not None else -7985492147856592190,
                     self.ipam_dns_server if self.ipam_dns_server is not None else -7985492147856592190,
                     self.dhcp_option_list if self.dhcp_option_list is not None else -7985492147856592190,
                     self.cidr_block if self.cidr_block is not None else -7985492147856592190,
                     self.host_routes if self.host_routes is not None else -7985492147856592190))

    def __repr__(self):
        return ("ipam_method = " + str(self.ipam_method) + ", " +
                "ipam_dns_method = " + str(self.ipam_dns_method) + ", " +
                "ipam_dns_server = " + str(self.ipam_dns_server) + ", " +
                "dhcp_option_list = " + str(self.dhcp_option_list) + ", " +
                "cidr_block = " + str(self.cidr_block) + ", " +
                "host_routes = " + str(self.host_routes))

    def copy(self):
        cp = IpamType()
        if self.ipam_method is not None:
            cp.ipam_method = self.ipam_method
        if self.ipam_dns_method is not None:
            cp.ipam_dns_method = self.ipam_dns_method
        if self.ipam_dns_server is not None:
            cp.ipam_dns_server = self.ipam_dns_server.copy()
        if self.dhcp_option_list is not None:
            cp.dhcp_option_list = self.dhcp_option_list.copy()
        if self.cidr_block is not None:
            cp.cidr_block = self.cidr_block.copy()
        if self.host_routes is not None:
            cp.host_routes = self.host_routes.copy()
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_ipam_method (obj.populate_string ("ipam_method"))
        obj.set_ipam_dns_method (obj.populate_string ("ipam_dns_method"))
        obj.set_ipam_dns_server (IpamDnsAddressType.populate ())
        obj.set_dhcp_option_list (DhcpOptionsListType.populate ())
        obj.set_cidr_block (SubnetType.populate ())
        obj.set_host_routes (RouteTableType.populate ())
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='IpamType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IpamType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IpamType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='IpamType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ipam_method is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sipam-method>%s</%sipam-method>%s' % (namespace_, self.gds_format_string(quote_xml(self.ipam_method).encode(ExternalEncoding), input_name='ipam-method'), namespace_, eol_))
        if self.ipam_dns_method is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sipam-dns-method>%s</%sipam-dns-method>%s' % (namespace_, self.gds_format_string(quote_xml(self.ipam_dns_method).encode(ExternalEncoding), input_name='ipam-dns-method'), namespace_, eol_))
        if self.ipam_dns_server is not None:
            self.ipam_dns_server.export_xml(outfile, level, namespace_, name_='ipam-dns-server', pretty_print=pretty_print)
        if self.dhcp_option_list is not None:
            self.dhcp_option_list.export_xml(outfile, level, namespace_, name_='dhcp-option-list', pretty_print=pretty_print)
        if self.cidr_block is not None:
            self.cidr_block.export_xml(outfile, level, namespace_, name_='cidr-block', pretty_print=pretty_print)
        if self.host_routes is not None:
            self.host_routes.export_xml(outfile, level, namespace_, name_='host-routes', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.ipam_method is not None or
            self.ipam_dns_method is not None or
            self.ipam_dns_server is not None or
            self.dhcp_option_list is not None or
            self.cidr_block is not None or
            self.host_routes is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='IpamType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ipam_method is not None:
            showIndent(outfile, level)
            outfile.write('ipam_method=%s,\n' % quote_python(self.ipam_method).encode(ExternalEncoding))
        if self.ipam_dns_method is not None:
            showIndent(outfile, level)
            outfile.write('ipam_dns_method=%s,\n' % quote_python(self.ipam_dns_method).encode(ExternalEncoding))
        if self.ipam_dns_server is not None:
            showIndent(outfile, level)
            outfile.write('ipam_dns_server=model_.IpamDnsAddressType(\n')
            self.ipam_dns_server.exportLiteral(outfile, level, name_='ipam_dns_server')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.dhcp_option_list is not None:
            showIndent(outfile, level)
            outfile.write('dhcp_option_list=model_.DhcpOptionsListType(\n')
            self.dhcp_option_list.exportLiteral(outfile, level, name_='dhcp_option_list')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.cidr_block is not None:
            showIndent(outfile, level)
            outfile.write('cidr_block=model_.SubnetType(\n')
            self.cidr_block.exportLiteral(outfile, level, name_='cidr_block')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.host_routes is not None:
            showIndent(outfile, level)
            outfile.write('host_routes=model_.RouteTableType(\n')
            self.host_routes.exportLiteral(outfile, level, name_='host_routes')
            showIndent(outfile, level)
            outfile.write('),\n')
    def exportDict(self, name_='IpamType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ipam-method':
            ipam_method_ = child_.text
            ipam_method_ = self.gds_validate_string(ipam_method_, node, 'ipam_method')
            self.ipam_method = ipam_method_
            self.validate_IpamMethodType(self.ipam_method)    # validate type IpamMethodType
        elif nodeName_ == 'ipam-dns-method':
            ipam_dns_method_ = child_.text
            ipam_dns_method_ = self.gds_validate_string(ipam_dns_method_, node, 'ipam_dns_method')
            self.ipam_dns_method = ipam_dns_method_
            self.validate_IpamDnsMethodType(self.ipam_dns_method)    # validate type IpamDnsMethodType
        elif nodeName_ == 'ipam-dns-server':
            obj_ = IpamDnsAddressType.factory()
            obj_.build(child_)
            self.set_ipam_dns_server(obj_)
        elif nodeName_ == 'dhcp-option-list':
            obj_ = DhcpOptionsListType.factory()
            obj_.build(child_)
            self.set_dhcp_option_list(obj_)
        elif nodeName_ == 'cidr-block':
            obj_ = SubnetType.factory()
            obj_.build(child_)
            self.set_cidr_block(obj_)
        elif nodeName_ == 'host-routes':
            obj_ = RouteTableType.factory()
            obj_.build(child_)
            self.set_host_routes(obj_)
# end class IpamType


class EncapsulationPrioritiesType(GeneratedsSuper):
    """
    Attributes:
    * encapsulation
        Type:           str, *one-of* [u'MPLSoGRE', u'MPLSoUDP', u'VXLAN']

        Created By:           User (optional)

        Description:
          Ordered list of encapsulation types to be used in priority

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'encapsulation']
    attr_field_type_vals = {u'encapsulation': {'restrictions': [u'MPLSoGRE', u'MPLSoUDP', u'VXLAN'], 'description': [u'Ordered list of encapsulation types to be used in priority'], 'simple_type': u'EncapsulationType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': True, 'required': u'optional', 'attr_type': u'string'}}
    def __init__(self, encapsulation=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _encapsulation = params_dict[u"encapsulation"]
        except KeyError:
            _encapsulation = encapsulation
        if not _encapsulation:
            self.encapsulation = []
        else:
            self.encapsulation = _encapsulation
    def factory(*args_, **kwargs_):
        if EncapsulationPrioritiesType.subclass:
            return EncapsulationPrioritiesType.subclass(*args_, **kwargs_)
        else:
            return EncapsulationPrioritiesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_encapsulation(self): return self.encapsulation
    def set_encapsulation(self, encapsulation): self.encapsulation = encapsulation
    def add_encapsulation(self, value): self.encapsulation.append(value)
    def insert_encapsulation(self, index, value): self.encapsulation[index] = value
    def delete_encapsulation(self, value): self.encapsulation.remove(value)
    def validate_EncapsulationType(self, value):
        # Validate type EncapsulationType, a restriction on xsd:string.
        error = False
        if isinstance(value, list):
            error = set(value) - set([u'MPLSoGRE', u'MPLSoUDP', u'VXLAN'])
        else:
            error = value not in [u'MPLSoGRE', u'MPLSoUDP', u'VXLAN']
        if error:
            raise ValueError("EncapsulationType must be one of [u'MPLSoGRE', u'MPLSoUDP', u'VXLAN']")
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.encapsulation == other.encapsulation)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.encapsulation or [])))

    def __repr__(self):
        return ("encapsulation = " + str(self.encapsulation))

    def copy(self):
        cp = EncapsulationPrioritiesType()
        if self.encapsulation is not None:
            cp.encapsulation = list(self.encapsulation)
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_encapsulation ([obj.populate_string ("encapsulation")])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='EncapsulationPrioritiesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EncapsulationPrioritiesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EncapsulationPrioritiesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='EncapsulationPrioritiesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for encapsulation_ in self.encapsulation:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sencapsulation>%s</%sencapsulation>%s' % (namespace_, self.gds_format_string(quote_xml(encapsulation_).encode(ExternalEncoding), input_name='encapsulation'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.encapsulation
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EncapsulationPrioritiesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('encapsulation=[\n')
        level += 1
        for encapsulation_ in self.encapsulation:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(encapsulation_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='EncapsulationPrioritiesType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'encapsulation':
            encapsulation_ = child_.text
            encapsulation_ = self.gds_validate_string(encapsulation_, node, 'encapsulation')
            self.encapsulation.append(encapsulation_)
            self.validate_EncapsulationType(self.encapsulation)    # validate type EncapsulationType
# end class EncapsulationPrioritiesType


class LinklocalServiceEntryType(GeneratedsSuper):
    """
    Attributes:
    * linklocal_service_name
        Type:           str

        Created By:           User (required)

        Description:
          Name of the link local service. VM name resolution of this name will result in

          link local ip address

    * linklocal_service_ip
        Type:           str, *one-of* xsd:string

        Created By:           User (required)

        Description:
          ip address of the link local service.

    * linklocal_service_port
        Type:           int

        Created By:           User (required)

        Description:
          Destination TCP port number of link local service

    * ip_fabric_DNS_service_name
        Type:           str

        Created By:           User (optional)

        Description:
          DNS name to which link local service will be proxied

    * ip_fabric_service_port
        Type:           int

        Created By:           User (required)

        Description:
          Destination TCP port number to which link local traffic will forwarded

    * ip_fabric_service_ip
        Type:           str, *one-of* xsd:string

        Created By:           User (optional)

        Description:
          Destination ip address to which link local traffic will forwarded

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'linklocal_service_name', u'linklocal_service_ip', u'linklocal_service_port', u'ip_fabric_DNS_service_name', u'ip_fabric_service_port', u'ip_fabric_service_ip']
    attr_field_type_vals = {u'ip_fabric_service_ip': {'restrictions': [], 'description': [u'Destination ip address to which link local traffic will forwarded'], 'simple_type': u'IpAddress', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': True, 'required': u'optional', 'attr_type': u'string'}, u'linklocal_service_name': {'restrictions': None, 'description': [u'Name of the link local service. VM name resolution of this name will result in link local ip address'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'true', 'attr_type': u'string'}, u'linklocal_service_ip': {'restrictions': [], 'description': [u'ip address of the link local service.'], 'simple_type': u'IpAddress', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'true', 'attr_type': u'string'}, u'ip_fabric_service_port': {'restrictions': None, 'description': [u'Destination TCP port number to which link local traffic will forwarded'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'true', 'attr_type': u'integer'}, u'ip_fabric_DNS_service_name': {'restrictions': None, 'description': [u'DNS name to which link local service will be proxied'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'linklocal_service_port': {'restrictions': None, 'description': [u'Destination TCP port number of link local service'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'true', 'attr_type': u'integer'}}
    def __init__(self, linklocal_service_name=None, linklocal_service_ip=None, linklocal_service_port=None, ip_fabric_DNS_service_name=None, ip_fabric_service_port=None, ip_fabric_service_ip=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _linklocal_service_name = params_dict[u"linklocal_service_name"]
        except KeyError:
            _linklocal_service_name = linklocal_service_name
        self.linklocal_service_name = _linklocal_service_name
        try:
            _linklocal_service_ip = params_dict[u"linklocal_service_ip"]
        except KeyError:
            _linklocal_service_ip = linklocal_service_ip
        self.linklocal_service_ip = _linklocal_service_ip
        try:
            _linklocal_service_port = params_dict[u"linklocal_service_port"]
        except KeyError:
            _linklocal_service_port = linklocal_service_port
        self.linklocal_service_port = _linklocal_service_port
        try:
            _ip_fabric_DNS_service_name = params_dict[u"ip_fabric_DNS_service_name"]
        except KeyError:
            _ip_fabric_DNS_service_name = ip_fabric_DNS_service_name
        self.ip_fabric_DNS_service_name = _ip_fabric_DNS_service_name
        try:
            _ip_fabric_service_port = params_dict[u"ip_fabric_service_port"]
        except KeyError:
            _ip_fabric_service_port = ip_fabric_service_port
        self.ip_fabric_service_port = _ip_fabric_service_port
        try:
            _ip_fabric_service_ip = params_dict[u"ip_fabric_service_ip"]
        except KeyError:
            _ip_fabric_service_ip = ip_fabric_service_ip
        if not _ip_fabric_service_ip:
            self.ip_fabric_service_ip = []
        else:
            self.ip_fabric_service_ip = _ip_fabric_service_ip
    def factory(*args_, **kwargs_):
        if LinklocalServiceEntryType.subclass:
            return LinklocalServiceEntryType.subclass(*args_, **kwargs_)
        else:
            return LinklocalServiceEntryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_linklocal_service_name(self): return self.linklocal_service_name
    def set_linklocal_service_name(self, linklocal_service_name): self.linklocal_service_name = linklocal_service_name
    def get_linklocal_service_ip(self): return self.linklocal_service_ip
    def set_linklocal_service_ip(self, linklocal_service_ip): self.linklocal_service_ip = linklocal_service_ip
    def validate_IpAddress(self, value):
        # Validate type IpAddress, a restriction on xsd:string.
        pass
    def get_linklocal_service_port(self): return self.linklocal_service_port
    def set_linklocal_service_port(self, linklocal_service_port): self.linklocal_service_port = linklocal_service_port
    def get_ip_fabric_DNS_service_name(self): return self.ip_fabric_DNS_service_name
    def set_ip_fabric_DNS_service_name(self, ip_fabric_DNS_service_name): self.ip_fabric_DNS_service_name = ip_fabric_DNS_service_name
    def get_ip_fabric_service_port(self): return self.ip_fabric_service_port
    def set_ip_fabric_service_port(self, ip_fabric_service_port): self.ip_fabric_service_port = ip_fabric_service_port
    def get_ip_fabric_service_ip(self): return self.ip_fabric_service_ip
    def set_ip_fabric_service_ip(self, ip_fabric_service_ip): self.ip_fabric_service_ip = ip_fabric_service_ip
    def add_ip_fabric_service_ip(self, value): self.ip_fabric_service_ip.append(value)
    def insert_ip_fabric_service_ip(self, index, value): self.ip_fabric_service_ip[index] = value
    def delete_ip_fabric_service_ip(self, value): self.ip_fabric_service_ip.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.linklocal_service_name == other.linklocal_service_name and
                    self.linklocal_service_ip == other.linklocal_service_ip and
                    self.linklocal_service_port == other.linklocal_service_port and
                    self.ip_fabric_DNS_service_name == other.ip_fabric_DNS_service_name and
                    self.ip_fabric_service_port == other.ip_fabric_service_port and
                    self.ip_fabric_service_ip == other.ip_fabric_service_ip)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.linklocal_service_name if self.linklocal_service_name is not None else -7985492147856592190,
                     self.linklocal_service_ip if self.linklocal_service_ip is not None else -7985492147856592190,
                     self.linklocal_service_port if self.linklocal_service_port is not None else -7985492147856592190,
                     self.ip_fabric_DNS_service_name if self.ip_fabric_DNS_service_name is not None else -7985492147856592190,
                     self.ip_fabric_service_port if self.ip_fabric_service_port is not None else -7985492147856592190,
                     tuple(self.ip_fabric_service_ip or [])))

    def __repr__(self):
        return ("linklocal_service_name = " + str(self.linklocal_service_name) + ", " +
                "linklocal_service_ip = " + str(self.linklocal_service_ip) + ", " +
                "linklocal_service_port = " + str(self.linklocal_service_port) + ", " +
                "ip_fabric_DNS_service_name = " + str(self.ip_fabric_DNS_service_name) + ", " +
                "ip_fabric_service_port = " + str(self.ip_fabric_service_port) + ", " +
                "ip_fabric_service_ip = " + str(self.ip_fabric_service_ip))

    def copy(self):
        cp = LinklocalServiceEntryType()
        if self.linklocal_service_name is not None:
            cp.linklocal_service_name = self.linklocal_service_name
        if self.linklocal_service_ip is not None:
            cp.linklocal_service_ip = self.linklocal_service_ip
        if self.linklocal_service_port is not None:
            cp.linklocal_service_port = self.linklocal_service_port
        if self.ip_fabric_DNS_service_name is not None:
            cp.ip_fabric_DNS_service_name = self.ip_fabric_DNS_service_name
        if self.ip_fabric_service_port is not None:
            cp.ip_fabric_service_port = self.ip_fabric_service_port
        if self.ip_fabric_service_ip is not None:
            cp.ip_fabric_service_ip = list(self.ip_fabric_service_ip)
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_linklocal_service_name (obj.populate_string ("linklocal_service_name"))
        obj.set_linklocal_service_ip (obj.populate_string ("linklocal_service_ip"))
        obj.set_linklocal_service_port (obj.populate_integer ("linklocal_service_port"))
        obj.set_ip_fabric_DNS_service_name (obj.populate_string ("ip_fabric_DNS_service_name"))
        obj.set_ip_fabric_service_port (obj.populate_integer ("ip_fabric_service_port"))
        obj.set_ip_fabric_service_ip ([obj.populate_string ("ip_fabric_service_ip")])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='LinklocalServiceEntryType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LinklocalServiceEntryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LinklocalServiceEntryType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LinklocalServiceEntryType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.linklocal_service_name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slinklocal-service-name>%s</%slinklocal-service-name>%s' % (namespace_, self.gds_format_string(quote_xml(self.linklocal_service_name).encode(ExternalEncoding), input_name='linklocal-service-name'), namespace_, eol_))
        if self.linklocal_service_ip is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slinklocal-service-ip>%s</%slinklocal-service-ip>%s' % (namespace_, self.gds_format_string(quote_xml(self.linklocal_service_ip).encode(ExternalEncoding), input_name='linklocal-service-ip'), namespace_, eol_))
        if self.linklocal_service_port is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slinklocal-service-port>%s</%slinklocal-service-port>%s' % (namespace_, self.gds_format_integer(self.linklocal_service_port, input_name='linklocal-service-port'), namespace_, eol_))
        if self.ip_fabric_DNS_service_name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sip-fabric-DNS-service-name>%s</%sip-fabric-DNS-service-name>%s' % (namespace_, self.gds_format_string(quote_xml(self.ip_fabric_DNS_service_name).encode(ExternalEncoding), input_name='ip-fabric-DNS-service-name'), namespace_, eol_))
        if self.ip_fabric_service_port is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sip-fabric-service-port>%s</%sip-fabric-service-port>%s' % (namespace_, self.gds_format_integer(self.ip_fabric_service_port, input_name='ip-fabric-service-port'), namespace_, eol_))
        for ip_fabric_service_ip_ in self.ip_fabric_service_ip:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sip-fabric-service-ip>%s</%sip-fabric-service-ip>%s' % (namespace_, self.gds_format_string(quote_xml(ip_fabric_service_ip_).encode(ExternalEncoding), input_name='ip-fabric-service-ip'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.linklocal_service_name is not None or
            self.linklocal_service_ip is not None or
            self.linklocal_service_port is not None or
            self.ip_fabric_DNS_service_name is not None or
            self.ip_fabric_service_port is not None or
            self.ip_fabric_service_ip
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LinklocalServiceEntryType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.linklocal_service_name is not None:
            showIndent(outfile, level)
            outfile.write('linklocal_service_name=%s,\n' % quote_python(self.linklocal_service_name).encode(ExternalEncoding))
        if self.linklocal_service_ip is not None:
            showIndent(outfile, level)
            outfile.write('linklocal_service_ip=%s,\n' % quote_python(self.linklocal_service_ip).encode(ExternalEncoding))
        if self.linklocal_service_port is not None:
            showIndent(outfile, level)
            outfile.write('linklocal_service_port=%d,\n' % self.linklocal_service_port)
        if self.ip_fabric_DNS_service_name is not None:
            showIndent(outfile, level)
            outfile.write('ip_fabric_DNS_service_name=%s,\n' % quote_python(self.ip_fabric_DNS_service_name).encode(ExternalEncoding))
        if self.ip_fabric_service_port is not None:
            showIndent(outfile, level)
            outfile.write('ip_fabric_service_port=%d,\n' % self.ip_fabric_service_port)
        showIndent(outfile, level)
        outfile.write('ip_fabric_service_ip=[\n')
        level += 1
        for ip_fabric_service_ip_ in self.ip_fabric_service_ip:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ip_fabric_service_ip_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='LinklocalServiceEntryType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'linklocal-service-name':
            linklocal_service_name_ = child_.text
            linklocal_service_name_ = self.gds_validate_string(linklocal_service_name_, node, 'linklocal_service_name')
            self.linklocal_service_name = linklocal_service_name_
        elif nodeName_ == 'linklocal-service-ip':
            linklocal_service_ip_ = child_.text
            linklocal_service_ip_ = self.gds_validate_string(linklocal_service_ip_, node, 'linklocal_service_ip')
            self.linklocal_service_ip = linklocal_service_ip_
            self.validate_IpAddress(self.linklocal_service_ip)    # validate type IpAddress
        elif nodeName_ == 'linklocal-service-port':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'linklocal_service_port')
            self.linklocal_service_port = ival_
        elif nodeName_ == 'ip-fabric-DNS-service-name':
            ip_fabric_DNS_service_name_ = child_.text
            ip_fabric_DNS_service_name_ = self.gds_validate_string(ip_fabric_DNS_service_name_, node, 'ip_fabric_DNS_service_name')
            self.ip_fabric_DNS_service_name = ip_fabric_DNS_service_name_
        elif nodeName_ == 'ip-fabric-service-port':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ip_fabric_service_port')
            self.ip_fabric_service_port = ival_
        elif nodeName_ == 'ip-fabric-service-ip':
            ip_fabric_service_ip_ = child_.text
            ip_fabric_service_ip_ = self.gds_validate_string(ip_fabric_service_ip_, node, 'ip_fabric_service_ip')
            self.ip_fabric_service_ip.append(ip_fabric_service_ip_)
            self.validate_IpAddress(self.ip_fabric_service_ip)    # validate type IpAddress
# end class LinklocalServiceEntryType


class LinklocalServicesTypes(GeneratedsSuper):
    """
    Attributes:
    * linklocal_service_entry
        Type:           :class:`.LinklocalServiceEntryType`

        Created By:           User (optional)

        Description:
          List of link local services

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'linklocal_service_entry']
    attr_field_type_vals = {u'linklocal_service_entry': {'restrictions': None, 'description': [u'List of link local services'], 'simple_type': u'LinklocalServiceEntryType', 'is_complex': 1, 'restriction_type': None, 'is_array': True, 'required': u'optional', 'attr_type': u'LinklocalServiceEntryType'}}
    def __init__(self, linklocal_service_entry=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _linklocal_service_entry = params_dict[u"linklocal_service_entry"]
        except KeyError:
            _linklocal_service_entry = linklocal_service_entry
        if not _linklocal_service_entry:
            self.linklocal_service_entry = []
        else:
            if isinstance(_linklocal_service_entry[0], dict):
                objs = [LinklocalServiceEntryType(params_dict=elem) for elem in _linklocal_service_entry]
                self.linklocal_service_entry = objs
            else:
                self.linklocal_service_entry = _linklocal_service_entry
    def factory(*args_, **kwargs_):
        if LinklocalServicesTypes.subclass:
            return LinklocalServicesTypes.subclass(*args_, **kwargs_)
        else:
            return LinklocalServicesTypes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_linklocal_service_entry(self): return self.linklocal_service_entry
    def set_linklocal_service_entry(self, linklocal_service_entry): self.linklocal_service_entry = linklocal_service_entry
    def add_linklocal_service_entry(self, value): self.linklocal_service_entry.append(value)
    def insert_linklocal_service_entry(self, index, value): self.linklocal_service_entry[index] = value
    def delete_linklocal_service_entry(self, value): self.linklocal_service_entry.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.linklocal_service_entry == other.linklocal_service_entry)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.linklocal_service_entry or [])))

    def __repr__(self):
        return ("linklocal_service_entry = " + str(self.linklocal_service_entry))

    def copy(self):
        cp = LinklocalServicesTypes()
        if self.linklocal_service_entry is not None:
            cp.linklocal_service_entry = [x.copy() for x in self.linklocal_service_entry]
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_linklocal_service_entry ([LinklocalServiceEntryType.populate ()])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='LinklocalServicesTypes', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LinklocalServicesTypes')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LinklocalServicesTypes'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LinklocalServicesTypes', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for linklocal_service_entry_ in self.linklocal_service_entry:
            if isinstance(linklocal_service_entry_, dict):
                linklocal_service_entry_ = LinklocalServiceEntryType(**linklocal_service_entry_)
            linklocal_service_entry_.export_xml(outfile, level, namespace_, name_='linklocal-service-entry', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.linklocal_service_entry
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LinklocalServicesTypes'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('linklocal_service_entry=[\n')
        level += 1
        for linklocal_service_entry_ in self.linklocal_service_entry:
            showIndent(outfile, level)
            outfile.write('model_.LinklocalServiceEntryType(\n')
            linklocal_service_entry_.exportLiteral(outfile, level, name_='LinklocalServiceEntryType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='LinklocalServicesTypes'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'linklocal-service-entry':
            obj_ = LinklocalServiceEntryType.factory()
            obj_.build(child_)
            self.linklocal_service_entry.append(obj_)
# end class LinklocalServicesTypes


class DnsSoaRecordType(GeneratedsSuper):
    """
    Attributes:
    * negative_cache_ttl_seconds
        Type:           int

        Created By:           User (optional)

        Description:
          Default Time To Live for negative caching of DNS queries

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'negative_cache_ttl_seconds']
    attr_field_type_vals = {u'negative_cache_ttl_seconds': {'restrictions': None, 'description': [u'Default Time To Live for negative caching of DNS queries'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}}
    def __init__(self, negative_cache_ttl_seconds=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _negative_cache_ttl_seconds = params_dict[u"negative_cache_ttl_seconds"]
        except KeyError:
            _negative_cache_ttl_seconds = negative_cache_ttl_seconds
        self.negative_cache_ttl_seconds = _negative_cache_ttl_seconds
    def factory(*args_, **kwargs_):
        if DnsSoaRecordType.subclass:
            return DnsSoaRecordType.subclass(*args_, **kwargs_)
        else:
            return DnsSoaRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_negative_cache_ttl_seconds(self): return self.negative_cache_ttl_seconds
    def set_negative_cache_ttl_seconds(self, negative_cache_ttl_seconds): self.negative_cache_ttl_seconds = negative_cache_ttl_seconds
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.negative_cache_ttl_seconds == other.negative_cache_ttl_seconds)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.negative_cache_ttl_seconds if self.negative_cache_ttl_seconds is not None else -7985492147856592190))

    def __repr__(self):
        return ("negative_cache_ttl_seconds = " + str(self.negative_cache_ttl_seconds))

    def copy(self):
        cp = DnsSoaRecordType()
        if self.negative_cache_ttl_seconds is not None:
            cp.negative_cache_ttl_seconds = self.negative_cache_ttl_seconds
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_negative_cache_ttl_seconds (obj.populate_integer ("negative_cache_ttl_seconds"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='DnsSoaRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DnsSoaRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DnsSoaRecordType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DnsSoaRecordType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.negative_cache_ttl_seconds is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snegative-cache-ttl-seconds>%s</%snegative-cache-ttl-seconds>%s' % (namespace_, self.gds_format_integer(self.negative_cache_ttl_seconds, input_name='negative-cache-ttl-seconds'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.negative_cache_ttl_seconds is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DnsSoaRecordType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.negative_cache_ttl_seconds is not None:
            showIndent(outfile, level)
            outfile.write('negative_cache_ttl_seconds=%d,\n' % self.negative_cache_ttl_seconds)
    def exportDict(self, name_='DnsSoaRecordType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'negative-cache-ttl-seconds':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'negative_cache_ttl_seconds')
            self.negative_cache_ttl_seconds = ival_
# end class DnsSoaRecordType


class VirtualDnsType(GeneratedsSuper):
    """
    Attributes:
    * domain_name
        Type:           str

        Created By:           User (required)

        Description:
          Default domain name for this virtual DNS server

    * dynamic_records_from_client
        Type:           bool

        Created By:           User (optional)

        Description:
          Allow automatic addition of records on VM launch, default is True

    * record_order
        Type:           str, *one-of* [u'fixed', u'random', u'round-robin']

        Created By:           User (optional)

        Description:
          Order of DNS load balancing, fixed, random, round-robin. Default is random

    * default_ttl_seconds
        Type:           int

        Created By:           User (optional)

        Description:
          Default Time To Live for DNS records

    * next_virtual_DNS
        Type:           str

        Created By:           User (optional)

        Description:
          Next virtual DNS server to lookup if record is not found. Default is proxy to

          infrastructure DNS

    * floating_ip_record
        Type:           str, *one-of* [u'dashed-ip', u'dashed-ip-tenant-name', u'vm-name', u'vm-name-tenant-name']

        Created By:           User (optional)

        Description:
          Decides how floating ip records are added

    * external_visible
        Type:           bool

        Created By:           User (optional)

        Description:
          Currently this option is not supported

    * reverse_resolution
        Type:           bool

        Created By:           User (optional)

        Description:
          Allow reverse DNS resolution, ip to name mapping

    * soa_record
        Type:           :class:`.DnsSoaRecordType`

        Created By:           User (optional)

        Description:
          Dns soa record values

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'domain_name', u'dynamic_records_from_client', u'record_order', u'default_ttl_seconds', u'next_virtual_DNS', u'floating_ip_record', u'external_visible', u'reverse_resolution', u'soa_record']
    attr_field_type_vals = {u'soa_record': {'restrictions': None, 'description': [u'Dns soa record values'], 'simple_type': u'DnsSoaRecordType', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'DnsSoaRecordType'}, u'floating_ip_record': {'restrictions': [u'dashed-ip', u'dashed-ip-tenant-name', u'vm-name', u'vm-name-tenant-name'], 'description': [u'Decides how floating ip records are added'], 'simple_type': u'FloatingIpDnsNotation', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'domain_name': {'restrictions': None, 'description': [u'Default domain name for this virtual DNS server'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'true', 'attr_type': u'string'}, u'external_visible': {'restrictions': None, 'description': [u'Currently this option is not supported'], 'simple_type': u'xsd:boolean', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'boolean'}, u'next_virtual_DNS': {'restrictions': None, 'description': [u'Next virtual DNS server to lookup if record is not found. Default is proxy to infrastructure DNS'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'dynamic_records_from_client': {'restrictions': None, 'description': [u'Allow automatic addition of records on VM launch, default is True'], 'simple_type': u'xsd:boolean', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'boolean'}, u'reverse_resolution': {'restrictions': None, 'description': [u'Allow reverse DNS resolution, ip to name mapping'], 'simple_type': u'xsd:boolean', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'boolean'}, u'default_ttl_seconds': {'restrictions': None, 'description': [u'Default Time To Live for DNS records'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'record_order': {'restrictions': [u'fixed', u'random', u'round-robin'], 'description': [u'Order of DNS load balancing, fixed, random, round-robin. Default is random'], 'simple_type': u'DnsRecordOrderType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'optional', 'attr_type': u'string'}}
    def __init__(self, domain_name=None, dynamic_records_from_client=None, record_order='random', default_ttl_seconds=None, next_virtual_DNS=None, floating_ip_record=None, external_visible=False, reverse_resolution=False, soa_record=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _domain_name = params_dict[u"domain_name"]
        except KeyError:
            _domain_name = domain_name
        self.domain_name = _domain_name
        try:
            _dynamic_records_from_client = params_dict[u"dynamic_records_from_client"]
        except KeyError:
            _dynamic_records_from_client = dynamic_records_from_client
        self.dynamic_records_from_client = _dynamic_records_from_client
        try:
            _record_order = params_dict[u"record_order"]
        except KeyError:
            _record_order = record_order
        self.record_order = _record_order
        try:
            _default_ttl_seconds = params_dict[u"default_ttl_seconds"]
        except KeyError:
            _default_ttl_seconds = default_ttl_seconds
        self.default_ttl_seconds = _default_ttl_seconds
        try:
            _next_virtual_DNS = params_dict[u"next_virtual_DNS"]
        except KeyError:
            _next_virtual_DNS = next_virtual_DNS
        self.next_virtual_DNS = _next_virtual_DNS
        try:
            _floating_ip_record = params_dict[u"floating_ip_record"]
        except KeyError:
            _floating_ip_record = floating_ip_record
        self.floating_ip_record = _floating_ip_record
        try:
            _external_visible = params_dict[u"external_visible"]
        except KeyError:
            _external_visible = external_visible
        self.external_visible = _external_visible
        try:
            _reverse_resolution = params_dict[u"reverse_resolution"]
        except KeyError:
            _reverse_resolution = reverse_resolution
        self.reverse_resolution = _reverse_resolution
        try:
            _soa_record = params_dict[u"soa_record"]
        except KeyError:
            _soa_record = soa_record
        if isinstance(_soa_record, dict):
            obj = DnsSoaRecordType(params_dict=_soa_record)
            self.soa_record = obj
        else:
            self.soa_record = _soa_record
    def factory(*args_, **kwargs_):
        if VirtualDnsType.subclass:
            return VirtualDnsType.subclass(*args_, **kwargs_)
        else:
            return VirtualDnsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_domain_name(self): return self.domain_name
    def set_domain_name(self, domain_name): self.domain_name = domain_name
    def get_dynamic_records_from_client(self): return self.dynamic_records_from_client
    def set_dynamic_records_from_client(self, dynamic_records_from_client): self.dynamic_records_from_client = dynamic_records_from_client
    def get_record_order(self): return self.record_order
    def set_record_order(self, record_order): self.record_order = record_order
    def validate_DnsRecordOrderType(self, value):
        # Validate type DnsRecordOrderType, a restriction on xsd:string.
        error = False
        if isinstance(value, list):
            error = set(value) - set([u'fixed', u'random', u'round-robin'])
        else:
            error = value not in [u'fixed', u'random', u'round-robin']
        if error:
            raise ValueError("DnsRecordOrderType must be one of [u'fixed', u'random', u'round-robin']")
    def get_default_ttl_seconds(self): return self.default_ttl_seconds
    def set_default_ttl_seconds(self, default_ttl_seconds): self.default_ttl_seconds = default_ttl_seconds
    def get_next_virtual_DNS(self): return self.next_virtual_DNS
    def set_next_virtual_DNS(self, next_virtual_DNS): self.next_virtual_DNS = next_virtual_DNS
    def get_floating_ip_record(self): return self.floating_ip_record
    def set_floating_ip_record(self, floating_ip_record): self.floating_ip_record = floating_ip_record
    def validate_FloatingIpDnsNotation(self, value):
        # Validate type FloatingIpDnsNotation, a restriction on xsd:string.
        error = False
        if isinstance(value, list):
            error = set(value) - set([u'dashed-ip', u'dashed-ip-tenant-name', u'vm-name', u'vm-name-tenant-name'])
        else:
            error = value not in [u'dashed-ip', u'dashed-ip-tenant-name', u'vm-name', u'vm-name-tenant-name']
        if error:
            raise ValueError("FloatingIpDnsNotation must be one of [u'dashed-ip', u'dashed-ip-tenant-name', u'vm-name', u'vm-name-tenant-name']")
    def get_external_visible(self): return self.external_visible
    def set_external_visible(self, external_visible): self.external_visible = external_visible
    def get_reverse_resolution(self): return self.reverse_resolution
    def set_reverse_resolution(self, reverse_resolution): self.reverse_resolution = reverse_resolution
    def get_soa_record(self): return self.soa_record
    def set_soa_record(self, soa_record): self.soa_record = soa_record
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.domain_name == other.domain_name and
                    self.dynamic_records_from_client == other.dynamic_records_from_client and
                    self.record_order == other.record_order and
                    self.default_ttl_seconds == other.default_ttl_seconds and
                    self.next_virtual_DNS == other.next_virtual_DNS and
                    self.floating_ip_record == other.floating_ip_record and
                    self.external_visible == other.external_visible and
                    self.reverse_resolution == other.reverse_resolution and
                    self.soa_record == other.soa_record)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.domain_name if self.domain_name is not None else -7985492147856592190,
                     self.dynamic_records_from_client if self.dynamic_records_from_client is not None else -7985492147856592190,
                     self.record_order if self.record_order is not None else -7985492147856592190,
                     self.default_ttl_seconds if self.default_ttl_seconds is not None else -7985492147856592190,
                     self.next_virtual_DNS if self.next_virtual_DNS is not None else -7985492147856592190,
                     self.floating_ip_record if self.floating_ip_record is not None else -7985492147856592190,
                     self.external_visible if self.external_visible is not None else -7985492147856592190,
                     self.reverse_resolution if self.reverse_resolution is not None else -7985492147856592190,
                     self.soa_record if self.soa_record is not None else -7985492147856592190))

    def __repr__(self):
        return ("domain_name = " + str(self.domain_name) + ", " +
                "dynamic_records_from_client = " + str(self.dynamic_records_from_client) + ", " +
                "record_order = " + str(self.record_order) + ", " +
                "default_ttl_seconds = " + str(self.default_ttl_seconds) + ", " +
                "next_virtual_DNS = " + str(self.next_virtual_DNS) + ", " +
                "floating_ip_record = " + str(self.floating_ip_record) + ", " +
                "external_visible = " + str(self.external_visible) + ", " +
                "reverse_resolution = " + str(self.reverse_resolution) + ", " +
                "soa_record = " + str(self.soa_record))

    def copy(self):
        cp = VirtualDnsType()
        if self.domain_name is not None:
            cp.domain_name = self.domain_name
        if self.dynamic_records_from_client is not None:
            cp.dynamic_records_from_client = self.dynamic_records_from_client
        if self.record_order is not None:
            cp.record_order = self.record_order
        if self.default_ttl_seconds is not None:
            cp.default_ttl_seconds = self.default_ttl_seconds
        if self.next_virtual_DNS is not None:
            cp.next_virtual_DNS = self.next_virtual_DNS
        if self.floating_ip_record is not None:
            cp.floating_ip_record = self.floating_ip_record
        if self.external_visible is not None:
            cp.external_visible = self.external_visible
        if self.reverse_resolution is not None:
            cp.reverse_resolution = self.reverse_resolution
        if self.soa_record is not None:
            cp.soa_record = self.soa_record.copy()
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_domain_name (obj.populate_string ("domain_name"))
        obj.set_dynamic_records_from_client (obj.populate_boolean ("dynamic_records_from_client"))
        obj.set_record_order (obj.populate_string ("record_order"))
        obj.set_default_ttl_seconds (obj.populate_integer ("default_ttl_seconds"))
        obj.set_next_virtual_DNS (obj.populate_string ("next_virtual_DNS"))
        obj.set_floating_ip_record (obj.populate_string ("floating_ip_record"))
        obj.set_external_visible (obj.populate_boolean ("external_visible"))
        obj.set_reverse_resolution (obj.populate_boolean ("reverse_resolution"))
        obj.set_soa_record (DnsSoaRecordType.populate ())
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='VirtualDnsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VirtualDnsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VirtualDnsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VirtualDnsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.domain_name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdomain-name>%s</%sdomain-name>%s' % (namespace_, self.gds_format_string(quote_xml(self.domain_name).encode(ExternalEncoding), input_name='domain-name'), namespace_, eol_))
        if self.dynamic_records_from_client is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdynamic-records-from-client>%s</%sdynamic-records-from-client>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.dynamic_records_from_client)), input_name='dynamic-records-from-client'), namespace_, eol_))
        if self.record_order is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srecord-order>%s</%srecord-order>%s' % (namespace_, self.gds_format_string(quote_xml(self.record_order).encode(ExternalEncoding), input_name='record-order'), namespace_, eol_))
        if self.default_ttl_seconds is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdefault-ttl-seconds>%s</%sdefault-ttl-seconds>%s' % (namespace_, self.gds_format_integer(self.default_ttl_seconds, input_name='default-ttl-seconds'), namespace_, eol_))
        if self.next_virtual_DNS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snext-virtual-DNS>%s</%snext-virtual-DNS>%s' % (namespace_, self.gds_format_string(quote_xml(self.next_virtual_DNS).encode(ExternalEncoding), input_name='next-virtual-DNS'), namespace_, eol_))
        if self.floating_ip_record is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfloating-ip-record>%s</%sfloating-ip-record>%s' % (namespace_, self.gds_format_string(quote_xml(self.floating_ip_record).encode(ExternalEncoding), input_name='floating-ip-record'), namespace_, eol_))
        if self.external_visible is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexternal-visible>%s</%sexternal-visible>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.external_visible)), input_name='external-visible'), namespace_, eol_))
        if self.reverse_resolution is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sreverse-resolution>%s</%sreverse-resolution>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.reverse_resolution)), input_name='reverse-resolution'), namespace_, eol_))
        if self.soa_record is not None:
            self.soa_record.export_xml(outfile, level, namespace_, name_='soa-record', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.domain_name is not None or
            self.dynamic_records_from_client is not None or
            self.record_order is not None or
            self.default_ttl_seconds is not None or
            self.next_virtual_DNS is not None or
            self.floating_ip_record is not None or
            self.external_visible is not None or
            self.reverse_resolution is not None or
            self.soa_record is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='VirtualDnsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.domain_name is not None:
            showIndent(outfile, level)
            outfile.write('domain_name=%s,\n' % quote_python(self.domain_name).encode(ExternalEncoding))
        if self.dynamic_records_from_client is not None:
            showIndent(outfile, level)
            outfile.write('dynamic_records_from_client=%s,\n' % self.dynamic_records_from_client)
        if self.record_order is not None:
            showIndent(outfile, level)
            outfile.write('record_order=%s,\n' % quote_python(self.record_order).encode(ExternalEncoding))
        if self.default_ttl_seconds is not None:
            showIndent(outfile, level)
            outfile.write('default_ttl_seconds=%d,\n' % self.default_ttl_seconds)
        if self.next_virtual_DNS is not None:
            showIndent(outfile, level)
            outfile.write('next_virtual_DNS=%s,\n' % quote_python(self.next_virtual_DNS).encode(ExternalEncoding))
        if self.floating_ip_record is not None:
            showIndent(outfile, level)
            outfile.write('floating_ip_record=%s,\n' % quote_python(self.floating_ip_record).encode(ExternalEncoding))
        if self.external_visible is not None:
            showIndent(outfile, level)
            outfile.write('external_visible=%s,\n' % self.external_visible)
        if self.reverse_resolution is not None:
            showIndent(outfile, level)
            outfile.write('reverse_resolution=%s,\n' % self.reverse_resolution)
        if self.soa_record is not None:
            showIndent(outfile, level)
            outfile.write('soa_record=model_.DnsSoaRecordType(\n')
            self.soa_record.exportLiteral(outfile, level, name_='soa_record')
            showIndent(outfile, level)
            outfile.write('),\n')
    def exportDict(self, name_='VirtualDnsType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'domain-name':
            domain_name_ = child_.text
            domain_name_ = self.gds_validate_string(domain_name_, node, 'domain_name')
            self.domain_name = domain_name_
        elif nodeName_ == 'dynamic-records-from-client':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'dynamic_records_from_client')
            self.dynamic_records_from_client = ival_
        elif nodeName_ == 'record-order':
            record_order_ = child_.text
            record_order_ = self.gds_validate_string(record_order_, node, 'record_order')
            self.record_order = record_order_
            self.validate_DnsRecordOrderType(self.record_order)    # validate type DnsRecordOrderType
        elif nodeName_ == 'default-ttl-seconds':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'default_ttl_seconds')
            self.default_ttl_seconds = ival_
        elif nodeName_ == 'next-virtual-DNS':
            next_virtual_DNS_ = child_.text
            next_virtual_DNS_ = self.gds_validate_string(next_virtual_DNS_, node, 'next_virtual_DNS')
            self.next_virtual_DNS = next_virtual_DNS_
        elif nodeName_ == 'floating-ip-record':
            floating_ip_record_ = child_.text
            floating_ip_record_ = self.gds_validate_string(floating_ip_record_, node, 'floating_ip_record')
            self.floating_ip_record = floating_ip_record_
            self.validate_FloatingIpDnsNotation(self.floating_ip_record)    # validate type FloatingIpDnsNotation
        elif nodeName_ == 'external-visible':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'external_visible')
            self.external_visible = ival_
        elif nodeName_ == 'reverse-resolution':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'reverse_resolution')
            self.reverse_resolution = ival_
        elif nodeName_ == 'soa-record':
            obj_ = DnsSoaRecordType.factory()
            obj_.build(child_)
            self.set_soa_record(obj_)
# end class VirtualDnsType


class VirtualDnsRecordType(GeneratedsSuper):
    """
    Attributes:
    * record_name
        Type:           str

        Created By:           User (required)

        Description:
          DNS name to be resolved

    * record_type
        Type:           str, *one-of* [u'A', u'AAAA', u'CNAME', u'PTR', u'NS', u'MX']

        Created By:           User (optional)

        Description:
          DNS record type can be A, AAAA, CNAME, PTR, NS and MX

    * record_class
        Type:           str, *one-of* [u'IN']

        Created By:           User (optional)

        Description:
          DNS record class supported is IN

    * record_data
        Type:           str

        Created By:           User (required)

        Description:
          DNS record data is either ip address or string depending on type

    * record_ttl_seconds
        Type:           int

        Created By:           User (optional)

        Description:
          Time To Live for this DNS record

    * record_mx_preference
        Type:           int

        Created By:           User (optional)

    * record_source_name
        Type:           str

        Description:
          name of the compute node which sends add for A type or PTR type dns record for

          vm

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'record_name', u'record_type', u'record_class', u'record_data', u'record_ttl_seconds', u'record_mx_preference', u'record_source_name']
    attr_field_type_vals = {u'record_name': {'restrictions': None, 'description': [u'DNS name to be resolved'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'true', 'attr_type': u'string'}, u'record_class': {'restrictions': [u'IN'], 'description': [u'DNS record class supported is IN'], 'simple_type': u'DnsRecordClassType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'record_data': {'restrictions': None, 'description': [u'DNS record data is either ip address or string depending on type'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'true', 'attr_type': u'string'}, u'record_type': {'restrictions': [u'A', u'AAAA', u'CNAME', u'PTR', u'NS', u'MX'], 'description': [u'DNS record type can be A, AAAA, CNAME, PTR, NS and MX'], 'simple_type': u'DnsRecordTypeType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'record_ttl_seconds': {'restrictions': None, 'description': [u'Time To Live for this DNS record'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'record_source_name': {'restrictions': None, 'description': [u'name of the compute node which sends add for A type or PTR type dns record for vm'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'system-only', 'attr_type': u'string'}, u'record_mx_preference': {'restrictions': None, 'description': [], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}}
    def __init__(self, record_name=None, record_type=None, record_class=None, record_data=None, record_ttl_seconds=None, record_mx_preference=None, record_source_name=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _record_name = params_dict[u"record_name"]
        except KeyError:
            _record_name = record_name
        self.record_name = _record_name
        try:
            _record_type = params_dict[u"record_type"]
        except KeyError:
            _record_type = record_type
        self.record_type = _record_type
        try:
            _record_class = params_dict[u"record_class"]
        except KeyError:
            _record_class = record_class
        self.record_class = _record_class
        try:
            _record_data = params_dict[u"record_data"]
        except KeyError:
            _record_data = record_data
        self.record_data = _record_data
        try:
            _record_ttl_seconds = params_dict[u"record_ttl_seconds"]
        except KeyError:
            _record_ttl_seconds = record_ttl_seconds
        self.record_ttl_seconds = _record_ttl_seconds
        try:
            _record_mx_preference = params_dict[u"record_mx_preference"]
        except KeyError:
            _record_mx_preference = record_mx_preference
        self.record_mx_preference = _record_mx_preference
        try:
            _record_source_name = params_dict[u"record_source_name"]
        except KeyError:
            _record_source_name = record_source_name
        self.record_source_name = _record_source_name
    def factory(*args_, **kwargs_):
        if VirtualDnsRecordType.subclass:
            return VirtualDnsRecordType.subclass(*args_, **kwargs_)
        else:
            return VirtualDnsRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_record_name(self): return self.record_name
    def set_record_name(self, record_name): self.record_name = record_name
    def get_record_type(self): return self.record_type
    def set_record_type(self, record_type): self.record_type = record_type
    def validate_DnsRecordTypeType(self, value):
        # Validate type DnsRecordTypeType, a restriction on xsd:string.
        error = False
        if isinstance(value, list):
            error = set(value) - set([u'A', u'AAAA', u'CNAME', u'PTR', u'NS', u'MX'])
        else:
            error = value not in [u'A', u'AAAA', u'CNAME', u'PTR', u'NS', u'MX']
        if error:
            raise ValueError("DnsRecordTypeType must be one of [u'A', u'AAAA', u'CNAME', u'PTR', u'NS', u'MX']")
    def get_record_class(self): return self.record_class
    def set_record_class(self, record_class): self.record_class = record_class
    def validate_DnsRecordClassType(self, value):
        # Validate type DnsRecordClassType, a restriction on xsd:string.
        error = False
        if isinstance(value, list):
            error = set(value) - set([u'IN'])
        else:
            error = value not in [u'IN']
        if error:
            raise ValueError("DnsRecordClassType must be one of [u'IN']")
    def get_record_data(self): return self.record_data
    def set_record_data(self, record_data): self.record_data = record_data
    def get_record_ttl_seconds(self): return self.record_ttl_seconds
    def set_record_ttl_seconds(self, record_ttl_seconds): self.record_ttl_seconds = record_ttl_seconds
    def get_record_mx_preference(self): return self.record_mx_preference
    def set_record_mx_preference(self, record_mx_preference): self.record_mx_preference = record_mx_preference
    def get_record_source_name(self): return self.record_source_name
    def set_record_source_name(self, record_source_name): self.record_source_name = record_source_name
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.record_name == other.record_name and
                    self.record_type == other.record_type and
                    self.record_class == other.record_class and
                    self.record_data == other.record_data and
                    self.record_ttl_seconds == other.record_ttl_seconds and
                    self.record_mx_preference == other.record_mx_preference and
                    self.record_source_name == other.record_source_name)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.record_name if self.record_name is not None else -7985492147856592190,
                     self.record_type if self.record_type is not None else -7985492147856592190,
                     self.record_class if self.record_class is not None else -7985492147856592190,
                     self.record_data if self.record_data is not None else -7985492147856592190,
                     self.record_ttl_seconds if self.record_ttl_seconds is not None else -7985492147856592190,
                     self.record_mx_preference if self.record_mx_preference is not None else -7985492147856592190,
                     self.record_source_name if self.record_source_name is not None else -7985492147856592190))

    def __repr__(self):
        return ("record_name = " + str(self.record_name) + ", " +
                "record_type = " + str(self.record_type) + ", " +
                "record_class = " + str(self.record_class) + ", " +
                "record_data = " + str(self.record_data) + ", " +
                "record_ttl_seconds = " + str(self.record_ttl_seconds) + ", " +
                "record_mx_preference = " + str(self.record_mx_preference) + ", " +
                "record_source_name = " + str(self.record_source_name))

    def copy(self):
        cp = VirtualDnsRecordType()
        if self.record_name is not None:
            cp.record_name = self.record_name
        if self.record_type is not None:
            cp.record_type = self.record_type
        if self.record_class is not None:
            cp.record_class = self.record_class
        if self.record_data is not None:
            cp.record_data = self.record_data
        if self.record_ttl_seconds is not None:
            cp.record_ttl_seconds = self.record_ttl_seconds
        if self.record_mx_preference is not None:
            cp.record_mx_preference = self.record_mx_preference
        if self.record_source_name is not None:
            cp.record_source_name = self.record_source_name
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_record_name (obj.populate_string ("record_name"))
        obj.set_record_type (obj.populate_string ("record_type"))
        obj.set_record_class (obj.populate_string ("record_class"))
        obj.set_record_data (obj.populate_string ("record_data"))
        obj.set_record_ttl_seconds (obj.populate_integer ("record_ttl_seconds"))
        obj.set_record_mx_preference (obj.populate_integer ("record_mx_preference"))
        obj.set_record_source_name (obj.populate_string ("record_source_name"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='VirtualDnsRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VirtualDnsRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VirtualDnsRecordType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VirtualDnsRecordType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.record_name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srecord-name>%s</%srecord-name>%s' % (namespace_, self.gds_format_string(quote_xml(self.record_name).encode(ExternalEncoding), input_name='record-name'), namespace_, eol_))
        if self.record_type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srecord-type>%s</%srecord-type>%s' % (namespace_, self.gds_format_string(quote_xml(self.record_type).encode(ExternalEncoding), input_name='record-type'), namespace_, eol_))
        if self.record_class is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srecord-class>%s</%srecord-class>%s' % (namespace_, self.gds_format_string(quote_xml(self.record_class).encode(ExternalEncoding), input_name='record-class'), namespace_, eol_))
        if self.record_data is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srecord-data>%s</%srecord-data>%s' % (namespace_, self.gds_format_string(quote_xml(self.record_data).encode(ExternalEncoding), input_name='record-data'), namespace_, eol_))
        if self.record_ttl_seconds is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srecord-ttl-seconds>%s</%srecord-ttl-seconds>%s' % (namespace_, self.gds_format_integer(self.record_ttl_seconds, input_name='record-ttl-seconds'), namespace_, eol_))
        if self.record_mx_preference is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srecord-mx-preference>%s</%srecord-mx-preference>%s' % (namespace_, self.gds_format_integer(self.record_mx_preference, input_name='record-mx-preference'), namespace_, eol_))
        if self.record_source_name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srecord-source-name>%s</%srecord-source-name>%s' % (namespace_, self.gds_format_string(quote_xml(self.record_source_name).encode(ExternalEncoding), input_name='record-source-name'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.record_name is not None or
            self.record_type is not None or
            self.record_class is not None or
            self.record_data is not None or
            self.record_ttl_seconds is not None or
            self.record_mx_preference is not None or
            self.record_source_name is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='VirtualDnsRecordType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.record_name is not None:
            showIndent(outfile, level)
            outfile.write('record_name=%s,\n' % quote_python(self.record_name).encode(ExternalEncoding))
        if self.record_type is not None:
            showIndent(outfile, level)
            outfile.write('record_type=%s,\n' % quote_python(self.record_type).encode(ExternalEncoding))
        if self.record_class is not None:
            showIndent(outfile, level)
            outfile.write('record_class=%s,\n' % quote_python(self.record_class).encode(ExternalEncoding))
        if self.record_data is not None:
            showIndent(outfile, level)
            outfile.write('record_data=%s,\n' % quote_python(self.record_data).encode(ExternalEncoding))
        if self.record_ttl_seconds is not None:
            showIndent(outfile, level)
            outfile.write('record_ttl_seconds=%d,\n' % self.record_ttl_seconds)
        if self.record_mx_preference is not None:
            showIndent(outfile, level)
            outfile.write('record_mx_preference=%d,\n' % self.record_mx_preference)
        if self.record_source_name is not None:
            showIndent(outfile, level)
            outfile.write('record_source_name=%s,\n' % quote_python(self.record_source_name).encode(ExternalEncoding))
    def exportDict(self, name_='VirtualDnsRecordType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'record-name':
            record_name_ = child_.text
            record_name_ = self.gds_validate_string(record_name_, node, 'record_name')
            self.record_name = record_name_
        elif nodeName_ == 'record-type':
            record_type_ = child_.text
            record_type_ = self.gds_validate_string(record_type_, node, 'record_type')
            self.record_type = record_type_
            self.validate_DnsRecordTypeType(self.record_type)    # validate type DnsRecordTypeType
        elif nodeName_ == 'record-class':
            record_class_ = child_.text
            record_class_ = self.gds_validate_string(record_class_, node, 'record_class')
            self.record_class = record_class_
            self.validate_DnsRecordClassType(self.record_class)    # validate type DnsRecordClassType
        elif nodeName_ == 'record-data':
            record_data_ = child_.text
            record_data_ = self.gds_validate_string(record_data_, node, 'record_data')
            self.record_data = record_data_
        elif nodeName_ == 'record-ttl-seconds':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'record_ttl_seconds')
            self.record_ttl_seconds = ival_
        elif nodeName_ == 'record-mx-preference':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'record_mx_preference')
            self.record_mx_preference = ival_
        elif nodeName_ == 'record-source-name':
            record_source_name_ = child_.text
            record_source_name_ = self.gds_validate_string(record_source_name_, node, 'record_source_name')
            self.record_source_name = record_source_name_
# end class VirtualDnsRecordType


class FloatingIpPoolSubnetType(GeneratedsSuper):
    """
    Attributes:
    * subnet_uuid
        Type:           str

        Description:
          List of subnets associated with this floating ip pool.

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'subnet_uuid']
    attr_field_type_vals = {u'subnet_uuid': {'restrictions': None, 'description': [u'List of subnets associated with this floating ip pool.'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': True, 'required': None, 'attr_type': u'string'}}
    def __init__(self, subnet_uuid=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _subnet_uuid = params_dict[u"subnet_uuid"]
        except KeyError:
            _subnet_uuid = subnet_uuid
        if not _subnet_uuid:
            self.subnet_uuid = []
        else:
            self.subnet_uuid = _subnet_uuid
    def factory(*args_, **kwargs_):
        if FloatingIpPoolSubnetType.subclass:
            return FloatingIpPoolSubnetType.subclass(*args_, **kwargs_)
        else:
            return FloatingIpPoolSubnetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_subnet_uuid(self): return self.subnet_uuid
    def set_subnet_uuid(self, subnet_uuid): self.subnet_uuid = subnet_uuid
    def add_subnet_uuid(self, value): self.subnet_uuid.append(value)
    def insert_subnet_uuid(self, index, value): self.subnet_uuid[index] = value
    def delete_subnet_uuid(self, value): self.subnet_uuid.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.subnet_uuid == other.subnet_uuid)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.subnet_uuid or [])))

    def __repr__(self):
        return ("subnet_uuid = " + str(self.subnet_uuid))

    def copy(self):
        cp = FloatingIpPoolSubnetType()
        if self.subnet_uuid is not None:
            cp.subnet_uuid = list(self.subnet_uuid)
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_subnet_uuid ([obj.populate_string ("subnet_uuid")])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='FloatingIpPoolSubnetType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FloatingIpPoolSubnetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FloatingIpPoolSubnetType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FloatingIpPoolSubnetType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for subnet_uuid_ in self.subnet_uuid:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssubnet-uuid>%s</%ssubnet-uuid>%s' % (namespace_, self.gds_format_string(quote_xml(subnet_uuid_).encode(ExternalEncoding), input_name='subnet-uuid'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.subnet_uuid
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FloatingIpPoolSubnetType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('subnet_uuid=[\n')
        level += 1
        for subnet_uuid_ in self.subnet_uuid:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(subnet_uuid_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='FloatingIpPoolSubnetType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'subnet-uuid':
            subnet_uuid_ = child_.text
            subnet_uuid_ = self.gds_validate_string(subnet_uuid_, node, 'subnet_uuid')
            self.subnet_uuid.append(subnet_uuid_)
# end class FloatingIpPoolSubnetType


class IpamSubnetType(GeneratedsSuper):
    """
    Attributes:
    * subnet
        Type:           :class:`.SubnetType`

        Created By:           User (required)

        Description:
          ip prefix and length for the subnet

    * default_gateway
        Type:           str, *one-of* xsd:string

        Created By:           User (optional)

        Description:
          default-gateway ip address in the subnet, if not provided one is auto generated

          by the system.

    * dns_server_address
        Type:           str, *one-of* xsd:string

        Created By:           User (optional)

        Description:
          DNS server ip address in the subnet, if not provided one is auto generated by

          the system.

    * subnet_uuid
        Type:           str

        Description:
          Subnet UUID is auto generated by the system

    * enable_dhcp
        Type:           bool

        Created By:           User (optional)

        Description:
          Enable DHCP for the VM(s) in this subnet

    * dns_nameservers
        Type:           str

        Created By:           User (optional)

        Description:
          Tenant DNS servers ip address in tenant DNS method

    * allocation_pools
        Type:           :class:`.AllocationPoolType`

        Created By:           User (optional)

        Description:
          List of ranges of ip address within the subnet from which to allocate ip

          address. default is entire prefix

    * addr_from_start
        Type:           bool

        Created By:           User (optional)

        Description:
          Start address allocation from start or from end of address range.

    * dhcp_option_list
        Type:           :class:`.DhcpOptionsListType`

        Created By:           User (optional)

        Description:
          DHCP options list to be sent via DHCP for  VM(s) in this subnet

    * host_routes
        Type:           :class:`.RouteTableType`

        Created By:           User (optional)

        Description:
          Host routes to be sent via DHCP for VM(s) in this subnet, Next hop for these

          routes is always default gateway

    * subnet_name
        Type:           str

        Created By:           User (optional)

        Description:
          User provided name for this subnet

    * alloc_unit
        Type:           int

        Created By:           User (optional)

        Description:
          allocation unit for this subnet to allocate bulk ip addresses

    * created
        Type:           :class:`.xsd:dateTime`

        Created By:           User (optional)

        Description:
          timestamp when subnet object gets created

    * last_modified
        Type:           :class:`.xsd:dateTime`

        Created By:           User (optional)

        Description:
          timestamp when subnet object gets updated

    * subscriber_tag
        Type:           str

        Created By:           User (optional)

        Description:
          This represents subscribers assigned ip addresses from this subnet for fabric

          peer network

    * vlan_tag
        Type:           int

        Created By:           User (optional)

        Description:
          vlan this subnet belongs to

    * dhcp_relay_server
        Type:           str, *one-of* xsd:string

        Created By:           User (optional)

        Description:
          DHCP relay server IP

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'subnet', u'default_gateway', u'dns_server_address', u'subnet_uuid', u'enable_dhcp', u'dns_nameservers', u'allocation_pools', u'addr_from_start', u'dhcp_option_list', u'host_routes', u'subnet_name', u'alloc_unit', u'created', u'last_modified', u'subscriber_tag', u'vlan_tag', u'dhcp_relay_server']
    attr_field_type_vals = {u'subnet': {'restrictions': None, 'description': [u'ip prefix and length for the subnet'], 'simple_type': u'SubnetType', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': u'true', 'attr_type': u'SubnetType'}, u'addr_from_start': {'restrictions': None, 'description': [u'Start address allocation from start or from end of address range.'], 'simple_type': u'xsd:boolean', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'boolean'}, u'enable_dhcp': {'restrictions': None, 'description': [u'Enable DHCP for the VM(s) in this subnet'], 'simple_type': u'xsd:boolean', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'boolean'}, u'default_gateway': {'restrictions': [], 'description': [u'default-gateway ip address in the subnet, if not provided one is auto generated by the system.'], 'simple_type': u'IpAddressType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'alloc_unit': {'restrictions': None, 'description': [u'allocation unit for this subnet to allocate bulk ip addresses'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'created': {'restrictions': None, 'description': [u'timestamp when subnet object gets created'], 'simple_type': u'xsd:dateTime', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'dateTime'}, u'dns_nameservers': {'restrictions': None, 'description': [u'Tenant DNS servers ip address in tenant DNS method'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': True, 'required': u'optional', 'attr_type': u'string'}, u'dhcp_option_list': {'restrictions': None, 'description': [u'DHCP options list to be sent via DHCP for  VM(s) in this subnet'], 'simple_type': u'DhcpOptionsListType', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'DhcpOptionsListType'}, u'subnet_uuid': {'restrictions': None, 'description': [u'Subnet UUID is auto generated by the system'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'system-only', 'attr_type': u'string'}, u'allocation_pools': {'restrictions': None, 'description': [u'List of ranges of ip address within the subnet from which to allocate ip address. default is entire prefix'], 'simple_type': u'AllocationPoolType', 'is_complex': 1, 'restriction_type': None, 'is_array': True, 'required': u'optional', 'attr_type': u'AllocationPoolType'}, u'last_modified': {'restrictions': None, 'description': [u'timestamp when subnet object gets updated'], 'simple_type': u'xsd:dateTime', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'dateTime'}, u'host_routes': {'restrictions': None, 'description': [u'Host routes to be sent via DHCP for VM(s) in this subnet, Next hop for these routes is always default gateway'], 'simple_type': u'RouteTableType', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'RouteTableType'}, u'subscriber_tag': {'restrictions': None, 'description': [u'This represents subscribers assigned ip addresses from this subnet for fabric peer network'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'dns_server_address': {'restrictions': [], 'description': [u'DNS server ip address in the subnet, if not provided one is auto generated by the system.'], 'simple_type': u'IpAddressType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'subnet_name': {'restrictions': None, 'description': [u'User provided name for this subnet'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'vlan_tag': {'restrictions': None, 'description': [u'vlan this subnet belongs to'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'dhcp_relay_server': {'restrictions': [], 'description': [u'DHCP relay server IP'], 'simple_type': u'IpAddressType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': True, 'required': u'optional', 'attr_type': u'string'}}
    def __init__(self, subnet=None, default_gateway=None, dns_server_address=None, subnet_uuid=None, enable_dhcp=True, dns_nameservers=None, allocation_pools=None, addr_from_start=None, dhcp_option_list=None, host_routes=None, subnet_name=None, alloc_unit=1, created=None, last_modified=None, subscriber_tag=None, vlan_tag=None, dhcp_relay_server=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _subnet = params_dict[u"subnet"]
        except KeyError:
            _subnet = subnet
        if isinstance(_subnet, dict):
            obj = SubnetType(params_dict=_subnet)
            self.subnet = obj
        else:
            self.subnet = _subnet
        try:
            _default_gateway = params_dict[u"default_gateway"]
        except KeyError:
            _default_gateway = default_gateway
        self.default_gateway = _default_gateway
        try:
            _dns_server_address = params_dict[u"dns_server_address"]
        except KeyError:
            _dns_server_address = dns_server_address
        self.dns_server_address = _dns_server_address
        try:
            _subnet_uuid = params_dict[u"subnet_uuid"]
        except KeyError:
            _subnet_uuid = subnet_uuid
        self.subnet_uuid = _subnet_uuid
        try:
            _enable_dhcp = params_dict[u"enable_dhcp"]
        except KeyError:
            _enable_dhcp = enable_dhcp
        self.enable_dhcp = _enable_dhcp
        try:
            _dns_nameservers = params_dict[u"dns_nameservers"]
        except KeyError:
            _dns_nameservers = dns_nameservers
        if not _dns_nameservers:
            self.dns_nameservers = []
        else:
            self.dns_nameservers = _dns_nameservers
        try:
            _allocation_pools = params_dict[u"allocation_pools"]
        except KeyError:
            _allocation_pools = allocation_pools
        if not _allocation_pools:
            self.allocation_pools = []
        else:
            if isinstance(_allocation_pools[0], dict):
                objs = [AllocationPoolType(params_dict=elem) for elem in _allocation_pools]
                self.allocation_pools = objs
            else:
                self.allocation_pools = _allocation_pools
        try:
            _addr_from_start = params_dict[u"addr_from_start"]
        except KeyError:
            _addr_from_start = addr_from_start
        self.addr_from_start = _addr_from_start
        try:
            _dhcp_option_list = params_dict[u"dhcp_option_list"]
        except KeyError:
            _dhcp_option_list = dhcp_option_list
        if isinstance(_dhcp_option_list, dict):
            obj = DhcpOptionsListType(params_dict=_dhcp_option_list)
            self.dhcp_option_list = obj
        else:
            self.dhcp_option_list = _dhcp_option_list
        try:
            _host_routes = params_dict[u"host_routes"]
        except KeyError:
            _host_routes = host_routes
        if isinstance(_host_routes, dict):
            obj = RouteTableType(params_dict=_host_routes)
            self.host_routes = obj
        else:
            self.host_routes = _host_routes
        try:
            _subnet_name = params_dict[u"subnet_name"]
        except KeyError:
            _subnet_name = subnet_name
        self.subnet_name = _subnet_name
        try:
            _alloc_unit = params_dict[u"alloc_unit"]
        except KeyError:
            _alloc_unit = alloc_unit
        self.alloc_unit = _alloc_unit
        try:
            _created = params_dict[u"created"]
        except KeyError:
            _created = created
        self.created = _created
        try:
            _last_modified = params_dict[u"last_modified"]
        except KeyError:
            _last_modified = last_modified
        self.last_modified = _last_modified
        try:
            _subscriber_tag = params_dict[u"subscriber_tag"]
        except KeyError:
            _subscriber_tag = subscriber_tag
        self.subscriber_tag = _subscriber_tag
        try:
            _vlan_tag = params_dict[u"vlan_tag"]
        except KeyError:
            _vlan_tag = vlan_tag
        self.vlan_tag = _vlan_tag
        try:
            _dhcp_relay_server = params_dict[u"dhcp_relay_server"]
        except KeyError:
            _dhcp_relay_server = dhcp_relay_server
        if not _dhcp_relay_server:
            self.dhcp_relay_server = []
        else:
            self.dhcp_relay_server = _dhcp_relay_server
    def factory(*args_, **kwargs_):
        if IpamSubnetType.subclass:
            return IpamSubnetType.subclass(*args_, **kwargs_)
        else:
            return IpamSubnetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_subnet(self): return self.subnet
    def set_subnet(self, subnet): self.subnet = subnet
    def get_default_gateway(self): return self.default_gateway
    def set_default_gateway(self, default_gateway): self.default_gateway = default_gateway
    def validate_IpAddressType(self, value):
        # Validate type IpAddressType, a restriction on xsd:string.
        pass
    def get_dns_server_address(self): return self.dns_server_address
    def set_dns_server_address(self, dns_server_address): self.dns_server_address = dns_server_address
    def get_subnet_uuid(self): return self.subnet_uuid
    def set_subnet_uuid(self, subnet_uuid): self.subnet_uuid = subnet_uuid
    def get_enable_dhcp(self): return self.enable_dhcp
    def set_enable_dhcp(self, enable_dhcp): self.enable_dhcp = enable_dhcp
    def get_dns_nameservers(self): return self.dns_nameservers
    def set_dns_nameservers(self, dns_nameservers): self.dns_nameservers = dns_nameservers
    def add_dns_nameservers(self, value): self.dns_nameservers.append(value)
    def insert_dns_nameservers(self, index, value): self.dns_nameservers[index] = value
    def delete_dns_nameservers(self, value): self.dns_nameservers.remove(value)
    def get_allocation_pools(self): return self.allocation_pools
    def set_allocation_pools(self, allocation_pools): self.allocation_pools = allocation_pools
    def add_allocation_pools(self, value): self.allocation_pools.append(value)
    def insert_allocation_pools(self, index, value): self.allocation_pools[index] = value
    def delete_allocation_pools(self, value): self.allocation_pools.remove(value)
    def get_addr_from_start(self): return self.addr_from_start
    def set_addr_from_start(self, addr_from_start): self.addr_from_start = addr_from_start
    def get_dhcp_option_list(self): return self.dhcp_option_list
    def set_dhcp_option_list(self, dhcp_option_list): self.dhcp_option_list = dhcp_option_list
    def get_host_routes(self): return self.host_routes
    def set_host_routes(self, host_routes): self.host_routes = host_routes
    def get_subnet_name(self): return self.subnet_name
    def set_subnet_name(self, subnet_name): self.subnet_name = subnet_name
    def get_alloc_unit(self): return self.alloc_unit
    def set_alloc_unit(self, alloc_unit): self.alloc_unit = alloc_unit
    def get_created(self): return self.created
    def set_created(self, created): self.created = created
    def get_last_modified(self): return self.last_modified
    def set_last_modified(self, last_modified): self.last_modified = last_modified
    def get_subscriber_tag(self): return self.subscriber_tag
    def set_subscriber_tag(self, subscriber_tag): self.subscriber_tag = subscriber_tag
    def get_vlan_tag(self): return self.vlan_tag
    def set_vlan_tag(self, vlan_tag): self.vlan_tag = vlan_tag
    def get_dhcp_relay_server(self): return self.dhcp_relay_server
    def set_dhcp_relay_server(self, dhcp_relay_server): self.dhcp_relay_server = dhcp_relay_server
    def add_dhcp_relay_server(self, value): self.dhcp_relay_server.append(value)
    def insert_dhcp_relay_server(self, index, value): self.dhcp_relay_server[index] = value
    def delete_dhcp_relay_server(self, value): self.dhcp_relay_server.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.subnet == other.subnet and
                    self.default_gateway == other.default_gateway and
                    self.dns_server_address == other.dns_server_address and
                    self.subnet_uuid == other.subnet_uuid and
                    self.enable_dhcp == other.enable_dhcp and
                    self.dns_nameservers == other.dns_nameservers and
                    self.allocation_pools == other.allocation_pools and
                    self.addr_from_start == other.addr_from_start and
                    self.dhcp_option_list == other.dhcp_option_list and
                    self.host_routes == other.host_routes and
                    self.subnet_name == other.subnet_name and
                    self.alloc_unit == other.alloc_unit and
                    self.created == other.created and
                    self.last_modified == other.last_modified and
                    self.subscriber_tag == other.subscriber_tag and
                    self.vlan_tag == other.vlan_tag and
                    self.dhcp_relay_server == other.dhcp_relay_server)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.subnet if self.subnet is not None else -7985492147856592190,
                     self.default_gateway if self.default_gateway is not None else -7985492147856592190,
                     self.dns_server_address if self.dns_server_address is not None else -7985492147856592190,
                     self.subnet_uuid if self.subnet_uuid is not None else -7985492147856592190,
                     self.enable_dhcp if self.enable_dhcp is not None else -7985492147856592190,
                     tuple(self.dns_nameservers or []),
                     tuple(self.allocation_pools or []),
                     self.addr_from_start if self.addr_from_start is not None else -7985492147856592190,
                     self.dhcp_option_list if self.dhcp_option_list is not None else -7985492147856592190,
                     self.host_routes if self.host_routes is not None else -7985492147856592190,
                     self.subnet_name if self.subnet_name is not None else -7985492147856592190,
                     self.alloc_unit if self.alloc_unit is not None else -7985492147856592190,
                     self.created if self.created is not None else -7985492147856592190,
                     self.last_modified if self.last_modified is not None else -7985492147856592190,
                     self.subscriber_tag if self.subscriber_tag is not None else -7985492147856592190,
                     self.vlan_tag if self.vlan_tag is not None else -7985492147856592190,
                     tuple(self.dhcp_relay_server or [])))

    def __repr__(self):
        return ("subnet = " + str(self.subnet) + ", " +
                "default_gateway = " + str(self.default_gateway) + ", " +
                "dns_server_address = " + str(self.dns_server_address) + ", " +
                "subnet_uuid = " + str(self.subnet_uuid) + ", " +
                "enable_dhcp = " + str(self.enable_dhcp) + ", " +
                "dns_nameservers = " + str(self.dns_nameservers) + ", " +
                "allocation_pools = " + str(self.allocation_pools) + ", " +
                "addr_from_start = " + str(self.addr_from_start) + ", " +
                "dhcp_option_list = " + str(self.dhcp_option_list) + ", " +
                "host_routes = " + str(self.host_routes) + ", " +
                "subnet_name = " + str(self.subnet_name) + ", " +
                "alloc_unit = " + str(self.alloc_unit) + ", " +
                "created = " + str(self.created) + ", " +
                "last_modified = " + str(self.last_modified) + ", " +
                "subscriber_tag = " + str(self.subscriber_tag) + ", " +
                "vlan_tag = " + str(self.vlan_tag) + ", " +
                "dhcp_relay_server = " + str(self.dhcp_relay_server))

    def copy(self):
        cp = IpamSubnetType()
        if self.subnet is not None:
            cp.subnet = self.subnet.copy()
        if self.default_gateway is not None:
            cp.default_gateway = self.default_gateway
        if self.dns_server_address is not None:
            cp.dns_server_address = self.dns_server_address
        if self.subnet_uuid is not None:
            cp.subnet_uuid = self.subnet_uuid
        if self.enable_dhcp is not None:
            cp.enable_dhcp = self.enable_dhcp
        if self.dns_nameservers is not None:
            cp.dns_nameservers = list(self.dns_nameservers)
        if self.allocation_pools is not None:
            cp.allocation_pools = [x.copy() for x in self.allocation_pools]
        if self.addr_from_start is not None:
            cp.addr_from_start = self.addr_from_start
        if self.dhcp_option_list is not None:
            cp.dhcp_option_list = self.dhcp_option_list.copy()
        if self.host_routes is not None:
            cp.host_routes = self.host_routes.copy()
        if self.subnet_name is not None:
            cp.subnet_name = self.subnet_name
        if self.alloc_unit is not None:
            cp.alloc_unit = self.alloc_unit
        if self.created is not None:
            cp.created = self.created
        if self.last_modified is not None:
            cp.last_modified = self.last_modified
        if self.subscriber_tag is not None:
            cp.subscriber_tag = self.subscriber_tag
        if self.vlan_tag is not None:
            cp.vlan_tag = self.vlan_tag
        if self.dhcp_relay_server is not None:
            cp.dhcp_relay_server = list(self.dhcp_relay_server)
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_subnet (SubnetType.populate ())
        obj.set_default_gateway (obj.populate_string ("default_gateway"))
        obj.set_dns_server_address (obj.populate_string ("dns_server_address"))
        obj.set_subnet_uuid (obj.populate_string ("subnet_uuid"))
        obj.set_enable_dhcp (obj.populate_boolean ("enable_dhcp"))
        obj.set_dns_nameservers ([obj.populate_string ("dns_nameservers")])
        obj.set_allocation_pools ([AllocationPoolType.populate ()])
        obj.set_addr_from_start (obj.populate_boolean ("addr_from_start"))
        obj.set_dhcp_option_list (DhcpOptionsListType.populate ())
        obj.set_host_routes (RouteTableType.populate ())
        obj.set_subnet_name (obj.populate_string ("subnet_name"))
        obj.set_alloc_unit (obj.populate_integer ("alloc_unit"))
        obj.set_created (obj.populate_dateTime ("created"))
        obj.set_last_modified (obj.populate_dateTime ("last_modified"))
        obj.set_subscriber_tag (obj.populate_string ("subscriber_tag"))
        obj.set_vlan_tag (obj.populate_integer ("vlan_tag"))
        obj.set_dhcp_relay_server ([obj.populate_string ("dhcp_relay_server")])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='IpamSubnetType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IpamSubnetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IpamSubnetType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='IpamSubnetType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.subnet is not None:
            self.subnet.export_xml(outfile, level, namespace_, name_='subnet', pretty_print=pretty_print)
        if self.default_gateway is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdefault-gateway>%s</%sdefault-gateway>%s' % (namespace_, self.gds_format_string(quote_xml(self.default_gateway).encode(ExternalEncoding), input_name='default-gateway'), namespace_, eol_))
        if self.dns_server_address is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdns-server-address>%s</%sdns-server-address>%s' % (namespace_, self.gds_format_string(quote_xml(self.dns_server_address).encode(ExternalEncoding), input_name='dns-server-address'), namespace_, eol_))
        if self.subnet_uuid is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssubnet-uuid>%s</%ssubnet-uuid>%s' % (namespace_, self.gds_format_string(quote_xml(self.subnet_uuid).encode(ExternalEncoding), input_name='subnet-uuid'), namespace_, eol_))
        if self.enable_dhcp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%senable-dhcp>%s</%senable-dhcp>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.enable_dhcp)), input_name='enable-dhcp'), namespace_, eol_))
        for dns_nameservers_ in self.dns_nameservers:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdns-nameservers>%s</%sdns-nameservers>%s' % (namespace_, self.gds_format_string(quote_xml(dns_nameservers_).encode(ExternalEncoding), input_name='dns-nameservers'), namespace_, eol_))
        for allocation_pools_ in self.allocation_pools:
            if isinstance(allocation_pools_, dict):
                allocation_pools_ = AllocationPoolType(**allocation_pools_)
            allocation_pools_.export_xml(outfile, level, namespace_, name_='allocation-pools', pretty_print=pretty_print)
        if self.addr_from_start is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saddr_from_start>%s</%saddr_from_start>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.addr_from_start)), input_name='addr_from_start'), namespace_, eol_))
        if self.dhcp_option_list is not None:
            self.dhcp_option_list.export_xml(outfile, level, namespace_, name_='dhcp-option-list', pretty_print=pretty_print)
        if self.host_routes is not None:
            self.host_routes.export_xml(outfile, level, namespace_, name_='host-routes', pretty_print=pretty_print)
        if self.subnet_name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssubnet-name>%s</%ssubnet-name>%s' % (namespace_, self.gds_format_string(quote_xml(self.subnet_name).encode(ExternalEncoding), input_name='subnet-name'), namespace_, eol_))
        if self.alloc_unit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%salloc-unit>%s</%salloc-unit>%s' % (namespace_, self.gds_format_integer(self.alloc_unit, input_name='alloc-unit'), namespace_, eol_))
        if self.created is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%screated>%s</%screated>%s' % (namespace_, self.gds_format_string(quote_xml(self.created).encode(ExternalEncoding), input_name='created'), namespace_, eol_))
        if self.last_modified is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slast-modified>%s</%slast-modified>%s' % (namespace_, self.gds_format_string(quote_xml(self.last_modified).encode(ExternalEncoding), input_name='last-modified'), namespace_, eol_))
        if self.subscriber_tag is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssubscriber-tag>%s</%ssubscriber-tag>%s' % (namespace_, self.gds_format_string(quote_xml(self.subscriber_tag).encode(ExternalEncoding), input_name='subscriber-tag'), namespace_, eol_))
        if self.vlan_tag is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svlan-tag>%s</%svlan-tag>%s' % (namespace_, self.gds_format_integer(self.vlan_tag, input_name='vlan-tag'), namespace_, eol_))
        for dhcp_relay_server_ in self.dhcp_relay_server:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdhcp-relay-server>%s</%sdhcp-relay-server>%s' % (namespace_, self.gds_format_string(quote_xml(dhcp_relay_server_).encode(ExternalEncoding), input_name='dhcp-relay-server'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.subnet is not None or
            self.default_gateway is not None or
            self.dns_server_address is not None or
            self.subnet_uuid is not None or
            self.enable_dhcp is not None or
            self.dns_nameservers or
            self.allocation_pools or
            self.addr_from_start is not None or
            self.dhcp_option_list is not None or
            self.host_routes is not None or
            self.subnet_name is not None or
            self.alloc_unit is not None or
            self.created is not None or
            self.last_modified is not None or
            self.subscriber_tag is not None or
            self.vlan_tag is not None or
            self.dhcp_relay_server
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='IpamSubnetType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.subnet is not None:
            showIndent(outfile, level)
            outfile.write('subnet=model_.SubnetType(\n')
            self.subnet.exportLiteral(outfile, level, name_='subnet')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.default_gateway is not None:
            showIndent(outfile, level)
            outfile.write('default_gateway=%s,\n' % quote_python(self.default_gateway).encode(ExternalEncoding))
        if self.dns_server_address is not None:
            showIndent(outfile, level)
            outfile.write('dns_server_address=%s,\n' % quote_python(self.dns_server_address).encode(ExternalEncoding))
        if self.subnet_uuid is not None:
            showIndent(outfile, level)
            outfile.write('subnet_uuid=%s,\n' % quote_python(self.subnet_uuid).encode(ExternalEncoding))
        if self.enable_dhcp is not None:
            showIndent(outfile, level)
            outfile.write('enable_dhcp=%s,\n' % self.enable_dhcp)
        showIndent(outfile, level)
        outfile.write('dns_nameservers=[\n')
        level += 1
        for dns_nameservers_ in self.dns_nameservers:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(dns_nameservers_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('allocation_pools=[\n')
        level += 1
        for allocation_pools_ in self.allocation_pools:
            showIndent(outfile, level)
            outfile.write('model_.AllocationPoolType(\n')
            allocation_pools_.exportLiteral(outfile, level, name_='AllocationPoolType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.addr_from_start is not None:
            showIndent(outfile, level)
            outfile.write('addr_from_start=%s,\n' % self.addr_from_start)
        if self.dhcp_option_list is not None:
            showIndent(outfile, level)
            outfile.write('dhcp_option_list=model_.DhcpOptionsListType(\n')
            self.dhcp_option_list.exportLiteral(outfile, level, name_='dhcp_option_list')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.host_routes is not None:
            showIndent(outfile, level)
            outfile.write('host_routes=model_.RouteTableType(\n')
            self.host_routes.exportLiteral(outfile, level, name_='host_routes')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.subnet_name is not None:
            showIndent(outfile, level)
            outfile.write('subnet_name=%s,\n' % quote_python(self.subnet_name).encode(ExternalEncoding))
        if self.alloc_unit is not None:
            showIndent(outfile, level)
            outfile.write('alloc_unit=%d,\n' % self.alloc_unit)
        if self.created is not None:
            showIndent(outfile, level)
            outfile.write('created=%s,\n' % quote_python(self.created).encode(ExternalEncoding))
        if self.last_modified is not None:
            showIndent(outfile, level)
            outfile.write('last_modified=%s,\n' % quote_python(self.last_modified).encode(ExternalEncoding))
        if self.subscriber_tag is not None:
            showIndent(outfile, level)
            outfile.write('subscriber_tag=%s,\n' % quote_python(self.subscriber_tag).encode(ExternalEncoding))
        if self.vlan_tag is not None:
            showIndent(outfile, level)
            outfile.write('vlan_tag=%d,\n' % self.vlan_tag)
        showIndent(outfile, level)
        outfile.write('dhcp_relay_server=[\n')
        level += 1
        for dhcp_relay_server_ in self.dhcp_relay_server:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(dhcp_relay_server_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='IpamSubnetType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'subnet':
            obj_ = SubnetType.factory()
            obj_.build(child_)
            self.set_subnet(obj_)
        elif nodeName_ == 'default-gateway':
            default_gateway_ = child_.text
            default_gateway_ = self.gds_validate_string(default_gateway_, node, 'default_gateway')
            self.default_gateway = default_gateway_
            self.validate_IpAddressType(self.default_gateway)    # validate type IpAddressType
        elif nodeName_ == 'dns-server-address':
            dns_server_address_ = child_.text
            dns_server_address_ = self.gds_validate_string(dns_server_address_, node, 'dns_server_address')
            self.dns_server_address = dns_server_address_
            self.validate_IpAddressType(self.dns_server_address)    # validate type IpAddressType
        elif nodeName_ == 'subnet-uuid':
            subnet_uuid_ = child_.text
            subnet_uuid_ = self.gds_validate_string(subnet_uuid_, node, 'subnet_uuid')
            self.subnet_uuid = subnet_uuid_
        elif nodeName_ == 'enable-dhcp':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'enable_dhcp')
            self.enable_dhcp = ival_
        elif nodeName_ == 'dns-nameservers':
            dns_nameservers_ = child_.text
            dns_nameservers_ = self.gds_validate_string(dns_nameservers_, node, 'dns_nameservers')
            self.dns_nameservers.append(dns_nameservers_)
        elif nodeName_ == 'allocation-pools':
            obj_ = AllocationPoolType.factory()
            obj_.build(child_)
            self.allocation_pools.append(obj_)
        elif nodeName_ == 'addr_from_start':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'addr_from_start')
            self.addr_from_start = ival_
        elif nodeName_ == 'dhcp-option-list':
            obj_ = DhcpOptionsListType.factory()
            obj_.build(child_)
            self.set_dhcp_option_list(obj_)
        elif nodeName_ == 'host-routes':
            obj_ = RouteTableType.factory()
            obj_.build(child_)
            self.set_host_routes(obj_)
        elif nodeName_ == 'subnet-name':
            subnet_name_ = child_.text
            subnet_name_ = self.gds_validate_string(subnet_name_, node, 'subnet_name')
            self.subnet_name = subnet_name_
        elif nodeName_ == 'alloc-unit':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'alloc_unit')
            self.alloc_unit = ival_
        elif nodeName_ == 'created':
            created_ = child_.text
            created_ = self.gds_validate_string(created_, node, 'created')
            self.created = created_
        elif nodeName_ == 'last-modified':
            last_modified_ = child_.text
            last_modified_ = self.gds_validate_string(last_modified_, node, 'last_modified')
            self.last_modified = last_modified_
        elif nodeName_ == 'subscriber-tag':
            subscriber_tag_ = child_.text
            subscriber_tag_ = self.gds_validate_string(subscriber_tag_, node, 'subscriber_tag')
            self.subscriber_tag = subscriber_tag_
        elif nodeName_ == 'vlan-tag':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'vlan_tag')
            self.vlan_tag = ival_
        elif nodeName_ == 'dhcp-relay-server':
            dhcp_relay_server_ = child_.text
            dhcp_relay_server_ = self.gds_validate_string(dhcp_relay_server_, node, 'dhcp_relay_server')
            self.dhcp_relay_server.append(dhcp_relay_server_)
            self.validate_IpAddressType(self.dhcp_relay_server)    # validate type IpAddressType
# end class IpamSubnetType


class VnSubnetsType(GeneratedsSuper):
    """
    Attributes:
    * ipam_subnets
        Type:           :class:`.IpamSubnetType`

    * host_routes
        Type:           :class:`.RouteTableType`

        Created By:           User (optional)

        Description:
          Common host routes to be sent via DHCP for VM(s) in all the subnets, Next hop

          for these routes is always default gateway

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'ipam_subnets', u'host_routes']
    attr_field_type_vals = {u'ipam_subnets': {'restrictions': None, 'description': [], 'simple_type': u'IpamSubnetType', 'is_complex': 1, 'restriction_type': None, 'is_array': True, 'required': None, 'attr_type': u'IpamSubnetType'}, u'host_routes': {'restrictions': None, 'description': [u'Common host routes to be sent via DHCP for VM(s) in all the subnets, Next hop for these routes is always default gateway'], 'simple_type': u'RouteTableType', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'RouteTableType'}}
    def __init__(self, ipam_subnets=None, host_routes=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _ipam_subnets = params_dict[u"ipam_subnets"]
        except KeyError:
            _ipam_subnets = ipam_subnets
        if not _ipam_subnets:
            self.ipam_subnets = []
        else:
            if isinstance(_ipam_subnets[0], dict):
                objs = [IpamSubnetType(params_dict=elem) for elem in _ipam_subnets]
                self.ipam_subnets = objs
            else:
                self.ipam_subnets = _ipam_subnets
        try:
            _host_routes = params_dict[u"host_routes"]
        except KeyError:
            _host_routes = host_routes
        if isinstance(_host_routes, dict):
            obj = RouteTableType(params_dict=_host_routes)
            self.host_routes = obj
        else:
            self.host_routes = _host_routes
    def factory(*args_, **kwargs_):
        if VnSubnetsType.subclass:
            return VnSubnetsType.subclass(*args_, **kwargs_)
        else:
            return VnSubnetsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ipam_subnets(self): return self.ipam_subnets
    def set_ipam_subnets(self, ipam_subnets): self.ipam_subnets = ipam_subnets
    def add_ipam_subnets(self, value): self.ipam_subnets.append(value)
    def insert_ipam_subnets(self, index, value): self.ipam_subnets[index] = value
    def delete_ipam_subnets(self, value): self.ipam_subnets.remove(value)
    def get_host_routes(self): return self.host_routes
    def set_host_routes(self, host_routes): self.host_routes = host_routes
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.ipam_subnets == other.ipam_subnets and
                    self.host_routes == other.host_routes)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.ipam_subnets or []),
                     self.host_routes if self.host_routes is not None else -7985492147856592190))

    def __repr__(self):
        return ("ipam_subnets = " + str(self.ipam_subnets) + ", " +
                "host_routes = " + str(self.host_routes))

    def copy(self):
        cp = VnSubnetsType()
        if self.ipam_subnets is not None:
            cp.ipam_subnets = [x.copy() for x in self.ipam_subnets]
        if self.host_routes is not None:
            cp.host_routes = self.host_routes.copy()
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_ipam_subnets ([IpamSubnetType.populate ()])
        obj.set_host_routes (RouteTableType.populate ())
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='VnSubnetsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VnSubnetsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VnSubnetsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VnSubnetsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ipam_subnets_ in self.ipam_subnets:
            if isinstance(ipam_subnets_, dict):
                ipam_subnets_ = IpamSubnetType(**ipam_subnets_)
            ipam_subnets_.export_xml(outfile, level, namespace_, name_='ipam-subnets', pretty_print=pretty_print)
        if self.host_routes is not None:
            self.host_routes.export_xml(outfile, level, namespace_, name_='host-routes', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.ipam_subnets or
            self.host_routes is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='VnSubnetsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ipam_subnets=[\n')
        level += 1
        for ipam_subnets_ in self.ipam_subnets:
            showIndent(outfile, level)
            outfile.write('model_.IpamSubnetType(\n')
            ipam_subnets_.exportLiteral(outfile, level, name_='IpamSubnetType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.host_routes is not None:
            showIndent(outfile, level)
            outfile.write('host_routes=model_.RouteTableType(\n')
            self.host_routes.exportLiteral(outfile, level, name_='host_routes')
            showIndent(outfile, level)
            outfile.write('),\n')
    def exportDict(self, name_='VnSubnetsType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ipam-subnets':
            obj_ = IpamSubnetType.factory()
            obj_.build(child_)
            self.ipam_subnets.append(obj_)
        elif nodeName_ == 'host-routes':
            obj_ = RouteTableType.factory()
            obj_.build(child_)
            self.set_host_routes(obj_)
# end class VnSubnetsType


class RbacPermType(GeneratedsSuper):
    """
    Attributes:
    * role_name
        Type:           str

        Created By:           User (required)

        Description:
          Name of the role

    * role_crud
        Type:           str

        Created By:           User (required)

        Description:
          String CRUD representing permissions for C=create, R=read, U=update, D=delete.

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'role_name', u'role_crud']
    attr_field_type_vals = {u'role_crud': {'restrictions': None, 'description': [u'String CRUD representing permissions for C=create, R=read, U=update, D=delete.'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'true', 'attr_type': u'string'}, u'role_name': {'restrictions': None, 'description': [u'Name of the role'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'true', 'attr_type': u'string'}}
    def __init__(self, role_name=None, role_crud=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _role_name = params_dict[u"role_name"]
        except KeyError:
            _role_name = role_name
        self.role_name = _role_name
        try:
            _role_crud = params_dict[u"role_crud"]
        except KeyError:
            _role_crud = role_crud
        self.role_crud = _role_crud
    def factory(*args_, **kwargs_):
        if RbacPermType.subclass:
            return RbacPermType.subclass(*args_, **kwargs_)
        else:
            return RbacPermType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_role_name(self): return self.role_name
    def set_role_name(self, role_name): self.role_name = role_name
    def get_role_crud(self): return self.role_crud
    def set_role_crud(self, role_crud): self.role_crud = role_crud
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.role_name == other.role_name and
                    self.role_crud == other.role_crud)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.role_name if self.role_name is not None else -7985492147856592190,
                     self.role_crud if self.role_crud is not None else -7985492147856592190))

    def __repr__(self):
        return ("role_name = " + str(self.role_name) + ", " +
                "role_crud = " + str(self.role_crud))

    def copy(self):
        cp = RbacPermType()
        if self.role_name is not None:
            cp.role_name = self.role_name
        if self.role_crud is not None:
            cp.role_crud = self.role_crud
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_role_name (obj.populate_string ("role_name"))
        obj.set_role_crud (obj.populate_string ("role_crud"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='RbacPermType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RbacPermType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RbacPermType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RbacPermType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.role_name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srole-name>%s</%srole-name>%s' % (namespace_, self.gds_format_string(quote_xml(self.role_name).encode(ExternalEncoding), input_name='role-name'), namespace_, eol_))
        if self.role_crud is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srole-crud>%s</%srole-crud>%s' % (namespace_, self.gds_format_string(quote_xml(self.role_crud).encode(ExternalEncoding), input_name='role-crud'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.role_name is not None or
            self.role_crud is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RbacPermType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.role_name is not None:
            showIndent(outfile, level)
            outfile.write('role_name=%s,\n' % quote_python(self.role_name).encode(ExternalEncoding))
        if self.role_crud is not None:
            showIndent(outfile, level)
            outfile.write('role_crud=%s,\n' % quote_python(self.role_crud).encode(ExternalEncoding))
    def exportDict(self, name_='RbacPermType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'role-name':
            role_name_ = child_.text
            role_name_ = self.gds_validate_string(role_name_, node, 'role_name')
            self.role_name = role_name_
        elif nodeName_ == 'role-crud':
            role_crud_ = child_.text
            role_crud_ = self.gds_validate_string(role_crud_, node, 'role_crud')
            self.role_crud = role_crud_
# end class RbacPermType


class RbacRuleType(GeneratedsSuper):
    """
    Attributes:
    * rule_object
        Type:           str

        Created By:           User (required)

        Description:
          Name of the REST API (object) for this rule, * represent all objects

    * rule_field
        Type:           str

        Created By:           User (optional)

        Description:
          Name of the level one field (property) for this object, * represent all

          properties

    * rule_perms
        Type:           :class:`.RbacPermType`

        Created By:           User (required)

        Description:
          List of [(role, permissions),...]

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'rule_object', u'rule_field', u'rule_perms']
    attr_field_type_vals = {u'rule_object': {'restrictions': None, 'description': [u'Name of the REST API (object) for this rule, * represent all objects'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'true', 'attr_type': u'string'}, u'rule_perms': {'restrictions': None, 'description': [u'List of [(role, permissions),...]'], 'simple_type': u'RbacPermType', 'is_complex': 1, 'restriction_type': None, 'is_array': True, 'required': u'true', 'attr_type': u'RbacPermType'}, u'rule_field': {'restrictions': None, 'description': [u'Name of the level one field (property) for this object, * represent all properties'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'string'}}
    def __init__(self, rule_object=None, rule_field=None, rule_perms=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _rule_object = params_dict[u"rule_object"]
        except KeyError:
            _rule_object = rule_object
        self.rule_object = _rule_object
        try:
            _rule_field = params_dict[u"rule_field"]
        except KeyError:
            _rule_field = rule_field
        self.rule_field = _rule_field
        try:
            _rule_perms = params_dict[u"rule_perms"]
        except KeyError:
            _rule_perms = rule_perms
        if not _rule_perms:
            self.rule_perms = []
        else:
            if isinstance(_rule_perms[0], dict):
                objs = [RbacPermType(params_dict=elem) for elem in _rule_perms]
                self.rule_perms = objs
            else:
                self.rule_perms = _rule_perms
    def factory(*args_, **kwargs_):
        if RbacRuleType.subclass:
            return RbacRuleType.subclass(*args_, **kwargs_)
        else:
            return RbacRuleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rule_object(self): return self.rule_object
    def set_rule_object(self, rule_object): self.rule_object = rule_object
    def get_rule_field(self): return self.rule_field
    def set_rule_field(self, rule_field): self.rule_field = rule_field
    def get_rule_perms(self): return self.rule_perms
    def set_rule_perms(self, rule_perms): self.rule_perms = rule_perms
    def add_rule_perms(self, value): self.rule_perms.append(value)
    def insert_rule_perms(self, index, value): self.rule_perms[index] = value
    def delete_rule_perms(self, value): self.rule_perms.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.rule_object == other.rule_object and
                    self.rule_field == other.rule_field and
                    self.rule_perms == other.rule_perms)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.rule_object if self.rule_object is not None else -7985492147856592190,
                     self.rule_field if self.rule_field is not None else -7985492147856592190,
                     tuple(self.rule_perms or [])))

    def __repr__(self):
        return ("rule_object = " + str(self.rule_object) + ", " +
                "rule_field = " + str(self.rule_field) + ", " +
                "rule_perms = " + str(self.rule_perms))

    def copy(self):
        cp = RbacRuleType()
        if self.rule_object is not None:
            cp.rule_object = self.rule_object
        if self.rule_field is not None:
            cp.rule_field = self.rule_field
        if self.rule_perms is not None:
            cp.rule_perms = [x.copy() for x in self.rule_perms]
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_rule_object (obj.populate_string ("rule_object"))
        obj.set_rule_field (obj.populate_string ("rule_field"))
        obj.set_rule_perms ([RbacPermType.populate ()])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='RbacRuleType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RbacRuleType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RbacRuleType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RbacRuleType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.rule_object is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srule-object>%s</%srule-object>%s' % (namespace_, self.gds_format_string(quote_xml(self.rule_object).encode(ExternalEncoding), input_name='rule-object'), namespace_, eol_))
        if self.rule_field is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srule-field>%s</%srule-field>%s' % (namespace_, self.gds_format_string(quote_xml(self.rule_field).encode(ExternalEncoding), input_name='rule-field'), namespace_, eol_))
        for rule_perms_ in self.rule_perms:
            if isinstance(rule_perms_, dict):
                rule_perms_ = RbacPermType(**rule_perms_)
            rule_perms_.export_xml(outfile, level, namespace_, name_='rule-perms', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.rule_object is not None or
            self.rule_field is not None or
            self.rule_perms
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RbacRuleType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.rule_object is not None:
            showIndent(outfile, level)
            outfile.write('rule_object=%s,\n' % quote_python(self.rule_object).encode(ExternalEncoding))
        if self.rule_field is not None:
            showIndent(outfile, level)
            outfile.write('rule_field=%s,\n' % quote_python(self.rule_field).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('rule_perms=[\n')
        level += 1
        for rule_perms_ in self.rule_perms:
            showIndent(outfile, level)
            outfile.write('model_.RbacPermType(\n')
            rule_perms_.exportLiteral(outfile, level, name_='RbacPermType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='RbacRuleType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'rule-object':
            rule_object_ = child_.text
            rule_object_ = self.gds_validate_string(rule_object_, node, 'rule_object')
            self.rule_object = rule_object_
        elif nodeName_ == 'rule-field':
            rule_field_ = child_.text
            rule_field_ = self.gds_validate_string(rule_field_, node, 'rule_field')
            self.rule_field = rule_field_
        elif nodeName_ == 'rule-perms':
            obj_ = RbacPermType.factory()
            obj_.build(child_)
            self.rule_perms.append(obj_)
# end class RbacRuleType


class RbacRuleEntriesType(GeneratedsSuper):
    """
    Attributes:
    * rbac_rule
        Type:           :class:`.RbacRuleType`

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'rbac_rule']
    attr_field_type_vals = {u'rbac_rule': {'restrictions': None, 'description': [], 'simple_type': u'RbacRuleType', 'is_complex': 1, 'restriction_type': None, 'is_array': True, 'required': None, 'attr_type': u'RbacRuleType'}}
    def __init__(self, rbac_rule=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _rbac_rule = params_dict[u"rbac_rule"]
        except KeyError:
            _rbac_rule = rbac_rule
        if not _rbac_rule:
            self.rbac_rule = []
        else:
            if isinstance(_rbac_rule[0], dict):
                objs = [RbacRuleType(params_dict=elem) for elem in _rbac_rule]
                self.rbac_rule = objs
            else:
                self.rbac_rule = _rbac_rule
    def factory(*args_, **kwargs_):
        if RbacRuleEntriesType.subclass:
            return RbacRuleEntriesType.subclass(*args_, **kwargs_)
        else:
            return RbacRuleEntriesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rbac_rule(self): return self.rbac_rule
    def set_rbac_rule(self, rbac_rule): self.rbac_rule = rbac_rule
    def add_rbac_rule(self, value): self.rbac_rule.append(value)
    def insert_rbac_rule(self, index, value): self.rbac_rule[index] = value
    def delete_rbac_rule(self, value): self.rbac_rule.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.rbac_rule == other.rbac_rule)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.rbac_rule or [])))

    def __repr__(self):
        return ("rbac_rule = " + str(self.rbac_rule))

    def copy(self):
        cp = RbacRuleEntriesType()
        if self.rbac_rule is not None:
            cp.rbac_rule = [x.copy() for x in self.rbac_rule]
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_rbac_rule ([RbacRuleType.populate ()])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='RbacRuleEntriesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RbacRuleEntriesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RbacRuleEntriesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RbacRuleEntriesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for rbac_rule_ in self.rbac_rule:
            if isinstance(rbac_rule_, dict):
                rbac_rule_ = RbacRuleType(**rbac_rule_)
            rbac_rule_.export_xml(outfile, level, namespace_, name_='rbac-rule', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.rbac_rule
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RbacRuleEntriesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('rbac_rule=[\n')
        level += 1
        for rbac_rule_ in self.rbac_rule:
            showIndent(outfile, level)
            outfile.write('model_.RbacRuleType(\n')
            rbac_rule_.exportLiteral(outfile, level, name_='RbacRuleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='RbacRuleEntriesType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'rbac-rule':
            obj_ = RbacRuleType.factory()
            obj_.build(child_)
            self.rbac_rule.append(obj_)
# end class RbacRuleEntriesType


class DomainLimitsType(GeneratedsSuper):
    """
    Attributes:
    * project_limit
        Type:           int

        Created By:           User (optional)

        Description:
          Maximum number of projects allowed in this domain

    * virtual_network_limit
        Type:           int

        Created By:           User (optional)

        Description:
          Maximum number of virtual networks allowed in this domain

    * security_group_limit
        Type:           int

        Created By:           User (optional)

        Description:
          Maximum number of security groups allowed in this domain

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'project_limit', u'virtual_network_limit', u'security_group_limit']
    attr_field_type_vals = {u'project_limit': {'restrictions': None, 'description': [u'Maximum number of projects allowed in this domain'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'virtual_network_limit': {'restrictions': None, 'description': [u'Maximum number of virtual networks allowed in this domain'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'security_group_limit': {'restrictions': None, 'description': [u'Maximum number of security groups allowed in this domain'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}}
    def __init__(self, project_limit=None, virtual_network_limit=None, security_group_limit=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _project_limit = params_dict[u"project_limit"]
        except KeyError:
            _project_limit = project_limit
        self.project_limit = _project_limit
        try:
            _virtual_network_limit = params_dict[u"virtual_network_limit"]
        except KeyError:
            _virtual_network_limit = virtual_network_limit
        self.virtual_network_limit = _virtual_network_limit
        try:
            _security_group_limit = params_dict[u"security_group_limit"]
        except KeyError:
            _security_group_limit = security_group_limit
        self.security_group_limit = _security_group_limit
    def factory(*args_, **kwargs_):
        if DomainLimitsType.subclass:
            return DomainLimitsType.subclass(*args_, **kwargs_)
        else:
            return DomainLimitsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_project_limit(self): return self.project_limit
    def set_project_limit(self, project_limit): self.project_limit = project_limit
    def get_virtual_network_limit(self): return self.virtual_network_limit
    def set_virtual_network_limit(self, virtual_network_limit): self.virtual_network_limit = virtual_network_limit
    def get_security_group_limit(self): return self.security_group_limit
    def set_security_group_limit(self, security_group_limit): self.security_group_limit = security_group_limit
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.project_limit == other.project_limit and
                    self.virtual_network_limit == other.virtual_network_limit and
                    self.security_group_limit == other.security_group_limit)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.project_limit if self.project_limit is not None else -7985492147856592190,
                     self.virtual_network_limit if self.virtual_network_limit is not None else -7985492147856592190,
                     self.security_group_limit if self.security_group_limit is not None else -7985492147856592190))

    def __repr__(self):
        return ("project_limit = " + str(self.project_limit) + ", " +
                "virtual_network_limit = " + str(self.virtual_network_limit) + ", " +
                "security_group_limit = " + str(self.security_group_limit))

    def copy(self):
        cp = DomainLimitsType()
        if self.project_limit is not None:
            cp.project_limit = self.project_limit
        if self.virtual_network_limit is not None:
            cp.virtual_network_limit = self.virtual_network_limit
        if self.security_group_limit is not None:
            cp.security_group_limit = self.security_group_limit
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_project_limit (obj.populate_integer ("project_limit"))
        obj.set_virtual_network_limit (obj.populate_integer ("virtual_network_limit"))
        obj.set_security_group_limit (obj.populate_integer ("security_group_limit"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='DomainLimitsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DomainLimitsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DomainLimitsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DomainLimitsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.project_limit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sproject-limit>%s</%sproject-limit>%s' % (namespace_, self.gds_format_integer(self.project_limit, input_name='project-limit'), namespace_, eol_))
        if self.virtual_network_limit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svirtual-network-limit>%s</%svirtual-network-limit>%s' % (namespace_, self.gds_format_integer(self.virtual_network_limit, input_name='virtual-network-limit'), namespace_, eol_))
        if self.security_group_limit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssecurity-group-limit>%s</%ssecurity-group-limit>%s' % (namespace_, self.gds_format_integer(self.security_group_limit, input_name='security-group-limit'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.project_limit is not None or
            self.virtual_network_limit is not None or
            self.security_group_limit is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DomainLimitsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.project_limit is not None:
            showIndent(outfile, level)
            outfile.write('project_limit=%d,\n' % self.project_limit)
        if self.virtual_network_limit is not None:
            showIndent(outfile, level)
            outfile.write('virtual_network_limit=%d,\n' % self.virtual_network_limit)
        if self.security_group_limit is not None:
            showIndent(outfile, level)
            outfile.write('security_group_limit=%d,\n' % self.security_group_limit)
    def exportDict(self, name_='DomainLimitsType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'project-limit':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'project_limit')
            self.project_limit = ival_
        elif nodeName_ == 'virtual-network-limit':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'virtual_network_limit')
            self.virtual_network_limit = ival_
        elif nodeName_ == 'security-group-limit':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'security_group_limit')
            self.security_group_limit = ival_
# end class DomainLimitsType


class PermType(GeneratedsSuper):
    """
    Attributes:
    * owner
        Type:           str

    * owner_access
        Type:           int, *within* [0, 7]

        Description:
          Three bits representing rwx.

             r=read permission,

             w=write permission,

             x=reference permission

    * group
        Type:           str

    * group_access
        Type:           int, *within* [0, 7]

        Description:
          Three bits representing rwx.

             r=read permission,

             w=write permission,

             x=reference permission

    * other_access
        Type:           int, *within* [0, 7]

        Description:
          Three bits representing rwx.

             r=read permission,

             w=write permission,

             x=reference permission

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'owner', u'owner_access', u'group', u'group_access', u'other_access']
    attr_field_type_vals = {u'owner': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'owner_access': {'restrictions': [0, 7], 'description': [], 'simple_type': u'AccessType', 'is_complex': 0, 'restriction_type': 'range', 'is_array': False, 'required': None, 'attr_type': u'integer'}, u'other_access': {'restrictions': [0, 7], 'description': [], 'simple_type': u'AccessType', 'is_complex': 0, 'restriction_type': 'range', 'is_array': False, 'required': None, 'attr_type': u'integer'}, u'group': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'group_access': {'restrictions': [0, 7], 'description': [], 'simple_type': u'AccessType', 'is_complex': 0, 'restriction_type': 'range', 'is_array': False, 'required': None, 'attr_type': u'integer'}}
    def __init__(self, owner=None, owner_access=None, group=None, group_access=None, other_access=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _owner = params_dict[u"owner"]
        except KeyError:
            _owner = owner
        self.owner = _owner
        try:
            _owner_access = params_dict[u"owner_access"]
        except KeyError:
            _owner_access = owner_access
        self.owner_access = _owner_access
        try:
            _group = params_dict[u"group"]
        except KeyError:
            _group = group
        self.group = _group
        try:
            _group_access = params_dict[u"group_access"]
        except KeyError:
            _group_access = group_access
        self.group_access = _group_access
        try:
            _other_access = params_dict[u"other_access"]
        except KeyError:
            _other_access = other_access
        self.other_access = _other_access
    def factory(*args_, **kwargs_):
        if PermType.subclass:
            return PermType.subclass(*args_, **kwargs_)
        else:
            return PermType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_owner(self): return self.owner
    def set_owner(self, owner): self.owner = owner
    def get_owner_access(self): return self.owner_access
    def set_owner_access(self, owner_access): self.owner_access = owner_access
    def validate_AccessType(self, value):
        # Validate type AccessType, a restriction on xsd:integer.
        error = False
        if isinstance(value, list):
            v_int = list(map(int, value))
            v1, v2 = min(v_int), max(v_int)
        else:
            v1, v2 = int(value), int(value)
        error |= (v2 > 7)
        if error:
            raise ValueError("AccessType must be in the range {'minimum': 0}-{'maximum': 7}")
    def get_group(self): return self.group
    def set_group(self, group): self.group = group
    def get_group_access(self): return self.group_access
    def set_group_access(self, group_access): self.group_access = group_access
    def get_other_access(self): return self.other_access
    def set_other_access(self, other_access): self.other_access = other_access
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.owner == other.owner and
                    self.owner_access == other.owner_access and
                    self.group == other.group and
                    self.group_access == other.group_access and
                    self.other_access == other.other_access)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.owner if self.owner is not None else -7985492147856592190,
                     self.owner_access if self.owner_access is not None else -7985492147856592190,
                     self.group if self.group is not None else -7985492147856592190,
                     self.group_access if self.group_access is not None else -7985492147856592190,
                     self.other_access if self.other_access is not None else -7985492147856592190))

    def __repr__(self):
        return ("owner = " + str(self.owner) + ", " +
                "owner_access = " + str(self.owner_access) + ", " +
                "group = " + str(self.group) + ", " +
                "group_access = " + str(self.group_access) + ", " +
                "other_access = " + str(self.other_access))

    def copy(self):
        cp = PermType()
        if self.owner is not None:
            cp.owner = self.owner
        if self.owner_access is not None:
            cp.owner_access = self.owner_access
        if self.group is not None:
            cp.group = self.group
        if self.group_access is not None:
            cp.group_access = self.group_access
        if self.other_access is not None:
            cp.other_access = self.other_access
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_owner (obj.populate_string ("owner"))
        obj.set_owner_access (obj.populate_integer ("owner_access"))
        obj.set_group (obj.populate_string ("group"))
        obj.set_group_access (obj.populate_integer ("group_access"))
        obj.set_other_access (obj.populate_integer ("other_access"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='PermType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PermType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PermType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PermType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.owner is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sowner>%s</%sowner>%s' % (namespace_, self.gds_format_string(quote_xml(self.owner).encode(ExternalEncoding), input_name='owner'), namespace_, eol_))
        if self.owner_access is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sowner-access>%s</%sowner-access>%s' % (namespace_, self.gds_format_integer(self.owner_access, input_name='owner-access'), namespace_, eol_))
        if self.group is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgroup>%s</%sgroup>%s' % (namespace_, self.gds_format_string(quote_xml(self.group).encode(ExternalEncoding), input_name='group'), namespace_, eol_))
        if self.group_access is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgroup-access>%s</%sgroup-access>%s' % (namespace_, self.gds_format_integer(self.group_access, input_name='group-access'), namespace_, eol_))
        if self.other_access is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sother-access>%s</%sother-access>%s' % (namespace_, self.gds_format_integer(self.other_access, input_name='other-access'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.owner is not None or
            self.owner_access is not None or
            self.group is not None or
            self.group_access is not None or
            self.other_access is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PermType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.owner is not None:
            showIndent(outfile, level)
            outfile.write('owner=%s,\n' % quote_python(self.owner).encode(ExternalEncoding))
        if self.owner_access is not None:
            showIndent(outfile, level)
            outfile.write('owner_access=%d,\n' % self.owner_access)
        if self.group is not None:
            showIndent(outfile, level)
            outfile.write('group=%s,\n' % quote_python(self.group).encode(ExternalEncoding))
        if self.group_access is not None:
            showIndent(outfile, level)
            outfile.write('group_access=%d,\n' % self.group_access)
        if self.other_access is not None:
            showIndent(outfile, level)
            outfile.write('other_access=%d,\n' % self.other_access)
    def exportDict(self, name_='PermType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'owner':
            owner_ = child_.text
            owner_ = self.gds_validate_string(owner_, node, 'owner')
            self.owner = owner_
        elif nodeName_ == 'owner-access':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'owner_access')
            self.owner_access = ival_
            self.validate_AccessType(self.owner_access)    # validate type AccessType
        elif nodeName_ == 'group':
            group_ = child_.text
            group_ = self.gds_validate_string(group_, node, 'group')
            self.group = group_
        elif nodeName_ == 'group-access':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'group_access')
            self.group_access = ival_
            self.validate_AccessType(self.group_access)    # validate type AccessType
        elif nodeName_ == 'other-access':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'other_access')
            self.other_access = ival_
            self.validate_AccessType(self.other_access)    # validate type AccessType
# end class PermType


class ShareType(GeneratedsSuper):
    """
    Attributes:
    * tenant
        Type:           str

        Created By:           User (required)

        Description:
          Name of tenant with whom the object is shared

    * tenant_access
        Type:           int, *within* [0, 7]

        Created By:           User (required)

        Description:
          Allowed permissions in sharing

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'tenant', u'tenant_access']
    attr_field_type_vals = {u'tenant_access': {'restrictions': [0, 7], 'description': [u'Allowed permissions in sharing'], 'simple_type': u'AccessType', 'is_complex': 0, 'restriction_type': 'range', 'is_array': False, 'required': u'true', 'attr_type': u'integer'}, u'tenant': {'restrictions': None, 'description': [u'Name of tenant with whom the object is shared'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'true', 'attr_type': u'string'}}
    def __init__(self, tenant=None, tenant_access=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _tenant = params_dict[u"tenant"]
        except KeyError:
            _tenant = tenant
        self.tenant = _tenant
        try:
            _tenant_access = params_dict[u"tenant_access"]
        except KeyError:
            _tenant_access = tenant_access
        self.tenant_access = _tenant_access
    def factory(*args_, **kwargs_):
        if ShareType.subclass:
            return ShareType.subclass(*args_, **kwargs_)
        else:
            return ShareType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tenant(self): return self.tenant
    def set_tenant(self, tenant): self.tenant = tenant
    def get_tenant_access(self): return self.tenant_access
    def set_tenant_access(self, tenant_access): self.tenant_access = tenant_access
    def validate_AccessType(self, value):
        # Validate type AccessType, a restriction on xsd:integer.
        error = False
        if isinstance(value, list):
            v_int = list(map(int, value))
            v1, v2 = min(v_int), max(v_int)
        else:
            v1, v2 = int(value), int(value)
        error |= (v2 > 7)
        if error:
            raise ValueError("AccessType must be in the range {'minimum': 0}-{'maximum': 7}")
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.tenant == other.tenant and
                    self.tenant_access == other.tenant_access)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.tenant if self.tenant is not None else -7985492147856592190,
                     self.tenant_access if self.tenant_access is not None else -7985492147856592190))

    def __repr__(self):
        return ("tenant = " + str(self.tenant) + ", " +
                "tenant_access = " + str(self.tenant_access))

    def copy(self):
        cp = ShareType()
        if self.tenant is not None:
            cp.tenant = self.tenant
        if self.tenant_access is not None:
            cp.tenant_access = self.tenant_access
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_tenant (obj.populate_string ("tenant"))
        obj.set_tenant_access (obj.populate_integer ("tenant_access"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='ShareType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ShareType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ShareType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ShareType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tenant is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stenant>%s</%stenant>%s' % (namespace_, self.gds_format_string(quote_xml(self.tenant).encode(ExternalEncoding), input_name='tenant'), namespace_, eol_))
        if self.tenant_access is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stenant-access>%s</%stenant-access>%s' % (namespace_, self.gds_format_integer(self.tenant_access, input_name='tenant-access'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.tenant is not None or
            self.tenant_access is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ShareType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.tenant is not None:
            showIndent(outfile, level)
            outfile.write('tenant=%s,\n' % quote_python(self.tenant).encode(ExternalEncoding))
        if self.tenant_access is not None:
            showIndent(outfile, level)
            outfile.write('tenant_access=%d,\n' % self.tenant_access)
    def exportDict(self, name_='ShareType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tenant':
            tenant_ = child_.text
            tenant_ = self.gds_validate_string(tenant_, node, 'tenant')
            self.tenant = tenant_
        elif nodeName_ == 'tenant-access':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'tenant_access')
            self.tenant_access = ival_
            self.validate_AccessType(self.tenant_access)    # validate type AccessType
# end class ShareType


class PermType2(GeneratedsSuper):
    """
    Attributes:
    * owner
        Type:           str

        Created By:           User (required)

        Description:
          Owner tenant of the object

    * owner_access
        Type:           int, *within* [0, 7]

        Created By:           User (required)

        Description:
          Owner permissions of the object

    * global_access
        Type:           int, *within* [0, 7]

        Created By:           User (optional)

        Description:
          Globally(others) shared object and permissions for others of the object

    * share
        Type:           :class:`.ShareType`

        Created By:           User (optional)

        Description:
          Selectively shared object, List of (tenant, permissions)

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'owner', u'owner_access', u'global_access', u'share']
    attr_field_type_vals = {u'owner': {'restrictions': None, 'description': [u'Owner tenant of the object'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'true', 'attr_type': u'string'}, u'owner_access': {'restrictions': [0, 7], 'description': [u'Owner permissions of the object'], 'simple_type': u'AccessType', 'is_complex': 0, 'restriction_type': 'range', 'is_array': False, 'required': u'true', 'attr_type': u'integer'}, u'global_access': {'restrictions': [0, 7], 'description': [u'Globally(others) shared object and permissions for others of the object'], 'simple_type': u'AccessType', 'is_complex': 0, 'restriction_type': 'range', 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'share': {'restrictions': None, 'description': [u'Selectively shared object, List of (tenant, permissions)'], 'simple_type': u'ShareType', 'is_complex': 1, 'restriction_type': None, 'is_array': True, 'required': u'optional', 'attr_type': u'ShareType'}}
    def __init__(self, owner=None, owner_access=7, global_access=0, share=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _owner = params_dict[u"owner"]
        except KeyError:
            _owner = owner
        self.owner = _owner
        try:
            _owner_access = params_dict[u"owner_access"]
        except KeyError:
            _owner_access = owner_access
        self.owner_access = _owner_access
        try:
            _global_access = params_dict[u"global_access"]
        except KeyError:
            _global_access = global_access
        self.global_access = _global_access
        try:
            _share = params_dict[u"share"]
        except KeyError:
            _share = share
        if not _share:
            self.share = []
        else:
            if isinstance(_share[0], dict):
                objs = [ShareType(params_dict=elem) for elem in _share]
                self.share = objs
            else:
                self.share = _share
    def factory(*args_, **kwargs_):
        if PermType2.subclass:
            return PermType2.subclass(*args_, **kwargs_)
        else:
            return PermType2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_owner(self): return self.owner
    def set_owner(self, owner): self.owner = owner
    def get_owner_access(self): return self.owner_access
    def set_owner_access(self, owner_access): self.owner_access = owner_access
    def validate_AccessType(self, value):
        # Validate type AccessType, a restriction on xsd:integer.
        error = False
        if isinstance(value, list):
            v_int = list(map(int, value))
            v1, v2 = min(v_int), max(v_int)
        else:
            v1, v2 = int(value), int(value)
        error |= (v2 > 7)
        if error:
            raise ValueError("AccessType must be in the range {'minimum': 0}-{'maximum': 7}")
    def get_global_access(self): return self.global_access
    def set_global_access(self, global_access): self.global_access = global_access
    def get_share(self): return self.share
    def set_share(self, share): self.share = share
    def add_share(self, value): self.share.append(value)
    def insert_share(self, index, value): self.share[index] = value
    def delete_share(self, value): self.share.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.owner == other.owner and
                    self.owner_access == other.owner_access and
                    self.global_access == other.global_access and
                    self.share == other.share)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.owner if self.owner is not None else -7985492147856592190,
                     self.owner_access if self.owner_access is not None else -7985492147856592190,
                     self.global_access if self.global_access is not None else -7985492147856592190,
                     tuple(self.share or [])))

    def __repr__(self):
        return ("owner = " + str(self.owner) + ", " +
                "owner_access = " + str(self.owner_access) + ", " +
                "global_access = " + str(self.global_access) + ", " +
                "share = " + str(self.share))

    def copy(self):
        cp = PermType2()
        if self.owner is not None:
            cp.owner = self.owner
        if self.owner_access is not None:
            cp.owner_access = self.owner_access
        if self.global_access is not None:
            cp.global_access = self.global_access
        if self.share is not None:
            cp.share = [x.copy() for x in self.share]
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_owner (obj.populate_string ("owner"))
        obj.set_owner_access (obj.populate_integer ("owner_access"))
        obj.set_global_access (obj.populate_integer ("global_access"))
        obj.set_share ([ShareType.populate ()])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='PermType2', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PermType2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PermType2'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PermType2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.owner is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sowner>%s</%sowner>%s' % (namespace_, self.gds_format_string(quote_xml(self.owner).encode(ExternalEncoding), input_name='owner'), namespace_, eol_))
        if self.owner_access is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sowner-access>%s</%sowner-access>%s' % (namespace_, self.gds_format_integer(self.owner_access, input_name='owner-access'), namespace_, eol_))
        if self.global_access is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sglobal-access>%s</%sglobal-access>%s' % (namespace_, self.gds_format_integer(self.global_access, input_name='global-access'), namespace_, eol_))
        for share_ in self.share:
            if isinstance(share_, dict):
                share_ = ShareType(**share_)
            share_.export_xml(outfile, level, namespace_, name_='share', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.owner is not None or
            self.owner_access is not None or
            self.global_access is not None or
            self.share
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PermType2'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.owner is not None:
            showIndent(outfile, level)
            outfile.write('owner=%s,\n' % quote_python(self.owner).encode(ExternalEncoding))
        if self.owner_access is not None:
            showIndent(outfile, level)
            outfile.write('owner_access=%d,\n' % self.owner_access)
        if self.global_access is not None:
            showIndent(outfile, level)
            outfile.write('global_access=%d,\n' % self.global_access)
        showIndent(outfile, level)
        outfile.write('share=[\n')
        level += 1
        for share_ in self.share:
            showIndent(outfile, level)
            outfile.write('model_.ShareType(\n')
            share_.exportLiteral(outfile, level, name_='ShareType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='PermType2'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'owner':
            owner_ = child_.text
            owner_ = self.gds_validate_string(owner_, node, 'owner')
            self.owner = owner_
        elif nodeName_ == 'owner-access':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'owner_access')
            self.owner_access = ival_
            self.validate_AccessType(self.owner_access)    # validate type AccessType
        elif nodeName_ == 'global-access':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'global_access')
            self.global_access = ival_
            self.validate_AccessType(self.global_access)    # validate type AccessType
        elif nodeName_ == 'share':
            obj_ = ShareType.factory()
            obj_.build(child_)
            self.share.append(obj_)
# end class PermType2


class IdPermsType(GeneratedsSuper):
    """
    Attributes:
    * permissions
        Type:           :class:`.PermType`

        Created By:           User (optional)

        Description:
          No longer used, will be removed

    * uuid
        Type:           :class:`.UuidType`

        Created By:           User (required)

        Description:
          UUID of the object, system automatically allocates one if not provided

    * enable
        Type:           bool

        Created By:           User (required)

        Description:
          Administratively Enable/Disable this object

    * created
        Type:           :class:`.xsd:dateTime`

        Description:
          Time when this object was created

    * last_modified
        Type:           :class:`.xsd:dateTime`

        Description:
          Time when this object was created

    * description
        Type:           str

        Created By:           User (optional)

        Description:
          User provided text

    * user_visible
        Type:           bool

        Description:
          System created internal objects will have this flag set and will not be visible

    * creator
        Type:           str

        Description:
          Id of tenant who created this object

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'permissions', u'uuid', u'enable', u'created', u'last_modified', u'description', u'user_visible', u'creator']
    attr_field_type_vals = {u'enable': {'restrictions': None, 'description': [u'Administratively Enable/Disable this object'], 'simple_type': u'xsd:boolean', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'true', 'attr_type': u'boolean'}, u'description': {'restrictions': None, 'description': [u'User provided text'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'created': {'restrictions': None, 'description': [u'Time when this object was created'], 'simple_type': u'xsd:dateTime', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'system-only', 'attr_type': u'dateTime'}, u'creator': {'restrictions': None, 'description': [u'Id of tenant who created this object'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'system-only', 'attr_type': u'string'}, u'user_visible': {'restrictions': None, 'description': [u'System created internal objects will have this flag set and will not be visible'], 'simple_type': u'xsd:boolean', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'system-only', 'attr_type': u'boolean'}, u'last_modified': {'restrictions': None, 'description': [u'Time when this object was created'], 'simple_type': u'xsd:dateTime', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'system-only', 'attr_type': u'dateTime'}, u'permissions': {'restrictions': None, 'description': [u'No longer used, will be removed'], 'simple_type': u'PermType', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'PermType'}, u'uuid': {'restrictions': None, 'description': [u'UUID of the object, system automatically allocates one if not provided'], 'simple_type': u'UuidType', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': u'true', 'attr_type': u'UuidType'}}
    def __init__(self, permissions=None, uuid=None, enable=None, created=None, last_modified=None, description=None, user_visible=True, creator=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _permissions = params_dict[u"permissions"]
        except KeyError:
            _permissions = permissions
        if isinstance(_permissions, dict):
            obj = PermType(params_dict=_permissions)
            self.permissions = obj
        else:
            self.permissions = _permissions
        try:
            _uuid = params_dict[u"uuid"]
        except KeyError:
            _uuid = uuid
        if isinstance(_uuid, dict):
            obj = UuidType(params_dict=_uuid)
            self.uuid = obj
        else:
            self.uuid = _uuid
        try:
            _enable = params_dict[u"enable"]
        except KeyError:
            _enable = enable
        self.enable = _enable
        try:
            _created = params_dict[u"created"]
        except KeyError:
            _created = created
        self.created = _created
        try:
            _last_modified = params_dict[u"last_modified"]
        except KeyError:
            _last_modified = last_modified
        self.last_modified = _last_modified
        try:
            _description = params_dict[u"description"]
        except KeyError:
            _description = description
        self.description = _description
        try:
            _user_visible = params_dict[u"user_visible"]
        except KeyError:
            _user_visible = user_visible
        self.user_visible = _user_visible
        try:
            _creator = params_dict[u"creator"]
        except KeyError:
            _creator = creator
        self.creator = _creator
    def factory(*args_, **kwargs_):
        if IdPermsType.subclass:
            return IdPermsType.subclass(*args_, **kwargs_)
        else:
            return IdPermsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_permissions(self): return self.permissions
    def set_permissions(self, permissions): self.permissions = permissions
    def get_uuid(self): return self.uuid
    def set_uuid(self, uuid): self.uuid = uuid
    def get_enable(self): return self.enable
    def set_enable(self, enable): self.enable = enable
    def get_created(self): return self.created
    def set_created(self, created): self.created = created
    def get_last_modified(self): return self.last_modified
    def set_last_modified(self, last_modified): self.last_modified = last_modified
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_user_visible(self): return self.user_visible
    def set_user_visible(self, user_visible): self.user_visible = user_visible
    def get_creator(self): return self.creator
    def set_creator(self, creator): self.creator = creator
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.permissions == other.permissions and
                    self.uuid == other.uuid and
                    self.enable == other.enable and
                    self.created == other.created and
                    self.last_modified == other.last_modified and
                    self.description == other.description and
                    self.user_visible == other.user_visible and
                    self.creator == other.creator)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.permissions if self.permissions is not None else -7985492147856592190,
                     self.uuid if self.uuid is not None else -7985492147856592190,
                     self.enable if self.enable is not None else -7985492147856592190,
                     self.created if self.created is not None else -7985492147856592190,
                     self.last_modified if self.last_modified is not None else -7985492147856592190,
                     self.description if self.description is not None else -7985492147856592190,
                     self.user_visible if self.user_visible is not None else -7985492147856592190,
                     self.creator if self.creator is not None else -7985492147856592190))

    def __repr__(self):
        return ("permissions = " + str(self.permissions) + ", " +
                "uuid = " + str(self.uuid) + ", " +
                "enable = " + str(self.enable) + ", " +
                "created = " + str(self.created) + ", " +
                "last_modified = " + str(self.last_modified) + ", " +
                "description = " + str(self.description) + ", " +
                "user_visible = " + str(self.user_visible) + ", " +
                "creator = " + str(self.creator))

    def copy(self):
        cp = IdPermsType()
        if self.permissions is not None:
            cp.permissions = self.permissions.copy()
        if self.uuid is not None:
            cp.uuid = self.uuid.copy()
        if self.enable is not None:
            cp.enable = self.enable
        if self.created is not None:
            cp.created = self.created
        if self.last_modified is not None:
            cp.last_modified = self.last_modified
        if self.description is not None:
            cp.description = self.description
        if self.user_visible is not None:
            cp.user_visible = self.user_visible
        if self.creator is not None:
            cp.creator = self.creator
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_permissions (PermType.populate ())
        obj.set_uuid (UuidType.populate ())
        obj.set_enable (obj.populate_boolean ("enable"))
        obj.set_created (obj.populate_dateTime ("created"))
        obj.set_last_modified (obj.populate_dateTime ("last_modified"))
        obj.set_description (obj.populate_string ("description"))
        obj.set_user_visible (obj.populate_boolean ("user_visible"))
        obj.set_creator (obj.populate_string ("creator"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='IdPermsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IdPermsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IdPermsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='IdPermsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.permissions is not None:
            self.permissions.export_xml(outfile, level, namespace_, name_='permissions', pretty_print=pretty_print)
        if self.uuid is not None:
            self.uuid.export_xml(outfile, level, namespace_, name_='uuid', pretty_print=pretty_print)
        if self.enable is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%senable>%s</%senable>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.enable)), input_name='enable'), namespace_, eol_))
        if self.created is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%screated>%s</%screated>%s' % (namespace_, self.gds_format_string(quote_xml(self.created).encode(ExternalEncoding), input_name='created'), namespace_, eol_))
        if self.last_modified is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slast-modified>%s</%slast-modified>%s' % (namespace_, self.gds_format_string(quote_xml(self.last_modified).encode(ExternalEncoding), input_name='last-modified'), namespace_, eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), namespace_, eol_))
        if self.user_visible is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%suser-visible>%s</%suser-visible>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.user_visible)), input_name='user-visible'), namespace_, eol_))
        if self.creator is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%screator>%s</%screator>%s' % (namespace_, self.gds_format_string(quote_xml(self.creator).encode(ExternalEncoding), input_name='creator'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.permissions is not None or
            self.uuid is not None or
            self.enable is not None or
            self.created is not None or
            self.last_modified is not None or
            self.description is not None or
            self.user_visible is not None or
            self.creator is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='IdPermsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.permissions is not None:
            showIndent(outfile, level)
            outfile.write('permissions=model_.PermType(\n')
            self.permissions.exportLiteral(outfile, level, name_='permissions')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.uuid is not None:
            showIndent(outfile, level)
            outfile.write('uuid=model_.UuidType(\n')
            self.uuid.exportLiteral(outfile, level, name_='uuid')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.enable is not None:
            showIndent(outfile, level)
            outfile.write('enable=%s,\n' % self.enable)
        if self.created is not None:
            showIndent(outfile, level)
            outfile.write('created=%s,\n' % quote_python(self.created).encode(ExternalEncoding))
        if self.last_modified is not None:
            showIndent(outfile, level)
            outfile.write('last_modified=%s,\n' % quote_python(self.last_modified).encode(ExternalEncoding))
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=%s,\n' % quote_python(self.description).encode(ExternalEncoding))
        if self.user_visible is not None:
            showIndent(outfile, level)
            outfile.write('user_visible=%s,\n' % self.user_visible)
        if self.creator is not None:
            showIndent(outfile, level)
            outfile.write('creator=%s,\n' % quote_python(self.creator).encode(ExternalEncoding))
    def exportDict(self, name_='IdPermsType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'permissions':
            obj_ = PermType.factory()
            obj_.build(child_)
            self.set_permissions(obj_)
        elif nodeName_ == 'uuid':
            obj_ = UuidType.factory()
            obj_.build(child_)
            self.set_uuid(obj_)
        elif nodeName_ == 'enable':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'enable')
            self.enable = ival_
        elif nodeName_ == 'created':
            created_ = child_.text
            created_ = self.gds_validate_string(created_, node, 'created')
            self.created = created_
        elif nodeName_ == 'last-modified':
            last_modified_ = child_.text
            last_modified_ = self.gds_validate_string(last_modified_, node, 'last_modified')
            self.last_modified = last_modified_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'user-visible':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'user_visible')
            self.user_visible = ival_
        elif nodeName_ == 'creator':
            creator_ = child_.text
            creator_ = self.gds_validate_string(creator_, node, 'creator')
            self.creator = creator_
# end class IdPermsType


class PluginProperty(GeneratedsSuper):
    """
    Attributes:
    * property
        Type:           str

    * value
        Type:           str

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'property', u'value']
    attr_field_type_vals = {u'property': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'value': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}}
    def __init__(self, property=None, value=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _property = params_dict[u"property"]
        except KeyError:
            _property = property
        self.property = _property
        try:
            _value = params_dict[u"value"]
        except KeyError:
            _value = value
        self.value = _value
    def factory(*args_, **kwargs_):
        if PluginProperty.subclass:
            return PluginProperty.subclass(*args_, **kwargs_)
        else:
            return PluginProperty(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_property(self): return self.property
    def set_property(self, property): self.property = property
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.property == other.property and
                    self.value == other.value)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.property if self.property is not None else -7985492147856592190,
                     self.value if self.value is not None else -7985492147856592190))

    def __repr__(self):
        return ("property = " + str(self.property) + ", " +
                "value = " + str(self.value))

    def copy(self):
        cp = PluginProperty()
        if self.property is not None:
            cp.property = self.property
        if self.value is not None:
            cp.value = self.value
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_property (obj.populate_string ("property"))
        obj.set_value (obj.populate_string ("value"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='PluginProperty', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PluginProperty')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PluginProperty'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PluginProperty', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.property is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sproperty>%s</%sproperty>%s' % (namespace_, self.gds_format_string(quote_xml(self.property).encode(ExternalEncoding), input_name='property'), namespace_, eol_))
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(self.value).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.property is not None or
            self.value is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PluginProperty'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.property is not None:
            showIndent(outfile, level)
            outfile.write('property=%s,\n' % quote_python(self.property).encode(ExternalEncoding))
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%s,\n' % quote_python(self.value).encode(ExternalEncoding))
    def exportDict(self, name_='PluginProperty'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'property':
            property_ = child_.text
            property_ = self.gds_validate_string(property_, node, 'property')
            self.property = property_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
# end class PluginProperty


class PluginProperties(GeneratedsSuper):
    """
    Attributes:
    * plugin_property
        Type:           :class:`.PluginProperty`

        Created By:           User (optional)

        Description:
          List of plugin specific properties (property, value)

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'plugin_property']
    attr_field_type_vals = {u'plugin_property': {'restrictions': None, 'description': [u'List of plugin specific properties (property, value)'], 'simple_type': u'PluginProperty', 'is_complex': 1, 'restriction_type': None, 'is_array': True, 'required': u'optional', 'attr_type': u'PluginProperty'}}
    def __init__(self, plugin_property=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _plugin_property = params_dict[u"plugin_property"]
        except KeyError:
            _plugin_property = plugin_property
        if not _plugin_property:
            self.plugin_property = []
        else:
            if isinstance(_plugin_property[0], dict):
                objs = [PluginProperty(params_dict=elem) for elem in _plugin_property]
                self.plugin_property = objs
            else:
                self.plugin_property = _plugin_property
    def factory(*args_, **kwargs_):
        if PluginProperties.subclass:
            return PluginProperties.subclass(*args_, **kwargs_)
        else:
            return PluginProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_plugin_property(self): return self.plugin_property
    def set_plugin_property(self, plugin_property): self.plugin_property = plugin_property
    def add_plugin_property(self, value): self.plugin_property.append(value)
    def insert_plugin_property(self, index, value): self.plugin_property[index] = value
    def delete_plugin_property(self, value): self.plugin_property.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.plugin_property == other.plugin_property)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.plugin_property or [])))

    def __repr__(self):
        return ("plugin_property = " + str(self.plugin_property))

    def copy(self):
        cp = PluginProperties()
        if self.plugin_property is not None:
            cp.plugin_property = [x.copy() for x in self.plugin_property]
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_plugin_property ([PluginProperty.populate ()])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='PluginProperties', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PluginProperties')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PluginProperties'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PluginProperties', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for plugin_property_ in self.plugin_property:
            if isinstance(plugin_property_, dict):
                plugin_property_ = PluginProperty(**plugin_property_)
            plugin_property_.export_xml(outfile, level, namespace_, name_='plugin-property', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.plugin_property
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PluginProperties'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('plugin_property=[\n')
        level += 1
        for plugin_property_ in self.plugin_property:
            showIndent(outfile, level)
            outfile.write('model_.PluginProperty(\n')
            plugin_property_.exportLiteral(outfile, level, name_='PluginProperty')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='PluginProperties'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'plugin-property':
            obj_ = PluginProperty.factory()
            obj_.build(child_)
            self.plugin_property.append(obj_)
# end class PluginProperties


class QuotaType(GeneratedsSuper):
    """
    Attributes:
    * defaults
        Type:           int

        Created By:           User (optional)

        Description:
          Need to clarify

    * floating_ip
        Type:           int

        Created By:           User (optional)

        Description:
          Maximum number of floating ips

    * instance_ip
        Type:           int

        Created By:           User (optional)

        Description:
          Maximum number of instance ips

    * virtual_machine_interface
        Type:           int

        Created By:           User (optional)

        Description:
          Maximum number of virtual machine interfaces

    * virtual_network
        Type:           int

        Created By:           User (optional)

        Description:
          Maximum number of virtual networks

    * virtual_router
        Type:           int

        Created By:           User (optional)

        Description:
          Maximum number of logical routers

    * virtual_DNS
        Type:           int

        Created By:           User (optional)

        Description:
          Maximum number of virtual DNS servers

    * virtual_DNS_record
        Type:           int

        Created By:           User (optional)

        Description:
          Maximum number of virtual DNS records

    * bgp_router
        Type:           int

        Created By:           User (optional)

        Description:
          Maximum number of bgp routers

    * network_ipam
        Type:           int

        Created By:           User (optional)

        Description:
          Maximum number of network IPAMs

    * access_control_list
        Type:           int

        Created By:           User (optional)

        Description:
          Maximum number of access control lists

    * network_policy
        Type:           int

        Created By:           User (optional)

        Description:
          Maximum number of network policies

    * floating_ip_pool
        Type:           int

        Created By:           User (optional)

        Description:
          Maximum number of floating ip pools

    * service_template
        Type:           int

        Created By:           User (optional)

        Description:
          Maximum number of service templates

    * service_instance
        Type:           int

        Created By:           User (optional)

        Description:
          Maximum number of service instances

    * logical_router
        Type:           int

        Created By:           User (optional)

        Description:
          Maximum number of logical routers

    * security_group
        Type:           int

        Created By:           User (optional)

        Description:
          Maximum number of security groups

    * security_group_rule
        Type:           int

        Created By:           User (optional)

        Description:
          Maximum number of security group rules

    * subnet
        Type:           int

        Created By:           User (optional)

        Description:
          Maximum number of subnets

    * global_vrouter_config
        Type:           int

        Created By:           User (optional)

        Description:
          Maximum number of global vrouter configs

    * loadbalancer_pool
        Type:           int

        Created By:           User (optional)

        Description:
          Maximum number of loadbalancer pools

    * loadbalancer_member
        Type:           int

        Created By:           User (optional)

        Description:
          Maximum number of loadbalancer member

    * loadbalancer_healthmonitor
        Type:           int

        Created By:           User (optional)

        Description:
          Maximum number of loadbalancer health monitors

    * virtual_ip
        Type:           int

        Created By:           User (optional)

        Description:
          Maximum number of virtual ips

    * security_logging_object
        Type:           int

        Created By:           User (optional)

        Description:
          Maximum number of security logging objects

    * route_table
        Type:           int

        Created By:           User (optional)

        Description:
          Maximum number of route tables

    * firewall_group
        Type:           int

        Created By:           User (optional)

        Description:
          Maximum number of application policy set

    * firewall_policy
        Type:           int

        Created By:           User (optional)

        Description:
          Maximum number of firewall policy

    * firewall_rule
        Type:           int

        Created By:           User (optional)

        Description:
          Maximum number of firewall rule

    * host_based_service
        Type:           int, *within* [0, 1]

        Created By:           User (optional)

        Description:
          Maximum number of host based service. Actually limited to 0 or 1 for a project

          (can not be unlimited or more than 1)

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'defaults', u'floating_ip', u'instance_ip', u'virtual_machine_interface', u'virtual_network', u'virtual_router', u'virtual_DNS', u'virtual_DNS_record', u'bgp_router', u'network_ipam', u'access_control_list', u'network_policy', u'floating_ip_pool', u'service_template', u'service_instance', u'logical_router', u'security_group', u'security_group_rule', u'subnet', u'global_vrouter_config', u'loadbalancer_pool', u'loadbalancer_member', u'loadbalancer_healthmonitor', u'virtual_ip', u'security_logging_object', u'route_table', u'firewall_group', u'firewall_policy', u'firewall_rule', u'host_based_service']
    attr_field_type_vals = {u'virtual_router': {'restrictions': None, 'description': [u'Maximum number of logical routers'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'network_policy': {'restrictions': None, 'description': [u'Maximum number of network policies'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'loadbalancer_pool': {'restrictions': None, 'description': [u'Maximum number of loadbalancer pools'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'route_table': {'restrictions': None, 'description': [u'Maximum number of route tables'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'subnet': {'restrictions': None, 'description': [u'Maximum number of subnets'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'firewall_rule': {'restrictions': None, 'description': [u'Maximum number of firewall rule'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'network_ipam': {'restrictions': None, 'description': [u'Maximum number of network IPAMs'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'virtual_DNS_record': {'restrictions': None, 'description': [u'Maximum number of virtual DNS records'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'logical_router': {'restrictions': None, 'description': [u'Maximum number of logical routers'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'security_group_rule': {'restrictions': None, 'description': [u'Maximum number of security group rules'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'firewall_group': {'restrictions': None, 'description': [u'Maximum number of application policy set'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'host_based_service': {'restrictions': [0, 1], 'description': [u'Maximum number of host based service. Actually limited to 0 or 1 for a project (can not be unlimited or more than 1)'], 'simple_type': u'UniqueQuotaType', 'is_complex': 0, 'restriction_type': 'range', 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'virtual_DNS': {'restrictions': None, 'description': [u'Maximum number of virtual DNS servers'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'service_instance': {'restrictions': None, 'description': [u'Maximum number of service instances'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'service_template': {'restrictions': None, 'description': [u'Maximum number of service templates'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'bgp_router': {'restrictions': None, 'description': [u'Maximum number of bgp routers'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'floating_ip': {'restrictions': None, 'description': [u'Maximum number of floating ips'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'floating_ip_pool': {'restrictions': None, 'description': [u'Maximum number of floating ip pools'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'loadbalancer_member': {'restrictions': None, 'description': [u'Maximum number of loadbalancer member'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'access_control_list': {'restrictions': None, 'description': [u'Maximum number of access control lists'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'firewall_policy': {'restrictions': None, 'description': [u'Maximum number of firewall policy'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'virtual_machine_interface': {'restrictions': None, 'description': [u'Maximum number of virtual machine interfaces'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'instance_ip': {'restrictions': None, 'description': [u'Maximum number of instance ips'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'global_vrouter_config': {'restrictions': None, 'description': [u'Maximum number of global vrouter configs'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'security_logging_object': {'restrictions': None, 'description': [u'Maximum number of security logging objects'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'loadbalancer_healthmonitor': {'restrictions': None, 'description': [u'Maximum number of loadbalancer health monitors'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'virtual_ip': {'restrictions': None, 'description': [u'Maximum number of virtual ips'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'defaults': {'restrictions': None, 'description': [u'Need to clarify'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'security_group': {'restrictions': None, 'description': [u'Maximum number of security groups'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'virtual_network': {'restrictions': None, 'description': [u'Maximum number of virtual networks'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}}
    def __init__(self, defaults=None, floating_ip=None, instance_ip=None, virtual_machine_interface=None, virtual_network=None, virtual_router=None, virtual_DNS=None, virtual_DNS_record=None, bgp_router=None, network_ipam=None, access_control_list=None, network_policy=None, floating_ip_pool=None, service_template=None, service_instance=None, logical_router=None, security_group=None, security_group_rule=None, subnet=None, global_vrouter_config=None, loadbalancer_pool=None, loadbalancer_member=None, loadbalancer_healthmonitor=None, virtual_ip=None, security_logging_object=None, route_table=None, firewall_group=None, firewall_policy=None, firewall_rule=None, host_based_service=0, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _defaults = params_dict[u"defaults"]
        except KeyError:
            _defaults = defaults
        self.defaults = _defaults
        try:
            _floating_ip = params_dict[u"floating_ip"]
        except KeyError:
            _floating_ip = floating_ip
        self.floating_ip = _floating_ip
        try:
            _instance_ip = params_dict[u"instance_ip"]
        except KeyError:
            _instance_ip = instance_ip
        self.instance_ip = _instance_ip
        try:
            _virtual_machine_interface = params_dict[u"virtual_machine_interface"]
        except KeyError:
            _virtual_machine_interface = virtual_machine_interface
        self.virtual_machine_interface = _virtual_machine_interface
        try:
            _virtual_network = params_dict[u"virtual_network"]
        except KeyError:
            _virtual_network = virtual_network
        self.virtual_network = _virtual_network
        try:
            _virtual_router = params_dict[u"virtual_router"]
        except KeyError:
            _virtual_router = virtual_router
        self.virtual_router = _virtual_router
        try:
            _virtual_DNS = params_dict[u"virtual_DNS"]
        except KeyError:
            _virtual_DNS = virtual_DNS
        self.virtual_DNS = _virtual_DNS
        try:
            _virtual_DNS_record = params_dict[u"virtual_DNS_record"]
        except KeyError:
            _virtual_DNS_record = virtual_DNS_record
        self.virtual_DNS_record = _virtual_DNS_record
        try:
            _bgp_router = params_dict[u"bgp_router"]
        except KeyError:
            _bgp_router = bgp_router
        self.bgp_router = _bgp_router
        try:
            _network_ipam = params_dict[u"network_ipam"]
        except KeyError:
            _network_ipam = network_ipam
        self.network_ipam = _network_ipam
        try:
            _access_control_list = params_dict[u"access_control_list"]
        except KeyError:
            _access_control_list = access_control_list
        self.access_control_list = _access_control_list
        try:
            _network_policy = params_dict[u"network_policy"]
        except KeyError:
            _network_policy = network_policy
        self.network_policy = _network_policy
        try:
            _floating_ip_pool = params_dict[u"floating_ip_pool"]
        except KeyError:
            _floating_ip_pool = floating_ip_pool
        self.floating_ip_pool = _floating_ip_pool
        try:
            _service_template = params_dict[u"service_template"]
        except KeyError:
            _service_template = service_template
        self.service_template = _service_template
        try:
            _service_instance = params_dict[u"service_instance"]
        except KeyError:
            _service_instance = service_instance
        self.service_instance = _service_instance
        try:
            _logical_router = params_dict[u"logical_router"]
        except KeyError:
            _logical_router = logical_router
        self.logical_router = _logical_router
        try:
            _security_group = params_dict[u"security_group"]
        except KeyError:
            _security_group = security_group
        self.security_group = _security_group
        try:
            _security_group_rule = params_dict[u"security_group_rule"]
        except KeyError:
            _security_group_rule = security_group_rule
        self.security_group_rule = _security_group_rule
        try:
            _subnet = params_dict[u"subnet"]
        except KeyError:
            _subnet = subnet
        self.subnet = _subnet
        try:
            _global_vrouter_config = params_dict[u"global_vrouter_config"]
        except KeyError:
            _global_vrouter_config = global_vrouter_config
        self.global_vrouter_config = _global_vrouter_config
        try:
            _loadbalancer_pool = params_dict[u"loadbalancer_pool"]
        except KeyError:
            _loadbalancer_pool = loadbalancer_pool
        self.loadbalancer_pool = _loadbalancer_pool
        try:
            _loadbalancer_member = params_dict[u"loadbalancer_member"]
        except KeyError:
            _loadbalancer_member = loadbalancer_member
        self.loadbalancer_member = _loadbalancer_member
        try:
            _loadbalancer_healthmonitor = params_dict[u"loadbalancer_healthmonitor"]
        except KeyError:
            _loadbalancer_healthmonitor = loadbalancer_healthmonitor
        self.loadbalancer_healthmonitor = _loadbalancer_healthmonitor
        try:
            _virtual_ip = params_dict[u"virtual_ip"]
        except KeyError:
            _virtual_ip = virtual_ip
        self.virtual_ip = _virtual_ip
        try:
            _security_logging_object = params_dict[u"security_logging_object"]
        except KeyError:
            _security_logging_object = security_logging_object
        self.security_logging_object = _security_logging_object
        try:
            _route_table = params_dict[u"route_table"]
        except KeyError:
            _route_table = route_table
        self.route_table = _route_table
        try:
            _firewall_group = params_dict[u"firewall_group"]
        except KeyError:
            _firewall_group = firewall_group
        self.firewall_group = _firewall_group
        try:
            _firewall_policy = params_dict[u"firewall_policy"]
        except KeyError:
            _firewall_policy = firewall_policy
        self.firewall_policy = _firewall_policy
        try:
            _firewall_rule = params_dict[u"firewall_rule"]
        except KeyError:
            _firewall_rule = firewall_rule
        self.firewall_rule = _firewall_rule
        try:
            _host_based_service = params_dict[u"host_based_service"]
        except KeyError:
            _host_based_service = host_based_service
        self.host_based_service = _host_based_service
    def factory(*args_, **kwargs_):
        if QuotaType.subclass:
            return QuotaType.subclass(*args_, **kwargs_)
        else:
            return QuotaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_defaults(self): return self.defaults
    def set_defaults(self, defaults): self.defaults = defaults
    def get_floating_ip(self): return self.floating_ip
    def set_floating_ip(self, floating_ip): self.floating_ip = floating_ip
    def get_instance_ip(self): return self.instance_ip
    def set_instance_ip(self, instance_ip): self.instance_ip = instance_ip
    def get_virtual_machine_interface(self): return self.virtual_machine_interface
    def set_virtual_machine_interface(self, virtual_machine_interface): self.virtual_machine_interface = virtual_machine_interface
    def get_virtual_network(self): return self.virtual_network
    def set_virtual_network(self, virtual_network): self.virtual_network = virtual_network
    def get_virtual_router(self): return self.virtual_router
    def set_virtual_router(self, virtual_router): self.virtual_router = virtual_router
    def get_virtual_DNS(self): return self.virtual_DNS
    def set_virtual_DNS(self, virtual_DNS): self.virtual_DNS = virtual_DNS
    def get_virtual_DNS_record(self): return self.virtual_DNS_record
    def set_virtual_DNS_record(self, virtual_DNS_record): self.virtual_DNS_record = virtual_DNS_record
    def get_bgp_router(self): return self.bgp_router
    def set_bgp_router(self, bgp_router): self.bgp_router = bgp_router
    def get_network_ipam(self): return self.network_ipam
    def set_network_ipam(self, network_ipam): self.network_ipam = network_ipam
    def get_access_control_list(self): return self.access_control_list
    def set_access_control_list(self, access_control_list): self.access_control_list = access_control_list
    def get_network_policy(self): return self.network_policy
    def set_network_policy(self, network_policy): self.network_policy = network_policy
    def get_floating_ip_pool(self): return self.floating_ip_pool
    def set_floating_ip_pool(self, floating_ip_pool): self.floating_ip_pool = floating_ip_pool
    def get_service_template(self): return self.service_template
    def set_service_template(self, service_template): self.service_template = service_template
    def get_service_instance(self): return self.service_instance
    def set_service_instance(self, service_instance): self.service_instance = service_instance
    def get_logical_router(self): return self.logical_router
    def set_logical_router(self, logical_router): self.logical_router = logical_router
    def get_security_group(self): return self.security_group
    def set_security_group(self, security_group): self.security_group = security_group
    def get_security_group_rule(self): return self.security_group_rule
    def set_security_group_rule(self, security_group_rule): self.security_group_rule = security_group_rule
    def get_subnet(self): return self.subnet
    def set_subnet(self, subnet): self.subnet = subnet
    def get_global_vrouter_config(self): return self.global_vrouter_config
    def set_global_vrouter_config(self, global_vrouter_config): self.global_vrouter_config = global_vrouter_config
    def get_loadbalancer_pool(self): return self.loadbalancer_pool
    def set_loadbalancer_pool(self, loadbalancer_pool): self.loadbalancer_pool = loadbalancer_pool
    def get_loadbalancer_member(self): return self.loadbalancer_member
    def set_loadbalancer_member(self, loadbalancer_member): self.loadbalancer_member = loadbalancer_member
    def get_loadbalancer_healthmonitor(self): return self.loadbalancer_healthmonitor
    def set_loadbalancer_healthmonitor(self, loadbalancer_healthmonitor): self.loadbalancer_healthmonitor = loadbalancer_healthmonitor
    def get_virtual_ip(self): return self.virtual_ip
    def set_virtual_ip(self, virtual_ip): self.virtual_ip = virtual_ip
    def get_security_logging_object(self): return self.security_logging_object
    def set_security_logging_object(self, security_logging_object): self.security_logging_object = security_logging_object
    def get_route_table(self): return self.route_table
    def set_route_table(self, route_table): self.route_table = route_table
    def get_firewall_group(self): return self.firewall_group
    def set_firewall_group(self, firewall_group): self.firewall_group = firewall_group
    def get_firewall_policy(self): return self.firewall_policy
    def set_firewall_policy(self, firewall_policy): self.firewall_policy = firewall_policy
    def get_firewall_rule(self): return self.firewall_rule
    def set_firewall_rule(self, firewall_rule): self.firewall_rule = firewall_rule
    def get_host_based_service(self): return self.host_based_service
    def set_host_based_service(self, host_based_service): self.host_based_service = host_based_service
    def validate_UniqueQuotaType(self, value):
        # Validate type UniqueQuotaType, a restriction on xsd:integer.
        error = False
        if isinstance(value, list):
            v_int = list(map(int, value))
            v1, v2 = min(v_int), max(v_int)
        else:
            v1, v2 = int(value), int(value)
        error |= (v2 > 1)
        if error:
            raise ValueError("UniqueQuotaType must be in the range {'minimum': 0}-{'maximum': 1}")
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.defaults == other.defaults and
                    self.floating_ip == other.floating_ip and
                    self.instance_ip == other.instance_ip and
                    self.virtual_machine_interface == other.virtual_machine_interface and
                    self.virtual_network == other.virtual_network and
                    self.virtual_router == other.virtual_router and
                    self.virtual_DNS == other.virtual_DNS and
                    self.virtual_DNS_record == other.virtual_DNS_record and
                    self.bgp_router == other.bgp_router and
                    self.network_ipam == other.network_ipam and
                    self.access_control_list == other.access_control_list and
                    self.network_policy == other.network_policy and
                    self.floating_ip_pool == other.floating_ip_pool and
                    self.service_template == other.service_template and
                    self.service_instance == other.service_instance and
                    self.logical_router == other.logical_router and
                    self.security_group == other.security_group and
                    self.security_group_rule == other.security_group_rule and
                    self.subnet == other.subnet and
                    self.global_vrouter_config == other.global_vrouter_config and
                    self.loadbalancer_pool == other.loadbalancer_pool and
                    self.loadbalancer_member == other.loadbalancer_member and
                    self.loadbalancer_healthmonitor == other.loadbalancer_healthmonitor and
                    self.virtual_ip == other.virtual_ip and
                    self.security_logging_object == other.security_logging_object and
                    self.route_table == other.route_table and
                    self.firewall_group == other.firewall_group and
                    self.firewall_policy == other.firewall_policy and
                    self.firewall_rule == other.firewall_rule and
                    self.host_based_service == other.host_based_service)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.defaults if self.defaults is not None else -7985492147856592190,
                     self.floating_ip if self.floating_ip is not None else -7985492147856592190,
                     self.instance_ip if self.instance_ip is not None else -7985492147856592190,
                     self.virtual_machine_interface if self.virtual_machine_interface is not None else -7985492147856592190,
                     self.virtual_network if self.virtual_network is not None else -7985492147856592190,
                     self.virtual_router if self.virtual_router is not None else -7985492147856592190,
                     self.virtual_DNS if self.virtual_DNS is not None else -7985492147856592190,
                     self.virtual_DNS_record if self.virtual_DNS_record is not None else -7985492147856592190,
                     self.bgp_router if self.bgp_router is not None else -7985492147856592190,
                     self.network_ipam if self.network_ipam is not None else -7985492147856592190,
                     self.access_control_list if self.access_control_list is not None else -7985492147856592190,
                     self.network_policy if self.network_policy is not None else -7985492147856592190,
                     self.floating_ip_pool if self.floating_ip_pool is not None else -7985492147856592190,
                     self.service_template if self.service_template is not None else -7985492147856592190,
                     self.service_instance if self.service_instance is not None else -7985492147856592190,
                     self.logical_router if self.logical_router is not None else -7985492147856592190,
                     self.security_group if self.security_group is not None else -7985492147856592190,
                     self.security_group_rule if self.security_group_rule is not None else -7985492147856592190,
                     self.subnet if self.subnet is not None else -7985492147856592190,
                     self.global_vrouter_config if self.global_vrouter_config is not None else -7985492147856592190,
                     self.loadbalancer_pool if self.loadbalancer_pool is not None else -7985492147856592190,
                     self.loadbalancer_member if self.loadbalancer_member is not None else -7985492147856592190,
                     self.loadbalancer_healthmonitor if self.loadbalancer_healthmonitor is not None else -7985492147856592190,
                     self.virtual_ip if self.virtual_ip is not None else -7985492147856592190,
                     self.security_logging_object if self.security_logging_object is not None else -7985492147856592190,
                     self.route_table if self.route_table is not None else -7985492147856592190,
                     self.firewall_group if self.firewall_group is not None else -7985492147856592190,
                     self.firewall_policy if self.firewall_policy is not None else -7985492147856592190,
                     self.firewall_rule if self.firewall_rule is not None else -7985492147856592190,
                     self.host_based_service if self.host_based_service is not None else -7985492147856592190))

    def __repr__(self):
        return ("defaults = " + str(self.defaults) + ", " +
                "floating_ip = " + str(self.floating_ip) + ", " +
                "instance_ip = " + str(self.instance_ip) + ", " +
                "virtual_machine_interface = " + str(self.virtual_machine_interface) + ", " +
                "virtual_network = " + str(self.virtual_network) + ", " +
                "virtual_router = " + str(self.virtual_router) + ", " +
                "virtual_DNS = " + str(self.virtual_DNS) + ", " +
                "virtual_DNS_record = " + str(self.virtual_DNS_record) + ", " +
                "bgp_router = " + str(self.bgp_router) + ", " +
                "network_ipam = " + str(self.network_ipam) + ", " +
                "access_control_list = " + str(self.access_control_list) + ", " +
                "network_policy = " + str(self.network_policy) + ", " +
                "floating_ip_pool = " + str(self.floating_ip_pool) + ", " +
                "service_template = " + str(self.service_template) + ", " +
                "service_instance = " + str(self.service_instance) + ", " +
                "logical_router = " + str(self.logical_router) + ", " +
                "security_group = " + str(self.security_group) + ", " +
                "security_group_rule = " + str(self.security_group_rule) + ", " +
                "subnet = " + str(self.subnet) + ", " +
                "global_vrouter_config = " + str(self.global_vrouter_config) + ", " +
                "loadbalancer_pool = " + str(self.loadbalancer_pool) + ", " +
                "loadbalancer_member = " + str(self.loadbalancer_member) + ", " +
                "loadbalancer_healthmonitor = " + str(self.loadbalancer_healthmonitor) + ", " +
                "virtual_ip = " + str(self.virtual_ip) + ", " +
                "security_logging_object = " + str(self.security_logging_object) + ", " +
                "route_table = " + str(self.route_table) + ", " +
                "firewall_group = " + str(self.firewall_group) + ", " +
                "firewall_policy = " + str(self.firewall_policy) + ", " +
                "firewall_rule = " + str(self.firewall_rule) + ", " +
                "host_based_service = " + str(self.host_based_service))

    def copy(self):
        cp = QuotaType()
        if self.defaults is not None:
            cp.defaults = self.defaults
        if self.floating_ip is not None:
            cp.floating_ip = self.floating_ip
        if self.instance_ip is not None:
            cp.instance_ip = self.instance_ip
        if self.virtual_machine_interface is not None:
            cp.virtual_machine_interface = self.virtual_machine_interface
        if self.virtual_network is not None:
            cp.virtual_network = self.virtual_network
        if self.virtual_router is not None:
            cp.virtual_router = self.virtual_router
        if self.virtual_DNS is not None:
            cp.virtual_DNS = self.virtual_DNS
        if self.virtual_DNS_record is not None:
            cp.virtual_DNS_record = self.virtual_DNS_record
        if self.bgp_router is not None:
            cp.bgp_router = self.bgp_router
        if self.network_ipam is not None:
            cp.network_ipam = self.network_ipam
        if self.access_control_list is not None:
            cp.access_control_list = self.access_control_list
        if self.network_policy is not None:
            cp.network_policy = self.network_policy
        if self.floating_ip_pool is not None:
            cp.floating_ip_pool = self.floating_ip_pool
        if self.service_template is not None:
            cp.service_template = self.service_template
        if self.service_instance is not None:
            cp.service_instance = self.service_instance
        if self.logical_router is not None:
            cp.logical_router = self.logical_router
        if self.security_group is not None:
            cp.security_group = self.security_group
        if self.security_group_rule is not None:
            cp.security_group_rule = self.security_group_rule
        if self.subnet is not None:
            cp.subnet = self.subnet
        if self.global_vrouter_config is not None:
            cp.global_vrouter_config = self.global_vrouter_config
        if self.loadbalancer_pool is not None:
            cp.loadbalancer_pool = self.loadbalancer_pool
        if self.loadbalancer_member is not None:
            cp.loadbalancer_member = self.loadbalancer_member
        if self.loadbalancer_healthmonitor is not None:
            cp.loadbalancer_healthmonitor = self.loadbalancer_healthmonitor
        if self.virtual_ip is not None:
            cp.virtual_ip = self.virtual_ip
        if self.security_logging_object is not None:
            cp.security_logging_object = self.security_logging_object
        if self.route_table is not None:
            cp.route_table = self.route_table
        if self.firewall_group is not None:
            cp.firewall_group = self.firewall_group
        if self.firewall_policy is not None:
            cp.firewall_policy = self.firewall_policy
        if self.firewall_rule is not None:
            cp.firewall_rule = self.firewall_rule
        if self.host_based_service is not None:
            cp.host_based_service = self.host_based_service
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_defaults (obj.populate_integer ("defaults"))
        obj.set_floating_ip (obj.populate_integer ("floating_ip"))
        obj.set_instance_ip (obj.populate_integer ("instance_ip"))
        obj.set_virtual_machine_interface (obj.populate_integer ("virtual_machine_interface"))
        obj.set_virtual_network (obj.populate_integer ("virtual_network"))
        obj.set_virtual_router (obj.populate_integer ("virtual_router"))
        obj.set_virtual_DNS (obj.populate_integer ("virtual_DNS"))
        obj.set_virtual_DNS_record (obj.populate_integer ("virtual_DNS_record"))
        obj.set_bgp_router (obj.populate_integer ("bgp_router"))
        obj.set_network_ipam (obj.populate_integer ("network_ipam"))
        obj.set_access_control_list (obj.populate_integer ("access_control_list"))
        obj.set_network_policy (obj.populate_integer ("network_policy"))
        obj.set_floating_ip_pool (obj.populate_integer ("floating_ip_pool"))
        obj.set_service_template (obj.populate_integer ("service_template"))
        obj.set_service_instance (obj.populate_integer ("service_instance"))
        obj.set_logical_router (obj.populate_integer ("logical_router"))
        obj.set_security_group (obj.populate_integer ("security_group"))
        obj.set_security_group_rule (obj.populate_integer ("security_group_rule"))
        obj.set_subnet (obj.populate_integer ("subnet"))
        obj.set_global_vrouter_config (obj.populate_integer ("global_vrouter_config"))
        obj.set_loadbalancer_pool (obj.populate_integer ("loadbalancer_pool"))
        obj.set_loadbalancer_member (obj.populate_integer ("loadbalancer_member"))
        obj.set_loadbalancer_healthmonitor (obj.populate_integer ("loadbalancer_healthmonitor"))
        obj.set_virtual_ip (obj.populate_integer ("virtual_ip"))
        obj.set_security_logging_object (obj.populate_integer ("security_logging_object"))
        obj.set_route_table (obj.populate_integer ("route_table"))
        obj.set_firewall_group (obj.populate_integer ("firewall_group"))
        obj.set_firewall_policy (obj.populate_integer ("firewall_policy"))
        obj.set_firewall_rule (obj.populate_integer ("firewall_rule"))
        obj.set_host_based_service (obj.populate_integer ("host_based_service"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='QuotaType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QuotaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QuotaType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='QuotaType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.defaults is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdefaults>%s</%sdefaults>%s' % (namespace_, self.gds_format_integer(self.defaults, input_name='defaults'), namespace_, eol_))
        if self.floating_ip is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfloating-ip>%s</%sfloating-ip>%s' % (namespace_, self.gds_format_integer(self.floating_ip, input_name='floating-ip'), namespace_, eol_))
        if self.instance_ip is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinstance-ip>%s</%sinstance-ip>%s' % (namespace_, self.gds_format_integer(self.instance_ip, input_name='instance-ip'), namespace_, eol_))
        if self.virtual_machine_interface is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svirtual-machine-interface>%s</%svirtual-machine-interface>%s' % (namespace_, self.gds_format_integer(self.virtual_machine_interface, input_name='virtual-machine-interface'), namespace_, eol_))
        if self.virtual_network is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svirtual-network>%s</%svirtual-network>%s' % (namespace_, self.gds_format_integer(self.virtual_network, input_name='virtual-network'), namespace_, eol_))
        if self.virtual_router is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svirtual-router>%s</%svirtual-router>%s' % (namespace_, self.gds_format_integer(self.virtual_router, input_name='virtual-router'), namespace_, eol_))
        if self.virtual_DNS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svirtual-DNS>%s</%svirtual-DNS>%s' % (namespace_, self.gds_format_integer(self.virtual_DNS, input_name='virtual-DNS'), namespace_, eol_))
        if self.virtual_DNS_record is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svirtual-DNS-record>%s</%svirtual-DNS-record>%s' % (namespace_, self.gds_format_integer(self.virtual_DNS_record, input_name='virtual-DNS-record'), namespace_, eol_))
        if self.bgp_router is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbgp-router>%s</%sbgp-router>%s' % (namespace_, self.gds_format_integer(self.bgp_router, input_name='bgp-router'), namespace_, eol_))
        if self.network_ipam is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snetwork-ipam>%s</%snetwork-ipam>%s' % (namespace_, self.gds_format_integer(self.network_ipam, input_name='network-ipam'), namespace_, eol_))
        if self.access_control_list is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saccess-control-list>%s</%saccess-control-list>%s' % (namespace_, self.gds_format_integer(self.access_control_list, input_name='access-control-list'), namespace_, eol_))
        if self.network_policy is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snetwork-policy>%s</%snetwork-policy>%s' % (namespace_, self.gds_format_integer(self.network_policy, input_name='network-policy'), namespace_, eol_))
        if self.floating_ip_pool is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfloating-ip-pool>%s</%sfloating-ip-pool>%s' % (namespace_, self.gds_format_integer(self.floating_ip_pool, input_name='floating-ip-pool'), namespace_, eol_))
        if self.service_template is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sservice-template>%s</%sservice-template>%s' % (namespace_, self.gds_format_integer(self.service_template, input_name='service-template'), namespace_, eol_))
        if self.service_instance is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sservice-instance>%s</%sservice-instance>%s' % (namespace_, self.gds_format_integer(self.service_instance, input_name='service-instance'), namespace_, eol_))
        if self.logical_router is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slogical-router>%s</%slogical-router>%s' % (namespace_, self.gds_format_integer(self.logical_router, input_name='logical-router'), namespace_, eol_))
        if self.security_group is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssecurity-group>%s</%ssecurity-group>%s' % (namespace_, self.gds_format_integer(self.security_group, input_name='security-group'), namespace_, eol_))
        if self.security_group_rule is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssecurity-group-rule>%s</%ssecurity-group-rule>%s' % (namespace_, self.gds_format_integer(self.security_group_rule, input_name='security-group-rule'), namespace_, eol_))
        if self.subnet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssubnet>%s</%ssubnet>%s' % (namespace_, self.gds_format_integer(self.subnet, input_name='subnet'), namespace_, eol_))
        if self.global_vrouter_config is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sglobal-vrouter-config>%s</%sglobal-vrouter-config>%s' % (namespace_, self.gds_format_integer(self.global_vrouter_config, input_name='global-vrouter-config'), namespace_, eol_))
        if self.loadbalancer_pool is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sloadbalancer-pool>%s</%sloadbalancer-pool>%s' % (namespace_, self.gds_format_integer(self.loadbalancer_pool, input_name='loadbalancer-pool'), namespace_, eol_))
        if self.loadbalancer_member is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sloadbalancer-member>%s</%sloadbalancer-member>%s' % (namespace_, self.gds_format_integer(self.loadbalancer_member, input_name='loadbalancer-member'), namespace_, eol_))
        if self.loadbalancer_healthmonitor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sloadbalancer-healthmonitor>%s</%sloadbalancer-healthmonitor>%s' % (namespace_, self.gds_format_integer(self.loadbalancer_healthmonitor, input_name='loadbalancer-healthmonitor'), namespace_, eol_))
        if self.virtual_ip is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svirtual-ip>%s</%svirtual-ip>%s' % (namespace_, self.gds_format_integer(self.virtual_ip, input_name='virtual-ip'), namespace_, eol_))
        if self.security_logging_object is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssecurity-logging-object>%s</%ssecurity-logging-object>%s' % (namespace_, self.gds_format_integer(self.security_logging_object, input_name='security-logging-object'), namespace_, eol_))
        if self.route_table is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sroute-table>%s</%sroute-table>%s' % (namespace_, self.gds_format_integer(self.route_table, input_name='route-table'), namespace_, eol_))
        if self.firewall_group is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfirewall-group>%s</%sfirewall-group>%s' % (namespace_, self.gds_format_integer(self.firewall_group, input_name='firewall-group'), namespace_, eol_))
        if self.firewall_policy is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfirewall-policy>%s</%sfirewall-policy>%s' % (namespace_, self.gds_format_integer(self.firewall_policy, input_name='firewall-policy'), namespace_, eol_))
        if self.firewall_rule is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfirewall-rule>%s</%sfirewall-rule>%s' % (namespace_, self.gds_format_integer(self.firewall_rule, input_name='firewall-rule'), namespace_, eol_))
        if self.host_based_service is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shost-based-service>%s</%shost-based-service>%s' % (namespace_, self.gds_format_integer(self.host_based_service, input_name='host-based-service'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.defaults is not None or
            self.floating_ip is not None or
            self.instance_ip is not None or
            self.virtual_machine_interface is not None or
            self.virtual_network is not None or
            self.virtual_router is not None or
            self.virtual_DNS is not None or
            self.virtual_DNS_record is not None or
            self.bgp_router is not None or
            self.network_ipam is not None or
            self.access_control_list is not None or
            self.network_policy is not None or
            self.floating_ip_pool is not None or
            self.service_template is not None or
            self.service_instance is not None or
            self.logical_router is not None or
            self.security_group is not None or
            self.security_group_rule is not None or
            self.subnet is not None or
            self.global_vrouter_config is not None or
            self.loadbalancer_pool is not None or
            self.loadbalancer_member is not None or
            self.loadbalancer_healthmonitor is not None or
            self.virtual_ip is not None or
            self.security_logging_object is not None or
            self.route_table is not None or
            self.firewall_group is not None or
            self.firewall_policy is not None or
            self.firewall_rule is not None or
            self.host_based_service is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='QuotaType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.defaults is not None:
            showIndent(outfile, level)
            outfile.write('defaults=%d,\n' % self.defaults)
        if self.floating_ip is not None:
            showIndent(outfile, level)
            outfile.write('floating_ip=%d,\n' % self.floating_ip)
        if self.instance_ip is not None:
            showIndent(outfile, level)
            outfile.write('instance_ip=%d,\n' % self.instance_ip)
        if self.virtual_machine_interface is not None:
            showIndent(outfile, level)
            outfile.write('virtual_machine_interface=%d,\n' % self.virtual_machine_interface)
        if self.virtual_network is not None:
            showIndent(outfile, level)
            outfile.write('virtual_network=%d,\n' % self.virtual_network)
        if self.virtual_router is not None:
            showIndent(outfile, level)
            outfile.write('virtual_router=%d,\n' % self.virtual_router)
        if self.virtual_DNS is not None:
            showIndent(outfile, level)
            outfile.write('virtual_DNS=%d,\n' % self.virtual_DNS)
        if self.virtual_DNS_record is not None:
            showIndent(outfile, level)
            outfile.write('virtual_DNS_record=%d,\n' % self.virtual_DNS_record)
        if self.bgp_router is not None:
            showIndent(outfile, level)
            outfile.write('bgp_router=%d,\n' % self.bgp_router)
        if self.network_ipam is not None:
            showIndent(outfile, level)
            outfile.write('network_ipam=%d,\n' % self.network_ipam)
        if self.access_control_list is not None:
            showIndent(outfile, level)
            outfile.write('access_control_list=%d,\n' % self.access_control_list)
        if self.network_policy is not None:
            showIndent(outfile, level)
            outfile.write('network_policy=%d,\n' % self.network_policy)
        if self.floating_ip_pool is not None:
            showIndent(outfile, level)
            outfile.write('floating_ip_pool=%d,\n' % self.floating_ip_pool)
        if self.service_template is not None:
            showIndent(outfile, level)
            outfile.write('service_template=%d,\n' % self.service_template)
        if self.service_instance is not None:
            showIndent(outfile, level)
            outfile.write('service_instance=%d,\n' % self.service_instance)
        if self.logical_router is not None:
            showIndent(outfile, level)
            outfile.write('logical_router=%d,\n' % self.logical_router)
        if self.security_group is not None:
            showIndent(outfile, level)
            outfile.write('security_group=%d,\n' % self.security_group)
        if self.security_group_rule is not None:
            showIndent(outfile, level)
            outfile.write('security_group_rule=%d,\n' % self.security_group_rule)
        if self.subnet is not None:
            showIndent(outfile, level)
            outfile.write('subnet=%d,\n' % self.subnet)
        if self.global_vrouter_config is not None:
            showIndent(outfile, level)
            outfile.write('global_vrouter_config=%d,\n' % self.global_vrouter_config)
        if self.loadbalancer_pool is not None:
            showIndent(outfile, level)
            outfile.write('loadbalancer_pool=%d,\n' % self.loadbalancer_pool)
        if self.loadbalancer_member is not None:
            showIndent(outfile, level)
            outfile.write('loadbalancer_member=%d,\n' % self.loadbalancer_member)
        if self.loadbalancer_healthmonitor is not None:
            showIndent(outfile, level)
            outfile.write('loadbalancer_healthmonitor=%d,\n' % self.loadbalancer_healthmonitor)
        if self.virtual_ip is not None:
            showIndent(outfile, level)
            outfile.write('virtual_ip=%d,\n' % self.virtual_ip)
        if self.security_logging_object is not None:
            showIndent(outfile, level)
            outfile.write('security_logging_object=%d,\n' % self.security_logging_object)
        if self.route_table is not None:
            showIndent(outfile, level)
            outfile.write('route_table=%d,\n' % self.route_table)
        if self.firewall_group is not None:
            showIndent(outfile, level)
            outfile.write('firewall_group=%d,\n' % self.firewall_group)
        if self.firewall_policy is not None:
            showIndent(outfile, level)
            outfile.write('firewall_policy=%d,\n' % self.firewall_policy)
        if self.firewall_rule is not None:
            showIndent(outfile, level)
            outfile.write('firewall_rule=%d,\n' % self.firewall_rule)
        if self.host_based_service is not None:
            showIndent(outfile, level)
            outfile.write('host_based_service=%d,\n' % self.host_based_service)
    def exportDict(self, name_='QuotaType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'defaults':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'defaults')
            self.defaults = ival_
        elif nodeName_ == 'floating-ip':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'floating_ip')
            self.floating_ip = ival_
        elif nodeName_ == 'instance-ip':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'instance_ip')
            self.instance_ip = ival_
        elif nodeName_ == 'virtual-machine-interface':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'virtual_machine_interface')
            self.virtual_machine_interface = ival_
        elif nodeName_ == 'virtual-network':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'virtual_network')
            self.virtual_network = ival_
        elif nodeName_ == 'virtual-router':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'virtual_router')
            self.virtual_router = ival_
        elif nodeName_ == 'virtual-DNS':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'virtual_DNS')
            self.virtual_DNS = ival_
        elif nodeName_ == 'virtual-DNS-record':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'virtual_DNS_record')
            self.virtual_DNS_record = ival_
        elif nodeName_ == 'bgp-router':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'bgp_router')
            self.bgp_router = ival_
        elif nodeName_ == 'network-ipam':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'network_ipam')
            self.network_ipam = ival_
        elif nodeName_ == 'access-control-list':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'access_control_list')
            self.access_control_list = ival_
        elif nodeName_ == 'network-policy':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'network_policy')
            self.network_policy = ival_
        elif nodeName_ == 'floating-ip-pool':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'floating_ip_pool')
            self.floating_ip_pool = ival_
        elif nodeName_ == 'service-template':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'service_template')
            self.service_template = ival_
        elif nodeName_ == 'service-instance':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'service_instance')
            self.service_instance = ival_
        elif nodeName_ == 'logical-router':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'logical_router')
            self.logical_router = ival_
        elif nodeName_ == 'security-group':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'security_group')
            self.security_group = ival_
        elif nodeName_ == 'security-group-rule':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'security_group_rule')
            self.security_group_rule = ival_
        elif nodeName_ == 'subnet':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'subnet')
            self.subnet = ival_
        elif nodeName_ == 'global-vrouter-config':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'global_vrouter_config')
            self.global_vrouter_config = ival_
        elif nodeName_ == 'loadbalancer-pool':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'loadbalancer_pool')
            self.loadbalancer_pool = ival_
        elif nodeName_ == 'loadbalancer-member':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'loadbalancer_member')
            self.loadbalancer_member = ival_
        elif nodeName_ == 'loadbalancer-healthmonitor':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'loadbalancer_healthmonitor')
            self.loadbalancer_healthmonitor = ival_
        elif nodeName_ == 'virtual-ip':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'virtual_ip')
            self.virtual_ip = ival_
        elif nodeName_ == 'security-logging-object':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'security_logging_object')
            self.security_logging_object = ival_
        elif nodeName_ == 'route-table':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'route_table')
            self.route_table = ival_
        elif nodeName_ == 'firewall-group':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'firewall_group')
            self.firewall_group = ival_
        elif nodeName_ == 'firewall-policy':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'firewall_policy')
            self.firewall_policy = ival_
        elif nodeName_ == 'firewall-rule':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'firewall_rule')
            self.firewall_rule = ival_
        elif nodeName_ == 'host-based-service':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'host_based_service')
            self.host_based_service = ival_
            self.validate_UniqueQuotaType(self.host_based_service)    # validate type UniqueQuotaType
# end class QuotaType


class FlowAgingTimeout(GeneratedsSuper):
    """
    Attributes:
    * protocol
        Type:           str

    * port
        Type:           int

    * timeout_in_seconds
        Type:           int

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'protocol', u'port', u'timeout_in_seconds']
    attr_field_type_vals = {u'timeout_in_seconds': {'restrictions': None, 'description': [], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'integer'}, u'protocol': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'port': {'restrictions': None, 'description': [], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'integer'}}
    def __init__(self, protocol=None, port=None, timeout_in_seconds=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _protocol = params_dict[u"protocol"]
        except KeyError:
            _protocol = protocol
        self.protocol = _protocol
        try:
            _port = params_dict[u"port"]
        except KeyError:
            _port = port
        self.port = _port
        try:
            _timeout_in_seconds = params_dict[u"timeout_in_seconds"]
        except KeyError:
            _timeout_in_seconds = timeout_in_seconds
        self.timeout_in_seconds = _timeout_in_seconds
    def factory(*args_, **kwargs_):
        if FlowAgingTimeout.subclass:
            return FlowAgingTimeout.subclass(*args_, **kwargs_)
        else:
            return FlowAgingTimeout(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_protocol(self): return self.protocol
    def set_protocol(self, protocol): self.protocol = protocol
    def get_port(self): return self.port
    def set_port(self, port): self.port = port
    def get_timeout_in_seconds(self): return self.timeout_in_seconds
    def set_timeout_in_seconds(self, timeout_in_seconds): self.timeout_in_seconds = timeout_in_seconds
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.protocol == other.protocol and
                    self.port == other.port and
                    self.timeout_in_seconds == other.timeout_in_seconds)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.protocol if self.protocol is not None else -7985492147856592190,
                     self.port if self.port is not None else -7985492147856592190,
                     self.timeout_in_seconds if self.timeout_in_seconds is not None else -7985492147856592190))

    def __repr__(self):
        return ("protocol = " + str(self.protocol) + ", " +
                "port = " + str(self.port) + ", " +
                "timeout_in_seconds = " + str(self.timeout_in_seconds))

    def copy(self):
        cp = FlowAgingTimeout()
        if self.protocol is not None:
            cp.protocol = self.protocol
        if self.port is not None:
            cp.port = self.port
        if self.timeout_in_seconds is not None:
            cp.timeout_in_seconds = self.timeout_in_seconds
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_protocol (obj.populate_string ("protocol"))
        obj.set_port (obj.populate_integer ("port"))
        obj.set_timeout_in_seconds (obj.populate_integer ("timeout_in_seconds"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='FlowAgingTimeout', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FlowAgingTimeout')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FlowAgingTimeout'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FlowAgingTimeout', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.protocol is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprotocol>%s</%sprotocol>%s' % (namespace_, self.gds_format_string(quote_xml(self.protocol).encode(ExternalEncoding), input_name='protocol'), namespace_, eol_))
        if self.port is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sport>%s</%sport>%s' % (namespace_, self.gds_format_integer(self.port, input_name='port'), namespace_, eol_))
        if self.timeout_in_seconds is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stimeout-in-seconds>%s</%stimeout-in-seconds>%s' % (namespace_, self.gds_format_integer(self.timeout_in_seconds, input_name='timeout-in-seconds'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.protocol is not None or
            self.port is not None or
            self.timeout_in_seconds is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FlowAgingTimeout'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.protocol is not None:
            showIndent(outfile, level)
            outfile.write('protocol=%s,\n' % quote_python(self.protocol).encode(ExternalEncoding))
        if self.port is not None:
            showIndent(outfile, level)
            outfile.write('port=%d,\n' % self.port)
        if self.timeout_in_seconds is not None:
            showIndent(outfile, level)
            outfile.write('timeout_in_seconds=%d,\n' % self.timeout_in_seconds)
    def exportDict(self, name_='FlowAgingTimeout'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'protocol':
            protocol_ = child_.text
            protocol_ = self.gds_validate_string(protocol_, node, 'protocol')
            self.protocol = protocol_
        elif nodeName_ == 'port':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'port')
            self.port = ival_
        elif nodeName_ == 'timeout-in-seconds':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'timeout_in_seconds')
            self.timeout_in_seconds = ival_
# end class FlowAgingTimeout


class FlowAgingTimeoutList(GeneratedsSuper):
    """
    Attributes:
    * flow_aging_timeout
        Type:           :class:`.FlowAgingTimeout`

        Created By:           User (optional)

        Description:
          List of (ip protocol, port number, timeout in seconds)

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'flow_aging_timeout']
    attr_field_type_vals = {u'flow_aging_timeout': {'restrictions': None, 'description': [u'List of (ip protocol, port number, timeout in seconds)'], 'simple_type': u'FlowAgingTimeout', 'is_complex': 1, 'restriction_type': None, 'is_array': True, 'required': u'optional', 'attr_type': u'FlowAgingTimeout'}}
    def __init__(self, flow_aging_timeout=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _flow_aging_timeout = params_dict[u"flow_aging_timeout"]
        except KeyError:
            _flow_aging_timeout = flow_aging_timeout
        if not _flow_aging_timeout:
            self.flow_aging_timeout = []
        else:
            if isinstance(_flow_aging_timeout[0], dict):
                objs = [FlowAgingTimeout(params_dict=elem) for elem in _flow_aging_timeout]
                self.flow_aging_timeout = objs
            else:
                self.flow_aging_timeout = _flow_aging_timeout
    def factory(*args_, **kwargs_):
        if FlowAgingTimeoutList.subclass:
            return FlowAgingTimeoutList.subclass(*args_, **kwargs_)
        else:
            return FlowAgingTimeoutList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_flow_aging_timeout(self): return self.flow_aging_timeout
    def set_flow_aging_timeout(self, flow_aging_timeout): self.flow_aging_timeout = flow_aging_timeout
    def add_flow_aging_timeout(self, value): self.flow_aging_timeout.append(value)
    def insert_flow_aging_timeout(self, index, value): self.flow_aging_timeout[index] = value
    def delete_flow_aging_timeout(self, value): self.flow_aging_timeout.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.flow_aging_timeout == other.flow_aging_timeout)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.flow_aging_timeout or [])))

    def __repr__(self):
        return ("flow_aging_timeout = " + str(self.flow_aging_timeout))

    def copy(self):
        cp = FlowAgingTimeoutList()
        if self.flow_aging_timeout is not None:
            cp.flow_aging_timeout = [x.copy() for x in self.flow_aging_timeout]
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_flow_aging_timeout ([FlowAgingTimeout.populate ()])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='FlowAgingTimeoutList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FlowAgingTimeoutList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FlowAgingTimeoutList'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FlowAgingTimeoutList', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for flow_aging_timeout_ in self.flow_aging_timeout:
            if isinstance(flow_aging_timeout_, dict):
                flow_aging_timeout_ = FlowAgingTimeout(**flow_aging_timeout_)
            flow_aging_timeout_.export_xml(outfile, level, namespace_, name_='flow-aging-timeout', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.flow_aging_timeout
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FlowAgingTimeoutList'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('flow_aging_timeout=[\n')
        level += 1
        for flow_aging_timeout_ in self.flow_aging_timeout:
            showIndent(outfile, level)
            outfile.write('model_.FlowAgingTimeout(\n')
            flow_aging_timeout_.exportLiteral(outfile, level, name_='FlowAgingTimeout')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='FlowAgingTimeoutList'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'flow-aging-timeout':
            obj_ = FlowAgingTimeout.factory()
            obj_.build(child_)
            self.flow_aging_timeout.append(obj_)
# end class FlowAgingTimeoutList


class QosIdForwardingClassPair(GeneratedsSuper):
    """
    Attributes:
    * key
        Type:           int

        Description:
          QoS bit value (DSCP or Vlan priority or EXP bit value

    * forwarding_class_id
        Type:           int, *within* [0, 255]

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'key', u'forwarding_class_id']
    attr_field_type_vals = {u'key': {'restrictions': None, 'description': [u'QoS bit value (DSCP or Vlan priority or EXP bit value'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'integer'}, u'forwarding_class_id': {'restrictions': [0, 255], 'description': [], 'simple_type': u'ForwardingClassId', 'is_complex': 0, 'restriction_type': 'range', 'is_array': False, 'required': None, 'attr_type': u'integer'}}
    def __init__(self, key=None, forwarding_class_id=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _key = params_dict[u"key"]
        except KeyError:
            _key = key
        self.key = _key
        try:
            _forwarding_class_id = params_dict[u"forwarding_class_id"]
        except KeyError:
            _forwarding_class_id = forwarding_class_id
        self.forwarding_class_id = _forwarding_class_id
    def factory(*args_, **kwargs_):
        if QosIdForwardingClassPair.subclass:
            return QosIdForwardingClassPair.subclass(*args_, **kwargs_)
        else:
            return QosIdForwardingClassPair(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_key(self): return self.key
    def set_key(self, key): self.key = key
    def get_forwarding_class_id(self): return self.forwarding_class_id
    def set_forwarding_class_id(self, forwarding_class_id): self.forwarding_class_id = forwarding_class_id
    def validate_ForwardingClassId(self, value):
        # Validate type ForwardingClassId, a restriction on xsd:integer.
        error = False
        if isinstance(value, list):
            v_int = list(map(int, value))
            v1, v2 = min(v_int), max(v_int)
        else:
            v1, v2 = int(value), int(value)
        error |= (v2 > 255)
        if error:
            raise ValueError("ForwardingClassId must be in the range {'minimum': 0}-{'maximum': 255}")
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.key == other.key and
                    self.forwarding_class_id == other.forwarding_class_id)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.key if self.key is not None else -7985492147856592190,
                     self.forwarding_class_id if self.forwarding_class_id is not None else -7985492147856592190))

    def __repr__(self):
        return ("key = " + str(self.key) + ", " +
                "forwarding_class_id = " + str(self.forwarding_class_id))

    def copy(self):
        cp = QosIdForwardingClassPair()
        if self.key is not None:
            cp.key = self.key
        if self.forwarding_class_id is not None:
            cp.forwarding_class_id = self.forwarding_class_id
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_key (obj.populate_integer ("key"))
        obj.set_forwarding_class_id (obj.populate_integer ("forwarding_class_id"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='QosIdForwardingClassPair', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QosIdForwardingClassPair')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QosIdForwardingClassPair'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='QosIdForwardingClassPair', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.key is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%skey>%s</%skey>%s' % (namespace_, self.gds_format_integer(self.key, input_name='key'), namespace_, eol_))
        if self.forwarding_class_id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sforwarding-class-id>%s</%sforwarding-class-id>%s' % (namespace_, self.gds_format_integer(self.forwarding_class_id, input_name='forwarding-class-id'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.key is not None or
            self.forwarding_class_id is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='QosIdForwardingClassPair'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.key is not None:
            showIndent(outfile, level)
            outfile.write('key=%d,\n' % self.key)
        if self.forwarding_class_id is not None:
            showIndent(outfile, level)
            outfile.write('forwarding_class_id=%d,\n' % self.forwarding_class_id)
    def exportDict(self, name_='QosIdForwardingClassPair'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'key':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'key')
            self.key = ival_
        elif nodeName_ == 'forwarding-class-id':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'forwarding_class_id')
            self.forwarding_class_id = ival_
            self.validate_ForwardingClassId(self.forwarding_class_id)    # validate type ForwardingClassId
# end class QosIdForwardingClassPair


class QosIdForwardingClassPairs(GeneratedsSuper):
    """
    Attributes:
    * qos_id_forwarding_class_pair
        Type:           :class:`.QosIdForwardingClassPair`

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'qos_id_forwarding_class_pair']
    attr_field_type_vals = {u'qos_id_forwarding_class_pair': {'restrictions': None, 'description': [], 'simple_type': u'QosIdForwardingClassPair', 'is_complex': 1, 'restriction_type': None, 'is_array': True, 'required': None, 'attr_type': u'QosIdForwardingClassPair'}}
    def __init__(self, qos_id_forwarding_class_pair=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _qos_id_forwarding_class_pair = params_dict[u"qos_id_forwarding_class_pair"]
        except KeyError:
            _qos_id_forwarding_class_pair = qos_id_forwarding_class_pair
        if not _qos_id_forwarding_class_pair:
            self.qos_id_forwarding_class_pair = []
        else:
            if isinstance(_qos_id_forwarding_class_pair[0], dict):
                objs = [QosIdForwardingClassPair(params_dict=elem) for elem in _qos_id_forwarding_class_pair]
                self.qos_id_forwarding_class_pair = objs
            else:
                self.qos_id_forwarding_class_pair = _qos_id_forwarding_class_pair
    def factory(*args_, **kwargs_):
        if QosIdForwardingClassPairs.subclass:
            return QosIdForwardingClassPairs.subclass(*args_, **kwargs_)
        else:
            return QosIdForwardingClassPairs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_qos_id_forwarding_class_pair(self): return self.qos_id_forwarding_class_pair
    def set_qos_id_forwarding_class_pair(self, qos_id_forwarding_class_pair): self.qos_id_forwarding_class_pair = qos_id_forwarding_class_pair
    def add_qos_id_forwarding_class_pair(self, value): self.qos_id_forwarding_class_pair.append(value)
    def insert_qos_id_forwarding_class_pair(self, index, value): self.qos_id_forwarding_class_pair[index] = value
    def delete_qos_id_forwarding_class_pair(self, value): self.qos_id_forwarding_class_pair.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.qos_id_forwarding_class_pair == other.qos_id_forwarding_class_pair)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.qos_id_forwarding_class_pair or [])))

    def __repr__(self):
        return ("qos_id_forwarding_class_pair = " + str(self.qos_id_forwarding_class_pair))

    def copy(self):
        cp = QosIdForwardingClassPairs()
        if self.qos_id_forwarding_class_pair is not None:
            cp.qos_id_forwarding_class_pair = [x.copy() for x in self.qos_id_forwarding_class_pair]
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_qos_id_forwarding_class_pair ([QosIdForwardingClassPair.populate ()])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='QosIdForwardingClassPairs', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QosIdForwardingClassPairs')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QosIdForwardingClassPairs'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='QosIdForwardingClassPairs', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for qos_id_forwarding_class_pair_ in self.qos_id_forwarding_class_pair:
            if isinstance(qos_id_forwarding_class_pair_, dict):
                qos_id_forwarding_class_pair_ = QosIdForwardingClassPair(**qos_id_forwarding_class_pair_)
            qos_id_forwarding_class_pair_.export_xml(outfile, level, namespace_, name_='qos-id-forwarding-class-pair', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.qos_id_forwarding_class_pair
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='QosIdForwardingClassPairs'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('qos_id_forwarding_class_pair=[\n')
        level += 1
        for qos_id_forwarding_class_pair_ in self.qos_id_forwarding_class_pair:
            showIndent(outfile, level)
            outfile.write('model_.QosIdForwardingClassPair(\n')
            qos_id_forwarding_class_pair_.exportLiteral(outfile, level, name_='QosIdForwardingClassPair')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='QosIdForwardingClassPairs'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'qos-id-forwarding-class-pair':
            obj_ = QosIdForwardingClassPair.factory()
            obj_.build(child_)
            self.qos_id_forwarding_class_pair.append(obj_)
# end class QosIdForwardingClassPairs


class ControlTrafficDscpType(GeneratedsSuper):
    """
    Attributes:
    * control
        Type:           int, *within* [0, 63]

        Created By:           User (optional)

        Description:
          DSCP value for control protocols traffic

    * analytics
        Type:           int, *within* [0, 63]

        Created By:           User (optional)

        Description:
          DSCP value for traffic towards analytics

    * dns
        Type:           int, *within* [0, 63]

        Created By:           User (optional)

        Description:
          DSCP value for DNS traffic

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'control', u'analytics', u'dns']
    attr_field_type_vals = {u'control': {'restrictions': [0, 63], 'description': [u'DSCP value for control protocols traffic'], 'simple_type': u'DscpValueType', 'is_complex': 0, 'restriction_type': 'range', 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'analytics': {'restrictions': [0, 63], 'description': [u'DSCP value for traffic towards analytics'], 'simple_type': u'DscpValueType', 'is_complex': 0, 'restriction_type': 'range', 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'dns': {'restrictions': [0, 63], 'description': [u'DSCP value for DNS traffic'], 'simple_type': u'DscpValueType', 'is_complex': 0, 'restriction_type': 'range', 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}}
    def __init__(self, control=None, analytics=None, dns=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _control = params_dict[u"control"]
        except KeyError:
            _control = control
        self.control = _control
        try:
            _analytics = params_dict[u"analytics"]
        except KeyError:
            _analytics = analytics
        self.analytics = _analytics
        try:
            _dns = params_dict[u"dns"]
        except KeyError:
            _dns = dns
        self.dns = _dns
    def factory(*args_, **kwargs_):
        if ControlTrafficDscpType.subclass:
            return ControlTrafficDscpType.subclass(*args_, **kwargs_)
        else:
            return ControlTrafficDscpType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_control(self): return self.control
    def set_control(self, control): self.control = control
    def validate_DscpValueType(self, value):
        # Validate type DscpValueType, a restriction on xsd:integer.
        error = False
        if isinstance(value, list):
            v_int = list(map(int, value))
            v1, v2 = min(v_int), max(v_int)
        else:
            v1, v2 = int(value), int(value)
        error |= (v2 > 63)
        if error:
            raise ValueError("DscpValueType must be in the range {'minimum': 0}-{'maximum': 63}")
    def get_analytics(self): return self.analytics
    def set_analytics(self, analytics): self.analytics = analytics
    def get_dns(self): return self.dns
    def set_dns(self, dns): self.dns = dns
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.control == other.control and
                    self.analytics == other.analytics and
                    self.dns == other.dns)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.control if self.control is not None else -7985492147856592190,
                     self.analytics if self.analytics is not None else -7985492147856592190,
                     self.dns if self.dns is not None else -7985492147856592190))

    def __repr__(self):
        return ("control = " + str(self.control) + ", " +
                "analytics = " + str(self.analytics) + ", " +
                "dns = " + str(self.dns))

    def copy(self):
        cp = ControlTrafficDscpType()
        if self.control is not None:
            cp.control = self.control
        if self.analytics is not None:
            cp.analytics = self.analytics
        if self.dns is not None:
            cp.dns = self.dns
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_control (obj.populate_integer ("control"))
        obj.set_analytics (obj.populate_integer ("analytics"))
        obj.set_dns (obj.populate_integer ("dns"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='ControlTrafficDscpType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ControlTrafficDscpType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ControlTrafficDscpType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ControlTrafficDscpType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.control is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scontrol>%s</%scontrol>%s' % (namespace_, self.gds_format_integer(self.control, input_name='control'), namespace_, eol_))
        if self.analytics is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sanalytics>%s</%sanalytics>%s' % (namespace_, self.gds_format_integer(self.analytics, input_name='analytics'), namespace_, eol_))
        if self.dns is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdns>%s</%sdns>%s' % (namespace_, self.gds_format_integer(self.dns, input_name='dns'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.control is not None or
            self.analytics is not None or
            self.dns is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ControlTrafficDscpType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.control is not None:
            showIndent(outfile, level)
            outfile.write('control=%d,\n' % self.control)
        if self.analytics is not None:
            showIndent(outfile, level)
            outfile.write('analytics=%d,\n' % self.analytics)
        if self.dns is not None:
            showIndent(outfile, level)
            outfile.write('dns=%d,\n' % self.dns)
    def exportDict(self, name_='ControlTrafficDscpType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'control':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'control')
            self.control = ival_
            self.validate_DscpValueType(self.control)    # validate type DscpValueType
        elif nodeName_ == 'analytics':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'analytics')
            self.analytics = ival_
            self.validate_DscpValueType(self.analytics)    # validate type DscpValueType
        elif nodeName_ == 'dns':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'dns')
            self.dns = ival_
            self.validate_DscpValueType(self.dns)    # validate type DscpValueType
# end class ControlTrafficDscpType


class GracefulRestartParametersType(GeneratedsSuper):
    """
    Attributes:
    * enable
        Type:           bool

        Description:
          Enable/Disable knob for all GR parameters to take effect

    * restart_time
        Type:           int, *within* [0, 4095]

        Description:
          Time (in seconds) taken by the restarting speaker to get back to stable state

    * long_lived_restart_time
        Type:           int, *within* [0, 16777215]

        Description:
          Extended Time (in seconds) taken by the restarting speaker after restart-time to

          get back to stable state

    * end_of_rib_timeout
        Type:           int, *within* [0, 4095]

        Description:
          Maximum time (in seconds) to wait for EndOfRib reception/transmission

    * bgp_helper_enable
        Type:           bool

        Description:
          Enable GR Helper mode for BGP peers in contrail-control

    * xmpp_helper_enable
        Type:           bool

        Description:
          Enable GR Helper mode for XMPP peers (agents) in contrail-control

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'enable', u'restart_time', u'long_lived_restart_time', u'end_of_rib_timeout', u'bgp_helper_enable', u'xmpp_helper_enable']
    attr_field_type_vals = {u'enable': {'restrictions': None, 'description': [u'Enable/Disable knob for all GR parameters to take effect'], 'simple_type': u'xsd:boolean', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'boolean'}, u'end_of_rib_timeout': {'restrictions': [0, 4095], 'description': [u'Maximum time (in seconds) to wait for EndOfRib reception/transmission'], 'simple_type': u'EndOfRibTimeType', 'is_complex': 0, 'restriction_type': 'range', 'is_array': False, 'required': None, 'attr_type': u'integer'}, u'bgp_helper_enable': {'restrictions': None, 'description': [u'Enable GR Helper mode for BGP peers in contrail-control'], 'simple_type': u'xsd:boolean', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'boolean'}, u'xmpp_helper_enable': {'restrictions': None, 'description': [u'Enable GR Helper mode for XMPP peers (agents) in contrail-control'], 'simple_type': u'xsd:boolean', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'boolean'}, u'restart_time': {'restrictions': [0, 4095], 'description': [u'Time (in seconds) taken by the restarting speaker to get back to stable state'], 'simple_type': u'GracefulRestartTimeType', 'is_complex': 0, 'restriction_type': 'range', 'is_array': False, 'required': None, 'attr_type': u'integer'}, u'long_lived_restart_time': {'restrictions': [0, 16777215], 'description': [u'Extended Time (in seconds) taken by the restarting speaker after restart-time to get back to stable state'], 'simple_type': u'LongLivedGracefulRestartTimeType', 'is_complex': 0, 'restriction_type': 'range', 'is_array': False, 'required': None, 'attr_type': u'integer'}}
    def __init__(self, enable=False, restart_time=300, long_lived_restart_time=300, end_of_rib_timeout=300, bgp_helper_enable=False, xmpp_helper_enable=False, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _enable = params_dict[u"enable"]
        except KeyError:
            _enable = enable
        self.enable = _enable
        try:
            _restart_time = params_dict[u"restart_time"]
        except KeyError:
            _restart_time = restart_time
        self.restart_time = _restart_time
        try:
            _long_lived_restart_time = params_dict[u"long_lived_restart_time"]
        except KeyError:
            _long_lived_restart_time = long_lived_restart_time
        self.long_lived_restart_time = _long_lived_restart_time
        try:
            _end_of_rib_timeout = params_dict[u"end_of_rib_timeout"]
        except KeyError:
            _end_of_rib_timeout = end_of_rib_timeout
        self.end_of_rib_timeout = _end_of_rib_timeout
        try:
            _bgp_helper_enable = params_dict[u"bgp_helper_enable"]
        except KeyError:
            _bgp_helper_enable = bgp_helper_enable
        self.bgp_helper_enable = _bgp_helper_enable
        try:
            _xmpp_helper_enable = params_dict[u"xmpp_helper_enable"]
        except KeyError:
            _xmpp_helper_enable = xmpp_helper_enable
        self.xmpp_helper_enable = _xmpp_helper_enable
    def factory(*args_, **kwargs_):
        if GracefulRestartParametersType.subclass:
            return GracefulRestartParametersType.subclass(*args_, **kwargs_)
        else:
            return GracefulRestartParametersType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_enable(self): return self.enable
    def set_enable(self, enable): self.enable = enable
    def get_restart_time(self): return self.restart_time
    def set_restart_time(self, restart_time): self.restart_time = restart_time
    def validate_GracefulRestartTimeType(self, value):
        # Validate type GracefulRestartTimeType, a restriction on xsd:integer.
        error = False
        if isinstance(value, list):
            v_int = list(map(int, value))
            v1, v2 = min(v_int), max(v_int)
        else:
            v1, v2 = int(value), int(value)
        error |= (v2 > 4095)
        if error:
            raise ValueError("GracefulRestartTimeType must be in the range {'minimum': 0}-{'maximum': 4095}")
    def get_long_lived_restart_time(self): return self.long_lived_restart_time
    def set_long_lived_restart_time(self, long_lived_restart_time): self.long_lived_restart_time = long_lived_restart_time
    def validate_LongLivedGracefulRestartTimeType(self, value):
        # Validate type LongLivedGracefulRestartTimeType, a restriction on xsd:integer.
        error = False
        if isinstance(value, list):
            v_int = list(map(int, value))
            v1, v2 = min(v_int), max(v_int)
        else:
            v1, v2 = int(value), int(value)
        error |= (v2 > 16777215)
        if error:
            raise ValueError("LongLivedGracefulRestartTimeType must be in the range {'minimum': 0}-{'maximum': 16777215}")
    def get_end_of_rib_timeout(self): return self.end_of_rib_timeout
    def set_end_of_rib_timeout(self, end_of_rib_timeout): self.end_of_rib_timeout = end_of_rib_timeout
    def validate_EndOfRibTimeType(self, value):
        # Validate type EndOfRibTimeType, a restriction on xsd:integer.
        error = False
        if isinstance(value, list):
            v_int = list(map(int, value))
            v1, v2 = min(v_int), max(v_int)
        else:
            v1, v2 = int(value), int(value)
        error |= (v2 > 4095)
        if error:
            raise ValueError("EndOfRibTimeType must be in the range {'minimum': 0}-{'maximum': 4095}")
    def get_bgp_helper_enable(self): return self.bgp_helper_enable
    def set_bgp_helper_enable(self, bgp_helper_enable): self.bgp_helper_enable = bgp_helper_enable
    def get_xmpp_helper_enable(self): return self.xmpp_helper_enable
    def set_xmpp_helper_enable(self, xmpp_helper_enable): self.xmpp_helper_enable = xmpp_helper_enable
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.enable == other.enable and
                    self.restart_time == other.restart_time and
                    self.long_lived_restart_time == other.long_lived_restart_time and
                    self.end_of_rib_timeout == other.end_of_rib_timeout and
                    self.bgp_helper_enable == other.bgp_helper_enable and
                    self.xmpp_helper_enable == other.xmpp_helper_enable)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.enable if self.enable is not None else -7985492147856592190,
                     self.restart_time if self.restart_time is not None else -7985492147856592190,
                     self.long_lived_restart_time if self.long_lived_restart_time is not None else -7985492147856592190,
                     self.end_of_rib_timeout if self.end_of_rib_timeout is not None else -7985492147856592190,
                     self.bgp_helper_enable if self.bgp_helper_enable is not None else -7985492147856592190,
                     self.xmpp_helper_enable if self.xmpp_helper_enable is not None else -7985492147856592190))

    def __repr__(self):
        return ("enable = " + str(self.enable) + ", " +
                "restart_time = " + str(self.restart_time) + ", " +
                "long_lived_restart_time = " + str(self.long_lived_restart_time) + ", " +
                "end_of_rib_timeout = " + str(self.end_of_rib_timeout) + ", " +
                "bgp_helper_enable = " + str(self.bgp_helper_enable) + ", " +
                "xmpp_helper_enable = " + str(self.xmpp_helper_enable))

    def copy(self):
        cp = GracefulRestartParametersType()
        if self.enable is not None:
            cp.enable = self.enable
        if self.restart_time is not None:
            cp.restart_time = self.restart_time
        if self.long_lived_restart_time is not None:
            cp.long_lived_restart_time = self.long_lived_restart_time
        if self.end_of_rib_timeout is not None:
            cp.end_of_rib_timeout = self.end_of_rib_timeout
        if self.bgp_helper_enable is not None:
            cp.bgp_helper_enable = self.bgp_helper_enable
        if self.xmpp_helper_enable is not None:
            cp.xmpp_helper_enable = self.xmpp_helper_enable
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_enable (obj.populate_boolean ("enable"))
        obj.set_restart_time (obj.populate_integer ("restart_time"))
        obj.set_long_lived_restart_time (obj.populate_integer ("long_lived_restart_time"))
        obj.set_end_of_rib_timeout (obj.populate_integer ("end_of_rib_timeout"))
        obj.set_bgp_helper_enable (obj.populate_boolean ("bgp_helper_enable"))
        obj.set_xmpp_helper_enable (obj.populate_boolean ("xmpp_helper_enable"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='GracefulRestartParametersType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GracefulRestartParametersType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GracefulRestartParametersType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GracefulRestartParametersType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.enable is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%senable>%s</%senable>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.enable)), input_name='enable'), namespace_, eol_))
        if self.restart_time is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srestart-time>%s</%srestart-time>%s' % (namespace_, self.gds_format_integer(self.restart_time, input_name='restart-time'), namespace_, eol_))
        if self.long_lived_restart_time is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slong-lived-restart-time>%s</%slong-lived-restart-time>%s' % (namespace_, self.gds_format_integer(self.long_lived_restart_time, input_name='long-lived-restart-time'), namespace_, eol_))
        if self.end_of_rib_timeout is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%send-of-rib-timeout>%s</%send-of-rib-timeout>%s' % (namespace_, self.gds_format_integer(self.end_of_rib_timeout, input_name='end-of-rib-timeout'), namespace_, eol_))
        if self.bgp_helper_enable is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbgp-helper-enable>%s</%sbgp-helper-enable>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.bgp_helper_enable)), input_name='bgp-helper-enable'), namespace_, eol_))
        if self.xmpp_helper_enable is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxmpp-helper-enable>%s</%sxmpp-helper-enable>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.xmpp_helper_enable)), input_name='xmpp-helper-enable'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.enable is not None or
            self.restart_time is not None or
            self.long_lived_restart_time is not None or
            self.end_of_rib_timeout is not None or
            self.bgp_helper_enable is not None or
            self.xmpp_helper_enable is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GracefulRestartParametersType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.enable is not None:
            showIndent(outfile, level)
            outfile.write('enable=%s,\n' % self.enable)
        if self.restart_time is not None:
            showIndent(outfile, level)
            outfile.write('restart_time=%d,\n' % self.restart_time)
        if self.long_lived_restart_time is not None:
            showIndent(outfile, level)
            outfile.write('long_lived_restart_time=%d,\n' % self.long_lived_restart_time)
        if self.end_of_rib_timeout is not None:
            showIndent(outfile, level)
            outfile.write('end_of_rib_timeout=%d,\n' % self.end_of_rib_timeout)
        if self.bgp_helper_enable is not None:
            showIndent(outfile, level)
            outfile.write('bgp_helper_enable=%s,\n' % self.bgp_helper_enable)
        if self.xmpp_helper_enable is not None:
            showIndent(outfile, level)
            outfile.write('xmpp_helper_enable=%s,\n' % self.xmpp_helper_enable)
    def exportDict(self, name_='GracefulRestartParametersType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'enable':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'enable')
            self.enable = ival_
        elif nodeName_ == 'restart-time':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'restart_time')
            self.restart_time = ival_
            self.validate_GracefulRestartTimeType(self.restart_time)    # validate type GracefulRestartTimeType
        elif nodeName_ == 'long-lived-restart-time':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'long_lived_restart_time')
            self.long_lived_restart_time = ival_
            self.validate_LongLivedGracefulRestartTimeType(self.long_lived_restart_time)    # validate type LongLivedGracefulRestartTimeType
        elif nodeName_ == 'end-of-rib-timeout':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'end_of_rib_timeout')
            self.end_of_rib_timeout = ival_
            self.validate_EndOfRibTimeType(self.end_of_rib_timeout)    # validate type EndOfRibTimeType
        elif nodeName_ == 'bgp-helper-enable':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'bgp_helper_enable')
            self.bgp_helper_enable = ival_
        elif nodeName_ == 'xmpp-helper-enable':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'xmpp_helper_enable')
            self.xmpp_helper_enable = ival_
# end class GracefulRestartParametersType


class PortTranslationPool(GeneratedsSuper):
    """
    Attributes:
    * protocol
        Type:           str

    * port_range
        Type:           :class:`.PortType`

        Created By:           User (optional)

        Description:
          Port range to be reserved for per layer 4 protocol for PAT

    * port_count
        Type:           :class:`.unsignedShort`

        Created By:           User (optional)

        Description:
          Number of ports per layer 4 protocol to be reserved for PAT

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'protocol', u'port_range', u'port_count']
    attr_field_type_vals = {u'port_range': {'restrictions': None, 'description': [u'Port range to be reserved for per layer 4 protocol for PAT'], 'simple_type': u'PortType', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': u'exclusive', 'attr_type': u'PortType'}, u'port_count': {'restrictions': None, 'description': [u'Number of ports per layer 4 protocol to be reserved for PAT'], 'simple_type': u'unsignedShort', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'exclusive', 'attr_type': u'string'}, u'protocol': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}}
    def __init__(self, protocol=None, port_range=None, port_count=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _protocol = params_dict[u"protocol"]
        except KeyError:
            _protocol = protocol
        self.protocol = _protocol
        try:
            _port_range = params_dict[u"port_range"]
        except KeyError:
            _port_range = port_range
        if isinstance(_port_range, dict):
            obj = PortType(params_dict=_port_range)
            self.port_range = obj
        else:
            self.port_range = _port_range
        try:
            _port_count = params_dict[u"port_count"]
        except KeyError:
            _port_count = port_count
        self.port_count = _port_count
    def factory(*args_, **kwargs_):
        if PortTranslationPool.subclass:
            return PortTranslationPool.subclass(*args_, **kwargs_)
        else:
            return PortTranslationPool(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_protocol(self): return self.protocol
    def set_protocol(self, protocol): self.protocol = protocol
    def get_port_range(self): return self.port_range
    def set_port_range(self, port_range): self.port_range = port_range
    def get_port_count(self): return self.port_count
    def set_port_count(self, port_count): self.port_count = port_count
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.protocol == other.protocol and
                    self.port_range == other.port_range and
                    self.port_count == other.port_count)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.protocol if self.protocol is not None else -7985492147856592190,
                     self.port_range if self.port_range is not None else -7985492147856592190,
                     self.port_count if self.port_count is not None else -7985492147856592190))

    def __repr__(self):
        return ("protocol = " + str(self.protocol) + ", " +
                "port_range = " + str(self.port_range) + ", " +
                "port_count = " + str(self.port_count))

    def copy(self):
        cp = PortTranslationPool()
        if self.protocol is not None:
            cp.protocol = self.protocol
        if self.port_range is not None:
            cp.port_range = self.port_range.copy()
        if self.port_count is not None:
            cp.port_count = self.port_count
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_protocol (obj.populate_string ("protocol"))
        obj.set_port_range (PortType.populate ())
        obj.set_port_count (obj.populate_string ("port_count"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='PortTranslationPool', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PortTranslationPool')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PortTranslationPool'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PortTranslationPool', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.protocol is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprotocol>%s</%sprotocol>%s' % (namespace_, self.gds_format_string(quote_xml(self.protocol).encode(ExternalEncoding), input_name='protocol'), namespace_, eol_))
        if self.port_range is not None:
            self.port_range.export_xml(outfile, level, namespace_, name_='port-range', pretty_print=pretty_print)
        if self.port_count is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sport-count>%s</%sport-count>%s' % (namespace_, self.gds_format_string(quote_xml(self.port_count).encode(ExternalEncoding), input_name='port-count'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.protocol is not None or
            self.port_range is not None or
            self.port_count is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PortTranslationPool'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.protocol is not None:
            showIndent(outfile, level)
            outfile.write('protocol=%s,\n' % quote_python(self.protocol).encode(ExternalEncoding))
        if self.port_range is not None:
            showIndent(outfile, level)
            outfile.write('port_range=model_.PortType(\n')
            self.port_range.exportLiteral(outfile, level, name_='port_range')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.port_count is not None:
            showIndent(outfile, level)
            outfile.write('port_count=%s,\n' % quote_python(self.port_count).encode(ExternalEncoding))
    def exportDict(self, name_='PortTranslationPool'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'protocol':
            protocol_ = child_.text
            protocol_ = self.gds_validate_string(protocol_, node, 'protocol')
            self.protocol = protocol_
        elif nodeName_ == 'port-range':
            obj_ = PortType.factory()
            obj_.build(child_)
            self.set_port_range(obj_)
        elif nodeName_ == 'port-count':
            port_count_ = child_.text
            port_count_ = self.gds_validate_string(port_count_, node, 'port_count')
            self.port_count = port_count_
# end class PortTranslationPool


class PortTranslationPools(GeneratedsSuper):
    """
    Attributes:
    * port_translation_pool
        Type:           :class:`.PortTranslationPool`

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'port_translation_pool']
    attr_field_type_vals = {u'port_translation_pool': {'restrictions': None, 'description': [], 'simple_type': u'PortTranslationPool', 'is_complex': 1, 'restriction_type': None, 'is_array': True, 'required': None, 'attr_type': u'PortTranslationPool'}}
    def __init__(self, port_translation_pool=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _port_translation_pool = params_dict[u"port_translation_pool"]
        except KeyError:
            _port_translation_pool = port_translation_pool
        if not _port_translation_pool:
            self.port_translation_pool = []
        else:
            if isinstance(_port_translation_pool[0], dict):
                objs = [PortTranslationPool(params_dict=elem) for elem in _port_translation_pool]
                self.port_translation_pool = objs
            else:
                self.port_translation_pool = _port_translation_pool
    def factory(*args_, **kwargs_):
        if PortTranslationPools.subclass:
            return PortTranslationPools.subclass(*args_, **kwargs_)
        else:
            return PortTranslationPools(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_port_translation_pool(self): return self.port_translation_pool
    def set_port_translation_pool(self, port_translation_pool): self.port_translation_pool = port_translation_pool
    def add_port_translation_pool(self, value): self.port_translation_pool.append(value)
    def insert_port_translation_pool(self, index, value): self.port_translation_pool[index] = value
    def delete_port_translation_pool(self, value): self.port_translation_pool.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.port_translation_pool == other.port_translation_pool)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.port_translation_pool or [])))

    def __repr__(self):
        return ("port_translation_pool = " + str(self.port_translation_pool))

    def copy(self):
        cp = PortTranslationPools()
        if self.port_translation_pool is not None:
            cp.port_translation_pool = [x.copy() for x in self.port_translation_pool]
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_port_translation_pool ([PortTranslationPool.populate ()])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='PortTranslationPools', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PortTranslationPools')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PortTranslationPools'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PortTranslationPools', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for port_translation_pool_ in self.port_translation_pool:
            if isinstance(port_translation_pool_, dict):
                port_translation_pool_ = PortTranslationPool(**port_translation_pool_)
            port_translation_pool_.export_xml(outfile, level, namespace_, name_='port-translation-pool', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.port_translation_pool
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PortTranslationPools'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('port_translation_pool=[\n')
        level += 1
        for port_translation_pool_ in self.port_translation_pool:
            showIndent(outfile, level)
            outfile.write('model_.PortTranslationPool(\n')
            port_translation_pool_.exportLiteral(outfile, level, name_='PortTranslationPool')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='PortTranslationPools'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'port-translation-pool':
            obj_ = PortTranslationPool.factory()
            obj_.build(child_)
            self.port_translation_pool.append(obj_)
# end class PortTranslationPools


class BGPaaSControlNodeZoneAttributes(GeneratedsSuper):
    """
    Attributes:
    * bgpaas_control_node_zone_type
        Type:           str, *one-of* [u'primary', u'secondary']

        Created By:           User (optional)

        Description:
          Specifies BGPaaSControlNodeZoneType. If bgpaas uses             x.x.x.1 ip for

          peering, BGPaaSControlNodeZoneType should be set to             primary. If it

          is x.x.x.2 ip for peering, BGPaaSControlNodeZoneType             should be

          secondary

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'bgpaas_control_node_zone_type']
    attr_field_type_vals = {u'bgpaas_control_node_zone_type': {'restrictions': [u'primary', u'secondary'], 'description': [u'Specifies BGPaaSControlNodeZoneType. If bgpaas uses             x.x.x.1 ip for peering, BGPaaSControlNodeZoneType should be set to             primary. If it is x.x.x.2 ip for peering, BGPaaSControlNodeZoneType             should be secondary'], 'simple_type': u'BGPaaSControlNodeZoneType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'optional', 'attr_type': u'string'}}
    def __init__(self, bgpaas_control_node_zone_type=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _bgpaas_control_node_zone_type = params_dict[u"bgpaas_control_node_zone_type"]
        except KeyError:
            _bgpaas_control_node_zone_type = bgpaas_control_node_zone_type
        self.bgpaas_control_node_zone_type = _bgpaas_control_node_zone_type
    def factory(*args_, **kwargs_):
        if BGPaaSControlNodeZoneAttributes.subclass:
            return BGPaaSControlNodeZoneAttributes.subclass(*args_, **kwargs_)
        else:
            return BGPaaSControlNodeZoneAttributes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_bgpaas_control_node_zone_type(self): return self.bgpaas_control_node_zone_type
    def set_bgpaas_control_node_zone_type(self, bgpaas_control_node_zone_type): self.bgpaas_control_node_zone_type = bgpaas_control_node_zone_type
    def validate_BGPaaSControlNodeZoneType(self, value):
        # Validate type BGPaaSControlNodeZoneType, a restriction on xsd:string.
        error = False
        if isinstance(value, list):
            error = set(value) - set([u'primary', u'secondary'])
        else:
            error = value not in [u'primary', u'secondary']
        if error:
            raise ValueError("BGPaaSControlNodeZoneType must be one of [u'primary', u'secondary']")
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.bgpaas_control_node_zone_type == other.bgpaas_control_node_zone_type)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.bgpaas_control_node_zone_type if self.bgpaas_control_node_zone_type is not None else -7985492147856592190))

    def __repr__(self):
        return ("bgpaas_control_node_zone_type = " + str(self.bgpaas_control_node_zone_type))

    def copy(self):
        cp = BGPaaSControlNodeZoneAttributes()
        if self.bgpaas_control_node_zone_type is not None:
            cp.bgpaas_control_node_zone_type = self.bgpaas_control_node_zone_type
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_bgpaas_control_node_zone_type (obj.populate_string ("bgpaas_control_node_zone_type"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='BGPaaSControlNodeZoneAttributes', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BGPaaSControlNodeZoneAttributes')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BGPaaSControlNodeZoneAttributes'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='BGPaaSControlNodeZoneAttributes', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.bgpaas_control_node_zone_type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbgpaas-control-node-zone-type>%s</%sbgpaas-control-node-zone-type>%s' % (namespace_, self.gds_format_string(quote_xml(self.bgpaas_control_node_zone_type).encode(ExternalEncoding), input_name='bgpaas-control-node-zone-type'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.bgpaas_control_node_zone_type is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BGPaaSControlNodeZoneAttributes'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.bgpaas_control_node_zone_type is not None:
            showIndent(outfile, level)
            outfile.write('bgpaas_control_node_zone_type=%s,\n' % quote_python(self.bgpaas_control_node_zone_type).encode(ExternalEncoding))
    def exportDict(self, name_='BGPaaSControlNodeZoneAttributes'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'bgpaas-control-node-zone-type':
            bgpaas_control_node_zone_type_ = child_.text
            bgpaas_control_node_zone_type_ = self.gds_validate_string(bgpaas_control_node_zone_type_, node, 'bgpaas_control_node_zone_type')
            self.bgpaas_control_node_zone_type = bgpaas_control_node_zone_type_
            self.validate_BGPaaSControlNodeZoneType(self.bgpaas_control_node_zone_type)    # validate type BGPaaSControlNodeZoneType
# end class BGPaaSControlNodeZoneAttributes


class BGPaaServiceParametersType(GeneratedsSuper):
    """
    Attributes:
    * port_start
        Type:           int, *within* [-1, 65535]

    * port_end
        Type:           int, *within* [-1, 65535]

    """
    """port-start is the start of port range for bgp as service object.
    port-end is the end of port range for bgp as service object."""
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'port_start', u'port_end']
    attr_field_type_vals = {u'port_start': {'restrictions': [-1, 65535], 'description': [], 'simple_type': u'L4PortType', 'is_complex': 0, 'restriction_type': 'range', 'is_array': False, 'required': None, 'attr_type': u'integer'}, u'port_end': {'restrictions': [-1, 65535], 'description': [], 'simple_type': u'L4PortType', 'is_complex': 0, 'restriction_type': 'range', 'is_array': False, 'required': None, 'attr_type': u'integer'}}
    def __init__(self, port_start=50000, port_end=50512, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _port_start = params_dict[u"port_start"]
        except KeyError:
            _port_start = port_start
        self.port_start = _port_start
        try:
            _port_end = params_dict[u"port_end"]
        except KeyError:
            _port_end = port_end
        self.port_end = _port_end
    def factory(*args_, **kwargs_):
        if BGPaaServiceParametersType.subclass:
            return BGPaaServiceParametersType.subclass(*args_, **kwargs_)
        else:
            return BGPaaServiceParametersType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_port_start(self): return self.port_start
    def set_port_start(self, port_start): self.port_start = port_start
    def validate_L4PortType(self, value):
        # Validate type L4PortType, a restriction on xsd:integer.
        error = False
        if isinstance(value, list):
            v_int = list(map(int, value))
            v1, v2 = min(v_int), max(v_int)
        else:
            v1, v2 = int(value), int(value)
        error = (-1 > v1)
        error |= (v2 > 65535)
        if error:
            raise ValueError("L4PortType must be in the range {'minimum': -1}-{'maximum': 65535}")
    def get_port_end(self): return self.port_end
    def set_port_end(self, port_end): self.port_end = port_end
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.port_start == other.port_start and
                    self.port_end == other.port_end)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.port_start if self.port_start is not None else -7985492147856592190,
                     self.port_end if self.port_end is not None else -7985492147856592190))

    def __repr__(self):
        return ("port_start = " + str(self.port_start) + ", " +
                "port_end = " + str(self.port_end))

    def copy(self):
        cp = BGPaaServiceParametersType()
        if self.port_start is not None:
            cp.port_start = self.port_start
        if self.port_end is not None:
            cp.port_end = self.port_end
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_port_start (obj.populate_integer ("port_start"))
        obj.set_port_end (obj.populate_integer ("port_end"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='BGPaaServiceParametersType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BGPaaServiceParametersType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BGPaaServiceParametersType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='BGPaaServiceParametersType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.port_start is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sport-start>%s</%sport-start>%s' % (namespace_, self.gds_format_integer(self.port_start, input_name='port-start'), namespace_, eol_))
        if self.port_end is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sport-end>%s</%sport-end>%s' % (namespace_, self.gds_format_integer(self.port_end, input_name='port-end'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.port_start is not None or
            self.port_end is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BGPaaServiceParametersType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.port_start is not None:
            showIndent(outfile, level)
            outfile.write('port_start=%d,\n' % self.port_start)
        if self.port_end is not None:
            showIndent(outfile, level)
            outfile.write('port_end=%d,\n' % self.port_end)
    def exportDict(self, name_='BGPaaServiceParametersType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'port-start':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'port_start')
            self.port_start = ival_
            self.validate_L4PortType(self.port_start)    # validate type L4PortType
        elif nodeName_ == 'port-end':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'port_end')
            self.port_end = ival_
            self.validate_L4PortType(self.port_end)    # validate type L4PortType
# end class BGPaaServiceParametersType


class SecurityLoggingObjectRuleEntryType(GeneratedsSuper):
    """
    Attributes:
    * rule_uuid
        Type:           str

        Created By:           User (optional)

        Description:
          Rule UUID of network policy or security-group. When this is absent it implies

          all rules of security-group or network-policy

    * rate
        Type:           int

        Created By:           User (optional)

        Description:
          Rate at which sessions are logged. When rates are specified at multiple levels,

          the rate which specifies highest frequency is selected

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'rule_uuid', u'rate']
    attr_field_type_vals = {u'rule_uuid': {'restrictions': None, 'description': [u'Rule UUID of network policy or security-group. When this is absent it implies all rules of security-group or network-policy'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'rate': {'restrictions': None, 'description': [u'Rate at which sessions are logged. When rates are specified at multiple levels, the rate which specifies highest frequency is selected'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}}
    def __init__(self, rule_uuid=None, rate=100, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _rule_uuid = params_dict[u"rule_uuid"]
        except KeyError:
            _rule_uuid = rule_uuid
        self.rule_uuid = _rule_uuid
        try:
            _rate = params_dict[u"rate"]
        except KeyError:
            _rate = rate
        self.rate = _rate
    def factory(*args_, **kwargs_):
        if SecurityLoggingObjectRuleEntryType.subclass:
            return SecurityLoggingObjectRuleEntryType.subclass(*args_, **kwargs_)
        else:
            return SecurityLoggingObjectRuleEntryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rule_uuid(self): return self.rule_uuid
    def set_rule_uuid(self, rule_uuid): self.rule_uuid = rule_uuid
    def get_rate(self): return self.rate
    def set_rate(self, rate): self.rate = rate
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.rule_uuid == other.rule_uuid and
                    self.rate == other.rate)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.rule_uuid if self.rule_uuid is not None else -7985492147856592190,
                     self.rate if self.rate is not None else -7985492147856592190))

    def __repr__(self):
        return ("rule_uuid = " + str(self.rule_uuid) + ", " +
                "rate = " + str(self.rate))

    def copy(self):
        cp = SecurityLoggingObjectRuleEntryType()
        if self.rule_uuid is not None:
            cp.rule_uuid = self.rule_uuid
        if self.rate is not None:
            cp.rate = self.rate
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_rule_uuid (obj.populate_string ("rule_uuid"))
        obj.set_rate (obj.populate_integer ("rate"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='SecurityLoggingObjectRuleEntryType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SecurityLoggingObjectRuleEntryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SecurityLoggingObjectRuleEntryType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SecurityLoggingObjectRuleEntryType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.rule_uuid is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srule-uuid>%s</%srule-uuid>%s' % (namespace_, self.gds_format_string(quote_xml(self.rule_uuid).encode(ExternalEncoding), input_name='rule-uuid'), namespace_, eol_))
        if self.rate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srate>%s</%srate>%s' % (namespace_, self.gds_format_integer(self.rate, input_name='rate'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.rule_uuid is not None or
            self.rate is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SecurityLoggingObjectRuleEntryType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.rule_uuid is not None:
            showIndent(outfile, level)
            outfile.write('rule_uuid=%s,\n' % quote_python(self.rule_uuid).encode(ExternalEncoding))
        if self.rate is not None:
            showIndent(outfile, level)
            outfile.write('rate=%d,\n' % self.rate)
    def exportDict(self, name_='SecurityLoggingObjectRuleEntryType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'rule-uuid':
            rule_uuid_ = child_.text
            rule_uuid_ = self.gds_validate_string(rule_uuid_, node, 'rule_uuid')
            self.rule_uuid = rule_uuid_
        elif nodeName_ == 'rate':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'rate')
            self.rate = ival_
# end class SecurityLoggingObjectRuleEntryType


class SecurityLoggingObjectRuleListType(GeneratedsSuper):
    """
    Attributes:
    * rule
        Type:           :class:`.SecurityLoggingObjectRuleEntryType`

        Created By:           User (optional)

        Description:
          List of rules along with logging rate for each rule. Both rule-uuid and rate are

          optional. When rule-uuid is absent then it means all rules of associated SG or

          network-policy

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'rule']
    attr_field_type_vals = {u'rule': {'restrictions': None, 'description': [u'List of rules along with logging rate for each rule. Both rule-uuid and rate are optional. When rule-uuid is absent then it means all rules of associated SG or network-policy'], 'simple_type': u'SecurityLoggingObjectRuleEntryType', 'is_complex': 1, 'restriction_type': None, 'is_array': True, 'required': u'optional', 'attr_type': u'SecurityLoggingObjectRuleEntryType'}}
    def __init__(self, rule=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _rule = params_dict[u"rule"]
        except KeyError:
            _rule = rule
        if not _rule:
            self.rule = []
        else:
            if isinstance(_rule[0], dict):
                objs = [SecurityLoggingObjectRuleEntryType(params_dict=elem) for elem in _rule]
                self.rule = objs
            else:
                self.rule = _rule
    def factory(*args_, **kwargs_):
        if SecurityLoggingObjectRuleListType.subclass:
            return SecurityLoggingObjectRuleListType.subclass(*args_, **kwargs_)
        else:
            return SecurityLoggingObjectRuleListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rule(self): return self.rule
    def set_rule(self, rule): self.rule = rule
    def add_rule(self, value): self.rule.append(value)
    def insert_rule(self, index, value): self.rule[index] = value
    def delete_rule(self, value): self.rule.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.rule == other.rule)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.rule or [])))

    def __repr__(self):
        return ("rule = " + str(self.rule))

    def copy(self):
        cp = SecurityLoggingObjectRuleListType()
        if self.rule is not None:
            cp.rule = [x.copy() for x in self.rule]
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_rule ([SecurityLoggingObjectRuleEntryType.populate ()])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='SecurityLoggingObjectRuleListType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SecurityLoggingObjectRuleListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SecurityLoggingObjectRuleListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SecurityLoggingObjectRuleListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for rule_ in self.rule:
            if isinstance(rule_, dict):
                rule_ = SecurityLoggingObjectRuleEntryType(**rule_)
            rule_.export_xml(outfile, level, namespace_, name_='rule', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.rule
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SecurityLoggingObjectRuleListType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('rule=[\n')
        level += 1
        for rule_ in self.rule:
            showIndent(outfile, level)
            outfile.write('model_.SecurityLoggingObjectRuleEntryType(\n')
            rule_.exportLiteral(outfile, level, name_='SecurityLoggingObjectRuleEntryType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='SecurityLoggingObjectRuleListType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'rule':
            obj_ = SecurityLoggingObjectRuleEntryType.factory()
            obj_.build(child_)
            self.rule.append(obj_)
# end class SecurityLoggingObjectRuleListType


class EcmpHashingIncludeFields(GeneratedsSuper):
    """
    Attributes:
    * hashing_configured
        Type:           bool

        Created By:           User (optional)

        Description:
          When True, Packet header fields used in calculating ECMP hash is decided by

          following flags

    * source_ip
        Type:           bool

        Created By:           User (optional)

        Description:
          When false, do not use source ip in the ECMP hash calculation

    * destination_ip
        Type:           bool

        Created By:           User (optional)

        Description:
          When false, do not use destination ip in the ECMP hash calculation

    * ip_protocol
        Type:           bool

        Created By:           User (optional)

        Description:
          When false, do not use ip protocol in the ECMP hash calculation

    * source_port
        Type:           bool

        Created By:           User (optional)

        Description:
          When false, do not use source port in the ECMP hash calculation

    * destination_port
        Type:           bool

        Created By:           User (optional)

        Description:
          When false, do not use destination port in the ECMP hash calculation

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'hashing_configured', u'source_ip', u'destination_ip', u'ip_protocol', u'source_port', u'destination_port']
    attr_field_type_vals = {u'destination_ip': {'restrictions': None, 'description': [u'When false, do not use destination ip in the ECMP hash calculation'], 'simple_type': u'xsd:boolean', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'boolean'}, u'ip_protocol': {'restrictions': None, 'description': [u'When false, do not use ip protocol in the ECMP hash calculation'], 'simple_type': u'xsd:boolean', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'boolean'}, u'source_ip': {'restrictions': None, 'description': [u'When false, do not use source ip in the ECMP hash calculation'], 'simple_type': u'xsd:boolean', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'boolean'}, u'hashing_configured': {'restrictions': None, 'description': [u'When True, Packet header fields used in calculating ECMP hash is decided by following flags'], 'simple_type': u'xsd:boolean', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'boolean'}, u'source_port': {'restrictions': None, 'description': [u'When false, do not use source port in the ECMP hash calculation'], 'simple_type': u'xsd:boolean', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'boolean'}, u'destination_port': {'restrictions': None, 'description': [u'When false, do not use destination port in the ECMP hash calculation'], 'simple_type': u'xsd:boolean', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'boolean'}}
    def __init__(self, hashing_configured=False, source_ip=True, destination_ip=True, ip_protocol=True, source_port=True, destination_port=True, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _hashing_configured = params_dict[u"hashing_configured"]
        except KeyError:
            _hashing_configured = hashing_configured
        self.hashing_configured = _hashing_configured
        try:
            _source_ip = params_dict[u"source_ip"]
        except KeyError:
            _source_ip = source_ip
        self.source_ip = _source_ip
        try:
            _destination_ip = params_dict[u"destination_ip"]
        except KeyError:
            _destination_ip = destination_ip
        self.destination_ip = _destination_ip
        try:
            _ip_protocol = params_dict[u"ip_protocol"]
        except KeyError:
            _ip_protocol = ip_protocol
        self.ip_protocol = _ip_protocol
        try:
            _source_port = params_dict[u"source_port"]
        except KeyError:
            _source_port = source_port
        self.source_port = _source_port
        try:
            _destination_port = params_dict[u"destination_port"]
        except KeyError:
            _destination_port = destination_port
        self.destination_port = _destination_port
    def factory(*args_, **kwargs_):
        if EcmpHashingIncludeFields.subclass:
            return EcmpHashingIncludeFields.subclass(*args_, **kwargs_)
        else:
            return EcmpHashingIncludeFields(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_hashing_configured(self): return self.hashing_configured
    def set_hashing_configured(self, hashing_configured): self.hashing_configured = hashing_configured
    def get_source_ip(self): return self.source_ip
    def set_source_ip(self, source_ip): self.source_ip = source_ip
    def get_destination_ip(self): return self.destination_ip
    def set_destination_ip(self, destination_ip): self.destination_ip = destination_ip
    def get_ip_protocol(self): return self.ip_protocol
    def set_ip_protocol(self, ip_protocol): self.ip_protocol = ip_protocol
    def get_source_port(self): return self.source_port
    def set_source_port(self, source_port): self.source_port = source_port
    def get_destination_port(self): return self.destination_port
    def set_destination_port(self, destination_port): self.destination_port = destination_port
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.hashing_configured == other.hashing_configured and
                    self.source_ip == other.source_ip and
                    self.destination_ip == other.destination_ip and
                    self.ip_protocol == other.ip_protocol and
                    self.source_port == other.source_port and
                    self.destination_port == other.destination_port)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.hashing_configured if self.hashing_configured is not None else -7985492147856592190,
                     self.source_ip if self.source_ip is not None else -7985492147856592190,
                     self.destination_ip if self.destination_ip is not None else -7985492147856592190,
                     self.ip_protocol if self.ip_protocol is not None else -7985492147856592190,
                     self.source_port if self.source_port is not None else -7985492147856592190,
                     self.destination_port if self.destination_port is not None else -7985492147856592190))

    def __repr__(self):
        return ("hashing_configured = " + str(self.hashing_configured) + ", " +
                "source_ip = " + str(self.source_ip) + ", " +
                "destination_ip = " + str(self.destination_ip) + ", " +
                "ip_protocol = " + str(self.ip_protocol) + ", " +
                "source_port = " + str(self.source_port) + ", " +
                "destination_port = " + str(self.destination_port))

    def copy(self):
        cp = EcmpHashingIncludeFields()
        if self.hashing_configured is not None:
            cp.hashing_configured = self.hashing_configured
        if self.source_ip is not None:
            cp.source_ip = self.source_ip
        if self.destination_ip is not None:
            cp.destination_ip = self.destination_ip
        if self.ip_protocol is not None:
            cp.ip_protocol = self.ip_protocol
        if self.source_port is not None:
            cp.source_port = self.source_port
        if self.destination_port is not None:
            cp.destination_port = self.destination_port
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_hashing_configured (obj.populate_boolean ("hashing_configured"))
        obj.set_source_ip (obj.populate_boolean ("source_ip"))
        obj.set_destination_ip (obj.populate_boolean ("destination_ip"))
        obj.set_ip_protocol (obj.populate_boolean ("ip_protocol"))
        obj.set_source_port (obj.populate_boolean ("source_port"))
        obj.set_destination_port (obj.populate_boolean ("destination_port"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='EcmpHashingIncludeFields', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EcmpHashingIncludeFields')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EcmpHashingIncludeFields'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='EcmpHashingIncludeFields', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.hashing_configured is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shashing-configured>%s</%shashing-configured>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.hashing_configured)), input_name='hashing-configured'), namespace_, eol_))
        if self.source_ip is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssource-ip>%s</%ssource-ip>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.source_ip)), input_name='source-ip'), namespace_, eol_))
        if self.destination_ip is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdestination-ip>%s</%sdestination-ip>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.destination_ip)), input_name='destination-ip'), namespace_, eol_))
        if self.ip_protocol is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sip-protocol>%s</%sip-protocol>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.ip_protocol)), input_name='ip-protocol'), namespace_, eol_))
        if self.source_port is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssource-port>%s</%ssource-port>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.source_port)), input_name='source-port'), namespace_, eol_))
        if self.destination_port is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdestination-port>%s</%sdestination-port>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.destination_port)), input_name='destination-port'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.hashing_configured is not None or
            self.source_ip is not None or
            self.destination_ip is not None or
            self.ip_protocol is not None or
            self.source_port is not None or
            self.destination_port is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EcmpHashingIncludeFields'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.hashing_configured is not None:
            showIndent(outfile, level)
            outfile.write('hashing_configured=%s,\n' % self.hashing_configured)
        if self.source_ip is not None:
            showIndent(outfile, level)
            outfile.write('source_ip=%s,\n' % self.source_ip)
        if self.destination_ip is not None:
            showIndent(outfile, level)
            outfile.write('destination_ip=%s,\n' % self.destination_ip)
        if self.ip_protocol is not None:
            showIndent(outfile, level)
            outfile.write('ip_protocol=%s,\n' % self.ip_protocol)
        if self.source_port is not None:
            showIndent(outfile, level)
            outfile.write('source_port=%s,\n' % self.source_port)
        if self.destination_port is not None:
            showIndent(outfile, level)
            outfile.write('destination_port=%s,\n' % self.destination_port)
    def exportDict(self, name_='EcmpHashingIncludeFields'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'hashing-configured':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'hashing_configured')
            self.hashing_configured = ival_
        elif nodeName_ == 'source-ip':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'source_ip')
            self.source_ip = ival_
        elif nodeName_ == 'destination-ip':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'destination_ip')
            self.destination_ip = ival_
        elif nodeName_ == 'ip-protocol':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'ip_protocol')
            self.ip_protocol = ival_
        elif nodeName_ == 'source-port':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'source_port')
            self.source_port = ival_
        elif nodeName_ == 'destination-port':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'destination_port')
            self.destination_port = ival_
# end class EcmpHashingIncludeFields


class EncryptionTunnelEndpoint(GeneratedsSuper):
    """
    Attributes:
    * tunnel_remote_ip_address
        Type:           str, *one-of* xsd:string

        Created By:           User (required)

        Description:
          Tunnel endpoint remote address

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'tunnel_remote_ip_address']
    attr_field_type_vals = {u'tunnel_remote_ip_address': {'restrictions': [], 'description': [u'Tunnel endpoint remote address'], 'simple_type': u'IpAddressType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'true', 'attr_type': u'string'}}
    def __init__(self, tunnel_remote_ip_address=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _tunnel_remote_ip_address = params_dict[u"tunnel_remote_ip_address"]
        except KeyError:
            _tunnel_remote_ip_address = tunnel_remote_ip_address
        self.tunnel_remote_ip_address = _tunnel_remote_ip_address
    def factory(*args_, **kwargs_):
        if EncryptionTunnelEndpoint.subclass:
            return EncryptionTunnelEndpoint.subclass(*args_, **kwargs_)
        else:
            return EncryptionTunnelEndpoint(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tunnel_remote_ip_address(self): return self.tunnel_remote_ip_address
    def set_tunnel_remote_ip_address(self, tunnel_remote_ip_address): self.tunnel_remote_ip_address = tunnel_remote_ip_address
    def validate_IpAddressType(self, value):
        # Validate type IpAddressType, a restriction on xsd:string.
        pass
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.tunnel_remote_ip_address == other.tunnel_remote_ip_address)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.tunnel_remote_ip_address if self.tunnel_remote_ip_address is not None else -7985492147856592190))

    def __repr__(self):
        return ("tunnel_remote_ip_address = " + str(self.tunnel_remote_ip_address))

    def copy(self):
        cp = EncryptionTunnelEndpoint()
        if self.tunnel_remote_ip_address is not None:
            cp.tunnel_remote_ip_address = self.tunnel_remote_ip_address
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_tunnel_remote_ip_address (obj.populate_string ("tunnel_remote_ip_address"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='EncryptionTunnelEndpoint', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EncryptionTunnelEndpoint')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EncryptionTunnelEndpoint'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='EncryptionTunnelEndpoint', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tunnel_remote_ip_address is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stunnel-remote-ip-address>%s</%stunnel-remote-ip-address>%s' % (namespace_, self.gds_format_string(quote_xml(self.tunnel_remote_ip_address).encode(ExternalEncoding), input_name='tunnel-remote-ip-address'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.tunnel_remote_ip_address is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EncryptionTunnelEndpoint'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.tunnel_remote_ip_address is not None:
            showIndent(outfile, level)
            outfile.write('tunnel_remote_ip_address=%s,\n' % quote_python(self.tunnel_remote_ip_address).encode(ExternalEncoding))
    def exportDict(self, name_='EncryptionTunnelEndpoint'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tunnel-remote-ip-address':
            tunnel_remote_ip_address_ = child_.text
            tunnel_remote_ip_address_ = self.gds_validate_string(tunnel_remote_ip_address_, node, 'tunnel_remote_ip_address')
            self.tunnel_remote_ip_address = tunnel_remote_ip_address_
            self.validate_IpAddressType(self.tunnel_remote_ip_address)    # validate type IpAddressType
# end class EncryptionTunnelEndpoint


class EncryptionTunnelEndpointList(GeneratedsSuper):
    """
    Attributes:
    * endpoint
        Type:           :class:`.EncryptionTunnelEndpoint`

        Description:
          Tunnel endpoint remote address

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'endpoint']
    attr_field_type_vals = {u'endpoint': {'restrictions': None, 'description': [u'Tunnel endpoint remote address'], 'simple_type': u'EncryptionTunnelEndpoint', 'is_complex': 1, 'restriction_type': None, 'is_array': True, 'required': None, 'attr_type': u'EncryptionTunnelEndpoint'}}
    def __init__(self, endpoint=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _endpoint = params_dict[u"endpoint"]
        except KeyError:
            _endpoint = endpoint
        if not _endpoint:
            self.endpoint = []
        else:
            if isinstance(_endpoint[0], dict):
                objs = [EncryptionTunnelEndpoint(params_dict=elem) for elem in _endpoint]
                self.endpoint = objs
            else:
                self.endpoint = _endpoint
    def factory(*args_, **kwargs_):
        if EncryptionTunnelEndpointList.subclass:
            return EncryptionTunnelEndpointList.subclass(*args_, **kwargs_)
        else:
            return EncryptionTunnelEndpointList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_endpoint(self): return self.endpoint
    def set_endpoint(self, endpoint): self.endpoint = endpoint
    def add_endpoint(self, value): self.endpoint.append(value)
    def insert_endpoint(self, index, value): self.endpoint[index] = value
    def delete_endpoint(self, value): self.endpoint.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.endpoint == other.endpoint)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.endpoint or [])))

    def __repr__(self):
        return ("endpoint = " + str(self.endpoint))

    def copy(self):
        cp = EncryptionTunnelEndpointList()
        if self.endpoint is not None:
            cp.endpoint = [x.copy() for x in self.endpoint]
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_endpoint ([EncryptionTunnelEndpoint.populate ()])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='EncryptionTunnelEndpointList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EncryptionTunnelEndpointList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EncryptionTunnelEndpointList'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='EncryptionTunnelEndpointList', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for endpoint_ in self.endpoint:
            if isinstance(endpoint_, dict):
                endpoint_ = EncryptionTunnelEndpoint(**endpoint_)
            endpoint_.export_xml(outfile, level, namespace_, name_='endpoint', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.endpoint
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EncryptionTunnelEndpointList'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('endpoint=[\n')
        level += 1
        for endpoint_ in self.endpoint:
            showIndent(outfile, level)
            outfile.write('model_.EncryptionTunnelEndpoint(\n')
            endpoint_.exportLiteral(outfile, level, name_='EncryptionTunnelEndpoint')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='EncryptionTunnelEndpointList'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'endpoint':
            obj_ = EncryptionTunnelEndpoint.factory()
            obj_.build(child_)
            self.endpoint.append(obj_)
# end class EncryptionTunnelEndpointList


class VirtualNetworkRoutedPropertiesType(GeneratedsSuper):
    """
    Attributes:
    * routed_properties
        Type:           :class:`.RoutedProperties`

        Description:
          List of routed properties for virtual network.

    * shared_across_all_lrs
        Type:           bool

        Created By:           User (optional)

        Description:
          Allow sharing of this routed virtual network across all LR's in the system.

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'routed_properties', u'shared_across_all_lrs']
    attr_field_type_vals = {u'routed_properties': {'restrictions': None, 'description': [u'List of routed properties for virtual network.'], 'simple_type': u'RoutedProperties', 'is_complex': 1, 'restriction_type': None, 'is_array': True, 'required': None, 'attr_type': u'RoutedProperties'}, u'shared_across_all_lrs': {'restrictions': None, 'description': [u"Allow sharing of this routed virtual network across all LR's in the system."], 'simple_type': u'xsd:boolean', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'boolean'}}
    def __init__(self, routed_properties=None, shared_across_all_lrs=False, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _routed_properties = params_dict[u"routed_properties"]
        except KeyError:
            _routed_properties = routed_properties
        if not _routed_properties:
            self.routed_properties = []
        else:
            if isinstance(_routed_properties[0], dict):
                objs = [RoutedProperties(params_dict=elem) for elem in _routed_properties]
                self.routed_properties = objs
            else:
                self.routed_properties = _routed_properties
        try:
            _shared_across_all_lrs = params_dict[u"shared_across_all_lrs"]
        except KeyError:
            _shared_across_all_lrs = shared_across_all_lrs
        self.shared_across_all_lrs = _shared_across_all_lrs
    def factory(*args_, **kwargs_):
        if VirtualNetworkRoutedPropertiesType.subclass:
            return VirtualNetworkRoutedPropertiesType.subclass(*args_, **kwargs_)
        else:
            return VirtualNetworkRoutedPropertiesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_routed_properties(self): return self.routed_properties
    def set_routed_properties(self, routed_properties): self.routed_properties = routed_properties
    def add_routed_properties(self, value): self.routed_properties.append(value)
    def insert_routed_properties(self, index, value): self.routed_properties[index] = value
    def delete_routed_properties(self, value): self.routed_properties.remove(value)
    def get_shared_across_all_lrs(self): return self.shared_across_all_lrs
    def set_shared_across_all_lrs(self, shared_across_all_lrs): self.shared_across_all_lrs = shared_across_all_lrs
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.routed_properties == other.routed_properties and
                    self.shared_across_all_lrs == other.shared_across_all_lrs)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.routed_properties or []),
                     self.shared_across_all_lrs if self.shared_across_all_lrs is not None else -7985492147856592190))

    def __repr__(self):
        return ("routed_properties = " + str(self.routed_properties) + ", " +
                "shared_across_all_lrs = " + str(self.shared_across_all_lrs))

    def copy(self):
        cp = VirtualNetworkRoutedPropertiesType()
        if self.routed_properties is not None:
            cp.routed_properties = [x.copy() for x in self.routed_properties]
        if self.shared_across_all_lrs is not None:
            cp.shared_across_all_lrs = self.shared_across_all_lrs
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_routed_properties ([RoutedProperties.populate ()])
        obj.set_shared_across_all_lrs (obj.populate_boolean ("shared_across_all_lrs"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='VirtualNetworkRoutedPropertiesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VirtualNetworkRoutedPropertiesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VirtualNetworkRoutedPropertiesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VirtualNetworkRoutedPropertiesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for routed_properties_ in self.routed_properties:
            if isinstance(routed_properties_, dict):
                routed_properties_ = RoutedProperties(**routed_properties_)
            routed_properties_.export_xml(outfile, level, namespace_, name_='routed-properties', pretty_print=pretty_print)
        if self.shared_across_all_lrs is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sshared_across_all_lrs>%s</%sshared_across_all_lrs>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.shared_across_all_lrs)), input_name='shared_across_all_lrs'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.routed_properties or
            self.shared_across_all_lrs is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='VirtualNetworkRoutedPropertiesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('routed_properties=[\n')
        level += 1
        for routed_properties_ in self.routed_properties:
            showIndent(outfile, level)
            outfile.write('model_.RoutedProperties(\n')
            routed_properties_.exportLiteral(outfile, level, name_='RoutedProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.shared_across_all_lrs is not None:
            showIndent(outfile, level)
            outfile.write('shared_across_all_lrs=%s,\n' % self.shared_across_all_lrs)
    def exportDict(self, name_='VirtualNetworkRoutedPropertiesType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'routed-properties':
            obj_ = RoutedProperties.factory()
            obj_.build(child_)
            self.routed_properties.append(obj_)
        elif nodeName_ == 'shared_across_all_lrs':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'shared_across_all_lrs')
            self.shared_across_all_lrs = ival_
# end class VirtualNetworkRoutedPropertiesType


class OspfParameters(GeneratedsSuper):
    """
    Attributes:
    * auth_data
        Type:           :class:`.AuthenticationData`

        Created By:           User (optional)

        Description:
          Authentication related configuration like type, keys etc.

    * hello_interval
        Type:           int

        Created By:           User (optional)

        Description:
          Specifies the length of time, in seconds, before the routing device sends a

          hello packet out of an interface.

    * dead_interval
        Type:           int

        Created By:           User (optional)

        Description:
          Specifies how long OSPF waits before declaring that a neighboring routing device

          is unavailable

    * area_id
        Type:           str, *one-of* xsd:string

        Created By:           User (required)

        Description:
          OSPF area ID

    * area_type
        Type:           str, *one-of* [u'nssa', u'stub', u'backbone']

        Created By:           User (required)

        Description:
          OSPF area type

    * advertise_loopback
        Type:           bool

        Created By:           User (optional)

        Description:
          Boolean to enable advertising loopback address.

    * orignate_summary_lsa
        Type:           bool

        Created By:           User (optional)

        Description:
          Boolean to enable originating summary LSA.

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'auth_data', u'hello_interval', u'dead_interval', u'area_id', u'area_type', u'advertise_loopback', u'orignate_summary_lsa']
    attr_field_type_vals = {u'area_id': {'restrictions': [], 'description': [u'OSPF area ID'], 'simple_type': u'IpAddress', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'true', 'attr_type': u'string'}, u'orignate_summary_lsa': {'restrictions': None, 'description': [u'Boolean to enable originating summary LSA.'], 'simple_type': u'xsd:boolean', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'boolean'}, u'area_type': {'restrictions': [u'nssa', u'stub', u'backbone'], 'description': [u'OSPF area type'], 'simple_type': u'OspfAreaType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'true', 'attr_type': u'string'}, u'auth_data': {'restrictions': None, 'description': [u'Authentication related configuration like type, keys etc.'], 'simple_type': u'AuthenticationData', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'AuthenticationData'}, u'dead_interval': {'restrictions': None, 'description': [u'Specifies how long OSPF waits before declaring that a neighboring routing device is unavailable'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'hello_interval': {'restrictions': None, 'description': [u'Specifies the length of time, in seconds, before the routing device sends a hello packet out of an interface.'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'advertise_loopback': {'restrictions': None, 'description': [u'Boolean to enable advertising loopback address.'], 'simple_type': u'xsd:boolean', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'boolean'}}
    def __init__(self, auth_data=None, hello_interval=10, dead_interval=40, area_id=None, area_type=None, advertise_loopback=None, orignate_summary_lsa=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _auth_data = params_dict[u"auth_data"]
        except KeyError:
            _auth_data = auth_data
        if isinstance(_auth_data, dict):
            obj = AuthenticationData(params_dict=_auth_data)
            self.auth_data = obj
        else:
            self.auth_data = _auth_data
        try:
            _hello_interval = params_dict[u"hello_interval"]
        except KeyError:
            _hello_interval = hello_interval
        self.hello_interval = _hello_interval
        try:
            _dead_interval = params_dict[u"dead_interval"]
        except KeyError:
            _dead_interval = dead_interval
        self.dead_interval = _dead_interval
        try:
            _area_id = params_dict[u"area_id"]
        except KeyError:
            _area_id = area_id
        self.area_id = _area_id
        try:
            _area_type = params_dict[u"area_type"]
        except KeyError:
            _area_type = area_type
        self.area_type = _area_type
        try:
            _advertise_loopback = params_dict[u"advertise_loopback"]
        except KeyError:
            _advertise_loopback = advertise_loopback
        self.advertise_loopback = _advertise_loopback
        try:
            _orignate_summary_lsa = params_dict[u"orignate_summary_lsa"]
        except KeyError:
            _orignate_summary_lsa = orignate_summary_lsa
        self.orignate_summary_lsa = _orignate_summary_lsa
    def factory(*args_, **kwargs_):
        if OspfParameters.subclass:
            return OspfParameters.subclass(*args_, **kwargs_)
        else:
            return OspfParameters(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_auth_data(self): return self.auth_data
    def set_auth_data(self, auth_data): self.auth_data = auth_data
    def get_hello_interval(self): return self.hello_interval
    def set_hello_interval(self, hello_interval): self.hello_interval = hello_interval
    def get_dead_interval(self): return self.dead_interval
    def set_dead_interval(self, dead_interval): self.dead_interval = dead_interval
    def get_area_id(self): return self.area_id
    def set_area_id(self, area_id): self.area_id = area_id
    def validate_IpAddress(self, value):
        # Validate type IpAddress, a restriction on xsd:string.
        pass
    def get_area_type(self): return self.area_type
    def set_area_type(self, area_type): self.area_type = area_type
    def validate_OspfAreaType(self, value):
        # Validate type OspfAreaType, a restriction on xsd:string.
        error = False
        if isinstance(value, list):
            error = set(value) - set([u'nssa', u'stub', u'backbone'])
        else:
            error = value not in [u'nssa', u'stub', u'backbone']
        if error:
            raise ValueError("OspfAreaType must be one of [u'nssa', u'stub', u'backbone']")
    def get_advertise_loopback(self): return self.advertise_loopback
    def set_advertise_loopback(self, advertise_loopback): self.advertise_loopback = advertise_loopback
    def get_orignate_summary_lsa(self): return self.orignate_summary_lsa
    def set_orignate_summary_lsa(self, orignate_summary_lsa): self.orignate_summary_lsa = orignate_summary_lsa
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.auth_data == other.auth_data and
                    self.hello_interval == other.hello_interval and
                    self.dead_interval == other.dead_interval and
                    self.area_id == other.area_id and
                    self.area_type == other.area_type and
                    self.advertise_loopback == other.advertise_loopback and
                    self.orignate_summary_lsa == other.orignate_summary_lsa)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.auth_data if self.auth_data is not None else -7985492147856592190,
                     self.hello_interval if self.hello_interval is not None else -7985492147856592190,
                     self.dead_interval if self.dead_interval is not None else -7985492147856592190,
                     self.area_id if self.area_id is not None else -7985492147856592190,
                     self.area_type if self.area_type is not None else -7985492147856592190,
                     self.advertise_loopback if self.advertise_loopback is not None else -7985492147856592190,
                     self.orignate_summary_lsa if self.orignate_summary_lsa is not None else -7985492147856592190))

    def __repr__(self):
        return ("auth_data = " + str(self.auth_data) + ", " +
                "hello_interval = " + str(self.hello_interval) + ", " +
                "dead_interval = " + str(self.dead_interval) + ", " +
                "area_id = " + str(self.area_id) + ", " +
                "area_type = " + str(self.area_type) + ", " +
                "advertise_loopback = " + str(self.advertise_loopback) + ", " +
                "orignate_summary_lsa = " + str(self.orignate_summary_lsa))

    def copy(self):
        cp = OspfParameters()
        if self.auth_data is not None:
            cp.auth_data = self.auth_data.copy()
        if self.hello_interval is not None:
            cp.hello_interval = self.hello_interval
        if self.dead_interval is not None:
            cp.dead_interval = self.dead_interval
        if self.area_id is not None:
            cp.area_id = self.area_id
        if self.area_type is not None:
            cp.area_type = self.area_type
        if self.advertise_loopback is not None:
            cp.advertise_loopback = self.advertise_loopback
        if self.orignate_summary_lsa is not None:
            cp.orignate_summary_lsa = self.orignate_summary_lsa
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_auth_data (AuthenticationData.populate ())
        obj.set_hello_interval (obj.populate_integer ("hello_interval"))
        obj.set_dead_interval (obj.populate_integer ("dead_interval"))
        obj.set_area_id (obj.populate_string ("area_id"))
        obj.set_area_type (obj.populate_string ("area_type"))
        obj.set_advertise_loopback (obj.populate_boolean ("advertise_loopback"))
        obj.set_orignate_summary_lsa (obj.populate_boolean ("orignate_summary_lsa"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='OspfParameters', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OspfParameters')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OspfParameters'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='OspfParameters', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.auth_data is not None:
            self.auth_data.export_xml(outfile, level, namespace_, name_='auth-data', pretty_print=pretty_print)
        if self.hello_interval is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shello-interval>%s</%shello-interval>%s' % (namespace_, self.gds_format_integer(self.hello_interval, input_name='hello-interval'), namespace_, eol_))
        if self.dead_interval is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdead-interval>%s</%sdead-interval>%s' % (namespace_, self.gds_format_integer(self.dead_interval, input_name='dead-interval'), namespace_, eol_))
        if self.area_id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sarea-id>%s</%sarea-id>%s' % (namespace_, self.gds_format_string(quote_xml(self.area_id).encode(ExternalEncoding), input_name='area-id'), namespace_, eol_))
        if self.area_type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sarea-type>%s</%sarea-type>%s' % (namespace_, self.gds_format_string(quote_xml(self.area_type).encode(ExternalEncoding), input_name='area-type'), namespace_, eol_))
        if self.advertise_loopback is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sadvertise-loopback>%s</%sadvertise-loopback>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.advertise_loopback)), input_name='advertise-loopback'), namespace_, eol_))
        if self.orignate_summary_lsa is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sorignate-summary-lsa>%s</%sorignate-summary-lsa>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.orignate_summary_lsa)), input_name='orignate-summary-lsa'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.auth_data is not None or
            self.hello_interval is not None or
            self.dead_interval is not None or
            self.area_id is not None or
            self.area_type is not None or
            self.advertise_loopback is not None or
            self.orignate_summary_lsa is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='OspfParameters'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.auth_data is not None:
            showIndent(outfile, level)
            outfile.write('auth_data=model_.AuthenticationData(\n')
            self.auth_data.exportLiteral(outfile, level, name_='auth_data')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.hello_interval is not None:
            showIndent(outfile, level)
            outfile.write('hello_interval=%d,\n' % self.hello_interval)
        if self.dead_interval is not None:
            showIndent(outfile, level)
            outfile.write('dead_interval=%d,\n' % self.dead_interval)
        if self.area_id is not None:
            showIndent(outfile, level)
            outfile.write('area_id=%s,\n' % quote_python(self.area_id).encode(ExternalEncoding))
        if self.area_type is not None:
            showIndent(outfile, level)
            outfile.write('area_type=%s,\n' % quote_python(self.area_type).encode(ExternalEncoding))
        if self.advertise_loopback is not None:
            showIndent(outfile, level)
            outfile.write('advertise_loopback=%s,\n' % self.advertise_loopback)
        if self.orignate_summary_lsa is not None:
            showIndent(outfile, level)
            outfile.write('orignate_summary_lsa=%s,\n' % self.orignate_summary_lsa)
    def exportDict(self, name_='OspfParameters'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'auth-data':
            obj_ = AuthenticationData.factory()
            obj_.build(child_)
            self.set_auth_data(obj_)
        elif nodeName_ == 'hello-interval':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'hello_interval')
            self.hello_interval = ival_
        elif nodeName_ == 'dead-interval':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'dead_interval')
            self.dead_interval = ival_
        elif nodeName_ == 'area-id':
            area_id_ = child_.text
            area_id_ = self.gds_validate_string(area_id_, node, 'area_id')
            self.area_id = area_id_
            self.validate_IpAddress(self.area_id)    # validate type IpAddress
        elif nodeName_ == 'area-type':
            area_type_ = child_.text
            area_type_ = self.gds_validate_string(area_type_, node, 'area_type')
            self.area_type = area_type_
            self.validate_OspfAreaType(self.area_type)    # validate type OspfAreaType
        elif nodeName_ == 'advertise-loopback':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'advertise_loopback')
            self.advertise_loopback = ival_
        elif nodeName_ == 'orignate-summary-lsa':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'orignate_summary_lsa')
            self.orignate_summary_lsa = ival_
# end class OspfParameters


class RoutingPolicyParameters(GeneratedsSuper):
    """
    Attributes:
    * import_routing_policy_uuid
        Type:           str

        Created By:           User (optional)

        Description:
          list of routing policy uuids used as import policies.

    * export_routing_policy_uuid
        Type:           str

        Created By:           User (optional)

        Description:
          list of routing policy uuids used as export policies.

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'import_routing_policy_uuid', u'export_routing_policy_uuid']
    attr_field_type_vals = {u'export_routing_policy_uuid': {'restrictions': None, 'description': [u'list of routing policy uuids used as export policies.'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': True, 'required': u'optional', 'attr_type': u'string'}, u'import_routing_policy_uuid': {'restrictions': None, 'description': [u'list of routing policy uuids used as import policies.'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': True, 'required': u'optional', 'attr_type': u'string'}}
    def __init__(self, import_routing_policy_uuid=None, export_routing_policy_uuid=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _import_routing_policy_uuid = params_dict[u"import_routing_policy_uuid"]
        except KeyError:
            _import_routing_policy_uuid = import_routing_policy_uuid
        if not _import_routing_policy_uuid:
            self.import_routing_policy_uuid = []
        else:
            self.import_routing_policy_uuid = _import_routing_policy_uuid
        try:
            _export_routing_policy_uuid = params_dict[u"export_routing_policy_uuid"]
        except KeyError:
            _export_routing_policy_uuid = export_routing_policy_uuid
        if not _export_routing_policy_uuid:
            self.export_routing_policy_uuid = []
        else:
            self.export_routing_policy_uuid = _export_routing_policy_uuid
    def factory(*args_, **kwargs_):
        if RoutingPolicyParameters.subclass:
            return RoutingPolicyParameters.subclass(*args_, **kwargs_)
        else:
            return RoutingPolicyParameters(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_import_routing_policy_uuid(self): return self.import_routing_policy_uuid
    def set_import_routing_policy_uuid(self, import_routing_policy_uuid): self.import_routing_policy_uuid = import_routing_policy_uuid
    def add_import_routing_policy_uuid(self, value): self.import_routing_policy_uuid.append(value)
    def insert_import_routing_policy_uuid(self, index, value): self.import_routing_policy_uuid[index] = value
    def delete_import_routing_policy_uuid(self, value): self.import_routing_policy_uuid.remove(value)
    def get_export_routing_policy_uuid(self): return self.export_routing_policy_uuid
    def set_export_routing_policy_uuid(self, export_routing_policy_uuid): self.export_routing_policy_uuid = export_routing_policy_uuid
    def add_export_routing_policy_uuid(self, value): self.export_routing_policy_uuid.append(value)
    def insert_export_routing_policy_uuid(self, index, value): self.export_routing_policy_uuid[index] = value
    def delete_export_routing_policy_uuid(self, value): self.export_routing_policy_uuid.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.import_routing_policy_uuid == other.import_routing_policy_uuid and
                    self.export_routing_policy_uuid == other.export_routing_policy_uuid)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.import_routing_policy_uuid or []),
                     tuple(self.export_routing_policy_uuid or [])))

    def __repr__(self):
        return ("import_routing_policy_uuid = " + str(self.import_routing_policy_uuid) + ", " +
                "export_routing_policy_uuid = " + str(self.export_routing_policy_uuid))

    def copy(self):
        cp = RoutingPolicyParameters()
        if self.import_routing_policy_uuid is not None:
            cp.import_routing_policy_uuid = list(self.import_routing_policy_uuid)
        if self.export_routing_policy_uuid is not None:
            cp.export_routing_policy_uuid = list(self.export_routing_policy_uuid)
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_import_routing_policy_uuid ([obj.populate_string ("import_routing_policy_uuid")])
        obj.set_export_routing_policy_uuid ([obj.populate_string ("export_routing_policy_uuid")])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='RoutingPolicyParameters', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RoutingPolicyParameters')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RoutingPolicyParameters'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RoutingPolicyParameters', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for import_routing_policy_uuid_ in self.import_routing_policy_uuid:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%simport-routing-policy-uuid>%s</%simport-routing-policy-uuid>%s' % (namespace_, self.gds_format_string(quote_xml(import_routing_policy_uuid_).encode(ExternalEncoding), input_name='import-routing-policy-uuid'), namespace_, eol_))
        for export_routing_policy_uuid_ in self.export_routing_policy_uuid:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexport-routing-policy-uuid>%s</%sexport-routing-policy-uuid>%s' % (namespace_, self.gds_format_string(quote_xml(export_routing_policy_uuid_).encode(ExternalEncoding), input_name='export-routing-policy-uuid'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.import_routing_policy_uuid or
            self.export_routing_policy_uuid
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RoutingPolicyParameters'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('import_routing_policy_uuid=[\n')
        level += 1
        for import_routing_policy_uuid_ in self.import_routing_policy_uuid:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(import_routing_policy_uuid_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('export_routing_policy_uuid=[\n')
        level += 1
        for export_routing_policy_uuid_ in self.export_routing_policy_uuid:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(export_routing_policy_uuid_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='RoutingPolicyParameters'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'import-routing-policy-uuid':
            import_routing_policy_uuid_ = child_.text
            import_routing_policy_uuid_ = self.gds_validate_string(import_routing_policy_uuid_, node, 'import_routing_policy_uuid')
            self.import_routing_policy_uuid.append(import_routing_policy_uuid_)
        elif nodeName_ == 'export-routing-policy-uuid':
            export_routing_policy_uuid_ = child_.text
            export_routing_policy_uuid_ = self.gds_validate_string(export_routing_policy_uuid_, node, 'export_routing_policy_uuid')
            self.export_routing_policy_uuid.append(export_routing_policy_uuid_)
# end class RoutingPolicyParameters


class StaticRouteParameters(GeneratedsSuper):
    """
    Attributes:
    * interface_route_table_uuid
        Type:           str

        Created By:           User (required)

        Description:
          list of interface route table uuids used to build list of prefixes.

    * next_hop_ip_address
        Type:           str, *one-of* xsd:string

        Created By:           User (required)

        Description:
          List of next-hop IP addresses.

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'interface_route_table_uuid', u'next_hop_ip_address']
    attr_field_type_vals = {u'interface_route_table_uuid': {'restrictions': None, 'description': [u'list of interface route table uuids used to build list of prefixes.'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': True, 'required': u'true', 'attr_type': u'string'}, u'next_hop_ip_address': {'restrictions': [], 'description': [u'List of next-hop IP addresses.'], 'simple_type': u'IpAddress', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': True, 'required': u'true', 'attr_type': u'string'}}
    def __init__(self, interface_route_table_uuid=None, next_hop_ip_address=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _interface_route_table_uuid = params_dict[u"interface_route_table_uuid"]
        except KeyError:
            _interface_route_table_uuid = interface_route_table_uuid
        if not _interface_route_table_uuid:
            self.interface_route_table_uuid = []
        else:
            self.interface_route_table_uuid = _interface_route_table_uuid
        try:
            _next_hop_ip_address = params_dict[u"next_hop_ip_address"]
        except KeyError:
            _next_hop_ip_address = next_hop_ip_address
        if not _next_hop_ip_address:
            self.next_hop_ip_address = []
        else:
            self.next_hop_ip_address = _next_hop_ip_address
    def factory(*args_, **kwargs_):
        if StaticRouteParameters.subclass:
            return StaticRouteParameters.subclass(*args_, **kwargs_)
        else:
            return StaticRouteParameters(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_interface_route_table_uuid(self): return self.interface_route_table_uuid
    def set_interface_route_table_uuid(self, interface_route_table_uuid): self.interface_route_table_uuid = interface_route_table_uuid
    def add_interface_route_table_uuid(self, value): self.interface_route_table_uuid.append(value)
    def insert_interface_route_table_uuid(self, index, value): self.interface_route_table_uuid[index] = value
    def delete_interface_route_table_uuid(self, value): self.interface_route_table_uuid.remove(value)
    def get_next_hop_ip_address(self): return self.next_hop_ip_address
    def set_next_hop_ip_address(self, next_hop_ip_address): self.next_hop_ip_address = next_hop_ip_address
    def add_next_hop_ip_address(self, value): self.next_hop_ip_address.append(value)
    def insert_next_hop_ip_address(self, index, value): self.next_hop_ip_address[index] = value
    def delete_next_hop_ip_address(self, value): self.next_hop_ip_address.remove(value)
    def validate_IpAddress(self, value):
        # Validate type IpAddress, a restriction on xsd:string.
        pass
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.interface_route_table_uuid == other.interface_route_table_uuid and
                    self.next_hop_ip_address == other.next_hop_ip_address)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.interface_route_table_uuid or []),
                     tuple(self.next_hop_ip_address or [])))

    def __repr__(self):
        return ("interface_route_table_uuid = " + str(self.interface_route_table_uuid) + ", " +
                "next_hop_ip_address = " + str(self.next_hop_ip_address))

    def copy(self):
        cp = StaticRouteParameters()
        if self.interface_route_table_uuid is not None:
            cp.interface_route_table_uuid = list(self.interface_route_table_uuid)
        if self.next_hop_ip_address is not None:
            cp.next_hop_ip_address = list(self.next_hop_ip_address)
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_interface_route_table_uuid ([obj.populate_string ("interface_route_table_uuid")])
        obj.set_next_hop_ip_address ([obj.populate_string ("next_hop_ip_address")])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='StaticRouteParameters', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StaticRouteParameters')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StaticRouteParameters'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='StaticRouteParameters', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for interface_route_table_uuid_ in self.interface_route_table_uuid:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinterface-route-table-uuid>%s</%sinterface-route-table-uuid>%s' % (namespace_, self.gds_format_string(quote_xml(interface_route_table_uuid_).encode(ExternalEncoding), input_name='interface-route-table-uuid'), namespace_, eol_))
        for next_hop_ip_address_ in self.next_hop_ip_address:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snext-hop-ip-address>%s</%snext-hop-ip-address>%s' % (namespace_, self.gds_format_string(quote_xml(next_hop_ip_address_).encode(ExternalEncoding), input_name='next-hop-ip-address'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.interface_route_table_uuid or
            self.next_hop_ip_address
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StaticRouteParameters'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('interface_route_table_uuid=[\n')
        level += 1
        for interface_route_table_uuid_ in self.interface_route_table_uuid:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(interface_route_table_uuid_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('next_hop_ip_address=[\n')
        level += 1
        for next_hop_ip_address_ in self.next_hop_ip_address:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(next_hop_ip_address_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='StaticRouteParameters'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'interface-route-table-uuid':
            interface_route_table_uuid_ = child_.text
            interface_route_table_uuid_ = self.gds_validate_string(interface_route_table_uuid_, node, 'interface_route_table_uuid')
            self.interface_route_table_uuid.append(interface_route_table_uuid_)
        elif nodeName_ == 'next-hop-ip-address':
            next_hop_ip_address_ = child_.text
            next_hop_ip_address_ = self.gds_validate_string(next_hop_ip_address_, node, 'next_hop_ip_address')
            self.next_hop_ip_address.append(next_hop_ip_address_)
            self.validate_IpAddress(self.next_hop_ip_address)    # validate type IpAddress
# end class StaticRouteParameters


class BfdParameters(GeneratedsSuper):
    """
    Attributes:
    * time_interval
        Type:           int

        Created By:           User (optional)

        Description:
          Rx/Tx time interval for BFD session in milliseconds.

    * detection_time_multiplier
        Type:           int

        Created By:           User (optional)

        Description:
          Detection time multiplier for BFD session.

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'time_interval', u'detection_time_multiplier']
    attr_field_type_vals = {u'time_interval': {'restrictions': None, 'description': [u'Rx/Tx time interval for BFD session in milliseconds.'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'detection_time_multiplier': {'restrictions': None, 'description': [u'Detection time multiplier for BFD session.'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}}
    def __init__(self, time_interval=None, detection_time_multiplier=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _time_interval = params_dict[u"time_interval"]
        except KeyError:
            _time_interval = time_interval
        self.time_interval = _time_interval
        try:
            _detection_time_multiplier = params_dict[u"detection_time_multiplier"]
        except KeyError:
            _detection_time_multiplier = detection_time_multiplier
        self.detection_time_multiplier = _detection_time_multiplier
    def factory(*args_, **kwargs_):
        if BfdParameters.subclass:
            return BfdParameters.subclass(*args_, **kwargs_)
        else:
            return BfdParameters(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_time_interval(self): return self.time_interval
    def set_time_interval(self, time_interval): self.time_interval = time_interval
    def get_detection_time_multiplier(self): return self.detection_time_multiplier
    def set_detection_time_multiplier(self, detection_time_multiplier): self.detection_time_multiplier = detection_time_multiplier
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.time_interval == other.time_interval and
                    self.detection_time_multiplier == other.detection_time_multiplier)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.time_interval if self.time_interval is not None else -7985492147856592190,
                     self.detection_time_multiplier if self.detection_time_multiplier is not None else -7985492147856592190))

    def __repr__(self):
        return ("time_interval = " + str(self.time_interval) + ", " +
                "detection_time_multiplier = " + str(self.detection_time_multiplier))

    def copy(self):
        cp = BfdParameters()
        if self.time_interval is not None:
            cp.time_interval = self.time_interval
        if self.detection_time_multiplier is not None:
            cp.detection_time_multiplier = self.detection_time_multiplier
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_time_interval (obj.populate_integer ("time_interval"))
        obj.set_detection_time_multiplier (obj.populate_integer ("detection_time_multiplier"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='BfdParameters', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BfdParameters')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BfdParameters'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='BfdParameters', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.time_interval is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stime-interval>%s</%stime-interval>%s' % (namespace_, self.gds_format_integer(self.time_interval, input_name='time-interval'), namespace_, eol_))
        if self.detection_time_multiplier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdetection-time-multiplier>%s</%sdetection-time-multiplier>%s' % (namespace_, self.gds_format_integer(self.detection_time_multiplier, input_name='detection-time-multiplier'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.time_interval is not None or
            self.detection_time_multiplier is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BfdParameters'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.time_interval is not None:
            showIndent(outfile, level)
            outfile.write('time_interval=%d,\n' % self.time_interval)
        if self.detection_time_multiplier is not None:
            showIndent(outfile, level)
            outfile.write('detection_time_multiplier=%d,\n' % self.detection_time_multiplier)
    def exportDict(self, name_='BfdParameters'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'time-interval':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'time_interval')
            self.time_interval = ival_
        elif nodeName_ == 'detection-time-multiplier':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'detection_time_multiplier')
            self.detection_time_multiplier = ival_
# end class BfdParameters


class BgpParameters(GeneratedsSuper):
    """
    Attributes:
    * peer_autonomous_system
        Type:           int

        Created By:           User (required)

        Description:
          Peer autonomous system number for this eBGP session.

    * peer_ip_address
        Type:           str, *one-of* xsd:string

        Created By:           User (optional)

        Description:
          Peer ip address used for this eBGP session.

    * peer_ip_address_list
        Type:           str, *one-of* xsd:string

        Created By:           User (required)

        Description:
          Peer ip address list used for this eBGP session.

    * hold_time
        Type:           int, *within* [0, 65535]

        Created By:           User (optional)

        Description:
          BGP hold time in seconds [0-65535], Max time to detect liveliness to peer. Value

          0 will result in default value of 90 seconds

    * auth_data
        Type:           :class:`.AuthenticationData`

        Created By:           User (optional)

        Description:
          Authentication related configuration like type, keys etc.

    * local_autonomous_system
        Type:           int

        Created By:           User (optional)

        Description:
          BgpRouter specific Autonomous System number if different from global AS number.

    * multihop_ttl
        Type:           int

        Created By:           User (optional)

        Description:
          time-to-live (TTL) value in the BGP packets to control how far they propagate.

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'peer_autonomous_system', u'peer_ip_address', u'peer_ip_address_list', u'hold_time', u'auth_data', u'local_autonomous_system', u'multihop_ttl']
    attr_field_type_vals = {u'auth_data': {'restrictions': None, 'description': [u'Authentication related configuration like type, keys etc.'], 'simple_type': u'AuthenticationData', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'AuthenticationData'}, u'peer_autonomous_system': {'restrictions': None, 'description': [u'Peer autonomous system number for this eBGP session.'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'true', 'attr_type': u'integer'}, u'peer_ip_address': {'restrictions': [], 'description': [u'Peer ip address used for this eBGP session.'], 'simple_type': u'IpAddress', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'local_autonomous_system': {'restrictions': None, 'description': [u'BgpRouter specific Autonomous System number if different from global AS number.'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'peer_ip_address_list': {'restrictions': [], 'description': [u'Peer ip address list used for this eBGP session.'], 'simple_type': u'IpAddress', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': True, 'required': u'true', 'attr_type': u'string'}, u'multihop_ttl': {'restrictions': None, 'description': [u'time-to-live (TTL) value in the BGP packets to control how far they propagate.'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'hold_time': {'restrictions': [0, 65535], 'description': [u'BGP hold time in seconds [0-65535], Max time to detect liveliness to peer. Value 0 will result in default value of 90 seconds'], 'simple_type': u'BgpHoldTime', 'is_complex': 0, 'restriction_type': 'range', 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}}
    def __init__(self, peer_autonomous_system=None, peer_ip_address=None, peer_ip_address_list=None, hold_time=0, auth_data=None, local_autonomous_system=None, multihop_ttl=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _peer_autonomous_system = params_dict[u"peer_autonomous_system"]
        except KeyError:
            _peer_autonomous_system = peer_autonomous_system
        self.peer_autonomous_system = _peer_autonomous_system
        try:
            _peer_ip_address = params_dict[u"peer_ip_address"]
        except KeyError:
            _peer_ip_address = peer_ip_address
        self.peer_ip_address = _peer_ip_address
        try:
            _peer_ip_address_list = params_dict[u"peer_ip_address_list"]
        except KeyError:
            _peer_ip_address_list = peer_ip_address_list
        if not _peer_ip_address_list:
            self.peer_ip_address_list = []
        else:
            self.peer_ip_address_list = _peer_ip_address_list
        try:
            _hold_time = params_dict[u"hold_time"]
        except KeyError:
            _hold_time = hold_time
        self.hold_time = _hold_time
        try:
            _auth_data = params_dict[u"auth_data"]
        except KeyError:
            _auth_data = auth_data
        if isinstance(_auth_data, dict):
            obj = AuthenticationData(params_dict=_auth_data)
            self.auth_data = obj
        else:
            self.auth_data = _auth_data
        try:
            _local_autonomous_system = params_dict[u"local_autonomous_system"]
        except KeyError:
            _local_autonomous_system = local_autonomous_system
        self.local_autonomous_system = _local_autonomous_system
        try:
            _multihop_ttl = params_dict[u"multihop_ttl"]
        except KeyError:
            _multihop_ttl = multihop_ttl
        self.multihop_ttl = _multihop_ttl
    def factory(*args_, **kwargs_):
        if BgpParameters.subclass:
            return BgpParameters.subclass(*args_, **kwargs_)
        else:
            return BgpParameters(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_peer_autonomous_system(self): return self.peer_autonomous_system
    def set_peer_autonomous_system(self, peer_autonomous_system): self.peer_autonomous_system = peer_autonomous_system
    def get_peer_ip_address(self): return self.peer_ip_address
    def set_peer_ip_address(self, peer_ip_address): self.peer_ip_address = peer_ip_address
    def validate_IpAddress(self, value):
        # Validate type IpAddress, a restriction on xsd:string.
        pass
    def get_peer_ip_address_list(self): return self.peer_ip_address_list
    def set_peer_ip_address_list(self, peer_ip_address_list): self.peer_ip_address_list = peer_ip_address_list
    def add_peer_ip_address_list(self, value): self.peer_ip_address_list.append(value)
    def insert_peer_ip_address_list(self, index, value): self.peer_ip_address_list[index] = value
    def delete_peer_ip_address_list(self, value): self.peer_ip_address_list.remove(value)
    def get_hold_time(self): return self.hold_time
    def set_hold_time(self, hold_time): self.hold_time = hold_time
    def validate_BgpHoldTime(self, value):
        # Validate type BgpHoldTime, a restriction on xsd:integer.
        error = False
        if isinstance(value, list):
            v_int = list(map(int, value))
            v1, v2 = min(v_int), max(v_int)
        else:
            v1, v2 = int(value), int(value)
        error |= (v2 > 65535)
        if error:
            raise ValueError("BgpHoldTime must be in the range {'minimum': 0}-{'maximum': 65535}")
    def get_auth_data(self): return self.auth_data
    def set_auth_data(self, auth_data): self.auth_data = auth_data
    def get_local_autonomous_system(self): return self.local_autonomous_system
    def set_local_autonomous_system(self, local_autonomous_system): self.local_autonomous_system = local_autonomous_system
    def get_multihop_ttl(self): return self.multihop_ttl
    def set_multihop_ttl(self, multihop_ttl): self.multihop_ttl = multihop_ttl
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.peer_autonomous_system == other.peer_autonomous_system and
                    self.peer_ip_address == other.peer_ip_address and
                    self.peer_ip_address_list == other.peer_ip_address_list and
                    self.hold_time == other.hold_time and
                    self.auth_data == other.auth_data and
                    self.local_autonomous_system == other.local_autonomous_system and
                    self.multihop_ttl == other.multihop_ttl)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.peer_autonomous_system if self.peer_autonomous_system is not None else -7985492147856592190,
                     self.peer_ip_address if self.peer_ip_address is not None else -7985492147856592190,
                     tuple(self.peer_ip_address_list or []),
                     self.hold_time if self.hold_time is not None else -7985492147856592190,
                     self.auth_data if self.auth_data is not None else -7985492147856592190,
                     self.local_autonomous_system if self.local_autonomous_system is not None else -7985492147856592190,
                     self.multihop_ttl if self.multihop_ttl is not None else -7985492147856592190))

    def __repr__(self):
        return ("peer_autonomous_system = " + str(self.peer_autonomous_system) + ", " +
                "peer_ip_address = " + str(self.peer_ip_address) + ", " +
                "peer_ip_address_list = " + str(self.peer_ip_address_list) + ", " +
                "hold_time = " + str(self.hold_time) + ", " +
                "auth_data = " + str(self.auth_data) + ", " +
                "local_autonomous_system = " + str(self.local_autonomous_system) + ", " +
                "multihop_ttl = " + str(self.multihop_ttl))

    def copy(self):
        cp = BgpParameters()
        if self.peer_autonomous_system is not None:
            cp.peer_autonomous_system = self.peer_autonomous_system
        if self.peer_ip_address is not None:
            cp.peer_ip_address = self.peer_ip_address
        if self.peer_ip_address_list is not None:
            cp.peer_ip_address_list = list(self.peer_ip_address_list)
        if self.hold_time is not None:
            cp.hold_time = self.hold_time
        if self.auth_data is not None:
            cp.auth_data = self.auth_data.copy()
        if self.local_autonomous_system is not None:
            cp.local_autonomous_system = self.local_autonomous_system
        if self.multihop_ttl is not None:
            cp.multihop_ttl = self.multihop_ttl
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_peer_autonomous_system (obj.populate_integer ("peer_autonomous_system"))
        obj.set_peer_ip_address (obj.populate_string ("peer_ip_address"))
        obj.set_peer_ip_address_list ([obj.populate_string ("peer_ip_address_list")])
        obj.set_hold_time (obj.populate_integer ("hold_time"))
        obj.set_auth_data (AuthenticationData.populate ())
        obj.set_local_autonomous_system (obj.populate_integer ("local_autonomous_system"))
        obj.set_multihop_ttl (obj.populate_integer ("multihop_ttl"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='BgpParameters', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BgpParameters')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BgpParameters'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='BgpParameters', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.peer_autonomous_system is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%speer-autonomous-system>%s</%speer-autonomous-system>%s' % (namespace_, self.gds_format_integer(self.peer_autonomous_system, input_name='peer-autonomous-system'), namespace_, eol_))
        if self.peer_ip_address is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%speer-ip-address>%s</%speer-ip-address>%s' % (namespace_, self.gds_format_string(quote_xml(self.peer_ip_address).encode(ExternalEncoding), input_name='peer-ip-address'), namespace_, eol_))
        for peer_ip_address_list_ in self.peer_ip_address_list:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%speer-ip-address-list>%s</%speer-ip-address-list>%s' % (namespace_, self.gds_format_string(quote_xml(peer_ip_address_list_).encode(ExternalEncoding), input_name='peer-ip-address-list'), namespace_, eol_))
        if self.hold_time is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shold-time>%s</%shold-time>%s' % (namespace_, self.gds_format_integer(self.hold_time, input_name='hold-time'), namespace_, eol_))
        if self.auth_data is not None:
            self.auth_data.export_xml(outfile, level, namespace_, name_='auth-data', pretty_print=pretty_print)
        if self.local_autonomous_system is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slocal-autonomous-system>%s</%slocal-autonomous-system>%s' % (namespace_, self.gds_format_integer(self.local_autonomous_system, input_name='local-autonomous-system'), namespace_, eol_))
        if self.multihop_ttl is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smultihop-ttl>%s</%smultihop-ttl>%s' % (namespace_, self.gds_format_integer(self.multihop_ttl, input_name='multihop-ttl'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.peer_autonomous_system is not None or
            self.peer_ip_address is not None or
            self.peer_ip_address_list or
            self.hold_time is not None or
            self.auth_data is not None or
            self.local_autonomous_system is not None or
            self.multihop_ttl is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BgpParameters'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.peer_autonomous_system is not None:
            showIndent(outfile, level)
            outfile.write('peer_autonomous_system=%d,\n' % self.peer_autonomous_system)
        if self.peer_ip_address is not None:
            showIndent(outfile, level)
            outfile.write('peer_ip_address=%s,\n' % quote_python(self.peer_ip_address).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('peer_ip_address_list=[\n')
        level += 1
        for peer_ip_address_list_ in self.peer_ip_address_list:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(peer_ip_address_list_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.hold_time is not None:
            showIndent(outfile, level)
            outfile.write('hold_time=%d,\n' % self.hold_time)
        if self.auth_data is not None:
            showIndent(outfile, level)
            outfile.write('auth_data=model_.AuthenticationData(\n')
            self.auth_data.exportLiteral(outfile, level, name_='auth_data')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.local_autonomous_system is not None:
            showIndent(outfile, level)
            outfile.write('local_autonomous_system=%d,\n' % self.local_autonomous_system)
        if self.multihop_ttl is not None:
            showIndent(outfile, level)
            outfile.write('multihop_ttl=%d,\n' % self.multihop_ttl)
    def exportDict(self, name_='BgpParameters'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'peer-autonomous-system':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'peer_autonomous_system')
            self.peer_autonomous_system = ival_
        elif nodeName_ == 'peer-ip-address':
            peer_ip_address_ = child_.text
            peer_ip_address_ = self.gds_validate_string(peer_ip_address_, node, 'peer_ip_address')
            self.peer_ip_address = peer_ip_address_
            self.validate_IpAddress(self.peer_ip_address)    # validate type IpAddress
        elif nodeName_ == 'peer-ip-address-list':
            peer_ip_address_list_ = child_.text
            peer_ip_address_list_ = self.gds_validate_string(peer_ip_address_list_, node, 'peer_ip_address_list')
            self.peer_ip_address_list.append(peer_ip_address_list_)
            self.validate_IpAddress(self.peer_ip_address_list)    # validate type IpAddress
        elif nodeName_ == 'hold-time':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'hold_time')
            self.hold_time = ival_
            self.validate_BgpHoldTime(self.hold_time)    # validate type BgpHoldTime
        elif nodeName_ == 'auth-data':
            obj_ = AuthenticationData.factory()
            obj_.build(child_)
            self.set_auth_data(obj_)
        elif nodeName_ == 'local-autonomous-system':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'local_autonomous_system')
            self.local_autonomous_system = ival_
        elif nodeName_ == 'multihop-ttl':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'multihop_ttl')
            self.multihop_ttl = ival_
# end class BgpParameters


class PimParameters(GeneratedsSuper):
    """
    Attributes:
    * rp_ip_address
        Type:           str, *one-of* xsd:string

        Created By:           User (required)

        Description:
          Static rendezvous point IP address.

    * mode
        Type:           str, *one-of* [u'sparse', u'sparse-dense', u'dense']

        Created By:           User (optional)

        Description:
          Pim mode.

    * enable_all_interfaces
        Type:           bool

        Created By:           User (optional)

        Description:
          Boolean to enable PIM on all interfaces.

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'rp_ip_address', u'mode', u'enable_all_interfaces']
    attr_field_type_vals = {u'enable_all_interfaces': {'restrictions': None, 'description': [u'Boolean to enable PIM on all interfaces.'], 'simple_type': u'xsd:boolean', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'boolean'}, u'mode': {'restrictions': [u'sparse', u'sparse-dense', u'dense'], 'description': [u'Pim mode.'], 'simple_type': u'PimMode', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'rp_ip_address': {'restrictions': [], 'description': [u'Static rendezvous point IP address.'], 'simple_type': u'IpAddress', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': True, 'required': u'true', 'attr_type': u'string'}}
    def __init__(self, rp_ip_address=None, mode='sparse-dense', enable_all_interfaces=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _rp_ip_address = params_dict[u"rp_ip_address"]
        except KeyError:
            _rp_ip_address = rp_ip_address
        if not _rp_ip_address:
            self.rp_ip_address = []
        else:
            self.rp_ip_address = _rp_ip_address
        try:
            _mode = params_dict[u"mode"]
        except KeyError:
            _mode = mode
        self.mode = _mode
        try:
            _enable_all_interfaces = params_dict[u"enable_all_interfaces"]
        except KeyError:
            _enable_all_interfaces = enable_all_interfaces
        self.enable_all_interfaces = _enable_all_interfaces
    def factory(*args_, **kwargs_):
        if PimParameters.subclass:
            return PimParameters.subclass(*args_, **kwargs_)
        else:
            return PimParameters(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rp_ip_address(self): return self.rp_ip_address
    def set_rp_ip_address(self, rp_ip_address): self.rp_ip_address = rp_ip_address
    def add_rp_ip_address(self, value): self.rp_ip_address.append(value)
    def insert_rp_ip_address(self, index, value): self.rp_ip_address[index] = value
    def delete_rp_ip_address(self, value): self.rp_ip_address.remove(value)
    def validate_IpAddress(self, value):
        # Validate type IpAddress, a restriction on xsd:string.
        pass
    def get_mode(self): return self.mode
    def set_mode(self, mode): self.mode = mode
    def validate_PimMode(self, value):
        # Validate type PimMode, a restriction on xsd:string.
        error = False
        if isinstance(value, list):
            error = set(value) - set([u'sparse', u'sparse-dense', u'dense'])
        else:
            error = value not in [u'sparse', u'sparse-dense', u'dense']
        if error:
            raise ValueError("PimMode must be one of [u'sparse', u'sparse-dense', u'dense']")
    def get_enable_all_interfaces(self): return self.enable_all_interfaces
    def set_enable_all_interfaces(self, enable_all_interfaces): self.enable_all_interfaces = enable_all_interfaces
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.rp_ip_address == other.rp_ip_address and
                    self.mode == other.mode and
                    self.enable_all_interfaces == other.enable_all_interfaces)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.rp_ip_address or []),
                     self.mode if self.mode is not None else -7985492147856592190,
                     self.enable_all_interfaces if self.enable_all_interfaces is not None else -7985492147856592190))

    def __repr__(self):
        return ("rp_ip_address = " + str(self.rp_ip_address) + ", " +
                "mode = " + str(self.mode) + ", " +
                "enable_all_interfaces = " + str(self.enable_all_interfaces))

    def copy(self):
        cp = PimParameters()
        if self.rp_ip_address is not None:
            cp.rp_ip_address = list(self.rp_ip_address)
        if self.mode is not None:
            cp.mode = self.mode
        if self.enable_all_interfaces is not None:
            cp.enable_all_interfaces = self.enable_all_interfaces
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_rp_ip_address ([obj.populate_string ("rp_ip_address")])
        obj.set_mode (obj.populate_string ("mode"))
        obj.set_enable_all_interfaces (obj.populate_boolean ("enable_all_interfaces"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='PimParameters', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PimParameters')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PimParameters'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PimParameters', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for rp_ip_address_ in self.rp_ip_address:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srp-ip-address>%s</%srp-ip-address>%s' % (namespace_, self.gds_format_string(quote_xml(rp_ip_address_).encode(ExternalEncoding), input_name='rp-ip-address'), namespace_, eol_))
        if self.mode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smode>%s</%smode>%s' % (namespace_, self.gds_format_string(quote_xml(self.mode).encode(ExternalEncoding), input_name='mode'), namespace_, eol_))
        if self.enable_all_interfaces is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%senable-all-interfaces>%s</%senable-all-interfaces>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.enable_all_interfaces)), input_name='enable-all-interfaces'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.rp_ip_address or
            self.mode is not None or
            self.enable_all_interfaces is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PimParameters'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('rp_ip_address=[\n')
        level += 1
        for rp_ip_address_ in self.rp_ip_address:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(rp_ip_address_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.mode is not None:
            showIndent(outfile, level)
            outfile.write('mode=%s,\n' % quote_python(self.mode).encode(ExternalEncoding))
        if self.enable_all_interfaces is not None:
            showIndent(outfile, level)
            outfile.write('enable_all_interfaces=%s,\n' % self.enable_all_interfaces)
    def exportDict(self, name_='PimParameters'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'rp-ip-address':
            rp_ip_address_ = child_.text
            rp_ip_address_ = self.gds_validate_string(rp_ip_address_, node, 'rp_ip_address')
            self.rp_ip_address.append(rp_ip_address_)
            self.validate_IpAddress(self.rp_ip_address)    # validate type IpAddress
        elif nodeName_ == 'mode':
            mode_ = child_.text
            mode_ = self.gds_validate_string(mode_, node, 'mode')
            self.mode = mode_
            self.validate_PimMode(self.mode)    # validate type PimMode
        elif nodeName_ == 'enable-all-interfaces':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'enable_all_interfaces')
            self.enable_all_interfaces = ival_
# end class PimParameters


class RoutedProperties(GeneratedsSuper):
    """
    Attributes:
    * physical_router_uuid
        Type:           str

        Created By:           User (required)

        Description:
          Routed properties for particular physical router for this virtual-network.

    * logical_router_uuid
        Type:           str

        Created By:           User (required)

        Description:
          Routed properties for particular logical router for this virtual-network.

    * routed_interface_ip_address
        Type:           str, *one-of* xsd:string

        Created By:           User (required)

        Description:
          IP address of the routed interface from the VN subnet.

    * loopback_ip_address
        Type:           str, *one-of* xsd:string

        Created By:           User (optional)

        Description:
          IP address of the loopback interface from the overlay loopback subnet.

    * routing_protocol
        Type:           str, *one-of* [u'static-routes', u'bgp', u'ospf', u'pim']

        Created By:           User (required)

        Description:
          Protocol used for exchanging route information.

    * bgp_params
        Type:           :class:`.BgpParameters`

        Created By:           User (optional)

        Description:
          BGP parameters such as ASN, peer IP address, authentication method/key.

    * ospf_params
        Type:           :class:`.OspfParameters`

        Created By:           User (optional)

        Description:
          OSPF parameters such as area ID, area type, hello-interval, dead-interval,

          authentication method/key.

    * pim_params
        Type:           :class:`.PimParameters`

        Created By:           User (optional)

        Description:
          PIM parameters such as RP IP address, mode.

    * static_route_params
        Type:           :class:`.StaticRouteParameters`

        Created By:           User (optional)

        Description:
          Static route parameters such as interface route table uuid, next hop IP address.

    * bfd_params
        Type:           :class:`.BfdParameters`

        Created By:           User (optional)

        Description:
          BFD parameters such as time interval, detection time multiplier.

    * routing_policy_params
        Type:           :class:`.RoutingPolicyParameters`

        Created By:           User (optional)

        Description:
          List of import/export routing policy uuids.

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'physical_router_uuid', u'logical_router_uuid', u'routed_interface_ip_address', u'loopback_ip_address', u'routing_protocol', u'bgp_params', u'ospf_params', u'pim_params', u'static_route_params', u'bfd_params', u'routing_policy_params']
    attr_field_type_vals = {u'routing_policy_params': {'restrictions': None, 'description': [u'List of import/export routing policy uuids.'], 'simple_type': u'RoutingPolicyParameters', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'RoutingPolicyParameters'}, u'static_route_params': {'restrictions': None, 'description': [u'Static route parameters such as interface route table uuid, next hop IP address.'], 'simple_type': u'StaticRouteParameters', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'StaticRouteParameters'}, u'bgp_params': {'restrictions': None, 'description': [u'BGP parameters such as ASN, peer IP address, authentication method/key.'], 'simple_type': u'BgpParameters', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'BgpParameters'}, u'loopback_ip_address': {'restrictions': [], 'description': [u'IP address of the loopback interface from the overlay loopback subnet.'], 'simple_type': u'IpAddressType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'routed_interface_ip_address': {'restrictions': [], 'description': [u'IP address of the routed interface from the VN subnet.'], 'simple_type': u'IpAddressType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'true', 'attr_type': u'string'}, u'pim_params': {'restrictions': None, 'description': [u'PIM parameters such as RP IP address, mode.'], 'simple_type': u'PimParameters', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'PimParameters'}, u'routing_protocol': {'restrictions': [u'static-routes', u'bgp', u'ospf', u'pim'], 'description': [u'Protocol used for exchanging route information.'], 'simple_type': u'RoutingProtocolType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'true', 'attr_type': u'string'}, u'bfd_params': {'restrictions': None, 'description': [u'BFD parameters such as time interval, detection time multiplier.'], 'simple_type': u'BfdParameters', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'BfdParameters'}, u'logical_router_uuid': {'restrictions': None, 'description': [u'Routed properties for particular logical router for this virtual-network.'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'true', 'attr_type': u'string'}, u'ospf_params': {'restrictions': None, 'description': [u'OSPF parameters such as area ID, area type, hello-interval, dead-interval, authentication method/key.'], 'simple_type': u'OspfParameters', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'OspfParameters'}, u'physical_router_uuid': {'restrictions': None, 'description': [u'Routed properties for particular physical router for this virtual-network.'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'true', 'attr_type': u'string'}}
    def __init__(self, physical_router_uuid=None, logical_router_uuid=None, routed_interface_ip_address=None, loopback_ip_address=None, routing_protocol=None, bgp_params=None, ospf_params=None, pim_params=None, static_route_params=None, bfd_params=None, routing_policy_params=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _physical_router_uuid = params_dict[u"physical_router_uuid"]
        except KeyError:
            _physical_router_uuid = physical_router_uuid
        self.physical_router_uuid = _physical_router_uuid
        try:
            _logical_router_uuid = params_dict[u"logical_router_uuid"]
        except KeyError:
            _logical_router_uuid = logical_router_uuid
        self.logical_router_uuid = _logical_router_uuid
        try:
            _routed_interface_ip_address = params_dict[u"routed_interface_ip_address"]
        except KeyError:
            _routed_interface_ip_address = routed_interface_ip_address
        self.routed_interface_ip_address = _routed_interface_ip_address
        try:
            _loopback_ip_address = params_dict[u"loopback_ip_address"]
        except KeyError:
            _loopback_ip_address = loopback_ip_address
        self.loopback_ip_address = _loopback_ip_address
        try:
            _routing_protocol = params_dict[u"routing_protocol"]
        except KeyError:
            _routing_protocol = routing_protocol
        self.routing_protocol = _routing_protocol
        try:
            _bgp_params = params_dict[u"bgp_params"]
        except KeyError:
            _bgp_params = bgp_params
        if isinstance(_bgp_params, dict):
            obj = BgpParameters(params_dict=_bgp_params)
            self.bgp_params = obj
        else:
            self.bgp_params = _bgp_params
        try:
            _ospf_params = params_dict[u"ospf_params"]
        except KeyError:
            _ospf_params = ospf_params
        if isinstance(_ospf_params, dict):
            obj = OspfParameters(params_dict=_ospf_params)
            self.ospf_params = obj
        else:
            self.ospf_params = _ospf_params
        try:
            _pim_params = params_dict[u"pim_params"]
        except KeyError:
            _pim_params = pim_params
        if isinstance(_pim_params, dict):
            obj = PimParameters(params_dict=_pim_params)
            self.pim_params = obj
        else:
            self.pim_params = _pim_params
        try:
            _static_route_params = params_dict[u"static_route_params"]
        except KeyError:
            _static_route_params = static_route_params
        if isinstance(_static_route_params, dict):
            obj = StaticRouteParameters(params_dict=_static_route_params)
            self.static_route_params = obj
        else:
            self.static_route_params = _static_route_params
        try:
            _bfd_params = params_dict[u"bfd_params"]
        except KeyError:
            _bfd_params = bfd_params
        if isinstance(_bfd_params, dict):
            obj = BfdParameters(params_dict=_bfd_params)
            self.bfd_params = obj
        else:
            self.bfd_params = _bfd_params
        try:
            _routing_policy_params = params_dict[u"routing_policy_params"]
        except KeyError:
            _routing_policy_params = routing_policy_params
        if isinstance(_routing_policy_params, dict):
            obj = RoutingPolicyParameters(params_dict=_routing_policy_params)
            self.routing_policy_params = obj
        else:
            self.routing_policy_params = _routing_policy_params
    def factory(*args_, **kwargs_):
        if RoutedProperties.subclass:
            return RoutedProperties.subclass(*args_, **kwargs_)
        else:
            return RoutedProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_physical_router_uuid(self): return self.physical_router_uuid
    def set_physical_router_uuid(self, physical_router_uuid): self.physical_router_uuid = physical_router_uuid
    def get_logical_router_uuid(self): return self.logical_router_uuid
    def set_logical_router_uuid(self, logical_router_uuid): self.logical_router_uuid = logical_router_uuid
    def get_routed_interface_ip_address(self): return self.routed_interface_ip_address
    def set_routed_interface_ip_address(self, routed_interface_ip_address): self.routed_interface_ip_address = routed_interface_ip_address
    def validate_IpAddressType(self, value):
        # Validate type IpAddressType, a restriction on xsd:string.
        pass
    def get_loopback_ip_address(self): return self.loopback_ip_address
    def set_loopback_ip_address(self, loopback_ip_address): self.loopback_ip_address = loopback_ip_address
    def get_routing_protocol(self): return self.routing_protocol
    def set_routing_protocol(self, routing_protocol): self.routing_protocol = routing_protocol
    def validate_RoutingProtocolType(self, value):
        # Validate type RoutingProtocolType, a restriction on xsd:string.
        error = False
        if isinstance(value, list):
            error = set(value) - set([u'static-routes', u'bgp', u'ospf', u'pim'])
        else:
            error = value not in [u'static-routes', u'bgp', u'ospf', u'pim']
        if error:
            raise ValueError("RoutingProtocolType must be one of [u'static-routes', u'bgp', u'ospf', u'pim']")
    def get_bgp_params(self): return self.bgp_params
    def set_bgp_params(self, bgp_params): self.bgp_params = bgp_params
    def get_ospf_params(self): return self.ospf_params
    def set_ospf_params(self, ospf_params): self.ospf_params = ospf_params
    def get_pim_params(self): return self.pim_params
    def set_pim_params(self, pim_params): self.pim_params = pim_params
    def get_static_route_params(self): return self.static_route_params
    def set_static_route_params(self, static_route_params): self.static_route_params = static_route_params
    def get_bfd_params(self): return self.bfd_params
    def set_bfd_params(self, bfd_params): self.bfd_params = bfd_params
    def get_routing_policy_params(self): return self.routing_policy_params
    def set_routing_policy_params(self, routing_policy_params): self.routing_policy_params = routing_policy_params
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.physical_router_uuid == other.physical_router_uuid and
                    self.logical_router_uuid == other.logical_router_uuid and
                    self.routed_interface_ip_address == other.routed_interface_ip_address and
                    self.loopback_ip_address == other.loopback_ip_address and
                    self.routing_protocol == other.routing_protocol and
                    self.bgp_params == other.bgp_params and
                    self.ospf_params == other.ospf_params and
                    self.pim_params == other.pim_params and
                    self.static_route_params == other.static_route_params and
                    self.bfd_params == other.bfd_params and
                    self.routing_policy_params == other.routing_policy_params)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.physical_router_uuid if self.physical_router_uuid is not None else -7985492147856592190,
                     self.logical_router_uuid if self.logical_router_uuid is not None else -7985492147856592190,
                     self.routed_interface_ip_address if self.routed_interface_ip_address is not None else -7985492147856592190,
                     self.loopback_ip_address if self.loopback_ip_address is not None else -7985492147856592190,
                     self.routing_protocol if self.routing_protocol is not None else -7985492147856592190,
                     self.bgp_params if self.bgp_params is not None else -7985492147856592190,
                     self.ospf_params if self.ospf_params is not None else -7985492147856592190,
                     self.pim_params if self.pim_params is not None else -7985492147856592190,
                     self.static_route_params if self.static_route_params is not None else -7985492147856592190,
                     self.bfd_params if self.bfd_params is not None else -7985492147856592190,
                     self.routing_policy_params if self.routing_policy_params is not None else -7985492147856592190))

    def __repr__(self):
        return ("physical_router_uuid = " + str(self.physical_router_uuid) + ", " +
                "logical_router_uuid = " + str(self.logical_router_uuid) + ", " +
                "routed_interface_ip_address = " + str(self.routed_interface_ip_address) + ", " +
                "loopback_ip_address = " + str(self.loopback_ip_address) + ", " +
                "routing_protocol = " + str(self.routing_protocol) + ", " +
                "bgp_params = " + str(self.bgp_params) + ", " +
                "ospf_params = " + str(self.ospf_params) + ", " +
                "pim_params = " + str(self.pim_params) + ", " +
                "static_route_params = " + str(self.static_route_params) + ", " +
                "bfd_params = " + str(self.bfd_params) + ", " +
                "routing_policy_params = " + str(self.routing_policy_params))

    def copy(self):
        cp = RoutedProperties()
        if self.physical_router_uuid is not None:
            cp.physical_router_uuid = self.physical_router_uuid
        if self.logical_router_uuid is not None:
            cp.logical_router_uuid = self.logical_router_uuid
        if self.routed_interface_ip_address is not None:
            cp.routed_interface_ip_address = self.routed_interface_ip_address
        if self.loopback_ip_address is not None:
            cp.loopback_ip_address = self.loopback_ip_address
        if self.routing_protocol is not None:
            cp.routing_protocol = self.routing_protocol
        if self.bgp_params is not None:
            cp.bgp_params = self.bgp_params.copy()
        if self.ospf_params is not None:
            cp.ospf_params = self.ospf_params.copy()
        if self.pim_params is not None:
            cp.pim_params = self.pim_params.copy()
        if self.static_route_params is not None:
            cp.static_route_params = self.static_route_params.copy()
        if self.bfd_params is not None:
            cp.bfd_params = self.bfd_params.copy()
        if self.routing_policy_params is not None:
            cp.routing_policy_params = self.routing_policy_params.copy()
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_physical_router_uuid (obj.populate_string ("physical_router_uuid"))
        obj.set_logical_router_uuid (obj.populate_string ("logical_router_uuid"))
        obj.set_routed_interface_ip_address (obj.populate_string ("routed_interface_ip_address"))
        obj.set_loopback_ip_address (obj.populate_string ("loopback_ip_address"))
        obj.set_routing_protocol (obj.populate_string ("routing_protocol"))
        obj.set_bgp_params (BgpParameters.populate ())
        obj.set_ospf_params (OspfParameters.populate ())
        obj.set_pim_params (PimParameters.populate ())
        obj.set_static_route_params (StaticRouteParameters.populate ())
        obj.set_bfd_params (BfdParameters.populate ())
        obj.set_routing_policy_params (RoutingPolicyParameters.populate ())
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='RoutedProperties', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RoutedProperties')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RoutedProperties'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RoutedProperties', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.physical_router_uuid is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sphysical-router-uuid>%s</%sphysical-router-uuid>%s' % (namespace_, self.gds_format_string(quote_xml(self.physical_router_uuid).encode(ExternalEncoding), input_name='physical-router-uuid'), namespace_, eol_))
        if self.logical_router_uuid is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slogical-router-uuid>%s</%slogical-router-uuid>%s' % (namespace_, self.gds_format_string(quote_xml(self.logical_router_uuid).encode(ExternalEncoding), input_name='logical-router-uuid'), namespace_, eol_))
        if self.routed_interface_ip_address is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srouted-interface-ip-address>%s</%srouted-interface-ip-address>%s' % (namespace_, self.gds_format_string(quote_xml(self.routed_interface_ip_address).encode(ExternalEncoding), input_name='routed-interface-ip-address'), namespace_, eol_))
        if self.loopback_ip_address is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sloopback-ip-address>%s</%sloopback-ip-address>%s' % (namespace_, self.gds_format_string(quote_xml(self.loopback_ip_address).encode(ExternalEncoding), input_name='loopback-ip-address'), namespace_, eol_))
        if self.routing_protocol is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srouting-protocol>%s</%srouting-protocol>%s' % (namespace_, self.gds_format_string(quote_xml(self.routing_protocol).encode(ExternalEncoding), input_name='routing-protocol'), namespace_, eol_))
        if self.bgp_params is not None:
            self.bgp_params.export_xml(outfile, level, namespace_, name_='bgp-params', pretty_print=pretty_print)
        if self.ospf_params is not None:
            self.ospf_params.export_xml(outfile, level, namespace_, name_='ospf-params', pretty_print=pretty_print)
        if self.pim_params is not None:
            self.pim_params.export_xml(outfile, level, namespace_, name_='pim-params', pretty_print=pretty_print)
        if self.static_route_params is not None:
            self.static_route_params.export_xml(outfile, level, namespace_, name_='static-route-params', pretty_print=pretty_print)
        if self.bfd_params is not None:
            self.bfd_params.export_xml(outfile, level, namespace_, name_='bfd-params', pretty_print=pretty_print)
        if self.routing_policy_params is not None:
            self.routing_policy_params.export_xml(outfile, level, namespace_, name_='routing-policy-params', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.physical_router_uuid is not None or
            self.logical_router_uuid is not None or
            self.routed_interface_ip_address is not None or
            self.loopback_ip_address is not None or
            self.routing_protocol is not None or
            self.bgp_params is not None or
            self.ospf_params is not None or
            self.pim_params is not None or
            self.static_route_params is not None or
            self.bfd_params is not None or
            self.routing_policy_params is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RoutedProperties'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.physical_router_uuid is not None:
            showIndent(outfile, level)
            outfile.write('physical_router_uuid=%s,\n' % quote_python(self.physical_router_uuid).encode(ExternalEncoding))
        if self.logical_router_uuid is not None:
            showIndent(outfile, level)
            outfile.write('logical_router_uuid=%s,\n' % quote_python(self.logical_router_uuid).encode(ExternalEncoding))
        if self.routed_interface_ip_address is not None:
            showIndent(outfile, level)
            outfile.write('routed_interface_ip_address=%s,\n' % quote_python(self.routed_interface_ip_address).encode(ExternalEncoding))
        if self.loopback_ip_address is not None:
            showIndent(outfile, level)
            outfile.write('loopback_ip_address=%s,\n' % quote_python(self.loopback_ip_address).encode(ExternalEncoding))
        if self.routing_protocol is not None:
            showIndent(outfile, level)
            outfile.write('routing_protocol=%s,\n' % quote_python(self.routing_protocol).encode(ExternalEncoding))
        if self.bgp_params is not None:
            showIndent(outfile, level)
            outfile.write('bgp_params=model_.BgpParameters(\n')
            self.bgp_params.exportLiteral(outfile, level, name_='bgp_params')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ospf_params is not None:
            showIndent(outfile, level)
            outfile.write('ospf_params=model_.OspfParameters(\n')
            self.ospf_params.exportLiteral(outfile, level, name_='ospf_params')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.pim_params is not None:
            showIndent(outfile, level)
            outfile.write('pim_params=model_.PimParameters(\n')
            self.pim_params.exportLiteral(outfile, level, name_='pim_params')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.static_route_params is not None:
            showIndent(outfile, level)
            outfile.write('static_route_params=model_.StaticRouteParameters(\n')
            self.static_route_params.exportLiteral(outfile, level, name_='static_route_params')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.bfd_params is not None:
            showIndent(outfile, level)
            outfile.write('bfd_params=model_.BfdParameters(\n')
            self.bfd_params.exportLiteral(outfile, level, name_='bfd_params')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.routing_policy_params is not None:
            showIndent(outfile, level)
            outfile.write('routing_policy_params=model_.RoutingPolicyParameters(\n')
            self.routing_policy_params.exportLiteral(outfile, level, name_='routing_policy_params')
            showIndent(outfile, level)
            outfile.write('),\n')
    def exportDict(self, name_='RoutedProperties'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'physical-router-uuid':
            physical_router_uuid_ = child_.text
            physical_router_uuid_ = self.gds_validate_string(physical_router_uuid_, node, 'physical_router_uuid')
            self.physical_router_uuid = physical_router_uuid_
        elif nodeName_ == 'logical-router-uuid':
            logical_router_uuid_ = child_.text
            logical_router_uuid_ = self.gds_validate_string(logical_router_uuid_, node, 'logical_router_uuid')
            self.logical_router_uuid = logical_router_uuid_
        elif nodeName_ == 'routed-interface-ip-address':
            routed_interface_ip_address_ = child_.text
            routed_interface_ip_address_ = self.gds_validate_string(routed_interface_ip_address_, node, 'routed_interface_ip_address')
            self.routed_interface_ip_address = routed_interface_ip_address_
            self.validate_IpAddressType(self.routed_interface_ip_address)    # validate type IpAddressType
        elif nodeName_ == 'loopback-ip-address':
            loopback_ip_address_ = child_.text
            loopback_ip_address_ = self.gds_validate_string(loopback_ip_address_, node, 'loopback_ip_address')
            self.loopback_ip_address = loopback_ip_address_
            self.validate_IpAddressType(self.loopback_ip_address)    # validate type IpAddressType
        elif nodeName_ == 'routing-protocol':
            routing_protocol_ = child_.text
            routing_protocol_ = self.gds_validate_string(routing_protocol_, node, 'routing_protocol')
            self.routing_protocol = routing_protocol_
            self.validate_RoutingProtocolType(self.routing_protocol)    # validate type RoutingProtocolType
        elif nodeName_ == 'bgp-params':
            obj_ = BgpParameters.factory()
            obj_.build(child_)
            self.set_bgp_params(obj_)
        elif nodeName_ == 'ospf-params':
            obj_ = OspfParameters.factory()
            obj_.build(child_)
            self.set_ospf_params(obj_)
        elif nodeName_ == 'pim-params':
            obj_ = PimParameters.factory()
            obj_.build(child_)
            self.set_pim_params(obj_)
        elif nodeName_ == 'static-route-params':
            obj_ = StaticRouteParameters.factory()
            obj_.build(child_)
            self.set_static_route_params(obj_)
        elif nodeName_ == 'bfd-params':
            obj_ = BfdParameters.factory()
            obj_.build(child_)
            self.set_bfd_params(obj_)
        elif nodeName_ == 'routing-policy-params':
            obj_ = RoutingPolicyParameters.factory()
            obj_.build(child_)
            self.set_routing_policy_params(obj_)
# end class RoutedProperties


class VirtualNetworkType(GeneratedsSuper):
    """
    Attributes:
    * allow_transit
        Type:           bool

        Created By:           User (optional)

        Description:
          Enables transitive property for route imports.

              If B imports routes of A and C imports from B,

              then if B is transitive then C will have routes from A.

    * network_id
        Type:           int

        Description:
          Not currently in used

    * vxlan_network_identifier
        Type:           int, *within* [1, 16777215]

        Created By:           User (required)

        Description:
          VxLAN VNI value for this network

    * forwarding_mode
        Type:           str, *one-of* [u'l2_l3', u'l2', u'l3']

        Created By:           User (optional)

        Description:
          Packet forwarding mode for this virtual network

    * rpf
        Type:           str, *one-of* [u'enable', u'disable']

        Created By:           User (optional)

        Description:
          Flag used to disable Reverse Path Forwarding(RPF) check for this network

    * mirror_destination
        Type:           bool

        Created By:           User (optional)

        Description:
          Flag to mark the virtual network as mirror destination network

    * max_flows
        Type:           int, *within* [0, 4294967296]

        Created By:           User (optional)

        Description:
          Maximum number of flows permitted on each VMI of the VN

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'allow_transit', u'network_id', u'vxlan_network_identifier', u'forwarding_mode', u'rpf', u'mirror_destination', u'max_flows']
    attr_field_type_vals = {u'forwarding_mode': {'restrictions': [u'l2_l3', u'l2', u'l3'], 'description': [u'Packet forwarding mode for this virtual network'], 'simple_type': u'ForwardingModeType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'allow_transit': {'restrictions': None, 'description': [u'Enables transitive property for route imports.', u'    If B imports routes of A and C imports from B,', u'    then if B is transitive then C will have routes from A.'], 'simple_type': u'xsd:boolean', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'boolean'}, u'network_id': {'restrictions': None, 'description': [u'Not currently in used'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'system-only', 'attr_type': u'integer'}, u'mirror_destination': {'restrictions': None, 'description': [u'Flag to mark the virtual network as mirror destination network'], 'simple_type': u'xsd:boolean', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'boolean'}, u'vxlan_network_identifier': {'restrictions': [1, 16777215], 'description': [u'VxLAN VNI value for this network'], 'simple_type': u'VxlanNetworkIdentifierType', 'is_complex': 0, 'restriction_type': 'range', 'is_array': False, 'required': u'true', 'attr_type': u'integer'}, u'max_flows': {'restrictions': [0, 4294967296], 'description': [u'Maximum number of flows permitted on each VMI of the VN'], 'simple_type': u'MaxFlowsType', 'is_complex': 0, 'restriction_type': 'range', 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'rpf': {'restrictions': [u'enable', u'disable'], 'description': [u'Flag used to disable Reverse Path Forwarding(RPF) check for this network'], 'simple_type': u'RpfModeType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'optional', 'attr_type': u'string'}}
    def __init__(self, allow_transit=None, network_id=None, vxlan_network_identifier=None, forwarding_mode=None, rpf=None, mirror_destination=False, max_flows=0, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _allow_transit = params_dict[u"allow_transit"]
        except KeyError:
            _allow_transit = allow_transit
        self.allow_transit = _allow_transit
        try:
            _network_id = params_dict[u"network_id"]
        except KeyError:
            _network_id = network_id
        self.network_id = _network_id
        try:
            _vxlan_network_identifier = params_dict[u"vxlan_network_identifier"]
        except KeyError:
            _vxlan_network_identifier = vxlan_network_identifier
        self.vxlan_network_identifier = _vxlan_network_identifier
        try:
            _forwarding_mode = params_dict[u"forwarding_mode"]
        except KeyError:
            _forwarding_mode = forwarding_mode
        self.forwarding_mode = _forwarding_mode
        try:
            _rpf = params_dict[u"rpf"]
        except KeyError:
            _rpf = rpf
        self.rpf = _rpf
        try:
            _mirror_destination = params_dict[u"mirror_destination"]
        except KeyError:
            _mirror_destination = mirror_destination
        self.mirror_destination = _mirror_destination
        try:
            _max_flows = params_dict[u"max_flows"]
        except KeyError:
            _max_flows = max_flows
        self.max_flows = _max_flows
    def factory(*args_, **kwargs_):
        if VirtualNetworkType.subclass:
            return VirtualNetworkType.subclass(*args_, **kwargs_)
        else:
            return VirtualNetworkType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_allow_transit(self): return self.allow_transit
    def set_allow_transit(self, allow_transit): self.allow_transit = allow_transit
    def get_network_id(self): return self.network_id
    def set_network_id(self, network_id): self.network_id = network_id
    def get_vxlan_network_identifier(self): return self.vxlan_network_identifier
    def set_vxlan_network_identifier(self, vxlan_network_identifier): self.vxlan_network_identifier = vxlan_network_identifier
    def validate_VxlanNetworkIdentifierType(self, value):
        # Validate type VxlanNetworkIdentifierType, a restriction on xsd:integer.
        error = False
        if isinstance(value, list):
            v_int = list(map(int, value))
            v1, v2 = min(v_int), max(v_int)
        else:
            v1, v2 = int(value), int(value)
        error = (1 > v1)
        error |= (v2 > 16777215)
        if error:
            raise ValueError("VxlanNetworkIdentifierType must be in the range {'minimum': 1}-{'maximum': 16777215}")
    def get_forwarding_mode(self): return self.forwarding_mode
    def set_forwarding_mode(self, forwarding_mode): self.forwarding_mode = forwarding_mode
    def validate_ForwardingModeType(self, value):
        # Validate type ForwardingModeType, a restriction on xsd:string.
        error = False
        if isinstance(value, list):
            error = set(value) - set([u'l2_l3', u'l2', u'l3'])
        else:
            error = value not in [u'l2_l3', u'l2', u'l3']
        if error:
            raise ValueError("ForwardingModeType must be one of [u'l2_l3', u'l2', u'l3']")
    def get_rpf(self): return self.rpf
    def set_rpf(self, rpf): self.rpf = rpf
    def validate_RpfModeType(self, value):
        # Validate type RpfModeType, a restriction on xsd:string.
        error = False
        if isinstance(value, list):
            error = set(value) - set([u'enable', u'disable'])
        else:
            error = value not in [u'enable', u'disable']
        if error:
            raise ValueError("RpfModeType must be one of [u'enable', u'disable']")
    def get_mirror_destination(self): return self.mirror_destination
    def set_mirror_destination(self, mirror_destination): self.mirror_destination = mirror_destination
    def get_max_flows(self): return self.max_flows
    def set_max_flows(self, max_flows): self.max_flows = max_flows
    def validate_MaxFlowsType(self, value):
        # Validate type MaxFlowsType, a restriction on xsd:integer.
        error = False
        if isinstance(value, list):
            v_int = list(map(int, value))
            v1, v2 = min(v_int), max(v_int)
        else:
            v1, v2 = int(value), int(value)
        error |= (v2 > 4294967296)
        if error:
            raise ValueError("MaxFlowsType must be in the range {'minimum': 0}-{'maximum': 4294967296}")
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.allow_transit == other.allow_transit and
                    self.network_id == other.network_id and
                    self.vxlan_network_identifier == other.vxlan_network_identifier and
                    self.forwarding_mode == other.forwarding_mode and
                    self.rpf == other.rpf and
                    self.mirror_destination == other.mirror_destination and
                    self.max_flows == other.max_flows)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.allow_transit if self.allow_transit is not None else -7985492147856592190,
                     self.network_id if self.network_id is not None else -7985492147856592190,
                     self.vxlan_network_identifier if self.vxlan_network_identifier is not None else -7985492147856592190,
                     self.forwarding_mode if self.forwarding_mode is not None else -7985492147856592190,
                     self.rpf if self.rpf is not None else -7985492147856592190,
                     self.mirror_destination if self.mirror_destination is not None else -7985492147856592190,
                     self.max_flows if self.max_flows is not None else -7985492147856592190))

    def __repr__(self):
        return ("allow_transit = " + str(self.allow_transit) + ", " +
                "network_id = " + str(self.network_id) + ", " +
                "vxlan_network_identifier = " + str(self.vxlan_network_identifier) + ", " +
                "forwarding_mode = " + str(self.forwarding_mode) + ", " +
                "rpf = " + str(self.rpf) + ", " +
                "mirror_destination = " + str(self.mirror_destination) + ", " +
                "max_flows = " + str(self.max_flows))

    def copy(self):
        cp = VirtualNetworkType()
        if self.allow_transit is not None:
            cp.allow_transit = self.allow_transit
        if self.network_id is not None:
            cp.network_id = self.network_id
        if self.vxlan_network_identifier is not None:
            cp.vxlan_network_identifier = self.vxlan_network_identifier
        if self.forwarding_mode is not None:
            cp.forwarding_mode = self.forwarding_mode
        if self.rpf is not None:
            cp.rpf = self.rpf
        if self.mirror_destination is not None:
            cp.mirror_destination = self.mirror_destination
        if self.max_flows is not None:
            cp.max_flows = self.max_flows
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_allow_transit (obj.populate_boolean ("allow_transit"))
        obj.set_network_id (obj.populate_integer ("network_id"))
        obj.set_vxlan_network_identifier (obj.populate_integer ("vxlan_network_identifier"))
        obj.set_forwarding_mode (obj.populate_string ("forwarding_mode"))
        obj.set_rpf (obj.populate_string ("rpf"))
        obj.set_mirror_destination (obj.populate_boolean ("mirror_destination"))
        obj.set_max_flows (obj.populate_integer ("max_flows"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='VirtualNetworkType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VirtualNetworkType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VirtualNetworkType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VirtualNetworkType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.allow_transit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sallow-transit>%s</%sallow-transit>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.allow_transit)), input_name='allow-transit'), namespace_, eol_))
        if self.network_id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snetwork-id>%s</%snetwork-id>%s' % (namespace_, self.gds_format_integer(self.network_id, input_name='network-id'), namespace_, eol_))
        if self.vxlan_network_identifier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svxlan-network-identifier>%s</%svxlan-network-identifier>%s' % (namespace_, self.gds_format_integer(self.vxlan_network_identifier, input_name='vxlan-network-identifier'), namespace_, eol_))
        if self.forwarding_mode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sforwarding-mode>%s</%sforwarding-mode>%s' % (namespace_, self.gds_format_string(quote_xml(self.forwarding_mode).encode(ExternalEncoding), input_name='forwarding-mode'), namespace_, eol_))
        if self.rpf is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srpf>%s</%srpf>%s' % (namespace_, self.gds_format_string(quote_xml(self.rpf).encode(ExternalEncoding), input_name='rpf'), namespace_, eol_))
        if self.mirror_destination is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smirror-destination>%s</%smirror-destination>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.mirror_destination)), input_name='mirror-destination'), namespace_, eol_))
        if self.max_flows is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smax-flows>%s</%smax-flows>%s' % (namespace_, self.gds_format_integer(self.max_flows, input_name='max-flows'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.allow_transit is not None or
            self.network_id is not None or
            self.vxlan_network_identifier is not None or
            self.forwarding_mode is not None or
            self.rpf is not None or
            self.mirror_destination is not None or
            self.max_flows is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='VirtualNetworkType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.allow_transit is not None:
            showIndent(outfile, level)
            outfile.write('allow_transit=%s,\n' % self.allow_transit)
        if self.network_id is not None:
            showIndent(outfile, level)
            outfile.write('network_id=%d,\n' % self.network_id)
        if self.vxlan_network_identifier is not None:
            showIndent(outfile, level)
            outfile.write('vxlan_network_identifier=%d,\n' % self.vxlan_network_identifier)
        if self.forwarding_mode is not None:
            showIndent(outfile, level)
            outfile.write('forwarding_mode=%s,\n' % quote_python(self.forwarding_mode).encode(ExternalEncoding))
        if self.rpf is not None:
            showIndent(outfile, level)
            outfile.write('rpf=%s,\n' % quote_python(self.rpf).encode(ExternalEncoding))
        if self.mirror_destination is not None:
            showIndent(outfile, level)
            outfile.write('mirror_destination=%s,\n' % self.mirror_destination)
        if self.max_flows is not None:
            showIndent(outfile, level)
            outfile.write('max_flows=%d,\n' % self.max_flows)
    def exportDict(self, name_='VirtualNetworkType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'allow-transit':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allow_transit')
            self.allow_transit = ival_
        elif nodeName_ == 'network-id':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'network_id')
            self.network_id = ival_
        elif nodeName_ == 'vxlan-network-identifier':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'vxlan_network_identifier')
            self.vxlan_network_identifier = ival_
            self.validate_VxlanNetworkIdentifierType(self.vxlan_network_identifier)    # validate type VxlanNetworkIdentifierType
        elif nodeName_ == 'forwarding-mode':
            forwarding_mode_ = child_.text
            forwarding_mode_ = self.gds_validate_string(forwarding_mode_, node, 'forwarding_mode')
            self.forwarding_mode = forwarding_mode_
            self.validate_ForwardingModeType(self.forwarding_mode)    # validate type ForwardingModeType
        elif nodeName_ == 'rpf':
            rpf_ = child_.text
            rpf_ = self.gds_validate_string(rpf_, node, 'rpf')
            self.rpf = rpf_
            self.validate_RpfModeType(self.rpf)    # validate type RpfModeType
        elif nodeName_ == 'mirror-destination':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'mirror_destination')
            self.mirror_destination = ival_
        elif nodeName_ == 'max-flows':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'max_flows')
            self.max_flows = ival_
            self.validate_MaxFlowsType(self.max_flows)    # validate type MaxFlowsType
# end class VirtualNetworkType


class ProviderDetails(GeneratedsSuper):
    """
    Attributes:
    * segmentation_id
        Type:           int, *within* [0, 4094]

    * physical_network
        Type:           str

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'segmentation_id', u'physical_network']
    attr_field_type_vals = {u'segmentation_id': {'restrictions': [0, 4094], 'description': [], 'simple_type': u'VlanIdType', 'is_complex': 0, 'restriction_type': 'range', 'is_array': False, 'required': None, 'attr_type': u'integer'}, u'physical_network': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}}
    def __init__(self, segmentation_id=None, physical_network=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _segmentation_id = params_dict[u"segmentation_id"]
        except KeyError:
            _segmentation_id = segmentation_id
        self.segmentation_id = _segmentation_id
        try:
            _physical_network = params_dict[u"physical_network"]
        except KeyError:
            _physical_network = physical_network
        self.physical_network = _physical_network
    def factory(*args_, **kwargs_):
        if ProviderDetails.subclass:
            return ProviderDetails.subclass(*args_, **kwargs_)
        else:
            return ProviderDetails(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_segmentation_id(self): return self.segmentation_id
    def set_segmentation_id(self, segmentation_id): self.segmentation_id = segmentation_id
    def validate_VlanIdType(self, value):
        # Validate type VlanIdType, a restriction on xsd:integer.
        error = False
        if isinstance(value, list):
            v_int = list(map(int, value))
            v1, v2 = min(v_int), max(v_int)
        else:
            v1, v2 = int(value), int(value)
        error |= (v2 > 4094)
        if error:
            raise ValueError("VlanIdType must be in the range {'minimum': 0}-{'maximum': 4094}")
    def get_physical_network(self): return self.physical_network
    def set_physical_network(self, physical_network): self.physical_network = physical_network
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.segmentation_id == other.segmentation_id and
                    self.physical_network == other.physical_network)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.segmentation_id if self.segmentation_id is not None else -7985492147856592190,
                     self.physical_network if self.physical_network is not None else -7985492147856592190))

    def __repr__(self):
        return ("segmentation_id = " + str(self.segmentation_id) + ", " +
                "physical_network = " + str(self.physical_network))

    def copy(self):
        cp = ProviderDetails()
        if self.segmentation_id is not None:
            cp.segmentation_id = self.segmentation_id
        if self.physical_network is not None:
            cp.physical_network = self.physical_network
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_segmentation_id (obj.populate_integer ("segmentation_id"))
        obj.set_physical_network (obj.populate_string ("physical_network"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='ProviderDetails', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProviderDetails')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ProviderDetails'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ProviderDetails', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.segmentation_id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssegmentation-id>%s</%ssegmentation-id>%s' % (namespace_, self.gds_format_integer(self.segmentation_id, input_name='segmentation-id'), namespace_, eol_))
        if self.physical_network is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sphysical-network>%s</%sphysical-network>%s' % (namespace_, self.gds_format_string(quote_xml(self.physical_network).encode(ExternalEncoding), input_name='physical-network'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.segmentation_id is not None or
            self.physical_network is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ProviderDetails'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.segmentation_id is not None:
            showIndent(outfile, level)
            outfile.write('segmentation_id=%d,\n' % self.segmentation_id)
        if self.physical_network is not None:
            showIndent(outfile, level)
            outfile.write('physical_network=%s,\n' % quote_python(self.physical_network).encode(ExternalEncoding))
    def exportDict(self, name_='ProviderDetails'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'segmentation-id':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'segmentation_id')
            self.segmentation_id = ival_
            self.validate_VlanIdType(self.segmentation_id)    # validate type VlanIdType
        elif nodeName_ == 'physical-network':
            physical_network_ = child_.text
            physical_network_ = self.gds_validate_string(physical_network_, node, 'physical_network')
            self.physical_network = physical_network_
# end class ProviderDetails


class RouteTargetList(GeneratedsSuper):
    """
    Attributes:
    * route_target
        Type:           str

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'route_target']
    attr_field_type_vals = {u'route_target': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': True, 'required': None, 'attr_type': u'string'}}
    def __init__(self, route_target=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _route_target = params_dict[u"route_target"]
        except KeyError:
            _route_target = route_target
        if not _route_target:
            self.route_target = []
        else:
            self.route_target = _route_target
    def factory(*args_, **kwargs_):
        if RouteTargetList.subclass:
            return RouteTargetList.subclass(*args_, **kwargs_)
        else:
            return RouteTargetList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_route_target(self): return self.route_target
    def set_route_target(self, route_target): self.route_target = route_target
    def add_route_target(self, value): self.route_target.append(value)
    def insert_route_target(self, index, value): self.route_target[index] = value
    def delete_route_target(self, value): self.route_target.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.route_target == other.route_target)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.route_target or [])))

    def __repr__(self):
        return ("route_target = " + str(self.route_target))

    def copy(self):
        cp = RouteTargetList()
        if self.route_target is not None:
            cp.route_target = list(self.route_target)
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_route_target ([obj.populate_string ("route_target")])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='RouteTargetList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RouteTargetList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RouteTargetList'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RouteTargetList', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for route_target_ in self.route_target:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sroute-target>%s</%sroute-target>%s' % (namespace_, self.gds_format_string(quote_xml(route_target_).encode(ExternalEncoding), input_name='route-target'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.route_target
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RouteTargetList'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('route_target=[\n')
        level += 1
        for route_target_ in self.route_target:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(route_target_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='RouteTargetList'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'route-target':
            route_target_ = child_.text
            route_target_ = self.gds_validate_string(route_target_, node, 'route_target')
            self.route_target.append(route_target_)
# end class RouteTargetList


class IpamSubnets(GeneratedsSuper):
    """
    Attributes:
    * subnets
        Type:           :class:`.IpamSubnetType`

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'subnets']
    attr_field_type_vals = {u'subnets': {'restrictions': None, 'description': [], 'simple_type': u'IpamSubnetType', 'is_complex': 1, 'restriction_type': None, 'is_array': True, 'required': None, 'attr_type': u'IpamSubnetType'}}
    def __init__(self, subnets=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _subnets = params_dict[u"subnets"]
        except KeyError:
            _subnets = subnets
        if not _subnets:
            self.subnets = []
        else:
            if isinstance(_subnets[0], dict):
                objs = [IpamSubnetType(params_dict=elem) for elem in _subnets]
                self.subnets = objs
            else:
                self.subnets = _subnets
    def factory(*args_, **kwargs_):
        if IpamSubnets.subclass:
            return IpamSubnets.subclass(*args_, **kwargs_)
        else:
            return IpamSubnets(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_subnets(self): return self.subnets
    def set_subnets(self, subnets): self.subnets = subnets
    def add_subnets(self, value): self.subnets.append(value)
    def insert_subnets(self, index, value): self.subnets[index] = value
    def delete_subnets(self, value): self.subnets.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.subnets == other.subnets)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.subnets or [])))

    def __repr__(self):
        return ("subnets = " + str(self.subnets))

    def copy(self):
        cp = IpamSubnets()
        if self.subnets is not None:
            cp.subnets = [x.copy() for x in self.subnets]
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_subnets ([IpamSubnetType.populate ()])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='IpamSubnets', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IpamSubnets')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IpamSubnets'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='IpamSubnets', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for subnets_ in self.subnets:
            if isinstance(subnets_, dict):
                subnets_ = IpamSubnetType(**subnets_)
            subnets_.export_xml(outfile, level, namespace_, name_='subnets', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.subnets
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='IpamSubnets'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('subnets=[\n')
        level += 1
        for subnets_ in self.subnets:
            showIndent(outfile, level)
            outfile.write('model_.IpamSubnetType(\n')
            subnets_.exportLiteral(outfile, level, name_='IpamSubnetType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='IpamSubnets'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'subnets':
            obj_ = IpamSubnetType.factory()
            obj_.build(child_)
            self.subnets.append(obj_)
# end class IpamSubnets


class VrfAssignRuleType(GeneratedsSuper):
    """
    Attributes:
    * match_condition
        Type:           :class:`.MatchConditionType`

    * vlan_tag
        Type:           int

    * routing_instance
        Type:           str

    * ignore_acl
        Type:           bool

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'match_condition', u'vlan_tag', u'routing_instance', u'ignore_acl']
    attr_field_type_vals = {u'routing_instance': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'match_condition': {'restrictions': None, 'description': [], 'simple_type': u'MatchConditionType', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'MatchConditionType'}, u'vlan_tag': {'restrictions': None, 'description': [], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'integer'}, u'ignore_acl': {'restrictions': None, 'description': [], 'simple_type': u'xsd:boolean', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'boolean'}}
    def __init__(self, match_condition=None, vlan_tag=None, routing_instance=None, ignore_acl=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _match_condition = params_dict[u"match_condition"]
        except KeyError:
            _match_condition = match_condition
        if isinstance(_match_condition, dict):
            obj = MatchConditionType(params_dict=_match_condition)
            self.match_condition = obj
        else:
            self.match_condition = _match_condition
        try:
            _vlan_tag = params_dict[u"vlan_tag"]
        except KeyError:
            _vlan_tag = vlan_tag
        self.vlan_tag = _vlan_tag
        try:
            _routing_instance = params_dict[u"routing_instance"]
        except KeyError:
            _routing_instance = routing_instance
        self.routing_instance = _routing_instance
        try:
            _ignore_acl = params_dict[u"ignore_acl"]
        except KeyError:
            _ignore_acl = ignore_acl
        self.ignore_acl = _ignore_acl
    def factory(*args_, **kwargs_):
        if VrfAssignRuleType.subclass:
            return VrfAssignRuleType.subclass(*args_, **kwargs_)
        else:
            return VrfAssignRuleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_match_condition(self): return self.match_condition
    def set_match_condition(self, match_condition): self.match_condition = match_condition
    def get_vlan_tag(self): return self.vlan_tag
    def set_vlan_tag(self, vlan_tag): self.vlan_tag = vlan_tag
    def get_routing_instance(self): return self.routing_instance
    def set_routing_instance(self, routing_instance): self.routing_instance = routing_instance
    def get_ignore_acl(self): return self.ignore_acl
    def set_ignore_acl(self, ignore_acl): self.ignore_acl = ignore_acl
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.match_condition == other.match_condition and
                    self.vlan_tag == other.vlan_tag and
                    self.routing_instance == other.routing_instance and
                    self.ignore_acl == other.ignore_acl)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.match_condition if self.match_condition is not None else -7985492147856592190,
                     self.vlan_tag if self.vlan_tag is not None else -7985492147856592190,
                     self.routing_instance if self.routing_instance is not None else -7985492147856592190,
                     self.ignore_acl if self.ignore_acl is not None else -7985492147856592190))

    def __repr__(self):
        return ("match_condition = " + str(self.match_condition) + ", " +
                "vlan_tag = " + str(self.vlan_tag) + ", " +
                "routing_instance = " + str(self.routing_instance) + ", " +
                "ignore_acl = " + str(self.ignore_acl))

    def copy(self):
        cp = VrfAssignRuleType()
        if self.match_condition is not None:
            cp.match_condition = self.match_condition.copy()
        if self.vlan_tag is not None:
            cp.vlan_tag = self.vlan_tag
        if self.routing_instance is not None:
            cp.routing_instance = self.routing_instance
        if self.ignore_acl is not None:
            cp.ignore_acl = self.ignore_acl
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_match_condition (MatchConditionType.populate ())
        obj.set_vlan_tag (obj.populate_integer ("vlan_tag"))
        obj.set_routing_instance (obj.populate_string ("routing_instance"))
        obj.set_ignore_acl (obj.populate_boolean ("ignore_acl"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='VrfAssignRuleType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VrfAssignRuleType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VrfAssignRuleType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VrfAssignRuleType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.match_condition is not None:
            self.match_condition.export_xml(outfile, level, namespace_, name_='match-condition', pretty_print=pretty_print)
        if self.vlan_tag is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svlan-tag>%s</%svlan-tag>%s' % (namespace_, self.gds_format_integer(self.vlan_tag, input_name='vlan-tag'), namespace_, eol_))
        if self.routing_instance is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srouting-instance>%s</%srouting-instance>%s' % (namespace_, self.gds_format_string(quote_xml(self.routing_instance).encode(ExternalEncoding), input_name='routing-instance'), namespace_, eol_))
        if self.ignore_acl is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%signore-acl>%s</%signore-acl>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.ignore_acl)), input_name='ignore-acl'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.match_condition is not None or
            self.vlan_tag is not None or
            self.routing_instance is not None or
            self.ignore_acl is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='VrfAssignRuleType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.match_condition is not None:
            showIndent(outfile, level)
            outfile.write('match_condition=model_.MatchConditionType(\n')
            self.match_condition.exportLiteral(outfile, level, name_='match_condition')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.vlan_tag is not None:
            showIndent(outfile, level)
            outfile.write('vlan_tag=%d,\n' % self.vlan_tag)
        if self.routing_instance is not None:
            showIndent(outfile, level)
            outfile.write('routing_instance=%s,\n' % quote_python(self.routing_instance).encode(ExternalEncoding))
        if self.ignore_acl is not None:
            showIndent(outfile, level)
            outfile.write('ignore_acl=%s,\n' % self.ignore_acl)
    def exportDict(self, name_='VrfAssignRuleType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'match-condition':
            obj_ = MatchConditionType.factory()
            obj_.build(child_)
            self.set_match_condition(obj_)
        elif nodeName_ == 'vlan-tag':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'vlan_tag')
            self.vlan_tag = ival_
        elif nodeName_ == 'routing-instance':
            routing_instance_ = child_.text
            routing_instance_ = self.gds_validate_string(routing_instance_, node, 'routing_instance')
            self.routing_instance = routing_instance_
        elif nodeName_ == 'ignore-acl':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'ignore_acl')
            self.ignore_acl = ival_
# end class VrfAssignRuleType


class VrfAssignTableType(GeneratedsSuper):
    """
    Attributes:
    * vrf_assign_rule
        Type:           :class:`.VrfAssignRuleType`

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'vrf_assign_rule']
    attr_field_type_vals = {u'vrf_assign_rule': {'restrictions': None, 'description': [], 'simple_type': u'VrfAssignRuleType', 'is_complex': 1, 'restriction_type': None, 'is_array': True, 'required': None, 'attr_type': u'VrfAssignRuleType'}}
    def __init__(self, vrf_assign_rule=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _vrf_assign_rule = params_dict[u"vrf_assign_rule"]
        except KeyError:
            _vrf_assign_rule = vrf_assign_rule
        if not _vrf_assign_rule:
            self.vrf_assign_rule = []
        else:
            if isinstance(_vrf_assign_rule[0], dict):
                objs = [VrfAssignRuleType(params_dict=elem) for elem in _vrf_assign_rule]
                self.vrf_assign_rule = objs
            else:
                self.vrf_assign_rule = _vrf_assign_rule
    def factory(*args_, **kwargs_):
        if VrfAssignTableType.subclass:
            return VrfAssignTableType.subclass(*args_, **kwargs_)
        else:
            return VrfAssignTableType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vrf_assign_rule(self): return self.vrf_assign_rule
    def set_vrf_assign_rule(self, vrf_assign_rule): self.vrf_assign_rule = vrf_assign_rule
    def add_vrf_assign_rule(self, value): self.vrf_assign_rule.append(value)
    def insert_vrf_assign_rule(self, index, value): self.vrf_assign_rule[index] = value
    def delete_vrf_assign_rule(self, value): self.vrf_assign_rule.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.vrf_assign_rule == other.vrf_assign_rule)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.vrf_assign_rule or [])))

    def __repr__(self):
        return ("vrf_assign_rule = " + str(self.vrf_assign_rule))

    def copy(self):
        cp = VrfAssignTableType()
        if self.vrf_assign_rule is not None:
            cp.vrf_assign_rule = [x.copy() for x in self.vrf_assign_rule]
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_vrf_assign_rule ([VrfAssignRuleType.populate ()])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='VrfAssignTableType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VrfAssignTableType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VrfAssignTableType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VrfAssignTableType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for vrf_assign_rule_ in self.vrf_assign_rule:
            if isinstance(vrf_assign_rule_, dict):
                vrf_assign_rule_ = VrfAssignRuleType(**vrf_assign_rule_)
            vrf_assign_rule_.export_xml(outfile, level, namespace_, name_='vrf-assign-rule', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.vrf_assign_rule
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='VrfAssignTableType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('vrf_assign_rule=[\n')
        level += 1
        for vrf_assign_rule_ in self.vrf_assign_rule:
            showIndent(outfile, level)
            outfile.write('model_.VrfAssignRuleType(\n')
            vrf_assign_rule_.exportLiteral(outfile, level, name_='VrfAssignRuleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='VrfAssignTableType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vrf-assign-rule':
            obj_ = VrfAssignRuleType.factory()
            obj_.build(child_)
            self.vrf_assign_rule.append(obj_)
# end class VrfAssignTableType


class ServiceInterfaceTag(GeneratedsSuper):
    """
    Attributes:
    * interface_type
        Type:           str, *one-of* xsd:string

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'interface_type']
    attr_field_type_vals = {u'interface_type': {'restrictions': [], 'description': [], 'simple_type': u'ServiceInterfaceType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': None, 'attr_type': u'string'}}
    def __init__(self, interface_type=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _interface_type = params_dict[u"interface_type"]
        except KeyError:
            _interface_type = interface_type
        self.interface_type = _interface_type
    def factory(*args_, **kwargs_):
        if ServiceInterfaceTag.subclass:
            return ServiceInterfaceTag.subclass(*args_, **kwargs_)
        else:
            return ServiceInterfaceTag(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_interface_type(self): return self.interface_type
    def set_interface_type(self, interface_type): self.interface_type = interface_type
    def validate_ServiceInterfaceType(self, value):
        # Validate type ServiceInterfaceType, a restriction on xsd:string.
        pass
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.interface_type == other.interface_type)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.interface_type if self.interface_type is not None else -7985492147856592190))

    def __repr__(self):
        return ("interface_type = " + str(self.interface_type))

    def copy(self):
        cp = ServiceInterfaceTag()
        if self.interface_type is not None:
            cp.interface_type = self.interface_type
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_interface_type (obj.populate_string ("interface_type"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='ServiceInterfaceTag', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ServiceInterfaceTag')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ServiceInterfaceTag'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ServiceInterfaceTag', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.interface_type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinterface-type>%s</%sinterface-type>%s' % (namespace_, self.gds_format_string(quote_xml(self.interface_type).encode(ExternalEncoding), input_name='interface-type'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.interface_type is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ServiceInterfaceTag'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.interface_type is not None:
            showIndent(outfile, level)
            outfile.write('interface_type=%s,\n' % quote_python(self.interface_type).encode(ExternalEncoding))
    def exportDict(self, name_='ServiceInterfaceTag'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'interface-type':
            interface_type_ = child_.text
            interface_type_ = self.gds_validate_string(interface_type_, node, 'interface_type')
            self.interface_type = interface_type_
            self.validate_ServiceInterfaceType(self.interface_type)    # validate type ServiceInterfaceType
# end class ServiceInterfaceTag


class RoutingPolicyServiceInstanceType(GeneratedsSuper):
    """
    Description:
        A given routing policy could be attached to both left or right interface of a

        service instance. If it is the case, set both the left-sequence and right-

        sequence. If you only want to attach it to either left or right, but not both,

        then only set the corresponding sequence number. A value of None also means it

        is not attached to that interface.

    Attributes:
    * left_sequence
        Type:           str, *one-of* xsd:string

    * right_sequence
        Type:           str, *one-of* xsd:string

    """
    subclass = None
    superclass = None
    class_description = [u'A given routing policy could be attached to both left or right interface of a service instance. If it is the case, set both the left-sequence and right-sequence. If you only want to attach it to either left or right, but not both, then only set the corresponding sequence number. A value of None also means it is not attached to that interface.']
    attr_fields = [u'left_sequence', u'right_sequence']
    attr_field_type_vals = {u'right_sequence': {'restrictions': [], 'description': [], 'simple_type': u'SequenceNumberType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': None, 'attr_type': u'string'}, u'left_sequence': {'restrictions': [], 'description': [], 'simple_type': u'SequenceNumberType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': None, 'attr_type': u'string'}}
    def __init__(self, left_sequence=None, right_sequence=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _left_sequence = params_dict[u"left_sequence"]
        except KeyError:
            _left_sequence = left_sequence
        self.left_sequence = _left_sequence
        try:
            _right_sequence = params_dict[u"right_sequence"]
        except KeyError:
            _right_sequence = right_sequence
        self.right_sequence = _right_sequence
    def factory(*args_, **kwargs_):
        if RoutingPolicyServiceInstanceType.subclass:
            return RoutingPolicyServiceInstanceType.subclass(*args_, **kwargs_)
        else:
            return RoutingPolicyServiceInstanceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_left_sequence(self): return self.left_sequence
    def set_left_sequence(self, left_sequence): self.left_sequence = left_sequence
    def validate_SequenceNumberType(self, value):
        # Validate type SequenceNumberType, a restriction on xsd:string.
        pass
    def get_right_sequence(self): return self.right_sequence
    def set_right_sequence(self, right_sequence): self.right_sequence = right_sequence
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.left_sequence == other.left_sequence and
                    self.right_sequence == other.right_sequence)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.left_sequence if self.left_sequence is not None else -7985492147856592190,
                     self.right_sequence if self.right_sequence is not None else -7985492147856592190))

    def __repr__(self):
        return ("left_sequence = " + str(self.left_sequence) + ", " +
                "right_sequence = " + str(self.right_sequence))

    def copy(self):
        cp = RoutingPolicyServiceInstanceType()
        if self.left_sequence is not None:
            cp.left_sequence = self.left_sequence
        if self.right_sequence is not None:
            cp.right_sequence = self.right_sequence
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_left_sequence (obj.populate_string ("left_sequence"))
        obj.set_right_sequence (obj.populate_string ("right_sequence"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='RoutingPolicyServiceInstanceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RoutingPolicyServiceInstanceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RoutingPolicyServiceInstanceType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RoutingPolicyServiceInstanceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.left_sequence is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sleft-sequence>%s</%sleft-sequence>%s' % (namespace_, self.gds_format_string(quote_xml(self.left_sequence).encode(ExternalEncoding), input_name='left-sequence'), namespace_, eol_))
        if self.right_sequence is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sright-sequence>%s</%sright-sequence>%s' % (namespace_, self.gds_format_string(quote_xml(self.right_sequence).encode(ExternalEncoding), input_name='right-sequence'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.left_sequence is not None or
            self.right_sequence is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RoutingPolicyServiceInstanceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.left_sequence is not None:
            showIndent(outfile, level)
            outfile.write('left_sequence=%s,\n' % quote_python(self.left_sequence).encode(ExternalEncoding))
        if self.right_sequence is not None:
            showIndent(outfile, level)
            outfile.write('right_sequence=%s,\n' % quote_python(self.right_sequence).encode(ExternalEncoding))
    def exportDict(self, name_='RoutingPolicyServiceInstanceType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'left-sequence':
            left_sequence_ = child_.text
            left_sequence_ = self.gds_validate_string(left_sequence_, node, 'left_sequence')
            self.left_sequence = left_sequence_
            self.validate_SequenceNumberType(self.left_sequence)    # validate type SequenceNumberType
        elif nodeName_ == 'right-sequence':
            right_sequence_ = child_.text
            right_sequence_ = self.gds_validate_string(right_sequence_, node, 'right_sequence')
            self.right_sequence = right_sequence_
            self.validate_SequenceNumberType(self.right_sequence)    # validate type SequenceNumberType
# end class RoutingPolicyServiceInstanceType


class InterfaceMirrorType(GeneratedsSuper):
    """
    Attributes:
    * traffic_direction
        Type:           str, *one-of* [u'ingress', u'egress', u'both']

        Created By:           User (required)

        Description:
          Specifies direction of traffic to mirror, Ingress, Egress or both

    * mirror_to
        Type:           :class:`.MirrorActionType`

        Created By:           User (required)

        Description:
          Mirror destination configuration

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'traffic_direction', u'mirror_to']
    attr_field_type_vals = {u'traffic_direction': {'restrictions': [u'ingress', u'egress', u'both'], 'description': [u'Specifies direction of traffic to mirror, Ingress, Egress or both'], 'simple_type': u'TrafficDirectionType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'true', 'attr_type': u'string'}, u'mirror_to': {'restrictions': None, 'description': [u'Mirror destination configuration'], 'simple_type': u'MirrorActionType', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': u'true', 'attr_type': u'MirrorActionType'}}
    def __init__(self, traffic_direction=None, mirror_to=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _traffic_direction = params_dict[u"traffic_direction"]
        except KeyError:
            _traffic_direction = traffic_direction
        self.traffic_direction = _traffic_direction
        try:
            _mirror_to = params_dict[u"mirror_to"]
        except KeyError:
            _mirror_to = mirror_to
        if isinstance(_mirror_to, dict):
            obj = MirrorActionType(params_dict=_mirror_to)
            self.mirror_to = obj
        else:
            self.mirror_to = _mirror_to
    def factory(*args_, **kwargs_):
        if InterfaceMirrorType.subclass:
            return InterfaceMirrorType.subclass(*args_, **kwargs_)
        else:
            return InterfaceMirrorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_traffic_direction(self): return self.traffic_direction
    def set_traffic_direction(self, traffic_direction): self.traffic_direction = traffic_direction
    def validate_TrafficDirectionType(self, value):
        # Validate type TrafficDirectionType, a restriction on xsd:string.
        error = False
        if isinstance(value, list):
            error = set(value) - set([u'ingress', u'egress', u'both'])
        else:
            error = value not in [u'ingress', u'egress', u'both']
        if error:
            raise ValueError("TrafficDirectionType must be one of [u'ingress', u'egress', u'both']")
    def get_mirror_to(self): return self.mirror_to
    def set_mirror_to(self, mirror_to): self.mirror_to = mirror_to
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.traffic_direction == other.traffic_direction and
                    self.mirror_to == other.mirror_to)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.traffic_direction if self.traffic_direction is not None else -7985492147856592190,
                     self.mirror_to if self.mirror_to is not None else -7985492147856592190))

    def __repr__(self):
        return ("traffic_direction = " + str(self.traffic_direction) + ", " +
                "mirror_to = " + str(self.mirror_to))

    def copy(self):
        cp = InterfaceMirrorType()
        if self.traffic_direction is not None:
            cp.traffic_direction = self.traffic_direction
        if self.mirror_to is not None:
            cp.mirror_to = self.mirror_to.copy()
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_traffic_direction (obj.populate_string ("traffic_direction"))
        obj.set_mirror_to (MirrorActionType.populate ())
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='InterfaceMirrorType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InterfaceMirrorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InterfaceMirrorType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='InterfaceMirrorType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.traffic_direction is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%straffic-direction>%s</%straffic-direction>%s' % (namespace_, self.gds_format_string(quote_xml(self.traffic_direction).encode(ExternalEncoding), input_name='traffic-direction'), namespace_, eol_))
        if self.mirror_to is not None:
            self.mirror_to.export_xml(outfile, level, namespace_, name_='mirror-to', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.traffic_direction is not None or
            self.mirror_to is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='InterfaceMirrorType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.traffic_direction is not None:
            showIndent(outfile, level)
            outfile.write('traffic_direction=%s,\n' % quote_python(self.traffic_direction).encode(ExternalEncoding))
        if self.mirror_to is not None:
            showIndent(outfile, level)
            outfile.write('mirror_to=model_.MirrorActionType(\n')
            self.mirror_to.exportLiteral(outfile, level, name_='mirror_to')
            showIndent(outfile, level)
            outfile.write('),\n')
    def exportDict(self, name_='InterfaceMirrorType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'traffic-direction':
            traffic_direction_ = child_.text
            traffic_direction_ = self.gds_validate_string(traffic_direction_, node, 'traffic_direction')
            self.traffic_direction = traffic_direction_
            self.validate_TrafficDirectionType(self.traffic_direction)    # validate type TrafficDirectionType
        elif nodeName_ == 'mirror-to':
            obj_ = MirrorActionType.factory()
            obj_.build(child_)
            self.set_mirror_to(obj_)
# end class InterfaceMirrorType


class VirtualMachineInterfacePropertiesType(GeneratedsSuper):
    """
    Attributes:
    * service_interface_type
        Type:           str, *one-of* xsd:string

        Created By:           User (optional)

        Description:
          This interface belongs to Service Instance and is tagged as left, right or other

    * interface_mirror
        Type:           :class:`.InterfaceMirrorType`

        Created By:           User (optional)

        Description:
          Interface Mirror configuration

    * local_preference
        Type:           int

        Created By:           User (optional)

        Description:
          BGP route local preference for routes representing this interface, higher value

          is higher preference

    * sub_interface_vlan_tag
        Type:           int

        Created By:           User (optional)

        Description:
          802.1Q VLAN tag to be used if this interface is sub-interface for some other

          interface.

    * max_flows
        Type:           int, *within* [0, 4294967296]

        Created By:           User (optional)

        Description:
          Maximum number of flows permitted on VMI

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'service_interface_type', u'interface_mirror', u'local_preference', u'sub_interface_vlan_tag', u'max_flows']
    attr_field_type_vals = {u'sub_interface_vlan_tag': {'restrictions': None, 'description': [u'802.1Q VLAN tag to be used if this interface is sub-interface for some other interface.'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'local_preference': {'restrictions': None, 'description': [u'BGP route local preference for routes representing this interface, higher value is higher preference'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'interface_mirror': {'restrictions': None, 'description': [u'Interface Mirror configuration'], 'simple_type': u'InterfaceMirrorType', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'InterfaceMirrorType'}, u'service_interface_type': {'restrictions': [], 'description': [u'This interface belongs to Service Instance and is tagged as left, right or other'], 'simple_type': u'ServiceInterfaceType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'max_flows': {'restrictions': [0, 4294967296], 'description': [u'Maximum number of flows permitted on VMI'], 'simple_type': u'MaxFlowsType', 'is_complex': 0, 'restriction_type': 'range', 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}}
    def __init__(self, service_interface_type=None, interface_mirror=None, local_preference=None, sub_interface_vlan_tag=None, max_flows=0, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _service_interface_type = params_dict[u"service_interface_type"]
        except KeyError:
            _service_interface_type = service_interface_type
        self.service_interface_type = _service_interface_type
        try:
            _interface_mirror = params_dict[u"interface_mirror"]
        except KeyError:
            _interface_mirror = interface_mirror
        if isinstance(_interface_mirror, dict):
            obj = InterfaceMirrorType(params_dict=_interface_mirror)
            self.interface_mirror = obj
        else:
            self.interface_mirror = _interface_mirror
        try:
            _local_preference = params_dict[u"local_preference"]
        except KeyError:
            _local_preference = local_preference
        self.local_preference = _local_preference
        try:
            _sub_interface_vlan_tag = params_dict[u"sub_interface_vlan_tag"]
        except KeyError:
            _sub_interface_vlan_tag = sub_interface_vlan_tag
        self.sub_interface_vlan_tag = _sub_interface_vlan_tag
        try:
            _max_flows = params_dict[u"max_flows"]
        except KeyError:
            _max_flows = max_flows
        self.max_flows = _max_flows
    def factory(*args_, **kwargs_):
        if VirtualMachineInterfacePropertiesType.subclass:
            return VirtualMachineInterfacePropertiesType.subclass(*args_, **kwargs_)
        else:
            return VirtualMachineInterfacePropertiesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_service_interface_type(self): return self.service_interface_type
    def set_service_interface_type(self, service_interface_type): self.service_interface_type = service_interface_type
    def validate_ServiceInterfaceType(self, value):
        # Validate type ServiceInterfaceType, a restriction on xsd:string.
        pass
    def get_interface_mirror(self): return self.interface_mirror
    def set_interface_mirror(self, interface_mirror): self.interface_mirror = interface_mirror
    def get_local_preference(self): return self.local_preference
    def set_local_preference(self, local_preference): self.local_preference = local_preference
    def get_sub_interface_vlan_tag(self): return self.sub_interface_vlan_tag
    def set_sub_interface_vlan_tag(self, sub_interface_vlan_tag): self.sub_interface_vlan_tag = sub_interface_vlan_tag
    def get_max_flows(self): return self.max_flows
    def set_max_flows(self, max_flows): self.max_flows = max_flows
    def validate_MaxFlowsType(self, value):
        # Validate type MaxFlowsType, a restriction on xsd:integer.
        error = False
        if isinstance(value, list):
            v_int = list(map(int, value))
            v1, v2 = min(v_int), max(v_int)
        else:
            v1, v2 = int(value), int(value)
        error |= (v2 > 4294967296)
        if error:
            raise ValueError("MaxFlowsType must be in the range {'minimum': 0}-{'maximum': 4294967296}")
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.service_interface_type == other.service_interface_type and
                    self.interface_mirror == other.interface_mirror and
                    self.local_preference == other.local_preference and
                    self.sub_interface_vlan_tag == other.sub_interface_vlan_tag and
                    self.max_flows == other.max_flows)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.service_interface_type if self.service_interface_type is not None else -7985492147856592190,
                     self.interface_mirror if self.interface_mirror is not None else -7985492147856592190,
                     self.local_preference if self.local_preference is not None else -7985492147856592190,
                     self.sub_interface_vlan_tag if self.sub_interface_vlan_tag is not None else -7985492147856592190,
                     self.max_flows if self.max_flows is not None else -7985492147856592190))

    def __repr__(self):
        return ("service_interface_type = " + str(self.service_interface_type) + ", " +
                "interface_mirror = " + str(self.interface_mirror) + ", " +
                "local_preference = " + str(self.local_preference) + ", " +
                "sub_interface_vlan_tag = " + str(self.sub_interface_vlan_tag) + ", " +
                "max_flows = " + str(self.max_flows))

    def copy(self):
        cp = VirtualMachineInterfacePropertiesType()
        if self.service_interface_type is not None:
            cp.service_interface_type = self.service_interface_type
        if self.interface_mirror is not None:
            cp.interface_mirror = self.interface_mirror.copy()
        if self.local_preference is not None:
            cp.local_preference = self.local_preference
        if self.sub_interface_vlan_tag is not None:
            cp.sub_interface_vlan_tag = self.sub_interface_vlan_tag
        if self.max_flows is not None:
            cp.max_flows = self.max_flows
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_service_interface_type (obj.populate_string ("service_interface_type"))
        obj.set_interface_mirror (InterfaceMirrorType.populate ())
        obj.set_local_preference (obj.populate_integer ("local_preference"))
        obj.set_sub_interface_vlan_tag (obj.populate_integer ("sub_interface_vlan_tag"))
        obj.set_max_flows (obj.populate_integer ("max_flows"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='VirtualMachineInterfacePropertiesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VirtualMachineInterfacePropertiesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VirtualMachineInterfacePropertiesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VirtualMachineInterfacePropertiesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.service_interface_type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sservice-interface-type>%s</%sservice-interface-type>%s' % (namespace_, self.gds_format_string(quote_xml(self.service_interface_type).encode(ExternalEncoding), input_name='service-interface-type'), namespace_, eol_))
        if self.interface_mirror is not None:
            self.interface_mirror.export_xml(outfile, level, namespace_, name_='interface-mirror', pretty_print=pretty_print)
        if self.local_preference is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slocal-preference>%s</%slocal-preference>%s' % (namespace_, self.gds_format_integer(self.local_preference, input_name='local-preference'), namespace_, eol_))
        if self.sub_interface_vlan_tag is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssub-interface-vlan-tag>%s</%ssub-interface-vlan-tag>%s' % (namespace_, self.gds_format_integer(self.sub_interface_vlan_tag, input_name='sub-interface-vlan-tag'), namespace_, eol_))
        if self.max_flows is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smax-flows>%s</%smax-flows>%s' % (namespace_, self.gds_format_integer(self.max_flows, input_name='max-flows'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.service_interface_type is not None or
            self.interface_mirror is not None or
            self.local_preference is not None or
            self.sub_interface_vlan_tag is not None or
            self.max_flows is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='VirtualMachineInterfacePropertiesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.service_interface_type is not None:
            showIndent(outfile, level)
            outfile.write('service_interface_type=%s,\n' % quote_python(self.service_interface_type).encode(ExternalEncoding))
        if self.interface_mirror is not None:
            showIndent(outfile, level)
            outfile.write('interface_mirror=model_.InterfaceMirrorType(\n')
            self.interface_mirror.exportLiteral(outfile, level, name_='interface_mirror')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.local_preference is not None:
            showIndent(outfile, level)
            outfile.write('local_preference=%d,\n' % self.local_preference)
        if self.sub_interface_vlan_tag is not None:
            showIndent(outfile, level)
            outfile.write('sub_interface_vlan_tag=%d,\n' % self.sub_interface_vlan_tag)
        if self.max_flows is not None:
            showIndent(outfile, level)
            outfile.write('max_flows=%d,\n' % self.max_flows)
    def exportDict(self, name_='VirtualMachineInterfacePropertiesType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'service-interface-type':
            service_interface_type_ = child_.text
            service_interface_type_ = self.gds_validate_string(service_interface_type_, node, 'service_interface_type')
            self.service_interface_type = service_interface_type_
            self.validate_ServiceInterfaceType(self.service_interface_type)    # validate type ServiceInterfaceType
        elif nodeName_ == 'interface-mirror':
            obj_ = InterfaceMirrorType.factory()
            obj_.build(child_)
            self.set_interface_mirror(obj_)
        elif nodeName_ == 'local-preference':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'local_preference')
            self.local_preference = ival_
        elif nodeName_ == 'sub-interface-vlan-tag':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'sub_interface_vlan_tag')
            self.sub_interface_vlan_tag = ival_
        elif nodeName_ == 'max-flows':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'max_flows')
            self.max_flows = ival_
            self.validate_MaxFlowsType(self.max_flows)    # validate type MaxFlowsType
# end class VirtualMachineInterfacePropertiesType


class ServiceTemplateInterfaceType(GeneratedsSuper):
    """
    Attributes:
    * service_interface_type
        Type:           str, *one-of* xsd:string

        Created By:           User (required)

        Description:
          Type of service interface supported by this template left, right or other.

    * shared_ip
        Type:           bool

        Created By:           User (optional)

        Description:
          Shared ip is required on this interface when service instance is scaled out

          (Only V1)

    * static_route_enable
        Type:           bool

        Created By:           User (optional)

        Description:
          Static routes configured required on this interface of service instance (Only

          V1)

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'service_interface_type', u'shared_ip', u'static_route_enable']
    attr_field_type_vals = {u'static_route_enable': {'restrictions': None, 'description': [u'Static routes configured required on this interface of service instance (Only V1)'], 'simple_type': u'xsd:boolean', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'boolean'}, u'shared_ip': {'restrictions': None, 'description': [u'Shared ip is required on this interface when service instance is scaled out (Only V1)'], 'simple_type': u'xsd:boolean', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'boolean'}, u'service_interface_type': {'restrictions': [], 'description': [u'Type of service interface supported by this template left, right or other.'], 'simple_type': u'ServiceInterfaceType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'true', 'attr_type': u'string'}}
    def __init__(self, service_interface_type=None, shared_ip=False, static_route_enable=False, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _service_interface_type = params_dict[u"service_interface_type"]
        except KeyError:
            _service_interface_type = service_interface_type
        self.service_interface_type = _service_interface_type
        try:
            _shared_ip = params_dict[u"shared_ip"]
        except KeyError:
            _shared_ip = shared_ip
        self.shared_ip = _shared_ip
        try:
            _static_route_enable = params_dict[u"static_route_enable"]
        except KeyError:
            _static_route_enable = static_route_enable
        self.static_route_enable = _static_route_enable
    def factory(*args_, **kwargs_):
        if ServiceTemplateInterfaceType.subclass:
            return ServiceTemplateInterfaceType.subclass(*args_, **kwargs_)
        else:
            return ServiceTemplateInterfaceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_service_interface_type(self): return self.service_interface_type
    def set_service_interface_type(self, service_interface_type): self.service_interface_type = service_interface_type
    def validate_ServiceInterfaceType(self, value):
        # Validate type ServiceInterfaceType, a restriction on xsd:string.
        pass
    def get_shared_ip(self): return self.shared_ip
    def set_shared_ip(self, shared_ip): self.shared_ip = shared_ip
    def get_static_route_enable(self): return self.static_route_enable
    def set_static_route_enable(self, static_route_enable): self.static_route_enable = static_route_enable
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.service_interface_type == other.service_interface_type and
                    self.shared_ip == other.shared_ip and
                    self.static_route_enable == other.static_route_enable)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.service_interface_type if self.service_interface_type is not None else -7985492147856592190,
                     self.shared_ip if self.shared_ip is not None else -7985492147856592190,
                     self.static_route_enable if self.static_route_enable is not None else -7985492147856592190))

    def __repr__(self):
        return ("service_interface_type = " + str(self.service_interface_type) + ", " +
                "shared_ip = " + str(self.shared_ip) + ", " +
                "static_route_enable = " + str(self.static_route_enable))

    def copy(self):
        cp = ServiceTemplateInterfaceType()
        if self.service_interface_type is not None:
            cp.service_interface_type = self.service_interface_type
        if self.shared_ip is not None:
            cp.shared_ip = self.shared_ip
        if self.static_route_enable is not None:
            cp.static_route_enable = self.static_route_enable
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_service_interface_type (obj.populate_string ("service_interface_type"))
        obj.set_shared_ip (obj.populate_boolean ("shared_ip"))
        obj.set_static_route_enable (obj.populate_boolean ("static_route_enable"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='ServiceTemplateInterfaceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ServiceTemplateInterfaceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ServiceTemplateInterfaceType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ServiceTemplateInterfaceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.service_interface_type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sservice-interface-type>%s</%sservice-interface-type>%s' % (namespace_, self.gds_format_string(quote_xml(self.service_interface_type).encode(ExternalEncoding), input_name='service-interface-type'), namespace_, eol_))
        if self.shared_ip is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sshared-ip>%s</%sshared-ip>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.shared_ip)), input_name='shared-ip'), namespace_, eol_))
        if self.static_route_enable is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstatic-route-enable>%s</%sstatic-route-enable>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.static_route_enable)), input_name='static-route-enable'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.service_interface_type is not None or
            self.shared_ip is not None or
            self.static_route_enable is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ServiceTemplateInterfaceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.service_interface_type is not None:
            showIndent(outfile, level)
            outfile.write('service_interface_type=%s,\n' % quote_python(self.service_interface_type).encode(ExternalEncoding))
        if self.shared_ip is not None:
            showIndent(outfile, level)
            outfile.write('shared_ip=%s,\n' % self.shared_ip)
        if self.static_route_enable is not None:
            showIndent(outfile, level)
            outfile.write('static_route_enable=%s,\n' % self.static_route_enable)
    def exportDict(self, name_='ServiceTemplateInterfaceType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'service-interface-type':
            service_interface_type_ = child_.text
            service_interface_type_ = self.gds_validate_string(service_interface_type_, node, 'service_interface_type')
            self.service_interface_type = service_interface_type_
            self.validate_ServiceInterfaceType(self.service_interface_type)    # validate type ServiceInterfaceType
        elif nodeName_ == 'shared-ip':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'shared_ip')
            self.shared_ip = ival_
        elif nodeName_ == 'static-route-enable':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'static_route_enable')
            self.static_route_enable = ival_
# end class ServiceTemplateInterfaceType


class ServiceInstanceInterfaceType(GeneratedsSuper):
    """
    Attributes:
    * virtual_network
        Type:           str

        Created By:           User (required)

        Description:
          Interface belongs to this virtual network.

    * ip_address
        Type:           str, *one-of* xsd:string

        Created By:           User (optional)

        Description:
          Shared ip for this interface (Only V1)

    * static_routes
        Type:           :class:`.RouteTableType`

        Created By:           User (optional)

        Description:
          Static routes for this interface (Only V1)

    * allowed_address_pairs
        Type:           :class:`.AllowedAddressPairs`

        Created By:           User (optional)

        Description:
          Allowed address pairs, list of (IP address, MAC) for this interface

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'virtual_network', u'ip_address', u'static_routes', u'allowed_address_pairs']
    attr_field_type_vals = {u'virtual_network': {'restrictions': None, 'description': [u'Interface belongs to this virtual network.'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'true', 'attr_type': u'string'}, u'ip_address': {'restrictions': [], 'description': [u'Shared ip for this interface (Only V1)'], 'simple_type': u'IpAddressType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'allowed_address_pairs': {'restrictions': None, 'description': [u'Allowed address pairs, list of (IP address, MAC) for this interface'], 'simple_type': u'AllowedAddressPairs', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'AllowedAddressPairs'}, u'static_routes': {'restrictions': None, 'description': [u'Static routes for this interface (Only V1)'], 'simple_type': u'RouteTableType', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'RouteTableType'}}
    def __init__(self, virtual_network=None, ip_address=None, static_routes=None, allowed_address_pairs=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _virtual_network = params_dict[u"virtual_network"]
        except KeyError:
            _virtual_network = virtual_network
        self.virtual_network = _virtual_network
        try:
            _ip_address = params_dict[u"ip_address"]
        except KeyError:
            _ip_address = ip_address
        self.ip_address = _ip_address
        try:
            _static_routes = params_dict[u"static_routes"]
        except KeyError:
            _static_routes = static_routes
        if isinstance(_static_routes, dict):
            obj = RouteTableType(params_dict=_static_routes)
            self.static_routes = obj
        else:
            self.static_routes = _static_routes
        try:
            _allowed_address_pairs = params_dict[u"allowed_address_pairs"]
        except KeyError:
            _allowed_address_pairs = allowed_address_pairs
        if isinstance(_allowed_address_pairs, dict):
            obj = AllowedAddressPairs(params_dict=_allowed_address_pairs)
            self.allowed_address_pairs = obj
        else:
            self.allowed_address_pairs = _allowed_address_pairs
    def factory(*args_, **kwargs_):
        if ServiceInstanceInterfaceType.subclass:
            return ServiceInstanceInterfaceType.subclass(*args_, **kwargs_)
        else:
            return ServiceInstanceInterfaceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_virtual_network(self): return self.virtual_network
    def set_virtual_network(self, virtual_network): self.virtual_network = virtual_network
    def get_ip_address(self): return self.ip_address
    def set_ip_address(self, ip_address): self.ip_address = ip_address
    def validate_IpAddressType(self, value):
        # Validate type IpAddressType, a restriction on xsd:string.
        pass
    def get_static_routes(self): return self.static_routes
    def set_static_routes(self, static_routes): self.static_routes = static_routes
    def get_allowed_address_pairs(self): return self.allowed_address_pairs
    def set_allowed_address_pairs(self, allowed_address_pairs): self.allowed_address_pairs = allowed_address_pairs
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.virtual_network == other.virtual_network and
                    self.ip_address == other.ip_address and
                    self.static_routes == other.static_routes and
                    self.allowed_address_pairs == other.allowed_address_pairs)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.virtual_network if self.virtual_network is not None else -7985492147856592190,
                     self.ip_address if self.ip_address is not None else -7985492147856592190,
                     self.static_routes if self.static_routes is not None else -7985492147856592190,
                     self.allowed_address_pairs if self.allowed_address_pairs is not None else -7985492147856592190))

    def __repr__(self):
        return ("virtual_network = " + str(self.virtual_network) + ", " +
                "ip_address = " + str(self.ip_address) + ", " +
                "static_routes = " + str(self.static_routes) + ", " +
                "allowed_address_pairs = " + str(self.allowed_address_pairs))

    def copy(self):
        cp = ServiceInstanceInterfaceType()
        if self.virtual_network is not None:
            cp.virtual_network = self.virtual_network
        if self.ip_address is not None:
            cp.ip_address = self.ip_address
        if self.static_routes is not None:
            cp.static_routes = self.static_routes.copy()
        if self.allowed_address_pairs is not None:
            cp.allowed_address_pairs = self.allowed_address_pairs.copy()
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_virtual_network (obj.populate_string ("virtual_network"))
        obj.set_ip_address (obj.populate_string ("ip_address"))
        obj.set_static_routes (RouteTableType.populate ())
        obj.set_allowed_address_pairs (AllowedAddressPairs.populate ())
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='ServiceInstanceInterfaceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ServiceInstanceInterfaceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ServiceInstanceInterfaceType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ServiceInstanceInterfaceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.virtual_network is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svirtual-network>%s</%svirtual-network>%s' % (namespace_, self.gds_format_string(quote_xml(self.virtual_network).encode(ExternalEncoding), input_name='virtual-network'), namespace_, eol_))
        if self.ip_address is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sip-address>%s</%sip-address>%s' % (namespace_, self.gds_format_string(quote_xml(self.ip_address).encode(ExternalEncoding), input_name='ip-address'), namespace_, eol_))
        if self.static_routes is not None:
            self.static_routes.export_xml(outfile, level, namespace_, name_='static-routes', pretty_print=pretty_print)
        if self.allowed_address_pairs is not None:
            self.allowed_address_pairs.export_xml(outfile, level, namespace_, name_='allowed-address-pairs', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.virtual_network is not None or
            self.ip_address is not None or
            self.static_routes is not None or
            self.allowed_address_pairs is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ServiceInstanceInterfaceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.virtual_network is not None:
            showIndent(outfile, level)
            outfile.write('virtual_network=%s,\n' % quote_python(self.virtual_network).encode(ExternalEncoding))
        if self.ip_address is not None:
            showIndent(outfile, level)
            outfile.write('ip_address=%s,\n' % quote_python(self.ip_address).encode(ExternalEncoding))
        if self.static_routes is not None:
            showIndent(outfile, level)
            outfile.write('static_routes=model_.RouteTableType(\n')
            self.static_routes.exportLiteral(outfile, level, name_='static_routes')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.allowed_address_pairs is not None:
            showIndent(outfile, level)
            outfile.write('allowed_address_pairs=model_.AllowedAddressPairs(\n')
            self.allowed_address_pairs.exportLiteral(outfile, level, name_='allowed_address_pairs')
            showIndent(outfile, level)
            outfile.write('),\n')
    def exportDict(self, name_='ServiceInstanceInterfaceType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'virtual-network':
            virtual_network_ = child_.text
            virtual_network_ = self.gds_validate_string(virtual_network_, node, 'virtual_network')
            self.virtual_network = virtual_network_
        elif nodeName_ == 'ip-address':
            ip_address_ = child_.text
            ip_address_ = self.gds_validate_string(ip_address_, node, 'ip_address')
            self.ip_address = ip_address_
            self.validate_IpAddressType(self.ip_address)    # validate type IpAddressType
        elif nodeName_ == 'static-routes':
            obj_ = RouteTableType.factory()
            obj_.build(child_)
            self.set_static_routes(obj_)
        elif nodeName_ == 'allowed-address-pairs':
            obj_ = AllowedAddressPairs.factory()
            obj_.build(child_)
            self.set_allowed_address_pairs(obj_)
# end class ServiceInstanceInterfaceType


class ProtocolType(GeneratedsSuper):
    """
    Attributes:
    * protocol
        Type:           str

    * port
        Type:           int

    * ignore_address
        Type:           str, *one-of* [u'none', u'source', u'destination']

        Created By:           User (optional)

        Description:
          Address ignored while creating flows, from the perspective of packets egressing

          the VM. For packets originated by VM, source and destination indicate the

          corresponding IPs in the packet. For packets coming from remote source, source

          indicates destination IP of the packet is ignored and destination indicates

          source IP of the packet is ignored.

    * source_prefix
        Type:           :class:`.SubnetType`

        Created By:           User (optional)

        Description:
          For packets originated from VM source-prefix is applied to source IP of the

          packet. For packets coming to VM, source-prefix is applied to destination IP of

          the packet

    * source_aggregate_prefix_length
        Type:           int

        Created By:           User (optional)

        Description:
          Fat flow prefix mask length for IP where source-prefix is applied

    * destination_prefix
        Type:           :class:`.SubnetType`

        Created By:           User (optional)

        Description:
          For packets originated from VM destination-prefix is applied to destination IP

          of the packet. For packets coming to VM, destination-prefix is applied to source

          IP of the packet

    * destination_aggregate_prefix_length
        Type:           int

        Created By:           User (optional)

        Description:
          Fat flow prefix mask length for IP where destination-prefix is applied

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'protocol', u'port', u'ignore_address', u'source_prefix', u'source_aggregate_prefix_length', u'destination_prefix', u'destination_aggregate_prefix_length']
    attr_field_type_vals = {u'source_aggregate_prefix_length': {'restrictions': None, 'description': [u'Fat flow prefix mask length for IP where source-prefix is applied'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'protocol': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'ignore_address': {'restrictions': [u'none', u'source', u'destination'], 'description': [u'Address ignored while creating flows, from the perspective of packets egressing the VM. For packets originated by VM, source and destination indicate the corresponding IPs in the packet. For packets coming from remote source, source indicates destination IP of the packet is ignored and destination indicates source IP of the packet is ignored.'], 'simple_type': u'FatFlowIgnoreAddressType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'destination_prefix': {'restrictions': None, 'description': [u'For packets originated from VM destination-prefix is applied to destination IP of the packet. For packets coming to VM, destination-prefix is applied to source IP of the packet'], 'simple_type': u'SubnetType', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'SubnetType'}, u'source_prefix': {'restrictions': None, 'description': [u'For packets originated from VM source-prefix is applied to source IP of the packet. For packets coming to VM, source-prefix is applied to destination IP of the packet'], 'simple_type': u'SubnetType', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'SubnetType'}, u'port': {'restrictions': None, 'description': [], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'integer'}, u'destination_aggregate_prefix_length': {'restrictions': None, 'description': [u'Fat flow prefix mask length for IP where destination-prefix is applied'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}}
    def __init__(self, protocol=None, port=None, ignore_address=None, source_prefix=None, source_aggregate_prefix_length=None, destination_prefix=None, destination_aggregate_prefix_length=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _protocol = params_dict[u"protocol"]
        except KeyError:
            _protocol = protocol
        self.protocol = _protocol
        try:
            _port = params_dict[u"port"]
        except KeyError:
            _port = port
        self.port = _port
        try:
            _ignore_address = params_dict[u"ignore_address"]
        except KeyError:
            _ignore_address = ignore_address
        self.ignore_address = _ignore_address
        try:
            _source_prefix = params_dict[u"source_prefix"]
        except KeyError:
            _source_prefix = source_prefix
        if isinstance(_source_prefix, dict):
            obj = SubnetType(params_dict=_source_prefix)
            self.source_prefix = obj
        else:
            self.source_prefix = _source_prefix
        try:
            _source_aggregate_prefix_length = params_dict[u"source_aggregate_prefix_length"]
        except KeyError:
            _source_aggregate_prefix_length = source_aggregate_prefix_length
        self.source_aggregate_prefix_length = _source_aggregate_prefix_length
        try:
            _destination_prefix = params_dict[u"destination_prefix"]
        except KeyError:
            _destination_prefix = destination_prefix
        if isinstance(_destination_prefix, dict):
            obj = SubnetType(params_dict=_destination_prefix)
            self.destination_prefix = obj
        else:
            self.destination_prefix = _destination_prefix
        try:
            _destination_aggregate_prefix_length = params_dict[u"destination_aggregate_prefix_length"]
        except KeyError:
            _destination_aggregate_prefix_length = destination_aggregate_prefix_length
        self.destination_aggregate_prefix_length = _destination_aggregate_prefix_length
    def factory(*args_, **kwargs_):
        if ProtocolType.subclass:
            return ProtocolType.subclass(*args_, **kwargs_)
        else:
            return ProtocolType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_protocol(self): return self.protocol
    def set_protocol(self, protocol): self.protocol = protocol
    def get_port(self): return self.port
    def set_port(self, port): self.port = port
    def get_ignore_address(self): return self.ignore_address
    def set_ignore_address(self, ignore_address): self.ignore_address = ignore_address
    def validate_FatFlowIgnoreAddressType(self, value):
        # Validate type FatFlowIgnoreAddressType, a restriction on xsd:string.
        error = False
        if isinstance(value, list):
            error = set(value) - set([u'none', u'source', u'destination'])
        else:
            error = value not in [u'none', u'source', u'destination']
        if error:
            raise ValueError("FatFlowIgnoreAddressType must be one of [u'none', u'source', u'destination']")
    def get_source_prefix(self): return self.source_prefix
    def set_source_prefix(self, source_prefix): self.source_prefix = source_prefix
    def get_source_aggregate_prefix_length(self): return self.source_aggregate_prefix_length
    def set_source_aggregate_prefix_length(self, source_aggregate_prefix_length): self.source_aggregate_prefix_length = source_aggregate_prefix_length
    def get_destination_prefix(self): return self.destination_prefix
    def set_destination_prefix(self, destination_prefix): self.destination_prefix = destination_prefix
    def get_destination_aggregate_prefix_length(self): return self.destination_aggregate_prefix_length
    def set_destination_aggregate_prefix_length(self, destination_aggregate_prefix_length): self.destination_aggregate_prefix_length = destination_aggregate_prefix_length
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.protocol == other.protocol and
                    self.port == other.port and
                    self.ignore_address == other.ignore_address and
                    self.source_prefix == other.source_prefix and
                    self.source_aggregate_prefix_length == other.source_aggregate_prefix_length and
                    self.destination_prefix == other.destination_prefix and
                    self.destination_aggregate_prefix_length == other.destination_aggregate_prefix_length)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.protocol if self.protocol is not None else -7985492147856592190,
                     self.port if self.port is not None else -7985492147856592190,
                     self.ignore_address if self.ignore_address is not None else -7985492147856592190,
                     self.source_prefix if self.source_prefix is not None else -7985492147856592190,
                     self.source_aggregate_prefix_length if self.source_aggregate_prefix_length is not None else -7985492147856592190,
                     self.destination_prefix if self.destination_prefix is not None else -7985492147856592190,
                     self.destination_aggregate_prefix_length if self.destination_aggregate_prefix_length is not None else -7985492147856592190))

    def __repr__(self):
        return ("protocol = " + str(self.protocol) + ", " +
                "port = " + str(self.port) + ", " +
                "ignore_address = " + str(self.ignore_address) + ", " +
                "source_prefix = " + str(self.source_prefix) + ", " +
                "source_aggregate_prefix_length = " + str(self.source_aggregate_prefix_length) + ", " +
                "destination_prefix = " + str(self.destination_prefix) + ", " +
                "destination_aggregate_prefix_length = " + str(self.destination_aggregate_prefix_length))

    def copy(self):
        cp = ProtocolType()
        if self.protocol is not None:
            cp.protocol = self.protocol
        if self.port is not None:
            cp.port = self.port
        if self.ignore_address is not None:
            cp.ignore_address = self.ignore_address
        if self.source_prefix is not None:
            cp.source_prefix = self.source_prefix.copy()
        if self.source_aggregate_prefix_length is not None:
            cp.source_aggregate_prefix_length = self.source_aggregate_prefix_length
        if self.destination_prefix is not None:
            cp.destination_prefix = self.destination_prefix.copy()
        if self.destination_aggregate_prefix_length is not None:
            cp.destination_aggregate_prefix_length = self.destination_aggregate_prefix_length
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_protocol (obj.populate_string ("protocol"))
        obj.set_port (obj.populate_integer ("port"))
        obj.set_ignore_address (obj.populate_string ("ignore_address"))
        obj.set_source_prefix (SubnetType.populate ())
        obj.set_source_aggregate_prefix_length (obj.populate_integer ("source_aggregate_prefix_length"))
        obj.set_destination_prefix (SubnetType.populate ())
        obj.set_destination_aggregate_prefix_length (obj.populate_integer ("destination_aggregate_prefix_length"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='ProtocolType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProtocolType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ProtocolType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ProtocolType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.protocol is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprotocol>%s</%sprotocol>%s' % (namespace_, self.gds_format_string(quote_xml(self.protocol).encode(ExternalEncoding), input_name='protocol'), namespace_, eol_))
        if self.port is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sport>%s</%sport>%s' % (namespace_, self.gds_format_integer(self.port, input_name='port'), namespace_, eol_))
        if self.ignore_address is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%signore-address>%s</%signore-address>%s' % (namespace_, self.gds_format_string(quote_xml(self.ignore_address).encode(ExternalEncoding), input_name='ignore-address'), namespace_, eol_))
        if self.source_prefix is not None:
            self.source_prefix.export_xml(outfile, level, namespace_, name_='source-prefix', pretty_print=pretty_print)
        if self.source_aggregate_prefix_length is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssource-aggregate-prefix-length>%s</%ssource-aggregate-prefix-length>%s' % (namespace_, self.gds_format_integer(self.source_aggregate_prefix_length, input_name='source-aggregate-prefix-length'), namespace_, eol_))
        if self.destination_prefix is not None:
            self.destination_prefix.export_xml(outfile, level, namespace_, name_='destination-prefix', pretty_print=pretty_print)
        if self.destination_aggregate_prefix_length is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdestination-aggregate-prefix-length>%s</%sdestination-aggregate-prefix-length>%s' % (namespace_, self.gds_format_integer(self.destination_aggregate_prefix_length, input_name='destination-aggregate-prefix-length'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.protocol is not None or
            self.port is not None or
            self.ignore_address is not None or
            self.source_prefix is not None or
            self.source_aggregate_prefix_length is not None or
            self.destination_prefix is not None or
            self.destination_aggregate_prefix_length is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ProtocolType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.protocol is not None:
            showIndent(outfile, level)
            outfile.write('protocol=%s,\n' % quote_python(self.protocol).encode(ExternalEncoding))
        if self.port is not None:
            showIndent(outfile, level)
            outfile.write('port=%d,\n' % self.port)
        if self.ignore_address is not None:
            showIndent(outfile, level)
            outfile.write('ignore_address=%s,\n' % quote_python(self.ignore_address).encode(ExternalEncoding))
        if self.source_prefix is not None:
            showIndent(outfile, level)
            outfile.write('source_prefix=model_.SubnetType(\n')
            self.source_prefix.exportLiteral(outfile, level, name_='source_prefix')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.source_aggregate_prefix_length is not None:
            showIndent(outfile, level)
            outfile.write('source_aggregate_prefix_length=%d,\n' % self.source_aggregate_prefix_length)
        if self.destination_prefix is not None:
            showIndent(outfile, level)
            outfile.write('destination_prefix=model_.SubnetType(\n')
            self.destination_prefix.exportLiteral(outfile, level, name_='destination_prefix')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.destination_aggregate_prefix_length is not None:
            showIndent(outfile, level)
            outfile.write('destination_aggregate_prefix_length=%d,\n' % self.destination_aggregate_prefix_length)
    def exportDict(self, name_='ProtocolType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'protocol':
            protocol_ = child_.text
            protocol_ = self.gds_validate_string(protocol_, node, 'protocol')
            self.protocol = protocol_
        elif nodeName_ == 'port':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'port')
            self.port = ival_
        elif nodeName_ == 'ignore-address':
            ignore_address_ = child_.text
            ignore_address_ = self.gds_validate_string(ignore_address_, node, 'ignore_address')
            self.ignore_address = ignore_address_
            self.validate_FatFlowIgnoreAddressType(self.ignore_address)    # validate type FatFlowIgnoreAddressType
        elif nodeName_ == 'source-prefix':
            obj_ = SubnetType.factory()
            obj_.build(child_)
            self.set_source_prefix(obj_)
        elif nodeName_ == 'source-aggregate-prefix-length':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'source_aggregate_prefix_length')
            self.source_aggregate_prefix_length = ival_
        elif nodeName_ == 'destination-prefix':
            obj_ = SubnetType.factory()
            obj_.build(child_)
            self.set_destination_prefix(obj_)
        elif nodeName_ == 'destination-aggregate-prefix-length':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'destination_aggregate_prefix_length')
            self.destination_aggregate_prefix_length = ival_
# end class ProtocolType


class FatFlowProtocols(GeneratedsSuper):
    """
    Attributes:
    * fat_flow_protocol
        Type:           :class:`.ProtocolType`

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'fat_flow_protocol']
    attr_field_type_vals = {u'fat_flow_protocol': {'restrictions': None, 'description': [], 'simple_type': u'ProtocolType', 'is_complex': 1, 'restriction_type': None, 'is_array': True, 'required': None, 'attr_type': u'ProtocolType'}}
    def __init__(self, fat_flow_protocol=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _fat_flow_protocol = params_dict[u"fat_flow_protocol"]
        except KeyError:
            _fat_flow_protocol = fat_flow_protocol
        if not _fat_flow_protocol:
            self.fat_flow_protocol = []
        else:
            if isinstance(_fat_flow_protocol[0], dict):
                objs = [ProtocolType(params_dict=elem) for elem in _fat_flow_protocol]
                self.fat_flow_protocol = objs
            else:
                self.fat_flow_protocol = _fat_flow_protocol
    def factory(*args_, **kwargs_):
        if FatFlowProtocols.subclass:
            return FatFlowProtocols.subclass(*args_, **kwargs_)
        else:
            return FatFlowProtocols(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fat_flow_protocol(self): return self.fat_flow_protocol
    def set_fat_flow_protocol(self, fat_flow_protocol): self.fat_flow_protocol = fat_flow_protocol
    def add_fat_flow_protocol(self, value): self.fat_flow_protocol.append(value)
    def insert_fat_flow_protocol(self, index, value): self.fat_flow_protocol[index] = value
    def delete_fat_flow_protocol(self, value): self.fat_flow_protocol.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.fat_flow_protocol == other.fat_flow_protocol)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.fat_flow_protocol or [])))

    def __repr__(self):
        return ("fat_flow_protocol = " + str(self.fat_flow_protocol))

    def copy(self):
        cp = FatFlowProtocols()
        if self.fat_flow_protocol is not None:
            cp.fat_flow_protocol = [x.copy() for x in self.fat_flow_protocol]
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_fat_flow_protocol ([ProtocolType.populate ()])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='FatFlowProtocols', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FatFlowProtocols')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FatFlowProtocols'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FatFlowProtocols', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for fat_flow_protocol_ in self.fat_flow_protocol:
            if isinstance(fat_flow_protocol_, dict):
                fat_flow_protocol_ = ProtocolType(**fat_flow_protocol_)
            fat_flow_protocol_.export_xml(outfile, level, namespace_, name_='fat-flow-protocol', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.fat_flow_protocol
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FatFlowProtocols'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('fat_flow_protocol=[\n')
        level += 1
        for fat_flow_protocol_ in self.fat_flow_protocol:
            showIndent(outfile, level)
            outfile.write('model_.ProtocolType(\n')
            fat_flow_protocol_.exportLiteral(outfile, level, name_='ProtocolType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='FatFlowProtocols'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'fat-flow-protocol':
            obj_ = ProtocolType.factory()
            obj_.build(child_)
            self.fat_flow_protocol.append(obj_)
# end class FatFlowProtocols


class PolicyBasedForwardingRuleType(GeneratedsSuper):
    """
    Attributes:
    * direction
        Type:           str, *one-of* [u'ingress', u'egress', u'both']

    * vlan_tag
        Type:           int

    * src_mac
        Type:           str

    * dst_mac
        Type:           str

    * mpls_label
        Type:           int

    * service_chain_address
        Type:           str, *one-of* xsd:string

    * ipv6_service_chain_address
        Type:           str, *one-of* xsd:string

        Description:
          String of standard notation of ipv4 or ipv6 address

    * protocol
        Type:           str

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'direction', u'vlan_tag', u'src_mac', u'dst_mac', u'mpls_label', u'service_chain_address', u'ipv6_service_chain_address', u'protocol']
    attr_field_type_vals = {u'dst_mac': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'protocol': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'ipv6_service_chain_address': {'restrictions': [], 'description': [], 'simple_type': u'IpAddressType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': None, 'attr_type': u'string'}, u'direction': {'restrictions': [u'ingress', u'egress', u'both'], 'description': [], 'simple_type': u'TrafficDirectionType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': None, 'attr_type': u'string'}, u'mpls_label': {'restrictions': None, 'description': [], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'integer'}, u'vlan_tag': {'restrictions': None, 'description': [], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'integer'}, u'src_mac': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'service_chain_address': {'restrictions': [], 'description': [], 'simple_type': u'IpAddress', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': None, 'attr_type': u'string'}}
    def __init__(self, direction=None, vlan_tag=None, src_mac=None, dst_mac=None, mpls_label=None, service_chain_address=None, ipv6_service_chain_address=None, protocol=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _direction = params_dict[u"direction"]
        except KeyError:
            _direction = direction
        self.direction = _direction
        try:
            _vlan_tag = params_dict[u"vlan_tag"]
        except KeyError:
            _vlan_tag = vlan_tag
        self.vlan_tag = _vlan_tag
        try:
            _src_mac = params_dict[u"src_mac"]
        except KeyError:
            _src_mac = src_mac
        self.src_mac = _src_mac
        try:
            _dst_mac = params_dict[u"dst_mac"]
        except KeyError:
            _dst_mac = dst_mac
        self.dst_mac = _dst_mac
        try:
            _mpls_label = params_dict[u"mpls_label"]
        except KeyError:
            _mpls_label = mpls_label
        self.mpls_label = _mpls_label
        try:
            _service_chain_address = params_dict[u"service_chain_address"]
        except KeyError:
            _service_chain_address = service_chain_address
        self.service_chain_address = _service_chain_address
        try:
            _ipv6_service_chain_address = params_dict[u"ipv6_service_chain_address"]
        except KeyError:
            _ipv6_service_chain_address = ipv6_service_chain_address
        self.ipv6_service_chain_address = _ipv6_service_chain_address
        try:
            _protocol = params_dict[u"protocol"]
        except KeyError:
            _protocol = protocol
        self.protocol = _protocol
    def factory(*args_, **kwargs_):
        if PolicyBasedForwardingRuleType.subclass:
            return PolicyBasedForwardingRuleType.subclass(*args_, **kwargs_)
        else:
            return PolicyBasedForwardingRuleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_direction(self): return self.direction
    def set_direction(self, direction): self.direction = direction
    def validate_TrafficDirectionType(self, value):
        # Validate type TrafficDirectionType, a restriction on xsd:string.
        error = False
        if isinstance(value, list):
            error = set(value) - set([u'ingress', u'egress', u'both'])
        else:
            error = value not in [u'ingress', u'egress', u'both']
        if error:
            raise ValueError("TrafficDirectionType must be one of [u'ingress', u'egress', u'both']")
    def get_vlan_tag(self): return self.vlan_tag
    def set_vlan_tag(self, vlan_tag): self.vlan_tag = vlan_tag
    def get_src_mac(self): return self.src_mac
    def set_src_mac(self, src_mac): self.src_mac = src_mac
    def get_dst_mac(self): return self.dst_mac
    def set_dst_mac(self, dst_mac): self.dst_mac = dst_mac
    def get_mpls_label(self): return self.mpls_label
    def set_mpls_label(self, mpls_label): self.mpls_label = mpls_label
    def get_service_chain_address(self): return self.service_chain_address
    def set_service_chain_address(self, service_chain_address): self.service_chain_address = service_chain_address
    def validate_IpAddress(self, value):
        # Validate type IpAddress, a restriction on xsd:string.
        pass
    def get_ipv6_service_chain_address(self): return self.ipv6_service_chain_address
    def set_ipv6_service_chain_address(self, ipv6_service_chain_address): self.ipv6_service_chain_address = ipv6_service_chain_address
    def validate_IpAddressType(self, value):
        # Validate type IpAddressType, a restriction on xsd:string.
        pass
    def get_protocol(self): return self.protocol
    def set_protocol(self, protocol): self.protocol = protocol
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.direction == other.direction and
                    self.vlan_tag == other.vlan_tag and
                    self.src_mac == other.src_mac and
                    self.dst_mac == other.dst_mac and
                    self.mpls_label == other.mpls_label and
                    self.service_chain_address == other.service_chain_address and
                    self.ipv6_service_chain_address == other.ipv6_service_chain_address and
                    self.protocol == other.protocol)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.direction if self.direction is not None else -7985492147856592190,
                     self.vlan_tag if self.vlan_tag is not None else -7985492147856592190,
                     self.src_mac if self.src_mac is not None else -7985492147856592190,
                     self.dst_mac if self.dst_mac is not None else -7985492147856592190,
                     self.mpls_label if self.mpls_label is not None else -7985492147856592190,
                     self.service_chain_address if self.service_chain_address is not None else -7985492147856592190,
                     self.ipv6_service_chain_address if self.ipv6_service_chain_address is not None else -7985492147856592190,
                     self.protocol if self.protocol is not None else -7985492147856592190))

    def __repr__(self):
        return ("direction = " + str(self.direction) + ", " +
                "vlan_tag = " + str(self.vlan_tag) + ", " +
                "src_mac = " + str(self.src_mac) + ", " +
                "dst_mac = " + str(self.dst_mac) + ", " +
                "mpls_label = " + str(self.mpls_label) + ", " +
                "service_chain_address = " + str(self.service_chain_address) + ", " +
                "ipv6_service_chain_address = " + str(self.ipv6_service_chain_address) + ", " +
                "protocol = " + str(self.protocol))

    def copy(self):
        cp = PolicyBasedForwardingRuleType()
        if self.direction is not None:
            cp.direction = self.direction
        if self.vlan_tag is not None:
            cp.vlan_tag = self.vlan_tag
        if self.src_mac is not None:
            cp.src_mac = self.src_mac
        if self.dst_mac is not None:
            cp.dst_mac = self.dst_mac
        if self.mpls_label is not None:
            cp.mpls_label = self.mpls_label
        if self.service_chain_address is not None:
            cp.service_chain_address = self.service_chain_address
        if self.ipv6_service_chain_address is not None:
            cp.ipv6_service_chain_address = self.ipv6_service_chain_address
        if self.protocol is not None:
            cp.protocol = self.protocol
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_direction (obj.populate_string ("direction"))
        obj.set_vlan_tag (obj.populate_integer ("vlan_tag"))
        obj.set_src_mac (obj.populate_string ("src_mac"))
        obj.set_dst_mac (obj.populate_string ("dst_mac"))
        obj.set_mpls_label (obj.populate_integer ("mpls_label"))
        obj.set_service_chain_address (obj.populate_string ("service_chain_address"))
        obj.set_ipv6_service_chain_address (obj.populate_string ("ipv6_service_chain_address"))
        obj.set_protocol (obj.populate_string ("protocol"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='PolicyBasedForwardingRuleType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PolicyBasedForwardingRuleType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PolicyBasedForwardingRuleType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PolicyBasedForwardingRuleType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.direction is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdirection>%s</%sdirection>%s' % (namespace_, self.gds_format_string(quote_xml(self.direction).encode(ExternalEncoding), input_name='direction'), namespace_, eol_))
        if self.vlan_tag is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svlan-tag>%s</%svlan-tag>%s' % (namespace_, self.gds_format_integer(self.vlan_tag, input_name='vlan-tag'), namespace_, eol_))
        if self.src_mac is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssrc-mac>%s</%ssrc-mac>%s' % (namespace_, self.gds_format_string(quote_xml(self.src_mac).encode(ExternalEncoding), input_name='src-mac'), namespace_, eol_))
        if self.dst_mac is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdst-mac>%s</%sdst-mac>%s' % (namespace_, self.gds_format_string(quote_xml(self.dst_mac).encode(ExternalEncoding), input_name='dst-mac'), namespace_, eol_))
        if self.mpls_label is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smpls-label>%s</%smpls-label>%s' % (namespace_, self.gds_format_integer(self.mpls_label, input_name='mpls-label'), namespace_, eol_))
        if self.service_chain_address is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sservice-chain-address>%s</%sservice-chain-address>%s' % (namespace_, self.gds_format_string(quote_xml(self.service_chain_address).encode(ExternalEncoding), input_name='service-chain-address'), namespace_, eol_))
        if self.ipv6_service_chain_address is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sipv6-service-chain-address>%s</%sipv6-service-chain-address>%s' % (namespace_, self.gds_format_string(quote_xml(self.ipv6_service_chain_address).encode(ExternalEncoding), input_name='ipv6-service-chain-address'), namespace_, eol_))
        if self.protocol is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprotocol>%s</%sprotocol>%s' % (namespace_, self.gds_format_string(quote_xml(self.protocol).encode(ExternalEncoding), input_name='protocol'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.direction is not None or
            self.vlan_tag is not None or
            self.src_mac is not None or
            self.dst_mac is not None or
            self.mpls_label is not None or
            self.service_chain_address is not None or
            self.ipv6_service_chain_address is not None or
            self.protocol is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PolicyBasedForwardingRuleType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.direction is not None:
            showIndent(outfile, level)
            outfile.write('direction=%s,\n' % quote_python(self.direction).encode(ExternalEncoding))
        if self.vlan_tag is not None:
            showIndent(outfile, level)
            outfile.write('vlan_tag=%d,\n' % self.vlan_tag)
        if self.src_mac is not None:
            showIndent(outfile, level)
            outfile.write('src_mac=%s,\n' % quote_python(self.src_mac).encode(ExternalEncoding))
        if self.dst_mac is not None:
            showIndent(outfile, level)
            outfile.write('dst_mac=%s,\n' % quote_python(self.dst_mac).encode(ExternalEncoding))
        if self.mpls_label is not None:
            showIndent(outfile, level)
            outfile.write('mpls_label=%d,\n' % self.mpls_label)
        if self.service_chain_address is not None:
            showIndent(outfile, level)
            outfile.write('service_chain_address=%s,\n' % quote_python(self.service_chain_address).encode(ExternalEncoding))
        if self.ipv6_service_chain_address is not None:
            showIndent(outfile, level)
            outfile.write('ipv6_service_chain_address=%s,\n' % quote_python(self.ipv6_service_chain_address).encode(ExternalEncoding))
        if self.protocol is not None:
            showIndent(outfile, level)
            outfile.write('protocol=%s,\n' % quote_python(self.protocol).encode(ExternalEncoding))
    def exportDict(self, name_='PolicyBasedForwardingRuleType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'direction':
            direction_ = child_.text
            direction_ = self.gds_validate_string(direction_, node, 'direction')
            self.direction = direction_
            self.validate_TrafficDirectionType(self.direction)    # validate type TrafficDirectionType
        elif nodeName_ == 'vlan-tag':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'vlan_tag')
            self.vlan_tag = ival_
        elif nodeName_ == 'src-mac':
            src_mac_ = child_.text
            src_mac_ = self.gds_validate_string(src_mac_, node, 'src_mac')
            self.src_mac = src_mac_
        elif nodeName_ == 'dst-mac':
            dst_mac_ = child_.text
            dst_mac_ = self.gds_validate_string(dst_mac_, node, 'dst_mac')
            self.dst_mac = dst_mac_
        elif nodeName_ == 'mpls-label':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'mpls_label')
            self.mpls_label = ival_
        elif nodeName_ == 'service-chain-address':
            service_chain_address_ = child_.text
            service_chain_address_ = self.gds_validate_string(service_chain_address_, node, 'service_chain_address')
            self.service_chain_address = service_chain_address_
            self.validate_IpAddress(self.service_chain_address)    # validate type IpAddress
        elif nodeName_ == 'ipv6-service-chain-address':
            ipv6_service_chain_address_ = child_.text
            ipv6_service_chain_address_ = self.gds_validate_string(ipv6_service_chain_address_, node, 'ipv6_service_chain_address')
            self.ipv6_service_chain_address = ipv6_service_chain_address_
            self.validate_IpAddressType(self.ipv6_service_chain_address)    # validate type IpAddressType
        elif nodeName_ == 'protocol':
            protocol_ = child_.text
            protocol_ = self.gds_validate_string(protocol_, node, 'protocol')
            self.protocol = protocol_
# end class PolicyBasedForwardingRuleType


class JunosServicePorts(GeneratedsSuper):
    """
    Attributes:
    * service_port
        Type:           str

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'service_port']
    attr_field_type_vals = {u'service_port': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': True, 'required': None, 'attr_type': u'string'}}
    def __init__(self, service_port=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _service_port = params_dict[u"service_port"]
        except KeyError:
            _service_port = service_port
        if not _service_port:
            self.service_port = []
        else:
            self.service_port = _service_port
    def factory(*args_, **kwargs_):
        if JunosServicePorts.subclass:
            return JunosServicePorts.subclass(*args_, **kwargs_)
        else:
            return JunosServicePorts(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_service_port(self): return self.service_port
    def set_service_port(self, service_port): self.service_port = service_port
    def add_service_port(self, value): self.service_port.append(value)
    def insert_service_port(self, index, value): self.service_port[index] = value
    def delete_service_port(self, value): self.service_port.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.service_port == other.service_port)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.service_port or [])))

    def __repr__(self):
        return ("service_port = " + str(self.service_port))

    def copy(self):
        cp = JunosServicePorts()
        if self.service_port is not None:
            cp.service_port = list(self.service_port)
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_service_port ([obj.populate_string ("service_port")])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='JunosServicePorts', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='JunosServicePorts')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='JunosServicePorts'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='JunosServicePorts', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for service_port_ in self.service_port:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sservice-port>%s</%sservice-port>%s' % (namespace_, self.gds_format_string(quote_xml(service_port_).encode(ExternalEncoding), input_name='service-port'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.service_port
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='JunosServicePorts'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('service_port=[\n')
        level += 1
        for service_port_ in self.service_port:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(service_port_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='JunosServicePorts'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'service-port':
            service_port_ = child_.text
            service_port_ = self.gds_validate_string(service_port_, node, 'service_port')
            self.service_port.append(service_port_)
# end class JunosServicePorts


class ServiceScaleOutType(GeneratedsSuper):
    """
    Attributes:
    * max_instances
        Type:           int

        Created By:           User (required)

        Description:
          Maximum number of scale out factor(virtual machines). can be changed dynamically

    * auto_scale
        Type:           bool

        Created By:           User (required)

        Description:
          Automatically change the number of virtual machines. Not implemented

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'max_instances', u'auto_scale']
    attr_field_type_vals = {u'auto_scale': {'restrictions': None, 'description': [u'Automatically change the number of virtual machines. Not implemented'], 'simple_type': u'xsd:boolean', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'true', 'attr_type': u'boolean'}, u'max_instances': {'restrictions': None, 'description': [u'Maximum number of scale out factor(virtual machines). can be changed dynamically'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'true', 'attr_type': u'integer'}}
    def __init__(self, max_instances=1, auto_scale=False, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _max_instances = params_dict[u"max_instances"]
        except KeyError:
            _max_instances = max_instances
        self.max_instances = _max_instances
        try:
            _auto_scale = params_dict[u"auto_scale"]
        except KeyError:
            _auto_scale = auto_scale
        self.auto_scale = _auto_scale
    def factory(*args_, **kwargs_):
        if ServiceScaleOutType.subclass:
            return ServiceScaleOutType.subclass(*args_, **kwargs_)
        else:
            return ServiceScaleOutType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_max_instances(self): return self.max_instances
    def set_max_instances(self, max_instances): self.max_instances = max_instances
    def get_auto_scale(self): return self.auto_scale
    def set_auto_scale(self, auto_scale): self.auto_scale = auto_scale
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.max_instances == other.max_instances and
                    self.auto_scale == other.auto_scale)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.max_instances if self.max_instances is not None else -7985492147856592190,
                     self.auto_scale if self.auto_scale is not None else -7985492147856592190))

    def __repr__(self):
        return ("max_instances = " + str(self.max_instances) + ", " +
                "auto_scale = " + str(self.auto_scale))

    def copy(self):
        cp = ServiceScaleOutType()
        if self.max_instances is not None:
            cp.max_instances = self.max_instances
        if self.auto_scale is not None:
            cp.auto_scale = self.auto_scale
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_max_instances (obj.populate_integer ("max_instances"))
        obj.set_auto_scale (obj.populate_boolean ("auto_scale"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='ServiceScaleOutType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ServiceScaleOutType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ServiceScaleOutType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ServiceScaleOutType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.max_instances is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smax-instances>%s</%smax-instances>%s' % (namespace_, self.gds_format_integer(self.max_instances, input_name='max-instances'), namespace_, eol_))
        if self.auto_scale is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sauto-scale>%s</%sauto-scale>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.auto_scale)), input_name='auto-scale'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.max_instances is not None or
            self.auto_scale is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ServiceScaleOutType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.max_instances is not None:
            showIndent(outfile, level)
            outfile.write('max_instances=%d,\n' % self.max_instances)
        if self.auto_scale is not None:
            showIndent(outfile, level)
            outfile.write('auto_scale=%s,\n' % self.auto_scale)
    def exportDict(self, name_='ServiceScaleOutType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'max-instances':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'max_instances')
            self.max_instances = ival_
        elif nodeName_ == 'auto-scale':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'auto_scale')
            self.auto_scale = ival_
# end class ServiceScaleOutType


class ServiceTemplateType(GeneratedsSuper):
    """
    Attributes:
    * version
        Type:           int

        Created By:           User (optional)

        Description:
          Version of service template.

              1: Service virtual machines and interfaces are  automatically launched,

          monitored and deleted.

              2: User creates all objects( virtual machines and interfaces) and manages

          the life cycle.

                 Useful when virtual machines and interfaces are managed via heat template

    * service_mode
        Type:           str, *one-of* [u'transparent', u'in-network', u'in-network-nat']

        Created By:           User (required)

        Description:
          Service instance mode decides how packets are forwarded across the service

    * service_type
        Type:           str, *one-of* [u'firewall', u'analyzer', u'source-nat', u'loadbalancer']

        Created By:           User (required)

        Description:
          Service instance mode decides how routing happens across the service

    * image_name
        Type:           str

        Created By:           User (optional)

        Description:
          Glance image name for the service virtual machine, Version 1 only

    * service_scaling
        Type:           bool

        Created By:           User (optional)

        Description:
          Enable scaling of service virtual machines, Version 1 only

    * interface_type
        Type:           :class:`.ServiceTemplateInterfaceType`

        Created By:           User (required)

        Description:
          List of interfaces which decided number of interfaces and type

    * flavor
        Type:           str

        Created By:           User (optional)

        Description:
          Nova flavor used for service virtual machines, Version 1 only

    * ordered_interfaces
        Type:           bool

        Created By:           User (optional)

        Description:
          Deprecated

    * service_virtualization_type
        Type:           str, *one-of* [u'virtual-machine', u'network-namespace', u'vrouter-instance', u'physical-device']

        Created By:           User (optional)

        Description:
          Service virtualization type decides how individual service instances are

          instantiated

    * availability_zone_enable
        Type:           bool

        Created By:           User (optional)

        Description:
          Enable availability zone for version 1 service instances

    * vrouter_instance_type
        Type:           str, *one-of* [u'libvirt-qemu', u'docker']

        Created By:           User (optional)

        Description:
          Mechanism used to spawn service instance, when vrouter is spawning

          instances.Allowed values libvirt-qemu, docker or netns

    * instance_data
        Type:           str

        Created By:           User (optional)

        Description:
          Opaque string (typically in json format) used to spawn a vrouter-instance.

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'version', u'service_mode', u'service_type', u'image_name', u'service_scaling', u'interface_type', u'flavor', u'ordered_interfaces', u'service_virtualization_type', u'availability_zone_enable', u'vrouter_instance_type', u'instance_data']
    attr_field_type_vals = {u'availability_zone_enable': {'restrictions': None, 'description': [u'Enable availability zone for version 1 service instances'], 'simple_type': u'xsd:boolean', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'boolean'}, u'instance_data': {'restrictions': None, 'description': [u'Opaque string (typically in json format) used to spawn a vrouter-instance.'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'ordered_interfaces': {'restrictions': None, 'description': [u'Deprecated'], 'simple_type': u'xsd:boolean', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'boolean'}, u'service_virtualization_type': {'restrictions': [u'virtual-machine', u'network-namespace', u'vrouter-instance', u'physical-device'], 'description': [u'Service virtualization type decides how individual service instances are instantiated'], 'simple_type': u'ServiceVirtualizationType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'interface_type': {'restrictions': None, 'description': [u'List of interfaces which decided number of interfaces and type'], 'simple_type': u'ServiceTemplateInterfaceType', 'is_complex': 1, 'restriction_type': None, 'is_array': True, 'required': u'true', 'attr_type': u'ServiceTemplateInterfaceType'}, u'image_name': {'restrictions': None, 'description': [u'Glance image name for the service virtual machine, Version 1 only'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'service_mode': {'restrictions': [u'transparent', u'in-network', u'in-network-nat'], 'description': [u'Service instance mode decides how packets are forwarded across the service'], 'simple_type': u'ServiceModeType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'true', 'attr_type': u'string'}, u'version': {'restrictions': None, 'description': [u'Version of service template.', u'    1: Service virtual machines and interfaces are  automatically launched, monitored and deleted. ', u'    2: User creates all objects( virtual machines and interfaces) and manages the life cycle.', u'       Useful when virtual machines and interfaces are managed via heat template'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'service_type': {'restrictions': [u'firewall', u'analyzer', u'source-nat', u'loadbalancer'], 'description': [u'Service instance mode decides how routing happens across the service'], 'simple_type': u'ServiceType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'true', 'attr_type': u'string'}, u'flavor': {'restrictions': None, 'description': [u'Nova flavor used for service virtual machines, Version 1 only'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'service_scaling': {'restrictions': None, 'description': [u'Enable scaling of service virtual machines, Version 1 only'], 'simple_type': u'xsd:boolean', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'boolean'}, u'vrouter_instance_type': {'restrictions': [u'libvirt-qemu', u'docker'], 'description': [u'Mechanism used to spawn service instance, when vrouter is spawning instances.Allowed values libvirt-qemu, docker or netns'], 'simple_type': u'VRouterInstanceType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'optional', 'attr_type': u'string'}}
    def __init__(self, version=1, service_mode=None, service_type=None, image_name=None, service_scaling=False, interface_type=None, flavor=None, ordered_interfaces=False, service_virtualization_type=None, availability_zone_enable=False, vrouter_instance_type=None, instance_data=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _version = params_dict[u"version"]
        except KeyError:
            _version = version
        self.version = _version
        try:
            _service_mode = params_dict[u"service_mode"]
        except KeyError:
            _service_mode = service_mode
        self.service_mode = _service_mode
        try:
            _service_type = params_dict[u"service_type"]
        except KeyError:
            _service_type = service_type
        self.service_type = _service_type
        try:
            _image_name = params_dict[u"image_name"]
        except KeyError:
            _image_name = image_name
        self.image_name = _image_name
        try:
            _service_scaling = params_dict[u"service_scaling"]
        except KeyError:
            _service_scaling = service_scaling
        self.service_scaling = _service_scaling
        try:
            _interface_type = params_dict[u"interface_type"]
        except KeyError:
            _interface_type = interface_type
        if not _interface_type:
            self.interface_type = []
        else:
            if isinstance(_interface_type[0], dict):
                objs = [ServiceTemplateInterfaceType(params_dict=elem) for elem in _interface_type]
                self.interface_type = objs
            else:
                self.interface_type = _interface_type
        try:
            _flavor = params_dict[u"flavor"]
        except KeyError:
            _flavor = flavor
        self.flavor = _flavor
        try:
            _ordered_interfaces = params_dict[u"ordered_interfaces"]
        except KeyError:
            _ordered_interfaces = ordered_interfaces
        self.ordered_interfaces = _ordered_interfaces
        try:
            _service_virtualization_type = params_dict[u"service_virtualization_type"]
        except KeyError:
            _service_virtualization_type = service_virtualization_type
        self.service_virtualization_type = _service_virtualization_type
        try:
            _availability_zone_enable = params_dict[u"availability_zone_enable"]
        except KeyError:
            _availability_zone_enable = availability_zone_enable
        self.availability_zone_enable = _availability_zone_enable
        try:
            _vrouter_instance_type = params_dict[u"vrouter_instance_type"]
        except KeyError:
            _vrouter_instance_type = vrouter_instance_type
        self.vrouter_instance_type = _vrouter_instance_type
        try:
            _instance_data = params_dict[u"instance_data"]
        except KeyError:
            _instance_data = instance_data
        self.instance_data = _instance_data
    def factory(*args_, **kwargs_):
        if ServiceTemplateType.subclass:
            return ServiceTemplateType.subclass(*args_, **kwargs_)
        else:
            return ServiceTemplateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_service_mode(self): return self.service_mode
    def set_service_mode(self, service_mode): self.service_mode = service_mode
    def validate_ServiceModeType(self, value):
        # Validate type ServiceModeType, a restriction on xsd:string.
        error = False
        if isinstance(value, list):
            error = set(value) - set([u'transparent', u'in-network', u'in-network-nat'])
        else:
            error = value not in [u'transparent', u'in-network', u'in-network-nat']
        if error:
            raise ValueError("ServiceModeType must be one of [u'transparent', u'in-network', u'in-network-nat']")
    def get_service_type(self): return self.service_type
    def set_service_type(self, service_type): self.service_type = service_type
    def validate_ServiceType(self, value):
        # Validate type ServiceType, a restriction on xsd:string.
        error = False
        if isinstance(value, list):
            error = set(value) - set([u'firewall', u'analyzer', u'source-nat', u'loadbalancer'])
        else:
            error = value not in [u'firewall', u'analyzer', u'source-nat', u'loadbalancer']
        if error:
            raise ValueError("ServiceType must be one of [u'firewall', u'analyzer', u'source-nat', u'loadbalancer']")
    def get_image_name(self): return self.image_name
    def set_image_name(self, image_name): self.image_name = image_name
    def get_service_scaling(self): return self.service_scaling
    def set_service_scaling(self, service_scaling): self.service_scaling = service_scaling
    def get_interface_type(self): return self.interface_type
    def set_interface_type(self, interface_type): self.interface_type = interface_type
    def add_interface_type(self, value): self.interface_type.append(value)
    def insert_interface_type(self, index, value): self.interface_type[index] = value
    def delete_interface_type(self, value): self.interface_type.remove(value)
    def get_flavor(self): return self.flavor
    def set_flavor(self, flavor): self.flavor = flavor
    def get_ordered_interfaces(self): return self.ordered_interfaces
    def set_ordered_interfaces(self, ordered_interfaces): self.ordered_interfaces = ordered_interfaces
    def get_service_virtualization_type(self): return self.service_virtualization_type
    def set_service_virtualization_type(self, service_virtualization_type): self.service_virtualization_type = service_virtualization_type
    def validate_ServiceVirtualizationType(self, value):
        # Validate type ServiceVirtualizationType, a restriction on xsd:string.
        error = False
        if isinstance(value, list):
            error = set(value) - set([u'virtual-machine', u'network-namespace', u'vrouter-instance', u'physical-device'])
        else:
            error = value not in [u'virtual-machine', u'network-namespace', u'vrouter-instance', u'physical-device']
        if error:
            raise ValueError("ServiceVirtualizationType must be one of [u'virtual-machine', u'network-namespace', u'vrouter-instance', u'physical-device']")
    def get_availability_zone_enable(self): return self.availability_zone_enable
    def set_availability_zone_enable(self, availability_zone_enable): self.availability_zone_enable = availability_zone_enable
    def get_vrouter_instance_type(self): return self.vrouter_instance_type
    def set_vrouter_instance_type(self, vrouter_instance_type): self.vrouter_instance_type = vrouter_instance_type
    def validate_VRouterInstanceType(self, value):
        # Validate type VRouterInstanceType, a restriction on xsd:string.
        error = False
        if isinstance(value, list):
            error = set(value) - set([u'libvirt-qemu', u'docker'])
        else:
            error = value not in [u'libvirt-qemu', u'docker']
        if error:
            raise ValueError("VRouterInstanceType must be one of [u'libvirt-qemu', u'docker']")
    def get_instance_data(self): return self.instance_data
    def set_instance_data(self, instance_data): self.instance_data = instance_data
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.version == other.version and
                    self.service_mode == other.service_mode and
                    self.service_type == other.service_type and
                    self.image_name == other.image_name and
                    self.service_scaling == other.service_scaling and
                    self.interface_type == other.interface_type and
                    self.flavor == other.flavor and
                    self.ordered_interfaces == other.ordered_interfaces and
                    self.service_virtualization_type == other.service_virtualization_type and
                    self.availability_zone_enable == other.availability_zone_enable and
                    self.vrouter_instance_type == other.vrouter_instance_type and
                    self.instance_data == other.instance_data)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.version if self.version is not None else -7985492147856592190,
                     self.service_mode if self.service_mode is not None else -7985492147856592190,
                     self.service_type if self.service_type is not None else -7985492147856592190,
                     self.image_name if self.image_name is not None else -7985492147856592190,
                     self.service_scaling if self.service_scaling is not None else -7985492147856592190,
                     tuple(self.interface_type or []),
                     self.flavor if self.flavor is not None else -7985492147856592190,
                     self.ordered_interfaces if self.ordered_interfaces is not None else -7985492147856592190,
                     self.service_virtualization_type if self.service_virtualization_type is not None else -7985492147856592190,
                     self.availability_zone_enable if self.availability_zone_enable is not None else -7985492147856592190,
                     self.vrouter_instance_type if self.vrouter_instance_type is not None else -7985492147856592190,
                     self.instance_data if self.instance_data is not None else -7985492147856592190))

    def __repr__(self):
        return ("version = " + str(self.version) + ", " +
                "service_mode = " + str(self.service_mode) + ", " +
                "service_type = " + str(self.service_type) + ", " +
                "image_name = " + str(self.image_name) + ", " +
                "service_scaling = " + str(self.service_scaling) + ", " +
                "interface_type = " + str(self.interface_type) + ", " +
                "flavor = " + str(self.flavor) + ", " +
                "ordered_interfaces = " + str(self.ordered_interfaces) + ", " +
                "service_virtualization_type = " + str(self.service_virtualization_type) + ", " +
                "availability_zone_enable = " + str(self.availability_zone_enable) + ", " +
                "vrouter_instance_type = " + str(self.vrouter_instance_type) + ", " +
                "instance_data = " + str(self.instance_data))

    def copy(self):
        cp = ServiceTemplateType()
        if self.version is not None:
            cp.version = self.version
        if self.service_mode is not None:
            cp.service_mode = self.service_mode
        if self.service_type is not None:
            cp.service_type = self.service_type
        if self.image_name is not None:
            cp.image_name = self.image_name
        if self.service_scaling is not None:
            cp.service_scaling = self.service_scaling
        if self.interface_type is not None:
            cp.interface_type = [x.copy() for x in self.interface_type]
        if self.flavor is not None:
            cp.flavor = self.flavor
        if self.ordered_interfaces is not None:
            cp.ordered_interfaces = self.ordered_interfaces
        if self.service_virtualization_type is not None:
            cp.service_virtualization_type = self.service_virtualization_type
        if self.availability_zone_enable is not None:
            cp.availability_zone_enable = self.availability_zone_enable
        if self.vrouter_instance_type is not None:
            cp.vrouter_instance_type = self.vrouter_instance_type
        if self.instance_data is not None:
            cp.instance_data = self.instance_data
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_version (obj.populate_integer ("version"))
        obj.set_service_mode (obj.populate_string ("service_mode"))
        obj.set_service_type (obj.populate_string ("service_type"))
        obj.set_image_name (obj.populate_string ("image_name"))
        obj.set_service_scaling (obj.populate_boolean ("service_scaling"))
        obj.set_interface_type ([ServiceTemplateInterfaceType.populate ()])
        obj.set_flavor (obj.populate_string ("flavor"))
        obj.set_ordered_interfaces (obj.populate_boolean ("ordered_interfaces"))
        obj.set_service_virtualization_type (obj.populate_string ("service_virtualization_type"))
        obj.set_availability_zone_enable (obj.populate_boolean ("availability_zone_enable"))
        obj.set_vrouter_instance_type (obj.populate_string ("vrouter_instance_type"))
        obj.set_instance_data (obj.populate_string ("instance_data"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='ServiceTemplateType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ServiceTemplateType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ServiceTemplateType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ServiceTemplateType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sversion>%s</%sversion>%s' % (namespace_, self.gds_format_integer(self.version, input_name='version'), namespace_, eol_))
        if self.service_mode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sservice-mode>%s</%sservice-mode>%s' % (namespace_, self.gds_format_string(quote_xml(self.service_mode).encode(ExternalEncoding), input_name='service-mode'), namespace_, eol_))
        if self.service_type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sservice-type>%s</%sservice-type>%s' % (namespace_, self.gds_format_string(quote_xml(self.service_type).encode(ExternalEncoding), input_name='service-type'), namespace_, eol_))
        if self.image_name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%simage-name>%s</%simage-name>%s' % (namespace_, self.gds_format_string(quote_xml(self.image_name).encode(ExternalEncoding), input_name='image-name'), namespace_, eol_))
        if self.service_scaling is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sservice-scaling>%s</%sservice-scaling>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.service_scaling)), input_name='service-scaling'), namespace_, eol_))
        for interface_type_ in self.interface_type:
            if isinstance(interface_type_, dict):
                interface_type_ = ServiceTemplateInterfaceType(**interface_type_)
            interface_type_.export_xml(outfile, level, namespace_, name_='interface-type', pretty_print=pretty_print)
        if self.flavor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sflavor>%s</%sflavor>%s' % (namespace_, self.gds_format_string(quote_xml(self.flavor).encode(ExternalEncoding), input_name='flavor'), namespace_, eol_))
        if self.ordered_interfaces is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sordered-interfaces>%s</%sordered-interfaces>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.ordered_interfaces)), input_name='ordered-interfaces'), namespace_, eol_))
        if self.service_virtualization_type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sservice-virtualization-type>%s</%sservice-virtualization-type>%s' % (namespace_, self.gds_format_string(quote_xml(self.service_virtualization_type).encode(ExternalEncoding), input_name='service-virtualization-type'), namespace_, eol_))
        if self.availability_zone_enable is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%savailability-zone-enable>%s</%savailability-zone-enable>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.availability_zone_enable)), input_name='availability-zone-enable'), namespace_, eol_))
        if self.vrouter_instance_type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svrouter-instance-type>%s</%svrouter-instance-type>%s' % (namespace_, self.gds_format_string(quote_xml(self.vrouter_instance_type).encode(ExternalEncoding), input_name='vrouter-instance-type'), namespace_, eol_))
        if self.instance_data is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinstance-data>%s</%sinstance-data>%s' % (namespace_, self.gds_format_string(quote_xml(self.instance_data).encode(ExternalEncoding), input_name='instance-data'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.version is not None or
            self.service_mode is not None or
            self.service_type is not None or
            self.image_name is not None or
            self.service_scaling is not None or
            self.interface_type or
            self.flavor is not None or
            self.ordered_interfaces is not None or
            self.service_virtualization_type is not None or
            self.availability_zone_enable is not None or
            self.vrouter_instance_type is not None or
            self.instance_data is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ServiceTemplateType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.version is not None:
            showIndent(outfile, level)
            outfile.write('version=%d,\n' % self.version)
        if self.service_mode is not None:
            showIndent(outfile, level)
            outfile.write('service_mode=%s,\n' % quote_python(self.service_mode).encode(ExternalEncoding))
        if self.service_type is not None:
            showIndent(outfile, level)
            outfile.write('service_type=%s,\n' % quote_python(self.service_type).encode(ExternalEncoding))
        if self.image_name is not None:
            showIndent(outfile, level)
            outfile.write('image_name=%s,\n' % quote_python(self.image_name).encode(ExternalEncoding))
        if self.service_scaling is not None:
            showIndent(outfile, level)
            outfile.write('service_scaling=%s,\n' % self.service_scaling)
        showIndent(outfile, level)
        outfile.write('interface_type=[\n')
        level += 1
        for interface_type_ in self.interface_type:
            showIndent(outfile, level)
            outfile.write('model_.ServiceTemplateInterfaceType(\n')
            interface_type_.exportLiteral(outfile, level, name_='ServiceTemplateInterfaceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.flavor is not None:
            showIndent(outfile, level)
            outfile.write('flavor=%s,\n' % quote_python(self.flavor).encode(ExternalEncoding))
        if self.ordered_interfaces is not None:
            showIndent(outfile, level)
            outfile.write('ordered_interfaces=%s,\n' % self.ordered_interfaces)
        if self.service_virtualization_type is not None:
            showIndent(outfile, level)
            outfile.write('service_virtualization_type=%s,\n' % quote_python(self.service_virtualization_type).encode(ExternalEncoding))
        if self.availability_zone_enable is not None:
            showIndent(outfile, level)
            outfile.write('availability_zone_enable=%s,\n' % self.availability_zone_enable)
        if self.vrouter_instance_type is not None:
            showIndent(outfile, level)
            outfile.write('vrouter_instance_type=%s,\n' % quote_python(self.vrouter_instance_type).encode(ExternalEncoding))
        if self.instance_data is not None:
            showIndent(outfile, level)
            outfile.write('instance_data=%s,\n' % quote_python(self.instance_data).encode(ExternalEncoding))
    def exportDict(self, name_='ServiceTemplateType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'version':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'version')
            self.version = ival_
        elif nodeName_ == 'service-mode':
            service_mode_ = child_.text
            service_mode_ = self.gds_validate_string(service_mode_, node, 'service_mode')
            self.service_mode = service_mode_
            self.validate_ServiceModeType(self.service_mode)    # validate type ServiceModeType
        elif nodeName_ == 'service-type':
            service_type_ = child_.text
            service_type_ = self.gds_validate_string(service_type_, node, 'service_type')
            self.service_type = service_type_
            self.validate_ServiceType(self.service_type)    # validate type ServiceType
        elif nodeName_ == 'image-name':
            image_name_ = child_.text
            image_name_ = self.gds_validate_string(image_name_, node, 'image_name')
            self.image_name = image_name_
        elif nodeName_ == 'service-scaling':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'service_scaling')
            self.service_scaling = ival_
        elif nodeName_ == 'interface-type':
            obj_ = ServiceTemplateInterfaceType.factory()
            obj_.build(child_)
            self.interface_type.append(obj_)
        elif nodeName_ == 'flavor':
            flavor_ = child_.text
            flavor_ = self.gds_validate_string(flavor_, node, 'flavor')
            self.flavor = flavor_
        elif nodeName_ == 'ordered-interfaces':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'ordered_interfaces')
            self.ordered_interfaces = ival_
        elif nodeName_ == 'service-virtualization-type':
            service_virtualization_type_ = child_.text
            service_virtualization_type_ = self.gds_validate_string(service_virtualization_type_, node, 'service_virtualization_type')
            self.service_virtualization_type = service_virtualization_type_
            self.validate_ServiceVirtualizationType(self.service_virtualization_type)    # validate type ServiceVirtualizationType
        elif nodeName_ == 'availability-zone-enable':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'availability_zone_enable')
            self.availability_zone_enable = ival_
        elif nodeName_ == 'vrouter-instance-type':
            vrouter_instance_type_ = child_.text
            vrouter_instance_type_ = self.gds_validate_string(vrouter_instance_type_, node, 'vrouter_instance_type')
            self.vrouter_instance_type = vrouter_instance_type_
            self.validate_VRouterInstanceType(self.vrouter_instance_type)    # validate type VRouterInstanceType
        elif nodeName_ == 'instance-data':
            instance_data_ = child_.text
            instance_data_ = self.gds_validate_string(instance_data_, node, 'instance_data')
            self.instance_data = instance_data_
# end class ServiceTemplateType


class ServiceInstanceType(GeneratedsSuper):
    """
    Attributes:
    * auto_policy
        Type:           bool

        Description:
          Set when system creates internal service chains, example SNAT with router

          external flag in logical router

    * availability_zone
        Type:           str

        Created By:           User (optional)

        Description:
          Availability zone used to spawn VM(s) for this service instance, used in version

          1 (V1) only

    * management_virtual_network
        Type:           str

        Created By:           User (optional)

        Description:
          Deprecated

    * left_virtual_network
        Type:           str

        Created By:           User (optional)

        Description:
          Deprecated

    * left_ip_address
        Type:           str, *one-of* xsd:string

        Created By:           User (optional)

        Description:
          Deprecated

    * right_virtual_network
        Type:           str

        Created By:           User (optional)

        Description:
          Deprecated

    * right_ip_address
        Type:           str, *one-of* xsd:string

        Created By:           User (optional)

        Description:
          Deprecated

    * interface_list
        Type:           :class:`.ServiceInstanceInterfaceType`

        Created By:           User (required)

        Description:
          List of service instance interface properties. Ordered list as per service

          template

    * scale_out
        Type:           :class:`.ServiceScaleOutType`

        Created By:           User (optional)

        Description:
          Number of virtual machines in this service instance, used in version 1 (V1) only

    * ha_mode
        Type:           str, *one-of* [u'active-active', u'active-standby']

        Created By:           User (optional)

        Description:
          When scale-out is greater than one, decides if active-active or active-backup,

          used in version 1 (V1) only

    * virtual_router_id
        Type:           str

        Created By:           User (optional)

        Description:
          UUID of a virtual-router on which this service instance need to spawn. Used to

          spawn services on CPE device when Nova is not present

    * service_virtualization_type
        Type:           str, *one-of* [u'virtual-machine', u'network-namespace', u'vrouter-instance', u'physical-device']

        Created By:           User (optional)

        Description:
          Service virtualization type decides how individual service instances are

          instantiated

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'auto_policy', u'availability_zone', u'management_virtual_network', u'left_virtual_network', u'left_ip_address', u'right_virtual_network', u'right_ip_address', u'interface_list', u'scale_out', u'ha_mode', u'virtual_router_id', u'service_virtualization_type']
    attr_field_type_vals = {u'right_virtual_network': {'restrictions': None, 'description': [u'Deprecated'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'right_ip_address': {'restrictions': [], 'description': [u'Deprecated'], 'simple_type': u'IpAddressType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'availability_zone': {'restrictions': None, 'description': [u'Availability zone used to spawn VM(s) for this service instance, used in version 1 (V1) only'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'management_virtual_network': {'restrictions': None, 'description': [u'Deprecated'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'service_virtualization_type': {'restrictions': [u'virtual-machine', u'network-namespace', u'vrouter-instance', u'physical-device'], 'description': [u'Service virtualization type decides how individual service instances are instantiated'], 'simple_type': u'ServiceVirtualizationType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'scale_out': {'restrictions': None, 'description': [u'Number of virtual machines in this service instance, used in version 1 (V1) only'], 'simple_type': u'ServiceScaleOutType', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'ServiceScaleOutType'}, u'ha_mode': {'restrictions': [u'active-active', u'active-standby'], 'description': [u'When scale-out is greater than one, decides if active-active or active-backup, used in version 1 (V1) only'], 'simple_type': u'AddressMode', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'virtual_router_id': {'restrictions': None, 'description': [u'UUID of a virtual-router on which this service instance need to spawn. Used to spawn services on CPE device when Nova is not present'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'interface_list': {'restrictions': None, 'description': [u'List of service instance interface properties. Ordered list as per service template'], 'simple_type': u'ServiceInstanceInterfaceType', 'is_complex': 1, 'restriction_type': None, 'is_array': True, 'required': u'true', 'attr_type': u'ServiceInstanceInterfaceType'}, u'left_ip_address': {'restrictions': [], 'description': [u'Deprecated'], 'simple_type': u'IpAddressType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'left_virtual_network': {'restrictions': None, 'description': [u'Deprecated'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'auto_policy': {'restrictions': None, 'description': [u'Set when system creates internal service chains, example SNAT with router external flag in logical router'], 'simple_type': u'xsd:boolean', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'system-only', 'attr_type': u'boolean'}}
    def __init__(self, auto_policy=False, availability_zone=None, management_virtual_network=None, left_virtual_network=None, left_ip_address=None, right_virtual_network=None, right_ip_address=None, interface_list=None, scale_out=None, ha_mode=None, virtual_router_id=None, service_virtualization_type=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _auto_policy = params_dict[u"auto_policy"]
        except KeyError:
            _auto_policy = auto_policy
        self.auto_policy = _auto_policy
        try:
            _availability_zone = params_dict[u"availability_zone"]
        except KeyError:
            _availability_zone = availability_zone
        self.availability_zone = _availability_zone
        try:
            _management_virtual_network = params_dict[u"management_virtual_network"]
        except KeyError:
            _management_virtual_network = management_virtual_network
        self.management_virtual_network = _management_virtual_network
        try:
            _left_virtual_network = params_dict[u"left_virtual_network"]
        except KeyError:
            _left_virtual_network = left_virtual_network
        self.left_virtual_network = _left_virtual_network
        try:
            _left_ip_address = params_dict[u"left_ip_address"]
        except KeyError:
            _left_ip_address = left_ip_address
        self.left_ip_address = _left_ip_address
        try:
            _right_virtual_network = params_dict[u"right_virtual_network"]
        except KeyError:
            _right_virtual_network = right_virtual_network
        self.right_virtual_network = _right_virtual_network
        try:
            _right_ip_address = params_dict[u"right_ip_address"]
        except KeyError:
            _right_ip_address = right_ip_address
        self.right_ip_address = _right_ip_address
        try:
            _interface_list = params_dict[u"interface_list"]
        except KeyError:
            _interface_list = interface_list
        if not _interface_list:
            self.interface_list = []
        else:
            if isinstance(_interface_list[0], dict):
                objs = [ServiceInstanceInterfaceType(params_dict=elem) for elem in _interface_list]
                self.interface_list = objs
            else:
                self.interface_list = _interface_list
        try:
            _scale_out = params_dict[u"scale_out"]
        except KeyError:
            _scale_out = scale_out
        if isinstance(_scale_out, dict):
            obj = ServiceScaleOutType(params_dict=_scale_out)
            self.scale_out = obj
        else:
            self.scale_out = _scale_out
        try:
            _ha_mode = params_dict[u"ha_mode"]
        except KeyError:
            _ha_mode = ha_mode
        self.ha_mode = _ha_mode
        try:
            _virtual_router_id = params_dict[u"virtual_router_id"]
        except KeyError:
            _virtual_router_id = virtual_router_id
        self.virtual_router_id = _virtual_router_id
        try:
            _service_virtualization_type = params_dict[u"service_virtualization_type"]
        except KeyError:
            _service_virtualization_type = service_virtualization_type
        self.service_virtualization_type = _service_virtualization_type
    def factory(*args_, **kwargs_):
        if ServiceInstanceType.subclass:
            return ServiceInstanceType.subclass(*args_, **kwargs_)
        else:
            return ServiceInstanceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_auto_policy(self): return self.auto_policy
    def set_auto_policy(self, auto_policy): self.auto_policy = auto_policy
    def get_availability_zone(self): return self.availability_zone
    def set_availability_zone(self, availability_zone): self.availability_zone = availability_zone
    def get_management_virtual_network(self): return self.management_virtual_network
    def set_management_virtual_network(self, management_virtual_network): self.management_virtual_network = management_virtual_network
    def get_left_virtual_network(self): return self.left_virtual_network
    def set_left_virtual_network(self, left_virtual_network): self.left_virtual_network = left_virtual_network
    def get_left_ip_address(self): return self.left_ip_address
    def set_left_ip_address(self, left_ip_address): self.left_ip_address = left_ip_address
    def validate_IpAddressType(self, value):
        # Validate type IpAddressType, a restriction on xsd:string.
        pass
    def get_right_virtual_network(self): return self.right_virtual_network
    def set_right_virtual_network(self, right_virtual_network): self.right_virtual_network = right_virtual_network
    def get_right_ip_address(self): return self.right_ip_address
    def set_right_ip_address(self, right_ip_address): self.right_ip_address = right_ip_address
    def get_interface_list(self): return self.interface_list
    def set_interface_list(self, interface_list): self.interface_list = interface_list
    def add_interface_list(self, value): self.interface_list.append(value)
    def insert_interface_list(self, index, value): self.interface_list[index] = value
    def delete_interface_list(self, value): self.interface_list.remove(value)
    def get_scale_out(self): return self.scale_out
    def set_scale_out(self, scale_out): self.scale_out = scale_out
    def get_ha_mode(self): return self.ha_mode
    def set_ha_mode(self, ha_mode): self.ha_mode = ha_mode
    def validate_AddressMode(self, value):
        # Validate type AddressMode, a restriction on xsd:string.
        error = False
        if isinstance(value, list):
            error = set(value) - set([u'active-active', u'active-standby'])
        else:
            error = value not in [u'active-active', u'active-standby']
        if error:
            raise ValueError("AddressMode must be one of [u'active-active', u'active-standby']")
    def get_virtual_router_id(self): return self.virtual_router_id
    def set_virtual_router_id(self, virtual_router_id): self.virtual_router_id = virtual_router_id
    def get_service_virtualization_type(self): return self.service_virtualization_type
    def set_service_virtualization_type(self, service_virtualization_type): self.service_virtualization_type = service_virtualization_type
    def validate_ServiceVirtualizationType(self, value):
        # Validate type ServiceVirtualizationType, a restriction on xsd:string.
        error = False
        if isinstance(value, list):
            error = set(value) - set([u'virtual-machine', u'network-namespace', u'vrouter-instance', u'physical-device'])
        else:
            error = value not in [u'virtual-machine', u'network-namespace', u'vrouter-instance', u'physical-device']
        if error:
            raise ValueError("ServiceVirtualizationType must be one of [u'virtual-machine', u'network-namespace', u'vrouter-instance', u'physical-device']")
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.auto_policy == other.auto_policy and
                    self.availability_zone == other.availability_zone and
                    self.management_virtual_network == other.management_virtual_network and
                    self.left_virtual_network == other.left_virtual_network and
                    self.left_ip_address == other.left_ip_address and
                    self.right_virtual_network == other.right_virtual_network and
                    self.right_ip_address == other.right_ip_address and
                    self.interface_list == other.interface_list and
                    self.scale_out == other.scale_out and
                    self.ha_mode == other.ha_mode and
                    self.virtual_router_id == other.virtual_router_id and
                    self.service_virtualization_type == other.service_virtualization_type)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.auto_policy if self.auto_policy is not None else -7985492147856592190,
                     self.availability_zone if self.availability_zone is not None else -7985492147856592190,
                     self.management_virtual_network if self.management_virtual_network is not None else -7985492147856592190,
                     self.left_virtual_network if self.left_virtual_network is not None else -7985492147856592190,
                     self.left_ip_address if self.left_ip_address is not None else -7985492147856592190,
                     self.right_virtual_network if self.right_virtual_network is not None else -7985492147856592190,
                     self.right_ip_address if self.right_ip_address is not None else -7985492147856592190,
                     tuple(self.interface_list or []),
                     self.scale_out if self.scale_out is not None else -7985492147856592190,
                     self.ha_mode if self.ha_mode is not None else -7985492147856592190,
                     self.virtual_router_id if self.virtual_router_id is not None else -7985492147856592190,
                     self.service_virtualization_type if self.service_virtualization_type is not None else -7985492147856592190))

    def __repr__(self):
        return ("auto_policy = " + str(self.auto_policy) + ", " +
                "availability_zone = " + str(self.availability_zone) + ", " +
                "management_virtual_network = " + str(self.management_virtual_network) + ", " +
                "left_virtual_network = " + str(self.left_virtual_network) + ", " +
                "left_ip_address = " + str(self.left_ip_address) + ", " +
                "right_virtual_network = " + str(self.right_virtual_network) + ", " +
                "right_ip_address = " + str(self.right_ip_address) + ", " +
                "interface_list = " + str(self.interface_list) + ", " +
                "scale_out = " + str(self.scale_out) + ", " +
                "ha_mode = " + str(self.ha_mode) + ", " +
                "virtual_router_id = " + str(self.virtual_router_id) + ", " +
                "service_virtualization_type = " + str(self.service_virtualization_type))

    def copy(self):
        cp = ServiceInstanceType()
        if self.auto_policy is not None:
            cp.auto_policy = self.auto_policy
        if self.availability_zone is not None:
            cp.availability_zone = self.availability_zone
        if self.management_virtual_network is not None:
            cp.management_virtual_network = self.management_virtual_network
        if self.left_virtual_network is not None:
            cp.left_virtual_network = self.left_virtual_network
        if self.left_ip_address is not None:
            cp.left_ip_address = self.left_ip_address
        if self.right_virtual_network is not None:
            cp.right_virtual_network = self.right_virtual_network
        if self.right_ip_address is not None:
            cp.right_ip_address = self.right_ip_address
        if self.interface_list is not None:
            cp.interface_list = [x.copy() for x in self.interface_list]
        if self.scale_out is not None:
            cp.scale_out = self.scale_out.copy()
        if self.ha_mode is not None:
            cp.ha_mode = self.ha_mode
        if self.virtual_router_id is not None:
            cp.virtual_router_id = self.virtual_router_id
        if self.service_virtualization_type is not None:
            cp.service_virtualization_type = self.service_virtualization_type
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_auto_policy (obj.populate_boolean ("auto_policy"))
        obj.set_availability_zone (obj.populate_string ("availability_zone"))
        obj.set_management_virtual_network (obj.populate_string ("management_virtual_network"))
        obj.set_left_virtual_network (obj.populate_string ("left_virtual_network"))
        obj.set_left_ip_address (obj.populate_string ("left_ip_address"))
        obj.set_right_virtual_network (obj.populate_string ("right_virtual_network"))
        obj.set_right_ip_address (obj.populate_string ("right_ip_address"))
        obj.set_interface_list ([ServiceInstanceInterfaceType.populate ()])
        obj.set_scale_out (ServiceScaleOutType.populate ())
        obj.set_ha_mode (obj.populate_string ("ha_mode"))
        obj.set_virtual_router_id (obj.populate_string ("virtual_router_id"))
        obj.set_service_virtualization_type (obj.populate_string ("service_virtualization_type"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='ServiceInstanceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ServiceInstanceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ServiceInstanceType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ServiceInstanceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.auto_policy is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sauto-policy>%s</%sauto-policy>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.auto_policy)), input_name='auto-policy'), namespace_, eol_))
        if self.availability_zone is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%savailability-zone>%s</%savailability-zone>%s' % (namespace_, self.gds_format_string(quote_xml(self.availability_zone).encode(ExternalEncoding), input_name='availability-zone'), namespace_, eol_))
        if self.management_virtual_network is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smanagement-virtual-network>%s</%smanagement-virtual-network>%s' % (namespace_, self.gds_format_string(quote_xml(self.management_virtual_network).encode(ExternalEncoding), input_name='management-virtual-network'), namespace_, eol_))
        if self.left_virtual_network is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sleft-virtual-network>%s</%sleft-virtual-network>%s' % (namespace_, self.gds_format_string(quote_xml(self.left_virtual_network).encode(ExternalEncoding), input_name='left-virtual-network'), namespace_, eol_))
        if self.left_ip_address is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sleft-ip-address>%s</%sleft-ip-address>%s' % (namespace_, self.gds_format_string(quote_xml(self.left_ip_address).encode(ExternalEncoding), input_name='left-ip-address'), namespace_, eol_))
        if self.right_virtual_network is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sright-virtual-network>%s</%sright-virtual-network>%s' % (namespace_, self.gds_format_string(quote_xml(self.right_virtual_network).encode(ExternalEncoding), input_name='right-virtual-network'), namespace_, eol_))
        if self.right_ip_address is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sright-ip-address>%s</%sright-ip-address>%s' % (namespace_, self.gds_format_string(quote_xml(self.right_ip_address).encode(ExternalEncoding), input_name='right-ip-address'), namespace_, eol_))
        for interface_list_ in self.interface_list:
            if isinstance(interface_list_, dict):
                interface_list_ = ServiceInstanceInterfaceType(**interface_list_)
            interface_list_.export_xml(outfile, level, namespace_, name_='interface-list', pretty_print=pretty_print)
        if self.scale_out is not None:
            self.scale_out.export_xml(outfile, level, namespace_, name_='scale-out', pretty_print=pretty_print)
        if self.ha_mode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sha-mode>%s</%sha-mode>%s' % (namespace_, self.gds_format_string(quote_xml(self.ha_mode).encode(ExternalEncoding), input_name='ha-mode'), namespace_, eol_))
        if self.virtual_router_id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svirtual-router-id>%s</%svirtual-router-id>%s' % (namespace_, self.gds_format_string(quote_xml(self.virtual_router_id).encode(ExternalEncoding), input_name='virtual-router-id'), namespace_, eol_))
        if self.service_virtualization_type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sservice-virtualization-type>%s</%sservice-virtualization-type>%s' % (namespace_, self.gds_format_string(quote_xml(self.service_virtualization_type).encode(ExternalEncoding), input_name='service-virtualization-type'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.auto_policy is not None or
            self.availability_zone is not None or
            self.management_virtual_network is not None or
            self.left_virtual_network is not None or
            self.left_ip_address is not None or
            self.right_virtual_network is not None or
            self.right_ip_address is not None or
            self.interface_list or
            self.scale_out is not None or
            self.ha_mode is not None or
            self.virtual_router_id is not None or
            self.service_virtualization_type is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ServiceInstanceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.auto_policy is not None:
            showIndent(outfile, level)
            outfile.write('auto_policy=%s,\n' % self.auto_policy)
        if self.availability_zone is not None:
            showIndent(outfile, level)
            outfile.write('availability_zone=%s,\n' % quote_python(self.availability_zone).encode(ExternalEncoding))
        if self.management_virtual_network is not None:
            showIndent(outfile, level)
            outfile.write('management_virtual_network=%s,\n' % quote_python(self.management_virtual_network).encode(ExternalEncoding))
        if self.left_virtual_network is not None:
            showIndent(outfile, level)
            outfile.write('left_virtual_network=%s,\n' % quote_python(self.left_virtual_network).encode(ExternalEncoding))
        if self.left_ip_address is not None:
            showIndent(outfile, level)
            outfile.write('left_ip_address=%s,\n' % quote_python(self.left_ip_address).encode(ExternalEncoding))
        if self.right_virtual_network is not None:
            showIndent(outfile, level)
            outfile.write('right_virtual_network=%s,\n' % quote_python(self.right_virtual_network).encode(ExternalEncoding))
        if self.right_ip_address is not None:
            showIndent(outfile, level)
            outfile.write('right_ip_address=%s,\n' % quote_python(self.right_ip_address).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('interface_list=[\n')
        level += 1
        for interface_list_ in self.interface_list:
            showIndent(outfile, level)
            outfile.write('model_.ServiceInstanceInterfaceType(\n')
            interface_list_.exportLiteral(outfile, level, name_='ServiceInstanceInterfaceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.scale_out is not None:
            showIndent(outfile, level)
            outfile.write('scale_out=model_.ServiceScaleOutType(\n')
            self.scale_out.exportLiteral(outfile, level, name_='scale_out')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ha_mode is not None:
            showIndent(outfile, level)
            outfile.write('ha_mode=%s,\n' % quote_python(self.ha_mode).encode(ExternalEncoding))
        if self.virtual_router_id is not None:
            showIndent(outfile, level)
            outfile.write('virtual_router_id=%s,\n' % quote_python(self.virtual_router_id).encode(ExternalEncoding))
        if self.service_virtualization_type is not None:
            showIndent(outfile, level)
            outfile.write('service_virtualization_type=%s,\n' % quote_python(self.service_virtualization_type).encode(ExternalEncoding))
    def exportDict(self, name_='ServiceInstanceType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'auto-policy':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'auto_policy')
            self.auto_policy = ival_
        elif nodeName_ == 'availability-zone':
            availability_zone_ = child_.text
            availability_zone_ = self.gds_validate_string(availability_zone_, node, 'availability_zone')
            self.availability_zone = availability_zone_
        elif nodeName_ == 'management-virtual-network':
            management_virtual_network_ = child_.text
            management_virtual_network_ = self.gds_validate_string(management_virtual_network_, node, 'management_virtual_network')
            self.management_virtual_network = management_virtual_network_
        elif nodeName_ == 'left-virtual-network':
            left_virtual_network_ = child_.text
            left_virtual_network_ = self.gds_validate_string(left_virtual_network_, node, 'left_virtual_network')
            self.left_virtual_network = left_virtual_network_
        elif nodeName_ == 'left-ip-address':
            left_ip_address_ = child_.text
            left_ip_address_ = self.gds_validate_string(left_ip_address_, node, 'left_ip_address')
            self.left_ip_address = left_ip_address_
            self.validate_IpAddressType(self.left_ip_address)    # validate type IpAddressType
        elif nodeName_ == 'right-virtual-network':
            right_virtual_network_ = child_.text
            right_virtual_network_ = self.gds_validate_string(right_virtual_network_, node, 'right_virtual_network')
            self.right_virtual_network = right_virtual_network_
        elif nodeName_ == 'right-ip-address':
            right_ip_address_ = child_.text
            right_ip_address_ = self.gds_validate_string(right_ip_address_, node, 'right_ip_address')
            self.right_ip_address = right_ip_address_
            self.validate_IpAddressType(self.right_ip_address)    # validate type IpAddressType
        elif nodeName_ == 'interface-list':
            obj_ = ServiceInstanceInterfaceType.factory()
            obj_.build(child_)
            self.interface_list.append(obj_)
        elif nodeName_ == 'scale-out':
            obj_ = ServiceScaleOutType.factory()
            obj_.build(child_)
            self.set_scale_out(obj_)
        elif nodeName_ == 'ha-mode':
            ha_mode_ = child_.text
            ha_mode_ = self.gds_validate_string(ha_mode_, node, 'ha_mode')
            self.ha_mode = ha_mode_
            self.validate_AddressMode(self.ha_mode)    # validate type AddressMode
        elif nodeName_ == 'virtual-router-id':
            virtual_router_id_ = child_.text
            virtual_router_id_ = self.gds_validate_string(virtual_router_id_, node, 'virtual_router_id')
            self.virtual_router_id = virtual_router_id_
        elif nodeName_ == 'service-virtualization-type':
            service_virtualization_type_ = child_.text
            service_virtualization_type_ = self.gds_validate_string(service_virtualization_type_, node, 'service_virtualization_type')
            self.service_virtualization_type = service_virtualization_type_
            self.validate_ServiceVirtualizationType(self.service_virtualization_type)    # validate type ServiceVirtualizationType
# end class ServiceInstanceType


class CommunityAttributes(GeneratedsSuper):
    """
    Attributes:
    * community_attribute
        Type:           str, *one-of* xsd:string

        Description:
          List of Community attributes, it indicates the attributes with which the routes

          are tagged while publishing.

          The attributes will be represented as bgp community in the path attribute.

          Each attribute is indicated as string.

              1. String with two integers separated by ":". E.g. "64512:123"

              2. Well-known community as string.

                 Possible values are "no-export" "accept-own" "no-advertise" "no-export-

          subconfed" "no-reoriginate"

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'community_attribute']
    attr_field_type_vals = {u'community_attribute': {'restrictions': [], 'description': [], 'simple_type': u'CommunityAttribute', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': True, 'required': None, 'attr_type': u'string'}}
    def __init__(self, community_attribute=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _community_attribute = params_dict[u"community_attribute"]
        except KeyError:
            _community_attribute = community_attribute
        if not _community_attribute:
            self.community_attribute = []
        else:
            self.community_attribute = _community_attribute
    def factory(*args_, **kwargs_):
        if CommunityAttributes.subclass:
            return CommunityAttributes.subclass(*args_, **kwargs_)
        else:
            return CommunityAttributes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_community_attribute(self): return self.community_attribute
    def set_community_attribute(self, community_attribute): self.community_attribute = community_attribute
    def add_community_attribute(self, value): self.community_attribute.append(value)
    def insert_community_attribute(self, index, value): self.community_attribute[index] = value
    def delete_community_attribute(self, value): self.community_attribute.remove(value)
    def validate_CommunityAttribute(self, value):
        # Validate type CommunityAttribute, a restriction on xsd:string.
        pass
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.community_attribute == other.community_attribute)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.community_attribute or [])))

    def __repr__(self):
        return ("community_attribute = " + str(self.community_attribute))

    def copy(self):
        cp = CommunityAttributes()
        if self.community_attribute is not None:
            cp.community_attribute = list(self.community_attribute)
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_community_attribute ([obj.populate_string ("community_attribute")])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='CommunityAttributes', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommunityAttributes')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommunityAttributes'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CommunityAttributes', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for community_attribute_ in self.community_attribute:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scommunity-attribute>%s</%scommunity-attribute>%s' % (namespace_, self.gds_format_string(quote_xml(community_attribute_).encode(ExternalEncoding), input_name='community-attribute'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.community_attribute
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CommunityAttributes'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('community_attribute=[\n')
        level += 1
        for community_attribute_ in self.community_attribute:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(community_attribute_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='CommunityAttributes'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'community-attribute':
            community_attribute_ = child_.text
            community_attribute_ = self.gds_validate_string(community_attribute_, node, 'community_attribute')
            self.community_attribute.append(community_attribute_)
            self.validate_CommunityAttribute(self.community_attribute)    # validate type CommunityAttribute
# end class CommunityAttributes


class RouteType(GeneratedsSuper):
    """
    Attributes:
    * prefix
        Type:           str

        Description:
          Ip prefix/len format prefix

    * next_hop
        Type:           str

        Description:
          Ip address or service instance name.

    * next_hop_type
        Type:           str, *one-of* [u'service-instance', u'ip-address']

    * community_attributes
        Type:           :class:`.CommunityAttributes`

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'prefix', u'next_hop', u'next_hop_type', u'community_attributes']
    attr_field_type_vals = {u'prefix': {'restrictions': None, 'description': [u'Ip prefix/len format prefix'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'next_hop': {'restrictions': None, 'description': [u'Ip address or service instance name.'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'community_attributes': {'restrictions': None, 'description': [], 'simple_type': u'CommunityAttributes', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'CommunityAttributes'}, u'next_hop_type': {'restrictions': [u'service-instance', u'ip-address'], 'description': [], 'simple_type': u'RouteNextHopType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': None, 'attr_type': u'string'}}
    def __init__(self, prefix=None, next_hop=None, next_hop_type=None, community_attributes=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _prefix = params_dict[u"prefix"]
        except KeyError:
            _prefix = prefix
        self.prefix = _prefix
        try:
            _next_hop = params_dict[u"next_hop"]
        except KeyError:
            _next_hop = next_hop
        self.next_hop = _next_hop
        try:
            _next_hop_type = params_dict[u"next_hop_type"]
        except KeyError:
            _next_hop_type = next_hop_type
        self.next_hop_type = _next_hop_type
        try:
            _community_attributes = params_dict[u"community_attributes"]
        except KeyError:
            _community_attributes = community_attributes
        if isinstance(_community_attributes, dict):
            obj = CommunityAttributes(params_dict=_community_attributes)
            self.community_attributes = obj
        else:
            self.community_attributes = _community_attributes
    def factory(*args_, **kwargs_):
        if RouteType.subclass:
            return RouteType.subclass(*args_, **kwargs_)
        else:
            return RouteType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_prefix(self): return self.prefix
    def set_prefix(self, prefix): self.prefix = prefix
    def get_next_hop(self): return self.next_hop
    def set_next_hop(self, next_hop): self.next_hop = next_hop
    def get_next_hop_type(self): return self.next_hop_type
    def set_next_hop_type(self, next_hop_type): self.next_hop_type = next_hop_type
    def validate_RouteNextHopType(self, value):
        # Validate type RouteNextHopType, a restriction on xsd:string.
        error = False
        if isinstance(value, list):
            error = set(value) - set([u'service-instance', u'ip-address'])
        else:
            error = value not in [u'service-instance', u'ip-address']
        if error:
            raise ValueError("RouteNextHopType must be one of [u'service-instance', u'ip-address']")
    def get_community_attributes(self): return self.community_attributes
    def set_community_attributes(self, community_attributes): self.community_attributes = community_attributes
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.prefix == other.prefix and
                    self.next_hop == other.next_hop and
                    self.next_hop_type == other.next_hop_type and
                    self.community_attributes == other.community_attributes)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.prefix if self.prefix is not None else -7985492147856592190,
                     self.next_hop if self.next_hop is not None else -7985492147856592190,
                     self.next_hop_type if self.next_hop_type is not None else -7985492147856592190,
                     self.community_attributes if self.community_attributes is not None else -7985492147856592190))

    def __repr__(self):
        return ("prefix = " + str(self.prefix) + ", " +
                "next_hop = " + str(self.next_hop) + ", " +
                "next_hop_type = " + str(self.next_hop_type) + ", " +
                "community_attributes = " + str(self.community_attributes))

    def copy(self):
        cp = RouteType()
        if self.prefix is not None:
            cp.prefix = self.prefix
        if self.next_hop is not None:
            cp.next_hop = self.next_hop
        if self.next_hop_type is not None:
            cp.next_hop_type = self.next_hop_type
        if self.community_attributes is not None:
            cp.community_attributes = self.community_attributes.copy()
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_prefix (obj.populate_string ("prefix"))
        obj.set_next_hop (obj.populate_string ("next_hop"))
        obj.set_next_hop_type (obj.populate_string ("next_hop_type"))
        obj.set_community_attributes (CommunityAttributes.populate ())
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='RouteType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RouteType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RouteType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RouteType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.prefix is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprefix>%s</%sprefix>%s' % (namespace_, self.gds_format_string(quote_xml(self.prefix).encode(ExternalEncoding), input_name='prefix'), namespace_, eol_))
        if self.next_hop is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snext-hop>%s</%snext-hop>%s' % (namespace_, self.gds_format_string(quote_xml(self.next_hop).encode(ExternalEncoding), input_name='next-hop'), namespace_, eol_))
        if self.next_hop_type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snext-hop-type>%s</%snext-hop-type>%s' % (namespace_, self.gds_format_string(quote_xml(self.next_hop_type).encode(ExternalEncoding), input_name='next-hop-type'), namespace_, eol_))
        if self.community_attributes is not None:
            self.community_attributes.export_xml(outfile, level, namespace_, name_='community-attributes', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.prefix is not None or
            self.next_hop is not None or
            self.next_hop_type is not None or
            self.community_attributes is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RouteType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.prefix is not None:
            showIndent(outfile, level)
            outfile.write('prefix=%s,\n' % quote_python(self.prefix).encode(ExternalEncoding))
        if self.next_hop is not None:
            showIndent(outfile, level)
            outfile.write('next_hop=%s,\n' % quote_python(self.next_hop).encode(ExternalEncoding))
        if self.next_hop_type is not None:
            showIndent(outfile, level)
            outfile.write('next_hop_type=%s,\n' % quote_python(self.next_hop_type).encode(ExternalEncoding))
        if self.community_attributes is not None:
            showIndent(outfile, level)
            outfile.write('community_attributes=model_.CommunityAttributes(\n')
            self.community_attributes.exportLiteral(outfile, level, name_='community_attributes')
            showIndent(outfile, level)
            outfile.write('),\n')
    def exportDict(self, name_='RouteType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'prefix':
            prefix_ = child_.text
            prefix_ = self.gds_validate_string(prefix_, node, 'prefix')
            self.prefix = prefix_
        elif nodeName_ == 'next-hop':
            next_hop_ = child_.text
            next_hop_ = self.gds_validate_string(next_hop_, node, 'next_hop')
            self.next_hop = next_hop_
        elif nodeName_ == 'next-hop-type':
            next_hop_type_ = child_.text
            next_hop_type_ = self.gds_validate_string(next_hop_type_, node, 'next_hop_type')
            self.next_hop_type = next_hop_type_
            self.validate_RouteNextHopType(self.next_hop_type)    # validate type RouteNextHopType
        elif nodeName_ == 'community-attributes':
            obj_ = CommunityAttributes.factory()
            obj_.build(child_)
            self.set_community_attributes(obj_)
# end class RouteType


class RouteTableType(GeneratedsSuper):
    """
    Attributes:
    * route
        Type:           :class:`.RouteType`

        Description:
          List of ip routes with following fields.

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'route']
    attr_field_type_vals = {u'route': {'restrictions': None, 'description': [u'List of ip routes with following fields.'], 'simple_type': u'RouteType', 'is_complex': 1, 'restriction_type': None, 'is_array': True, 'required': None, 'attr_type': u'RouteType'}}
    def __init__(self, route=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _route = params_dict[u"route"]
        except KeyError:
            _route = route
        if not _route:
            self.route = []
        else:
            if isinstance(_route[0], dict):
                objs = [RouteType(params_dict=elem) for elem in _route]
                self.route = objs
            else:
                self.route = _route
    def factory(*args_, **kwargs_):
        if RouteTableType.subclass:
            return RouteTableType.subclass(*args_, **kwargs_)
        else:
            return RouteTableType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_route(self): return self.route
    def set_route(self, route): self.route = route
    def add_route(self, value): self.route.append(value)
    def insert_route(self, index, value): self.route[index] = value
    def delete_route(self, value): self.route.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.route == other.route)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.route or [])))

    def __repr__(self):
        return ("route = " + str(self.route))

    def copy(self):
        cp = RouteTableType()
        if self.route is not None:
            cp.route = [x.copy() for x in self.route]
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_route ([RouteType.populate ()])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='RouteTableType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RouteTableType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RouteTableType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RouteTableType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for route_ in self.route:
            if isinstance(route_, dict):
                route_ = RouteType(**route_)
            route_.export_xml(outfile, level, namespace_, name_='route', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.route
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RouteTableType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('route=[\n')
        level += 1
        for route_ in self.route:
            showIndent(outfile, level)
            outfile.write('model_.RouteType(\n')
            route_.exportLiteral(outfile, level, name_='RouteType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='RouteTableType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'route':
            obj_ = RouteType.factory()
            obj_.build(child_)
            self.route.append(obj_)
# end class RouteTableType


class ServiceHealthCheckType(GeneratedsSuper):
    """
    Attributes:
    * enabled
        Type:           bool

        Created By:           User (optional)

        Description:
          Administratively enable or disable this health check.

    * health_check_type
        Type:           str, *one-of* [u'link-local', u'end-to-end', u'segment']

        Created By:           User (required)

        Description:
          Health check type, currently only link-local, end-to-end and segment are

          supported

    * monitor_type
        Type:           str, *one-of* [u'PING', u'HTTP', u'BFD']

        Created By:           User (required)

        Description:
          Protocol used to monitor health, currently only HTTP, ICMP(ping), and BFD are

          supported

    * delay
        Type:           int

        Created By:           User (required)

        Description:
          Time in seconds at which health check is repeated

    * delayUsecs
        Type:           int

        Created By:           User (optional)

        Description:
          Time in micro seconds at which health check is repeated

    * timeout
        Type:           int

        Created By:           User (required)

        Description:
          Time in seconds to wait for response

    * timeoutUsecs
        Type:           int

        Created By:           User (optional)

        Description:
          Time in micro seconds to wait for response

    * max_retries
        Type:           int

        Created By:           User (required)

        Description:
          Number of failures before declaring health bad

    * http_method
        Type:           str

        Created By:           User (optional)

        Description:
          In case monitor protocol is HTTP, type of http method used like GET, PUT, POST

          etc

    * url_path
        Type:           str

        Created By:           User (optional)

        Description:
          In case monitor protocol is HTTP, URL to be used. In case of ICMP, ip address

    * expected_codes
        Type:           str

        Created By:           User (optional)

        Description:
          In case monitor protocol is HTTP, expected return code for HTTP operations like

          200 ok.

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'enabled', u'health_check_type', u'monitor_type', u'delay', u'delayUsecs', u'timeout', u'timeoutUsecs', u'max_retries', u'http_method', u'url_path', u'expected_codes']
    attr_field_type_vals = {u'delayUsecs': {'restrictions': None, 'description': [u'Time in micro seconds at which health check is repeated'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'timeoutUsecs': {'restrictions': None, 'description': [u'Time in micro seconds to wait for response'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'enabled': {'restrictions': None, 'description': [u'Administratively enable or disable this health check.'], 'simple_type': u'xsd:boolean', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'boolean'}, u'delay': {'restrictions': None, 'description': [u'Time in seconds at which health check is repeated'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'true', 'attr_type': u'integer'}, u'expected_codes': {'restrictions': None, 'description': [u'In case monitor protocol is HTTP, expected return code for HTTP operations like 200 ok.'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'max_retries': {'restrictions': None, 'description': [u'Number of failures before declaring health bad'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'true', 'attr_type': u'integer'}, u'health_check_type': {'restrictions': [u'link-local', u'end-to-end', u'segment'], 'description': [u'Health check type, currently only link-local, end-to-end and segment are supported'], 'simple_type': u'HealthCheckType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'true', 'attr_type': u'string'}, u'http_method': {'restrictions': None, 'description': [u'In case monitor protocol is HTTP, type of http method used like GET, PUT, POST etc'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'timeout': {'restrictions': None, 'description': [u'Time in seconds to wait for response'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'true', 'attr_type': u'integer'}, u'url_path': {'restrictions': None, 'description': [u'In case monitor protocol is HTTP, URL to be used. In case of ICMP, ip address'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'monitor_type': {'restrictions': [u'PING', u'HTTP', u'BFD'], 'description': [u'Protocol used to monitor health, currently only HTTP, ICMP(ping), and BFD are supported'], 'simple_type': u'HealthCheckProtocolType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'true', 'attr_type': u'string'}}
    def __init__(self, enabled=False, health_check_type=None, monitor_type=None, delay=None, delayUsecs=0, timeout=None, timeoutUsecs=0, max_retries=None, http_method=None, url_path=None, expected_codes=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _enabled = params_dict[u"enabled"]
        except KeyError:
            _enabled = enabled
        self.enabled = _enabled
        try:
            _health_check_type = params_dict[u"health_check_type"]
        except KeyError:
            _health_check_type = health_check_type
        self.health_check_type = _health_check_type
        try:
            _monitor_type = params_dict[u"monitor_type"]
        except KeyError:
            _monitor_type = monitor_type
        self.monitor_type = _monitor_type
        try:
            _delay = params_dict[u"delay"]
        except KeyError:
            _delay = delay
        self.delay = _delay
        try:
            _delayUsecs = params_dict[u"delayUsecs"]
        except KeyError:
            _delayUsecs = delayUsecs
        self.delayUsecs = _delayUsecs
        try:
            _timeout = params_dict[u"timeout"]
        except KeyError:
            _timeout = timeout
        self.timeout = _timeout
        try:
            _timeoutUsecs = params_dict[u"timeoutUsecs"]
        except KeyError:
            _timeoutUsecs = timeoutUsecs
        self.timeoutUsecs = _timeoutUsecs
        try:
            _max_retries = params_dict[u"max_retries"]
        except KeyError:
            _max_retries = max_retries
        self.max_retries = _max_retries
        try:
            _http_method = params_dict[u"http_method"]
        except KeyError:
            _http_method = http_method
        self.http_method = _http_method
        try:
            _url_path = params_dict[u"url_path"]
        except KeyError:
            _url_path = url_path
        self.url_path = _url_path
        try:
            _expected_codes = params_dict[u"expected_codes"]
        except KeyError:
            _expected_codes = expected_codes
        self.expected_codes = _expected_codes
    def factory(*args_, **kwargs_):
        if ServiceHealthCheckType.subclass:
            return ServiceHealthCheckType.subclass(*args_, **kwargs_)
        else:
            return ServiceHealthCheckType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_enabled(self): return self.enabled
    def set_enabled(self, enabled): self.enabled = enabled
    def get_health_check_type(self): return self.health_check_type
    def set_health_check_type(self, health_check_type): self.health_check_type = health_check_type
    def validate_HealthCheckType(self, value):
        # Validate type HealthCheckType, a restriction on xsd:string.
        error = False
        if isinstance(value, list):
            error = set(value) - set([u'link-local', u'end-to-end', u'segment'])
        else:
            error = value not in [u'link-local', u'end-to-end', u'segment']
        if error:
            raise ValueError("HealthCheckType must be one of [u'link-local', u'end-to-end', u'segment']")
    def get_monitor_type(self): return self.monitor_type
    def set_monitor_type(self, monitor_type): self.monitor_type = monitor_type
    def validate_HealthCheckProtocolType(self, value):
        # Validate type HealthCheckProtocolType, a restriction on xsd:string.
        error = False
        if isinstance(value, list):
            error = set(value) - set([u'PING', u'HTTP', u'BFD'])
        else:
            error = value not in [u'PING', u'HTTP', u'BFD']
        if error:
            raise ValueError("HealthCheckProtocolType must be one of [u'PING', u'HTTP', u'BFD']")
    def get_delay(self): return self.delay
    def set_delay(self, delay): self.delay = delay
    def get_delayUsecs(self): return self.delayUsecs
    def set_delayUsecs(self, delayUsecs): self.delayUsecs = delayUsecs
    def get_timeout(self): return self.timeout
    def set_timeout(self, timeout): self.timeout = timeout
    def get_timeoutUsecs(self): return self.timeoutUsecs
    def set_timeoutUsecs(self, timeoutUsecs): self.timeoutUsecs = timeoutUsecs
    def get_max_retries(self): return self.max_retries
    def set_max_retries(self, max_retries): self.max_retries = max_retries
    def get_http_method(self): return self.http_method
    def set_http_method(self, http_method): self.http_method = http_method
    def get_url_path(self): return self.url_path
    def set_url_path(self, url_path): self.url_path = url_path
    def get_expected_codes(self): return self.expected_codes
    def set_expected_codes(self, expected_codes): self.expected_codes = expected_codes
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.enabled == other.enabled and
                    self.health_check_type == other.health_check_type and
                    self.monitor_type == other.monitor_type and
                    self.delay == other.delay and
                    self.delayUsecs == other.delayUsecs and
                    self.timeout == other.timeout and
                    self.timeoutUsecs == other.timeoutUsecs and
                    self.max_retries == other.max_retries and
                    self.http_method == other.http_method and
                    self.url_path == other.url_path and
                    self.expected_codes == other.expected_codes)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.enabled if self.enabled is not None else -7985492147856592190,
                     self.health_check_type if self.health_check_type is not None else -7985492147856592190,
                     self.monitor_type if self.monitor_type is not None else -7985492147856592190,
                     self.delay if self.delay is not None else -7985492147856592190,
                     self.delayUsecs if self.delayUsecs is not None else -7985492147856592190,
                     self.timeout if self.timeout is not None else -7985492147856592190,
                     self.timeoutUsecs if self.timeoutUsecs is not None else -7985492147856592190,
                     self.max_retries if self.max_retries is not None else -7985492147856592190,
                     self.http_method if self.http_method is not None else -7985492147856592190,
                     self.url_path if self.url_path is not None else -7985492147856592190,
                     self.expected_codes if self.expected_codes is not None else -7985492147856592190))

    def __repr__(self):
        return ("enabled = " + str(self.enabled) + ", " +
                "health_check_type = " + str(self.health_check_type) + ", " +
                "monitor_type = " + str(self.monitor_type) + ", " +
                "delay = " + str(self.delay) + ", " +
                "delayUsecs = " + str(self.delayUsecs) + ", " +
                "timeout = " + str(self.timeout) + ", " +
                "timeoutUsecs = " + str(self.timeoutUsecs) + ", " +
                "max_retries = " + str(self.max_retries) + ", " +
                "http_method = " + str(self.http_method) + ", " +
                "url_path = " + str(self.url_path) + ", " +
                "expected_codes = " + str(self.expected_codes))

    def copy(self):
        cp = ServiceHealthCheckType()
        if self.enabled is not None:
            cp.enabled = self.enabled
        if self.health_check_type is not None:
            cp.health_check_type = self.health_check_type
        if self.monitor_type is not None:
            cp.monitor_type = self.monitor_type
        if self.delay is not None:
            cp.delay = self.delay
        if self.delayUsecs is not None:
            cp.delayUsecs = self.delayUsecs
        if self.timeout is not None:
            cp.timeout = self.timeout
        if self.timeoutUsecs is not None:
            cp.timeoutUsecs = self.timeoutUsecs
        if self.max_retries is not None:
            cp.max_retries = self.max_retries
        if self.http_method is not None:
            cp.http_method = self.http_method
        if self.url_path is not None:
            cp.url_path = self.url_path
        if self.expected_codes is not None:
            cp.expected_codes = self.expected_codes
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_enabled (obj.populate_boolean ("enabled"))
        obj.set_health_check_type (obj.populate_string ("health_check_type"))
        obj.set_monitor_type (obj.populate_string ("monitor_type"))
        obj.set_delay (obj.populate_integer ("delay"))
        obj.set_delayUsecs (obj.populate_integer ("delayUsecs"))
        obj.set_timeout (obj.populate_integer ("timeout"))
        obj.set_timeoutUsecs (obj.populate_integer ("timeoutUsecs"))
        obj.set_max_retries (obj.populate_integer ("max_retries"))
        obj.set_http_method (obj.populate_string ("http_method"))
        obj.set_url_path (obj.populate_string ("url_path"))
        obj.set_expected_codes (obj.populate_string ("expected_codes"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='ServiceHealthCheckType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ServiceHealthCheckType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ServiceHealthCheckType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ServiceHealthCheckType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.enabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%senabled>%s</%senabled>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.enabled)), input_name='enabled'), namespace_, eol_))
        if self.health_check_type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shealth-check-type>%s</%shealth-check-type>%s' % (namespace_, self.gds_format_string(quote_xml(self.health_check_type).encode(ExternalEncoding), input_name='health-check-type'), namespace_, eol_))
        if self.monitor_type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smonitor-type>%s</%smonitor-type>%s' % (namespace_, self.gds_format_string(quote_xml(self.monitor_type).encode(ExternalEncoding), input_name='monitor-type'), namespace_, eol_))
        if self.delay is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdelay>%s</%sdelay>%s' % (namespace_, self.gds_format_integer(self.delay, input_name='delay'), namespace_, eol_))
        if self.delayUsecs is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdelayUsecs>%s</%sdelayUsecs>%s' % (namespace_, self.gds_format_integer(self.delayUsecs, input_name='delayUsecs'), namespace_, eol_))
        if self.timeout is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stimeout>%s</%stimeout>%s' % (namespace_, self.gds_format_integer(self.timeout, input_name='timeout'), namespace_, eol_))
        if self.timeoutUsecs is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stimeoutUsecs>%s</%stimeoutUsecs>%s' % (namespace_, self.gds_format_integer(self.timeoutUsecs, input_name='timeoutUsecs'), namespace_, eol_))
        if self.max_retries is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smax-retries>%s</%smax-retries>%s' % (namespace_, self.gds_format_integer(self.max_retries, input_name='max-retries'), namespace_, eol_))
        if self.http_method is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shttp-method>%s</%shttp-method>%s' % (namespace_, self.gds_format_string(quote_xml(self.http_method).encode(ExternalEncoding), input_name='http-method'), namespace_, eol_))
        if self.url_path is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%surl-path>%s</%surl-path>%s' % (namespace_, self.gds_format_string(quote_xml(self.url_path).encode(ExternalEncoding), input_name='url-path'), namespace_, eol_))
        if self.expected_codes is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexpected-codes>%s</%sexpected-codes>%s' % (namespace_, self.gds_format_string(quote_xml(self.expected_codes).encode(ExternalEncoding), input_name='expected-codes'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.enabled is not None or
            self.health_check_type is not None or
            self.monitor_type is not None or
            self.delay is not None or
            self.delayUsecs is not None or
            self.timeout is not None or
            self.timeoutUsecs is not None or
            self.max_retries is not None or
            self.http_method is not None or
            self.url_path is not None or
            self.expected_codes is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ServiceHealthCheckType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.enabled is not None:
            showIndent(outfile, level)
            outfile.write('enabled=%s,\n' % self.enabled)
        if self.health_check_type is not None:
            showIndent(outfile, level)
            outfile.write('health_check_type=%s,\n' % quote_python(self.health_check_type).encode(ExternalEncoding))
        if self.monitor_type is not None:
            showIndent(outfile, level)
            outfile.write('monitor_type=%s,\n' % quote_python(self.monitor_type).encode(ExternalEncoding))
        if self.delay is not None:
            showIndent(outfile, level)
            outfile.write('delay=%d,\n' % self.delay)
        if self.delayUsecs is not None:
            showIndent(outfile, level)
            outfile.write('delayUsecs=%d,\n' % self.delayUsecs)
        if self.timeout is not None:
            showIndent(outfile, level)
            outfile.write('timeout=%d,\n' % self.timeout)
        if self.timeoutUsecs is not None:
            showIndent(outfile, level)
            outfile.write('timeoutUsecs=%d,\n' % self.timeoutUsecs)
        if self.max_retries is not None:
            showIndent(outfile, level)
            outfile.write('max_retries=%d,\n' % self.max_retries)
        if self.http_method is not None:
            showIndent(outfile, level)
            outfile.write('http_method=%s,\n' % quote_python(self.http_method).encode(ExternalEncoding))
        if self.url_path is not None:
            showIndent(outfile, level)
            outfile.write('url_path=%s,\n' % quote_python(self.url_path).encode(ExternalEncoding))
        if self.expected_codes is not None:
            showIndent(outfile, level)
            outfile.write('expected_codes=%s,\n' % quote_python(self.expected_codes).encode(ExternalEncoding))
    def exportDict(self, name_='ServiceHealthCheckType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'enabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'enabled')
            self.enabled = ival_
        elif nodeName_ == 'health-check-type':
            health_check_type_ = child_.text
            health_check_type_ = self.gds_validate_string(health_check_type_, node, 'health_check_type')
            self.health_check_type = health_check_type_
            self.validate_HealthCheckType(self.health_check_type)    # validate type HealthCheckType
        elif nodeName_ == 'monitor-type':
            monitor_type_ = child_.text
            monitor_type_ = self.gds_validate_string(monitor_type_, node, 'monitor_type')
            self.monitor_type = monitor_type_
            self.validate_HealthCheckProtocolType(self.monitor_type)    # validate type HealthCheckProtocolType
        elif nodeName_ == 'delay':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'delay')
            self.delay = ival_
        elif nodeName_ == 'delayUsecs':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'delayUsecs')
            self.delayUsecs = ival_
        elif nodeName_ == 'timeout':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'timeout')
            self.timeout = ival_
        elif nodeName_ == 'timeoutUsecs':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'timeoutUsecs')
            self.timeoutUsecs = ival_
        elif nodeName_ == 'max-retries':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'max_retries')
            self.max_retries = ival_
        elif nodeName_ == 'http-method':
            http_method_ = child_.text
            http_method_ = self.gds_validate_string(http_method_, node, 'http_method')
            self.http_method = http_method_
        elif nodeName_ == 'url-path':
            url_path_ = child_.text
            url_path_ = self.gds_validate_string(url_path_, node, 'url_path')
            self.url_path = url_path_
        elif nodeName_ == 'expected-codes':
            expected_codes_ = child_.text
            expected_codes_ = self.gds_validate_string(expected_codes_, node, 'expected_codes')
            self.expected_codes = expected_codes_
# end class ServiceHealthCheckType


class LogicalRouterVirtualNetworkType(GeneratedsSuper):
    """
    Attributes:
    * logical_router_virtual_network_type
        Type:           str, *one-of* [u'ExternalGateway', u'InternalVirtualNetwork']

        Created By:           User (optional)

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'logical_router_virtual_network_type']
    attr_field_type_vals = {u'logical_router_virtual_network_type': {'restrictions': [u'ExternalGateway', u'InternalVirtualNetwork'], 'description': [], 'simple_type': u'LogicalRouterVirtualNetworkEnumType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'optional', 'attr_type': u'string'}}
    def __init__(self, logical_router_virtual_network_type='ExternalGateway', params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _logical_router_virtual_network_type = params_dict[u"logical_router_virtual_network_type"]
        except KeyError:
            _logical_router_virtual_network_type = logical_router_virtual_network_type
        self.logical_router_virtual_network_type = _logical_router_virtual_network_type
    def factory(*args_, **kwargs_):
        if LogicalRouterVirtualNetworkType.subclass:
            return LogicalRouterVirtualNetworkType.subclass(*args_, **kwargs_)
        else:
            return LogicalRouterVirtualNetworkType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_logical_router_virtual_network_type(self): return self.logical_router_virtual_network_type
    def set_logical_router_virtual_network_type(self, logical_router_virtual_network_type): self.logical_router_virtual_network_type = logical_router_virtual_network_type
    def validate_LogicalRouterVirtualNetworkEnumType(self, value):
        # Validate type LogicalRouterVirtualNetworkEnumType, a restriction on xsd:string.
        error = False
        if isinstance(value, list):
            error = set(value) - set([u'ExternalGateway', u'InternalVirtualNetwork'])
        else:
            error = value not in [u'ExternalGateway', u'InternalVirtualNetwork']
        if error:
            raise ValueError("LogicalRouterVirtualNetworkEnumType must be one of [u'ExternalGateway', u'InternalVirtualNetwork']")
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.logical_router_virtual_network_type == other.logical_router_virtual_network_type)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.logical_router_virtual_network_type if self.logical_router_virtual_network_type is not None else -7985492147856592190))

    def __repr__(self):
        return ("logical_router_virtual_network_type = " + str(self.logical_router_virtual_network_type))

    def copy(self):
        cp = LogicalRouterVirtualNetworkType()
        if self.logical_router_virtual_network_type is not None:
            cp.logical_router_virtual_network_type = self.logical_router_virtual_network_type
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_logical_router_virtual_network_type (obj.populate_string ("logical_router_virtual_network_type"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='LogicalRouterVirtualNetworkType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LogicalRouterVirtualNetworkType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LogicalRouterVirtualNetworkType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LogicalRouterVirtualNetworkType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.logical_router_virtual_network_type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slogical-router-virtual-network-type>%s</%slogical-router-virtual-network-type>%s' % (namespace_, self.gds_format_string(quote_xml(self.logical_router_virtual_network_type).encode(ExternalEncoding), input_name='logical-router-virtual-network-type'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.logical_router_virtual_network_type is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LogicalRouterVirtualNetworkType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.logical_router_virtual_network_type is not None:
            showIndent(outfile, level)
            outfile.write('logical_router_virtual_network_type=%s,\n' % quote_python(self.logical_router_virtual_network_type).encode(ExternalEncoding))
    def exportDict(self, name_='LogicalRouterVirtualNetworkType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'logical-router-virtual-network-type':
            logical_router_virtual_network_type_ = child_.text
            logical_router_virtual_network_type_ = self.gds_validate_string(logical_router_virtual_network_type_, node, 'logical_router_virtual_network_type')
            self.logical_router_virtual_network_type = logical_router_virtual_network_type_
            self.validate_LogicalRouterVirtualNetworkEnumType(self.logical_router_virtual_network_type)    # validate type LogicalRouterVirtualNetworkEnumType
# end class LogicalRouterVirtualNetworkType


class KeyValuePair(GeneratedsSuper):
    """
    Attributes:
    * key
        Type:           str

    * value
        Type:           str

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'key', u'value']
    attr_field_type_vals = {u'value': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'key': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}}
    def __init__(self, key=None, value=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _key = params_dict[u"key"]
        except KeyError:
            _key = key
        self.key = _key
        try:
            _value = params_dict[u"value"]
        except KeyError:
            _value = value
        self.value = _value
    def factory(*args_, **kwargs_):
        if KeyValuePair.subclass:
            return KeyValuePair.subclass(*args_, **kwargs_)
        else:
            return KeyValuePair(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_key(self): return self.key
    def set_key(self, key): self.key = key
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.key == other.key and
                    self.value == other.value)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.key if self.key is not None else -7985492147856592190,
                     self.value if self.value is not None else -7985492147856592190))

    def __repr__(self):
        return ("key = " + str(self.key) + ", " +
                "value = " + str(self.value))

    def copy(self):
        cp = KeyValuePair()
        if self.key is not None:
            cp.key = self.key
        if self.value is not None:
            cp.value = self.value
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_key (obj.populate_string ("key"))
        obj.set_value (obj.populate_string ("value"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='KeyValuePair', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='KeyValuePair')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='KeyValuePair'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='KeyValuePair', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.key is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%skey>%s</%skey>%s' % (namespace_, self.gds_format_string(quote_xml(self.key).encode(ExternalEncoding), input_name='key'), namespace_, eol_))
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(self.value).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.key is not None or
            self.value is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='KeyValuePair'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.key is not None:
            showIndent(outfile, level)
            outfile.write('key=%s,\n' % quote_python(self.key).encode(ExternalEncoding))
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%s,\n' % quote_python(self.value).encode(ExternalEncoding))
    def exportDict(self, name_='KeyValuePair'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'key':
            key_ = child_.text
            key_ = self.gds_validate_string(key_, node, 'key')
            self.key = key_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
# end class KeyValuePair


class KeyValuePairs(GeneratedsSuper):
    """
    Attributes:
    * key_value_pair
        Type:           :class:`.KeyValuePair`

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'key_value_pair']
    attr_field_type_vals = {u'key_value_pair': {'restrictions': None, 'description': [], 'simple_type': u'KeyValuePair', 'is_complex': 1, 'restriction_type': None, 'is_array': True, 'required': None, 'attr_type': u'KeyValuePair'}}
    def __init__(self, key_value_pair=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _key_value_pair = params_dict[u"key_value_pair"]
        except KeyError:
            _key_value_pair = key_value_pair
        if not _key_value_pair:
            self.key_value_pair = []
        else:
            if isinstance(_key_value_pair[0], dict):
                objs = [KeyValuePair(params_dict=elem) for elem in _key_value_pair]
                self.key_value_pair = objs
            else:
                self.key_value_pair = _key_value_pair
    def factory(*args_, **kwargs_):
        if KeyValuePairs.subclass:
            return KeyValuePairs.subclass(*args_, **kwargs_)
        else:
            return KeyValuePairs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_key_value_pair(self): return self.key_value_pair
    def set_key_value_pair(self, key_value_pair): self.key_value_pair = key_value_pair
    def add_key_value_pair(self, value): self.key_value_pair.append(value)
    def insert_key_value_pair(self, index, value): self.key_value_pair[index] = value
    def delete_key_value_pair(self, value): self.key_value_pair.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.key_value_pair == other.key_value_pair)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.key_value_pair or [])))

    def __repr__(self):
        return ("key_value_pair = " + str(self.key_value_pair))

    def copy(self):
        cp = KeyValuePairs()
        if self.key_value_pair is not None:
            cp.key_value_pair = [x.copy() for x in self.key_value_pair]
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_key_value_pair ([KeyValuePair.populate ()])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='KeyValuePairs', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='KeyValuePairs')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='KeyValuePairs'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='KeyValuePairs', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for key_value_pair_ in self.key_value_pair:
            if isinstance(key_value_pair_, dict):
                key_value_pair_ = KeyValuePair(**key_value_pair_)
            key_value_pair_.export_xml(outfile, level, namespace_, name_='key-value-pair', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.key_value_pair
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='KeyValuePairs'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('key_value_pair=[\n')
        level += 1
        for key_value_pair_ in self.key_value_pair:
            showIndent(outfile, level)
            outfile.write('model_.KeyValuePair(\n')
            key_value_pair_.exportLiteral(outfile, level, name_='KeyValuePair')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='KeyValuePairs'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'key-value-pair':
            obj_ = KeyValuePair.factory()
            obj_.build(child_)
            self.key_value_pair.append(obj_)
# end class KeyValuePairs


class ServiceApplianceInterfaceType(GeneratedsSuper):
    """
    Attributes:
    * interface_type
        Type:           str, *one-of* xsd:string

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'interface_type']
    attr_field_type_vals = {u'interface_type': {'restrictions': [], 'description': [], 'simple_type': u'ServiceInterfaceType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': None, 'attr_type': u'string'}}
    def __init__(self, interface_type=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _interface_type = params_dict[u"interface_type"]
        except KeyError:
            _interface_type = interface_type
        self.interface_type = _interface_type
    def factory(*args_, **kwargs_):
        if ServiceApplianceInterfaceType.subclass:
            return ServiceApplianceInterfaceType.subclass(*args_, **kwargs_)
        else:
            return ServiceApplianceInterfaceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_interface_type(self): return self.interface_type
    def set_interface_type(self, interface_type): self.interface_type = interface_type
    def validate_ServiceInterfaceType(self, value):
        # Validate type ServiceInterfaceType, a restriction on xsd:string.
        pass
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.interface_type == other.interface_type)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.interface_type if self.interface_type is not None else -7985492147856592190))

    def __repr__(self):
        return ("interface_type = " + str(self.interface_type))

    def copy(self):
        cp = ServiceApplianceInterfaceType()
        if self.interface_type is not None:
            cp.interface_type = self.interface_type
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_interface_type (obj.populate_string ("interface_type"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='ServiceApplianceInterfaceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ServiceApplianceInterfaceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ServiceApplianceInterfaceType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ServiceApplianceInterfaceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.interface_type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinterface-type>%s</%sinterface-type>%s' % (namespace_, self.gds_format_string(quote_xml(self.interface_type).encode(ExternalEncoding), input_name='interface-type'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.interface_type is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ServiceApplianceInterfaceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.interface_type is not None:
            showIndent(outfile, level)
            outfile.write('interface_type=%s,\n' % quote_python(self.interface_type).encode(ExternalEncoding))
    def exportDict(self, name_='ServiceApplianceInterfaceType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'interface-type':
            interface_type_ = child_.text
            interface_type_ = self.gds_validate_string(interface_type_, node, 'interface_type')
            self.interface_type = interface_type_
            self.validate_ServiceInterfaceType(self.interface_type)    # validate type ServiceInterfaceType
# end class ServiceApplianceInterfaceType


class DiscoveryPubSubEndPointType(GeneratedsSuper):
    """
    Attributes:
    * ep_type
        Type:           str

        Created By:           User (required)

        Description:
          Type of service or client

    * ep_id
        Type:           str

        Created By:           User (optional)

        Description:
          Specific service or client which is set of one.

    * ep_prefix
        Type:           :class:`.SubnetType`

        Created By:           User (optional)

        Description:
          All  servers or clients whose ip match this prefix

    * ep_version
        Type:           str

        Created By:           User (optional)

        Description:
          All  servers or clients whose version match this version

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'ep_type', u'ep_id', u'ep_prefix', u'ep_version']
    attr_field_type_vals = {u'ep_version': {'restrictions': None, 'description': [u'All  servers or clients whose version match this version'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'ep_id': {'restrictions': None, 'description': [u'Specific service or client which is set of one.'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'ep_type': {'restrictions': None, 'description': [u'Type of service or client'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'true', 'attr_type': u'string'}, u'ep_prefix': {'restrictions': None, 'description': [u'All  servers or clients whose ip match this prefix'], 'simple_type': u'SubnetType', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'SubnetType'}}
    def __init__(self, ep_type=None, ep_id=None, ep_prefix=None, ep_version=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _ep_type = params_dict[u"ep_type"]
        except KeyError:
            _ep_type = ep_type
        self.ep_type = _ep_type
        try:
            _ep_id = params_dict[u"ep_id"]
        except KeyError:
            _ep_id = ep_id
        self.ep_id = _ep_id
        try:
            _ep_prefix = params_dict[u"ep_prefix"]
        except KeyError:
            _ep_prefix = ep_prefix
        if isinstance(_ep_prefix, dict):
            obj = SubnetType(params_dict=_ep_prefix)
            self.ep_prefix = obj
        else:
            self.ep_prefix = _ep_prefix
        try:
            _ep_version = params_dict[u"ep_version"]
        except KeyError:
            _ep_version = ep_version
        self.ep_version = _ep_version
    def factory(*args_, **kwargs_):
        if DiscoveryPubSubEndPointType.subclass:
            return DiscoveryPubSubEndPointType.subclass(*args_, **kwargs_)
        else:
            return DiscoveryPubSubEndPointType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ep_type(self): return self.ep_type
    def set_ep_type(self, ep_type): self.ep_type = ep_type
    def get_ep_id(self): return self.ep_id
    def set_ep_id(self, ep_id): self.ep_id = ep_id
    def get_ep_prefix(self): return self.ep_prefix
    def set_ep_prefix(self, ep_prefix): self.ep_prefix = ep_prefix
    def get_ep_version(self): return self.ep_version
    def set_ep_version(self, ep_version): self.ep_version = ep_version
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.ep_type == other.ep_type and
                    self.ep_id == other.ep_id and
                    self.ep_prefix == other.ep_prefix and
                    self.ep_version == other.ep_version)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.ep_type if self.ep_type is not None else -7985492147856592190,
                     self.ep_id if self.ep_id is not None else -7985492147856592190,
                     self.ep_prefix if self.ep_prefix is not None else -7985492147856592190,
                     self.ep_version if self.ep_version is not None else -7985492147856592190))

    def __repr__(self):
        return ("ep_type = " + str(self.ep_type) + ", " +
                "ep_id = " + str(self.ep_id) + ", " +
                "ep_prefix = " + str(self.ep_prefix) + ", " +
                "ep_version = " + str(self.ep_version))

    def copy(self):
        cp = DiscoveryPubSubEndPointType()
        if self.ep_type is not None:
            cp.ep_type = self.ep_type
        if self.ep_id is not None:
            cp.ep_id = self.ep_id
        if self.ep_prefix is not None:
            cp.ep_prefix = self.ep_prefix.copy()
        if self.ep_version is not None:
            cp.ep_version = self.ep_version
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_ep_type (obj.populate_string ("ep_type"))
        obj.set_ep_id (obj.populate_string ("ep_id"))
        obj.set_ep_prefix (SubnetType.populate ())
        obj.set_ep_version (obj.populate_string ("ep_version"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='DiscoveryPubSubEndPointType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DiscoveryPubSubEndPointType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DiscoveryPubSubEndPointType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DiscoveryPubSubEndPointType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ep_type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sep-type>%s</%sep-type>%s' % (namespace_, self.gds_format_string(quote_xml(self.ep_type).encode(ExternalEncoding), input_name='ep-type'), namespace_, eol_))
        if self.ep_id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sep-id>%s</%sep-id>%s' % (namespace_, self.gds_format_string(quote_xml(self.ep_id).encode(ExternalEncoding), input_name='ep-id'), namespace_, eol_))
        if self.ep_prefix is not None:
            self.ep_prefix.export_xml(outfile, level, namespace_, name_='ep-prefix', pretty_print=pretty_print)
        if self.ep_version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sep-version>%s</%sep-version>%s' % (namespace_, self.gds_format_string(quote_xml(self.ep_version).encode(ExternalEncoding), input_name='ep-version'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.ep_type is not None or
            self.ep_id is not None or
            self.ep_prefix is not None or
            self.ep_version is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DiscoveryPubSubEndPointType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ep_type is not None:
            showIndent(outfile, level)
            outfile.write('ep_type=%s,\n' % quote_python(self.ep_type).encode(ExternalEncoding))
        if self.ep_id is not None:
            showIndent(outfile, level)
            outfile.write('ep_id=%s,\n' % quote_python(self.ep_id).encode(ExternalEncoding))
        if self.ep_prefix is not None:
            showIndent(outfile, level)
            outfile.write('ep_prefix=model_.SubnetType(\n')
            self.ep_prefix.exportLiteral(outfile, level, name_='ep_prefix')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ep_version is not None:
            showIndent(outfile, level)
            outfile.write('ep_version=%s,\n' % quote_python(self.ep_version).encode(ExternalEncoding))
    def exportDict(self, name_='DiscoveryPubSubEndPointType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ep-type':
            ep_type_ = child_.text
            ep_type_ = self.gds_validate_string(ep_type_, node, 'ep_type')
            self.ep_type = ep_type_
        elif nodeName_ == 'ep-id':
            ep_id_ = child_.text
            ep_id_ = self.gds_validate_string(ep_id_, node, 'ep_id')
            self.ep_id = ep_id_
        elif nodeName_ == 'ep-prefix':
            obj_ = SubnetType.factory()
            obj_.build(child_)
            self.set_ep_prefix(obj_)
        elif nodeName_ == 'ep-version':
            ep_version_ = child_.text
            ep_version_ = self.gds_validate_string(ep_version_, node, 'ep_version')
            self.ep_version = ep_version_
# end class DiscoveryPubSubEndPointType


class DiscoveryServiceAssignmentType(GeneratedsSuper):
    """
    Attributes:
    * publisher
        Type:           :class:`.DiscoveryPubSubEndPointType`

        Created By:           User (required)

        Description:
          Publisher set

    * subscriber
        Type:           :class:`.DiscoveryPubSubEndPointType`

        Created By:           User (required)

        Description:
          subscriber set

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'publisher', u'subscriber']
    attr_field_type_vals = {u'subscriber': {'restrictions': None, 'description': [u'subscriber set'], 'simple_type': u'DiscoveryPubSubEndPointType', 'is_complex': 1, 'restriction_type': None, 'is_array': True, 'required': u'true', 'attr_type': u'DiscoveryPubSubEndPointType'}, u'publisher': {'restrictions': None, 'description': [u'Publisher set'], 'simple_type': u'DiscoveryPubSubEndPointType', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': u'true', 'attr_type': u'DiscoveryPubSubEndPointType'}}
    def __init__(self, publisher=None, subscriber=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _publisher = params_dict[u"publisher"]
        except KeyError:
            _publisher = publisher
        if isinstance(_publisher, dict):
            obj = DiscoveryPubSubEndPointType(params_dict=_publisher)
            self.publisher = obj
        else:
            self.publisher = _publisher
        try:
            _subscriber = params_dict[u"subscriber"]
        except KeyError:
            _subscriber = subscriber
        if not _subscriber:
            self.subscriber = []
        else:
            if isinstance(_subscriber[0], dict):
                objs = [DiscoveryPubSubEndPointType(params_dict=elem) for elem in _subscriber]
                self.subscriber = objs
            else:
                self.subscriber = _subscriber
    def factory(*args_, **kwargs_):
        if DiscoveryServiceAssignmentType.subclass:
            return DiscoveryServiceAssignmentType.subclass(*args_, **kwargs_)
        else:
            return DiscoveryServiceAssignmentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_publisher(self): return self.publisher
    def set_publisher(self, publisher): self.publisher = publisher
    def get_subscriber(self): return self.subscriber
    def set_subscriber(self, subscriber): self.subscriber = subscriber
    def add_subscriber(self, value): self.subscriber.append(value)
    def insert_subscriber(self, index, value): self.subscriber[index] = value
    def delete_subscriber(self, value): self.subscriber.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.publisher == other.publisher and
                    self.subscriber == other.subscriber)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.publisher if self.publisher is not None else -7985492147856592190,
                     tuple(self.subscriber or [])))

    def __repr__(self):
        return ("publisher = " + str(self.publisher) + ", " +
                "subscriber = " + str(self.subscriber))

    def copy(self):
        cp = DiscoveryServiceAssignmentType()
        if self.publisher is not None:
            cp.publisher = self.publisher.copy()
        if self.subscriber is not None:
            cp.subscriber = [x.copy() for x in self.subscriber]
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_publisher (DiscoveryPubSubEndPointType.populate ())
        obj.set_subscriber ([DiscoveryPubSubEndPointType.populate ()])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='DiscoveryServiceAssignmentType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DiscoveryServiceAssignmentType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DiscoveryServiceAssignmentType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DiscoveryServiceAssignmentType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.publisher is not None:
            self.publisher.export_xml(outfile, level, namespace_, name_='publisher', pretty_print=pretty_print)
        for subscriber_ in self.subscriber:
            if isinstance(subscriber_, dict):
                subscriber_ = DiscoveryPubSubEndPointType(**subscriber_)
            subscriber_.export_xml(outfile, level, namespace_, name_='subscriber', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.publisher is not None or
            self.subscriber
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DiscoveryServiceAssignmentType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.publisher is not None:
            showIndent(outfile, level)
            outfile.write('publisher=model_.DiscoveryPubSubEndPointType(\n')
            self.publisher.exportLiteral(outfile, level, name_='publisher')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('subscriber=[\n')
        level += 1
        for subscriber_ in self.subscriber:
            showIndent(outfile, level)
            outfile.write('model_.DiscoveryPubSubEndPointType(\n')
            subscriber_.exportLiteral(outfile, level, name_='DiscoveryPubSubEndPointType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='DiscoveryServiceAssignmentType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'publisher':
            obj_ = DiscoveryPubSubEndPointType.factory()
            obj_.build(child_)
            self.set_publisher(obj_)
        elif nodeName_ == 'subscriber':
            obj_ = DiscoveryPubSubEndPointType.factory()
            obj_.build(child_)
            self.subscriber.append(obj_)
# end class DiscoveryServiceAssignmentType


class MACLimitControlType(GeneratedsSuper):
    """
    Attributes:
    * mac_limit
        Type:           int

        Created By:           User (required)

        Description:
          Number of MACs that can be learnt

    * mac_limit_action
        Type:           str, *one-of* [u'log', u'alarm', u'shutdown', u'drop']

        Created By:           User (optional)

        Description:
          Action to be taken when MAC limit exceeds

    """
    """This property defines the MAC limit and MAC limit exceed actions"""
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'mac_limit', u'mac_limit_action']
    attr_field_type_vals = {u'mac_limit': {'restrictions': None, 'description': [u'Number of MACs that can be learnt'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'true', 'attr_type': u'integer'}, u'mac_limit_action': {'restrictions': [u'log', u'alarm', u'shutdown', u'drop'], 'description': [u'Action to be taken when MAC limit exceeds'], 'simple_type': u'MACLimitExceedActionType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'optional', 'attr_type': u'string'}}
    def __init__(self, mac_limit=None, mac_limit_action='log', params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _mac_limit = params_dict[u"mac_limit"]
        except KeyError:
            _mac_limit = mac_limit
        self.mac_limit = _mac_limit
        try:
            _mac_limit_action = params_dict[u"mac_limit_action"]
        except KeyError:
            _mac_limit_action = mac_limit_action
        self.mac_limit_action = _mac_limit_action
    def factory(*args_, **kwargs_):
        if MACLimitControlType.subclass:
            return MACLimitControlType.subclass(*args_, **kwargs_)
        else:
            return MACLimitControlType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_mac_limit(self): return self.mac_limit
    def set_mac_limit(self, mac_limit): self.mac_limit = mac_limit
    def get_mac_limit_action(self): return self.mac_limit_action
    def set_mac_limit_action(self, mac_limit_action): self.mac_limit_action = mac_limit_action
    def validate_MACLimitExceedActionType(self, value):
        # Validate type MACLimitExceedActionType, a restriction on xsd:string.
        error = False
        if isinstance(value, list):
            error = set(value) - set([u'log', u'alarm', u'shutdown', u'drop'])
        else:
            error = value not in [u'log', u'alarm', u'shutdown', u'drop']
        if error:
            raise ValueError("MACLimitExceedActionType must be one of [u'log', u'alarm', u'shutdown', u'drop']")
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.mac_limit == other.mac_limit and
                    self.mac_limit_action == other.mac_limit_action)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.mac_limit if self.mac_limit is not None else -7985492147856592190,
                     self.mac_limit_action if self.mac_limit_action is not None else -7985492147856592190))

    def __repr__(self):
        return ("mac_limit = " + str(self.mac_limit) + ", " +
                "mac_limit_action = " + str(self.mac_limit_action))

    def copy(self):
        cp = MACLimitControlType()
        if self.mac_limit is not None:
            cp.mac_limit = self.mac_limit
        if self.mac_limit_action is not None:
            cp.mac_limit_action = self.mac_limit_action
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_mac_limit (obj.populate_integer ("mac_limit"))
        obj.set_mac_limit_action (obj.populate_string ("mac_limit_action"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='MACLimitControlType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MACLimitControlType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MACLimitControlType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='MACLimitControlType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.mac_limit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smac-limit>%s</%smac-limit>%s' % (namespace_, self.gds_format_integer(self.mac_limit, input_name='mac-limit'), namespace_, eol_))
        if self.mac_limit_action is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smac-limit-action>%s</%smac-limit-action>%s' % (namespace_, self.gds_format_string(quote_xml(self.mac_limit_action).encode(ExternalEncoding), input_name='mac-limit-action'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.mac_limit is not None or
            self.mac_limit_action is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MACLimitControlType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.mac_limit is not None:
            showIndent(outfile, level)
            outfile.write('mac_limit=%d,\n' % self.mac_limit)
        if self.mac_limit_action is not None:
            showIndent(outfile, level)
            outfile.write('mac_limit_action=%s,\n' % quote_python(self.mac_limit_action).encode(ExternalEncoding))
    def exportDict(self, name_='MACLimitControlType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'mac-limit':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'mac_limit')
            self.mac_limit = ival_
        elif nodeName_ == 'mac-limit-action':
            mac_limit_action_ = child_.text
            mac_limit_action_ = self.gds_validate_string(mac_limit_action_, node, 'mac_limit_action')
            self.mac_limit_action = mac_limit_action_
            self.validate_MACLimitExceedActionType(self.mac_limit_action)    # validate type MACLimitExceedActionType
# end class MACLimitControlType


class MACMoveLimitControlType(GeneratedsSuper):
    """
    Attributes:
    * mac_move_limit
        Type:           int

        Created By:           User (required)

        Description:
          Number of MAC moves permitted in mac move time window

    * mac_move_time_window
        Type:           int, *within* [1, 60]

        Created By:           User (required)

        Description:
          MAC move time window

    * mac_move_limit_action
        Type:           str, *one-of* [u'log', u'alarm', u'shutdown', u'drop']

        Created By:           User (optional)

        Description:
          Action to be taken when MAC move limit exceeds

    """
    """This property defines the permitted MAC moves in a specified time
    and actions to be taken when MAC move limit exceeds"""
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'mac_move_limit', u'mac_move_time_window', u'mac_move_limit_action']
    attr_field_type_vals = {u'mac_move_time_window': {'restrictions': [1, 60], 'description': [u'MAC move time window'], 'simple_type': u'MACMoveTimeWindow', 'is_complex': 0, 'restriction_type': 'range', 'is_array': False, 'required': u'true', 'attr_type': u'integer'}, u'mac_move_limit': {'restrictions': None, 'description': [u'Number of MAC moves permitted in mac move time window'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'true', 'attr_type': u'integer'}, u'mac_move_limit_action': {'restrictions': [u'log', u'alarm', u'shutdown', u'drop'], 'description': [u'Action to be taken when MAC move limit exceeds'], 'simple_type': u'MACLimitExceedActionType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'optional', 'attr_type': u'string'}}
    def __init__(self, mac_move_limit=None, mac_move_time_window=10, mac_move_limit_action='log', params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _mac_move_limit = params_dict[u"mac_move_limit"]
        except KeyError:
            _mac_move_limit = mac_move_limit
        self.mac_move_limit = _mac_move_limit
        try:
            _mac_move_time_window = params_dict[u"mac_move_time_window"]
        except KeyError:
            _mac_move_time_window = mac_move_time_window
        self.mac_move_time_window = _mac_move_time_window
        try:
            _mac_move_limit_action = params_dict[u"mac_move_limit_action"]
        except KeyError:
            _mac_move_limit_action = mac_move_limit_action
        self.mac_move_limit_action = _mac_move_limit_action
    def factory(*args_, **kwargs_):
        if MACMoveLimitControlType.subclass:
            return MACMoveLimitControlType.subclass(*args_, **kwargs_)
        else:
            return MACMoveLimitControlType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_mac_move_limit(self): return self.mac_move_limit
    def set_mac_move_limit(self, mac_move_limit): self.mac_move_limit = mac_move_limit
    def get_mac_move_time_window(self): return self.mac_move_time_window
    def set_mac_move_time_window(self, mac_move_time_window): self.mac_move_time_window = mac_move_time_window
    def validate_MACMoveTimeWindow(self, value):
        # Validate type MACMoveTimeWindow, a restriction on xsd:integer.
        error = False
        if isinstance(value, list):
            v_int = list(map(int, value))
            v1, v2 = min(v_int), max(v_int)
        else:
            v1, v2 = int(value), int(value)
        error = (1 > v1)
        error |= (v2 > 60)
        if error:
            raise ValueError("MACMoveTimeWindow must be in the range {'minimum': 1}-{'maximum': 60}")
    def get_mac_move_limit_action(self): return self.mac_move_limit_action
    def set_mac_move_limit_action(self, mac_move_limit_action): self.mac_move_limit_action = mac_move_limit_action
    def validate_MACLimitExceedActionType(self, value):
        # Validate type MACLimitExceedActionType, a restriction on xsd:string.
        error = False
        if isinstance(value, list):
            error = set(value) - set([u'log', u'alarm', u'shutdown', u'drop'])
        else:
            error = value not in [u'log', u'alarm', u'shutdown', u'drop']
        if error:
            raise ValueError("MACLimitExceedActionType must be one of [u'log', u'alarm', u'shutdown', u'drop']")
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.mac_move_limit == other.mac_move_limit and
                    self.mac_move_time_window == other.mac_move_time_window and
                    self.mac_move_limit_action == other.mac_move_limit_action)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.mac_move_limit if self.mac_move_limit is not None else -7985492147856592190,
                     self.mac_move_time_window if self.mac_move_time_window is not None else -7985492147856592190,
                     self.mac_move_limit_action if self.mac_move_limit_action is not None else -7985492147856592190))

    def __repr__(self):
        return ("mac_move_limit = " + str(self.mac_move_limit) + ", " +
                "mac_move_time_window = " + str(self.mac_move_time_window) + ", " +
                "mac_move_limit_action = " + str(self.mac_move_limit_action))

    def copy(self):
        cp = MACMoveLimitControlType()
        if self.mac_move_limit is not None:
            cp.mac_move_limit = self.mac_move_limit
        if self.mac_move_time_window is not None:
            cp.mac_move_time_window = self.mac_move_time_window
        if self.mac_move_limit_action is not None:
            cp.mac_move_limit_action = self.mac_move_limit_action
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_mac_move_limit (obj.populate_integer ("mac_move_limit"))
        obj.set_mac_move_time_window (obj.populate_integer ("mac_move_time_window"))
        obj.set_mac_move_limit_action (obj.populate_string ("mac_move_limit_action"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='MACMoveLimitControlType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MACMoveLimitControlType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MACMoveLimitControlType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='MACMoveLimitControlType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.mac_move_limit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smac-move-limit>%s</%smac-move-limit>%s' % (namespace_, self.gds_format_integer(self.mac_move_limit, input_name='mac-move-limit'), namespace_, eol_))
        if self.mac_move_time_window is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smac-move-time-window>%s</%smac-move-time-window>%s' % (namespace_, self.gds_format_integer(self.mac_move_time_window, input_name='mac-move-time-window'), namespace_, eol_))
        if self.mac_move_limit_action is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smac-move-limit-action>%s</%smac-move-limit-action>%s' % (namespace_, self.gds_format_string(quote_xml(self.mac_move_limit_action).encode(ExternalEncoding), input_name='mac-move-limit-action'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.mac_move_limit is not None or
            self.mac_move_time_window is not None or
            self.mac_move_limit_action is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MACMoveLimitControlType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.mac_move_limit is not None:
            showIndent(outfile, level)
            outfile.write('mac_move_limit=%d,\n' % self.mac_move_limit)
        if self.mac_move_time_window is not None:
            showIndent(outfile, level)
            outfile.write('mac_move_time_window=%d,\n' % self.mac_move_time_window)
        if self.mac_move_limit_action is not None:
            showIndent(outfile, level)
            outfile.write('mac_move_limit_action=%s,\n' % quote_python(self.mac_move_limit_action).encode(ExternalEncoding))
    def exportDict(self, name_='MACMoveLimitControlType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'mac-move-limit':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'mac_move_limit')
            self.mac_move_limit = ival_
        elif nodeName_ == 'mac-move-time-window':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'mac_move_time_window')
            self.mac_move_time_window = ival_
            self.validate_MACMoveTimeWindow(self.mac_move_time_window)    # validate type MACMoveTimeWindow
        elif nodeName_ == 'mac-move-limit-action':
            mac_move_limit_action_ = child_.text
            mac_move_limit_action_ = self.gds_validate_string(mac_move_limit_action_, node, 'mac_move_limit_action')
            self.mac_move_limit_action = mac_move_limit_action_
            self.validate_MACLimitExceedActionType(self.mac_move_limit_action)    # validate type MACLimitExceedActionType
# end class MACMoveLimitControlType


class BridgeDomainMembershipType(GeneratedsSuper):
    """
    Attributes:
    * vlan_tag
        Type:           int, *within* [0, 4094]

        Description:
          VLAN tag of the incoming packet that maps the                      virtual-

          machine-interface to bridge domain

    """
    """VLAN tag 0 means incoming packet is either untagged or priority
    tagged"""
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'vlan_tag']
    attr_field_type_vals = {u'vlan_tag': {'restrictions': [0, 4094], 'description': [u'VLAN tag of the incoming packet that maps the                      virtual-machine-interface to bridge domain'], 'simple_type': u'Dot1QTagType', 'is_complex': 0, 'restriction_type': 'range', 'is_array': False, 'required': None, 'attr_type': u'integer'}}
    def __init__(self, vlan_tag=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _vlan_tag = params_dict[u"vlan_tag"]
        except KeyError:
            _vlan_tag = vlan_tag
        self.vlan_tag = _vlan_tag
    def factory(*args_, **kwargs_):
        if BridgeDomainMembershipType.subclass:
            return BridgeDomainMembershipType.subclass(*args_, **kwargs_)
        else:
            return BridgeDomainMembershipType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vlan_tag(self): return self.vlan_tag
    def set_vlan_tag(self, vlan_tag): self.vlan_tag = vlan_tag
    def validate_Dot1QTagType(self, value):
        # Validate type Dot1QTagType, a restriction on xsd:integer.
        error = False
        if isinstance(value, list):
            v_int = list(map(int, value))
            v1, v2 = min(v_int), max(v_int)
        else:
            v1, v2 = int(value), int(value)
        error |= (v2 > 4094)
        if error:
            raise ValueError("Dot1QTagType must be in the range {'minimum': 0}-{'maximum': 4094}")
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.vlan_tag == other.vlan_tag)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.vlan_tag if self.vlan_tag is not None else -7985492147856592190))

    def __repr__(self):
        return ("vlan_tag = " + str(self.vlan_tag))

    def copy(self):
        cp = BridgeDomainMembershipType()
        if self.vlan_tag is not None:
            cp.vlan_tag = self.vlan_tag
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_vlan_tag (obj.populate_integer ("vlan_tag"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='BridgeDomainMembershipType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BridgeDomainMembershipType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BridgeDomainMembershipType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='BridgeDomainMembershipType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vlan_tag is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svlan-tag>%s</%svlan-tag>%s' % (namespace_, self.gds_format_integer(self.vlan_tag, input_name='vlan-tag'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.vlan_tag is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BridgeDomainMembershipType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.vlan_tag is not None:
            showIndent(outfile, level)
            outfile.write('vlan_tag=%d,\n' % self.vlan_tag)
    def exportDict(self, name_='BridgeDomainMembershipType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vlan-tag':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'vlan_tag')
            self.vlan_tag = ival_
            self.validate_Dot1QTagType(self.vlan_tag)    # validate type Dot1QTagType
# end class BridgeDomainMembershipType


class AutonomousSystemsType(GeneratedsSuper):
    """
    Attributes:
    * asn
        Type:           int, *within* [1, 4294967295]

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'asn']
    attr_field_type_vals = {u'asn': {'restrictions': [1, 4294967295], 'description': [], 'simple_type': u'AutonomousSystemType', 'is_complex': 0, 'restriction_type': 'range', 'is_array': True, 'required': None, 'attr_type': u'integer'}}
    def __init__(self, asn=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _asn = params_dict[u"asn"]
        except KeyError:
            _asn = asn
        if not _asn:
            self.asn = []
        else:
            self.asn = _asn
    def factory(*args_, **kwargs_):
        if AutonomousSystemsType.subclass:
            return AutonomousSystemsType.subclass(*args_, **kwargs_)
        else:
            return AutonomousSystemsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_asn(self): return self.asn
    def set_asn(self, asn): self.asn = asn
    def add_asn(self, value): self.asn.append(value)
    def insert_asn(self, index, value): self.asn[index] = value
    def delete_asn(self, value): self.asn.remove(value)
    def validate_AutonomousSystemType(self, value):
        # Validate type AutonomousSystemType, a restriction on xsd:integer.
        error = False
        if isinstance(value, list):
            v_int = list(map(int, value))
            v1, v2 = min(v_int), max(v_int)
        else:
            v1, v2 = int(value), int(value)
        error = (1 > v1)
        error |= (v2 > 4294967295)
        if error:
            raise ValueError("AutonomousSystemType must be in the range {'minimum': 1}-{'maximum': 4294967295}")
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.asn == other.asn)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.asn or [])))

    def __repr__(self):
        return ("asn = " + str(self.asn))

    def copy(self):
        cp = AutonomousSystemsType()
        if self.asn is not None:
            cp.asn = list(self.asn)
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_asn ([obj.populate_integer ("asn")])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='AutonomousSystemsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AutonomousSystemsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AutonomousSystemsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AutonomousSystemsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for asn_ in self.asn:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sasn>%s</%sasn>%s' % (namespace_, self.gds_format_integer(asn_, input_name='asn'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.asn
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AutonomousSystemsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('asn=[\n')
        level += 1
        for asn_ in self.asn:
            showIndent(outfile, level)
            outfile.write('%d,\n' % asn)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='AutonomousSystemsType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'asn':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'asn')
            self.asn.append(ival_)
            self.validate_AutonomousSystemType(self.asn)    # validate type AutonomousSystemType
# end class AutonomousSystemsType


class MulticastSourceGroup(GeneratedsSuper):
    """
    Attributes:
    * source_address
        Type:           str, *one-of* xsd:string

        Created By:           User (required)

        Description:
          Multicast Source Address

    * group_address
        Type:           str, *one-of* xsd:string

        Created By:           User (required)

        Description:
          Multicast Group Address

    * action
        Type:           str, *one-of* [u'deny', u'pass']

        Created By:           User (required)

        Description:
          Pass or deny action for (S,G) matching this rule

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'source_address', u'group_address', u'action']
    attr_field_type_vals = {u'action': {'restrictions': [u'deny', u'pass'], 'description': [u'Pass or deny action for (S,G) matching this rule'], 'simple_type': u'SimpleActionType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'true', 'attr_type': u'string'}, u'group_address': {'restrictions': [], 'description': [u'Multicast Group Address'], 'simple_type': u'IpAddressType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'true', 'attr_type': u'string'}, u'source_address': {'restrictions': [], 'description': [u'Multicast Source Address'], 'simple_type': u'IpAddressType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'true', 'attr_type': u'string'}}
    def __init__(self, source_address=None, group_address=None, action=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _source_address = params_dict[u"source_address"]
        except KeyError:
            _source_address = source_address
        self.source_address = _source_address
        try:
            _group_address = params_dict[u"group_address"]
        except KeyError:
            _group_address = group_address
        self.group_address = _group_address
        try:
            _action = params_dict[u"action"]
        except KeyError:
            _action = action
        self.action = _action
    def factory(*args_, **kwargs_):
        if MulticastSourceGroup.subclass:
            return MulticastSourceGroup.subclass(*args_, **kwargs_)
        else:
            return MulticastSourceGroup(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_source_address(self): return self.source_address
    def set_source_address(self, source_address): self.source_address = source_address
    def validate_IpAddressType(self, value):
        # Validate type IpAddressType, a restriction on xsd:string.
        pass
    def get_group_address(self): return self.group_address
    def set_group_address(self, group_address): self.group_address = group_address
    def get_action(self): return self.action
    def set_action(self, action): self.action = action
    def validate_SimpleActionType(self, value):
        # Validate type SimpleActionType, a restriction on xsd:string.
        error = False
        if isinstance(value, list):
            error = set(value) - set([u'deny', u'pass'])
        else:
            error = value not in [u'deny', u'pass']
        if error:
            raise ValueError("SimpleActionType must be one of [u'deny', u'pass']")
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.source_address == other.source_address and
                    self.group_address == other.group_address and
                    self.action == other.action)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.source_address if self.source_address is not None else -7985492147856592190,
                     self.group_address if self.group_address is not None else -7985492147856592190,
                     self.action if self.action is not None else -7985492147856592190))

    def __repr__(self):
        return ("source_address = " + str(self.source_address) + ", " +
                "group_address = " + str(self.group_address) + ", " +
                "action = " + str(self.action))

    def copy(self):
        cp = MulticastSourceGroup()
        if self.source_address is not None:
            cp.source_address = self.source_address
        if self.group_address is not None:
            cp.group_address = self.group_address
        if self.action is not None:
            cp.action = self.action
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_source_address (obj.populate_string ("source_address"))
        obj.set_group_address (obj.populate_string ("group_address"))
        obj.set_action (obj.populate_string ("action"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='MulticastSourceGroup', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MulticastSourceGroup')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MulticastSourceGroup'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='MulticastSourceGroup', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.source_address is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssource-address>%s</%ssource-address>%s' % (namespace_, self.gds_format_string(quote_xml(self.source_address).encode(ExternalEncoding), input_name='source-address'), namespace_, eol_))
        if self.group_address is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgroup-address>%s</%sgroup-address>%s' % (namespace_, self.gds_format_string(quote_xml(self.group_address).encode(ExternalEncoding), input_name='group-address'), namespace_, eol_))
        if self.action is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saction>%s</%saction>%s' % (namespace_, self.gds_format_string(quote_xml(self.action).encode(ExternalEncoding), input_name='action'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.source_address is not None or
            self.group_address is not None or
            self.action is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MulticastSourceGroup'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.source_address is not None:
            showIndent(outfile, level)
            outfile.write('source_address=%s,\n' % quote_python(self.source_address).encode(ExternalEncoding))
        if self.group_address is not None:
            showIndent(outfile, level)
            outfile.write('group_address=%s,\n' % quote_python(self.group_address).encode(ExternalEncoding))
        if self.action is not None:
            showIndent(outfile, level)
            outfile.write('action=%s,\n' % quote_python(self.action).encode(ExternalEncoding))
    def exportDict(self, name_='MulticastSourceGroup'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'source-address':
            source_address_ = child_.text
            source_address_ = self.gds_validate_string(source_address_, node, 'source_address')
            self.source_address = source_address_
            self.validate_IpAddressType(self.source_address)    # validate type IpAddressType
        elif nodeName_ == 'group-address':
            group_address_ = child_.text
            group_address_ = self.gds_validate_string(group_address_, node, 'group_address')
            self.group_address = group_address_
            self.validate_IpAddressType(self.group_address)    # validate type IpAddressType
        elif nodeName_ == 'action':
            action_ = child_.text
            action_ = self.gds_validate_string(action_, node, 'action')
            self.action = action_
            self.validate_SimpleActionType(self.action)    # validate type SimpleActionType
# end class MulticastSourceGroup


class MulticastSourceGroups(GeneratedsSuper):
    """
    Attributes:
    * multicast_source_group
        Type:           :class:`.MulticastSourceGroup`

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'multicast_source_group']
    attr_field_type_vals = {u'multicast_source_group': {'restrictions': None, 'description': [], 'simple_type': u'MulticastSourceGroup', 'is_complex': 1, 'restriction_type': None, 'is_array': True, 'required': None, 'attr_type': u'MulticastSourceGroup'}}
    def __init__(self, multicast_source_group=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _multicast_source_group = params_dict[u"multicast_source_group"]
        except KeyError:
            _multicast_source_group = multicast_source_group
        if not _multicast_source_group:
            self.multicast_source_group = []
        else:
            if isinstance(_multicast_source_group[0], dict):
                objs = [MulticastSourceGroup(params_dict=elem) for elem in _multicast_source_group]
                self.multicast_source_group = objs
            else:
                self.multicast_source_group = _multicast_source_group
    def factory(*args_, **kwargs_):
        if MulticastSourceGroups.subclass:
            return MulticastSourceGroups.subclass(*args_, **kwargs_)
        else:
            return MulticastSourceGroups(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_multicast_source_group(self): return self.multicast_source_group
    def set_multicast_source_group(self, multicast_source_group): self.multicast_source_group = multicast_source_group
    def add_multicast_source_group(self, value): self.multicast_source_group.append(value)
    def insert_multicast_source_group(self, index, value): self.multicast_source_group[index] = value
    def delete_multicast_source_group(self, value): self.multicast_source_group.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.multicast_source_group == other.multicast_source_group)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.multicast_source_group or [])))

    def __repr__(self):
        return ("multicast_source_group = " + str(self.multicast_source_group))

    def copy(self):
        cp = MulticastSourceGroups()
        if self.multicast_source_group is not None:
            cp.multicast_source_group = [x.copy() for x in self.multicast_source_group]
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_multicast_source_group ([MulticastSourceGroup.populate ()])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='MulticastSourceGroups', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MulticastSourceGroups')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MulticastSourceGroups'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='MulticastSourceGroups', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for multicast_source_group_ in self.multicast_source_group:
            if isinstance(multicast_source_group_, dict):
                multicast_source_group_ = MulticastSourceGroup(**multicast_source_group_)
            multicast_source_group_.export_xml(outfile, level, namespace_, name_='multicast-source-group', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.multicast_source_group
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MulticastSourceGroups'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('multicast_source_group=[\n')
        level += 1
        for multicast_source_group_ in self.multicast_source_group:
            showIndent(outfile, level)
            outfile.write('model_.MulticastSourceGroup(\n')
            multicast_source_group_.exportLiteral(outfile, level, name_='MulticastSourceGroup')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='MulticastSourceGroups'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'multicast-source-group':
            obj_ = MulticastSourceGroup.factory()
            obj_.build(child_)
            self.multicast_source_group.append(obj_)
# end class MulticastSourceGroups


class TelemetryResourceInfo(GeneratedsSuper):
    """
    Attributes:
    * name
        Type:           str

    * path
        Type:           str

    * rate
        Type:           str

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'name', u'path', u'rate']
    attr_field_type_vals = {u'path': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'rate': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'name': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}}
    def __init__(self, name=None, path=None, rate=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _name = params_dict[u"name"]
        except KeyError:
            _name = name
        self.name = _name
        try:
            _path = params_dict[u"path"]
        except KeyError:
            _path = path
        self.path = _path
        try:
            _rate = params_dict[u"rate"]
        except KeyError:
            _rate = rate
        self.rate = _rate
    def factory(*args_, **kwargs_):
        if TelemetryResourceInfo.subclass:
            return TelemetryResourceInfo.subclass(*args_, **kwargs_)
        else:
            return TelemetryResourceInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_path(self): return self.path
    def set_path(self, path): self.path = path
    def get_rate(self): return self.rate
    def set_rate(self, rate): self.rate = rate
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.name == other.name and
                    self.path == other.path and
                    self.rate == other.rate)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.name if self.name is not None else -7985492147856592190,
                     self.path if self.path is not None else -7985492147856592190,
                     self.rate if self.rate is not None else -7985492147856592190))

    def __repr__(self):
        return ("name = " + str(self.name) + ", " +
                "path = " + str(self.path) + ", " +
                "rate = " + str(self.rate))

    def copy(self):
        cp = TelemetryResourceInfo()
        if self.name is not None:
            cp.name = self.name
        if self.path is not None:
            cp.path = self.path
        if self.rate is not None:
            cp.rate = self.rate
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_name (obj.populate_string ("name"))
        obj.set_path (obj.populate_string ("path"))
        obj.set_rate (obj.populate_string ("rate"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='TelemetryResourceInfo', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TelemetryResourceInfo')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TelemetryResourceInfo'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TelemetryResourceInfo', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        if self.path is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spath>%s</%spath>%s' % (namespace_, self.gds_format_string(quote_xml(self.path).encode(ExternalEncoding), input_name='path'), namespace_, eol_))
        if self.rate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srate>%s</%srate>%s' % (namespace_, self.gds_format_string(quote_xml(self.rate).encode(ExternalEncoding), input_name='rate'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.name is not None or
            self.path is not None or
            self.rate is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TelemetryResourceInfo'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.path is not None:
            showIndent(outfile, level)
            outfile.write('path=%s,\n' % quote_python(self.path).encode(ExternalEncoding))
        if self.rate is not None:
            showIndent(outfile, level)
            outfile.write('rate=%s,\n' % quote_python(self.rate).encode(ExternalEncoding))
    def exportDict(self, name_='TelemetryResourceInfo'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'path':
            path_ = child_.text
            path_ = self.gds_validate_string(path_, node, 'path')
            self.path = path_
        elif nodeName_ == 'rate':
            rate_ = child_.text
            rate_ = self.gds_validate_string(rate_, node, 'rate')
            self.rate = rate_
# end class TelemetryResourceInfo


class TelemetryStateInfo(GeneratedsSuper):
    """
    Attributes:
    * resource
        Type:           :class:`.TelemetryResourceInfo`

    * server_ip
        Type:           str

    * server_port
        Type:           int

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'resource', u'server_ip', u'server_port']
    attr_field_type_vals = {u'resource': {'restrictions': None, 'description': [], 'simple_type': u'TelemetryResourceInfo', 'is_complex': 1, 'restriction_type': None, 'is_array': True, 'required': None, 'attr_type': u'TelemetryResourceInfo'}, u'server_port': {'restrictions': None, 'description': [], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'integer'}, u'server_ip': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}}
    def __init__(self, resource=None, server_ip=None, server_port=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _resource = params_dict[u"resource"]
        except KeyError:
            _resource = resource
        if not _resource:
            self.resource = []
        else:
            if isinstance(_resource[0], dict):
                objs = [TelemetryResourceInfo(params_dict=elem) for elem in _resource]
                self.resource = objs
            else:
                self.resource = _resource
        try:
            _server_ip = params_dict[u"server_ip"]
        except KeyError:
            _server_ip = server_ip
        self.server_ip = _server_ip
        try:
            _server_port = params_dict[u"server_port"]
        except KeyError:
            _server_port = server_port
        self.server_port = _server_port
    def factory(*args_, **kwargs_):
        if TelemetryStateInfo.subclass:
            return TelemetryStateInfo.subclass(*args_, **kwargs_)
        else:
            return TelemetryStateInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_resource(self): return self.resource
    def set_resource(self, resource): self.resource = resource
    def add_resource(self, value): self.resource.append(value)
    def insert_resource(self, index, value): self.resource[index] = value
    def delete_resource(self, value): self.resource.remove(value)
    def get_server_ip(self): return self.server_ip
    def set_server_ip(self, server_ip): self.server_ip = server_ip
    def get_server_port(self): return self.server_port
    def set_server_port(self, server_port): self.server_port = server_port
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.resource == other.resource and
                    self.server_ip == other.server_ip and
                    self.server_port == other.server_port)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.resource or []),
                     self.server_ip if self.server_ip is not None else -7985492147856592190,
                     self.server_port if self.server_port is not None else -7985492147856592190))

    def __repr__(self):
        return ("resource = " + str(self.resource) + ", " +
                "server_ip = " + str(self.server_ip) + ", " +
                "server_port = " + str(self.server_port))

    def copy(self):
        cp = TelemetryStateInfo()
        if self.resource is not None:
            cp.resource = [x.copy() for x in self.resource]
        if self.server_ip is not None:
            cp.server_ip = self.server_ip
        if self.server_port is not None:
            cp.server_port = self.server_port
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_resource ([TelemetryResourceInfo.populate ()])
        obj.set_server_ip (obj.populate_string ("server_ip"))
        obj.set_server_port (obj.populate_integer ("server_port"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='TelemetryStateInfo', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TelemetryStateInfo')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TelemetryStateInfo'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TelemetryStateInfo', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for resource_ in self.resource:
            if isinstance(resource_, dict):
                resource_ = TelemetryResourceInfo(**resource_)
            resource_.export_xml(outfile, level, namespace_, name_='resource', pretty_print=pretty_print)
        if self.server_ip is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sserver-ip>%s</%sserver-ip>%s' % (namespace_, self.gds_format_string(quote_xml(self.server_ip).encode(ExternalEncoding), input_name='server-ip'), namespace_, eol_))
        if self.server_port is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sserver-port>%s</%sserver-port>%s' % (namespace_, self.gds_format_integer(self.server_port, input_name='server-port'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.resource or
            self.server_ip is not None or
            self.server_port is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TelemetryStateInfo'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('resource=[\n')
        level += 1
        for resource_ in self.resource:
            showIndent(outfile, level)
            outfile.write('model_.TelemetryResourceInfo(\n')
            resource_.exportLiteral(outfile, level, name_='TelemetryResourceInfo')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.server_ip is not None:
            showIndent(outfile, level)
            outfile.write('server_ip=%s,\n' % quote_python(self.server_ip).encode(ExternalEncoding))
        if self.server_port is not None:
            showIndent(outfile, level)
            outfile.write('server_port=%d,\n' % self.server_port)
    def exportDict(self, name_='TelemetryStateInfo'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'resource':
            obj_ = TelemetryResourceInfo.factory()
            obj_.build(child_)
            self.resource.append(obj_)
        elif nodeName_ == 'server-ip':
            server_ip_ = child_.text
            server_ip_ = self.gds_validate_string(server_ip_, node, 'server_ip')
            self.server_ip = server_ip_
        elif nodeName_ == 'server-port':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'server_port')
            self.server_port = ival_
# end class TelemetryStateInfo


class LoadbalancerPoolType(GeneratedsSuper):
    """
    Attributes:
    * status
        Type:           str

        Description:
          Operating status for this loadbalancer pool.

    * status_description
        Type:           str

        Description:
          Operating status description for this loadbalancer pool.

    * admin_state
        Type:           bool

        Created By:           User (optional)

        Description:
          Administrative up or down

    * protocol
        Type:           str, *one-of* [u'HTTP', u'HTTPS', u'TCP', u'UDP', u'TERMINATED_HTTPS']

        Created By:           User (optional)

        Description:
          IP protocol string like http, https or tcp.

    * loadbalancer_method
        Type:           str, *one-of* [u'ROUND_ROBIN', u'LEAST_CONNECTIONS', u'SOURCE_IP']

        Created By:           User (optional)

        Description:
          Load balancing method ROUND_ROBIN, LEAST_CONNECTIONS, or SOURCE_IP

    * subnet_id
        Type:           str, *one-of* xsd:string

        Created By:           User (optional)

        Description:
          UUID of the subnet from where the members of the pool are reachable.

    * session_persistence
        Type:           str, *one-of* [u'SOURCE_IP', u'HTTP_COOKIE', u'APP_COOKIE']

        Created By:           User (optional)

        Description:
          Method for persistence. HTTP_COOKIE, SOURCE_IP or APP_COOKIE.

    * persistence_cookie_name
        Type:           str

        Created By:           User (optional)

        Description:
          To Be Added

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'status', u'status_description', u'admin_state', u'protocol', u'loadbalancer_method', u'subnet_id', u'session_persistence', u'persistence_cookie_name']
    attr_field_type_vals = {u'status': {'restrictions': None, 'description': [u'Operating status for this loadbalancer pool.'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'system-only', 'attr_type': u'string'}, u'protocol': {'restrictions': [u'HTTP', u'HTTPS', u'TCP', u'UDP', u'TERMINATED_HTTPS'], 'description': [u'IP protocol string like http, https or tcp.'], 'simple_type': u'LoadbalancerProtocolType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'required', 'attr_type': u'string'}, u'subnet_id': {'restrictions': [], 'description': [u'UUID of the subnet from where the members of the pool are reachable.'], 'simple_type': u'UuidStringType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'required', 'attr_type': u'string'}, u'session_persistence': {'restrictions': [u'SOURCE_IP', u'HTTP_COOKIE', u'APP_COOKIE'], 'description': [u'Method for persistence. HTTP_COOKIE, SOURCE_IP or APP_COOKIE.'], 'simple_type': u'SessionPersistenceType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'admin_state': {'restrictions': None, 'description': [u'Administrative up or down'], 'simple_type': u'xsd:boolean', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'boolean'}, u'persistence_cookie_name': {'restrictions': None, 'description': [u'To Be Added'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'status_description': {'restrictions': None, 'description': [u'Operating status description for this loadbalancer pool.'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'system-only', 'attr_type': u'string'}, u'loadbalancer_method': {'restrictions': [u'ROUND_ROBIN', u'LEAST_CONNECTIONS', u'SOURCE_IP'], 'description': [u'Load balancing method ROUND_ROBIN, LEAST_CONNECTIONS, or SOURCE_IP'], 'simple_type': u'LoadbalancerMethodType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'optional', 'attr_type': u'string'}}
    def __init__(self, status=None, status_description=None, admin_state=True, protocol=None, loadbalancer_method=None, subnet_id=None, session_persistence=None, persistence_cookie_name=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _status = params_dict[u"status"]
        except KeyError:
            _status = status
        self.status = _status
        try:
            _status_description = params_dict[u"status_description"]
        except KeyError:
            _status_description = status_description
        self.status_description = _status_description
        try:
            _admin_state = params_dict[u"admin_state"]
        except KeyError:
            _admin_state = admin_state
        self.admin_state = _admin_state
        try:
            _protocol = params_dict[u"protocol"]
        except KeyError:
            _protocol = protocol
        self.protocol = _protocol
        try:
            _loadbalancer_method = params_dict[u"loadbalancer_method"]
        except KeyError:
            _loadbalancer_method = loadbalancer_method
        self.loadbalancer_method = _loadbalancer_method
        try:
            _subnet_id = params_dict[u"subnet_id"]
        except KeyError:
            _subnet_id = subnet_id
        self.subnet_id = _subnet_id
        try:
            _session_persistence = params_dict[u"session_persistence"]
        except KeyError:
            _session_persistence = session_persistence
        self.session_persistence = _session_persistence
        try:
            _persistence_cookie_name = params_dict[u"persistence_cookie_name"]
        except KeyError:
            _persistence_cookie_name = persistence_cookie_name
        self.persistence_cookie_name = _persistence_cookie_name
    def factory(*args_, **kwargs_):
        if LoadbalancerPoolType.subclass:
            return LoadbalancerPoolType.subclass(*args_, **kwargs_)
        else:
            return LoadbalancerPoolType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_status_description(self): return self.status_description
    def set_status_description(self, status_description): self.status_description = status_description
    def get_admin_state(self): return self.admin_state
    def set_admin_state(self, admin_state): self.admin_state = admin_state
    def get_protocol(self): return self.protocol
    def set_protocol(self, protocol): self.protocol = protocol
    def validate_LoadbalancerProtocolType(self, value):
        # Validate type LoadbalancerProtocolType, a restriction on xsd:string.
        error = False
        if isinstance(value, list):
            error = set(value) - set([u'HTTP', u'HTTPS', u'TCP', u'UDP', u'TERMINATED_HTTPS'])
        else:
            error = value not in [u'HTTP', u'HTTPS', u'TCP', u'UDP', u'TERMINATED_HTTPS']
        if error:
            raise ValueError("LoadbalancerProtocolType must be one of [u'HTTP', u'HTTPS', u'TCP', u'UDP', u'TERMINATED_HTTPS']")
    def get_loadbalancer_method(self): return self.loadbalancer_method
    def set_loadbalancer_method(self, loadbalancer_method): self.loadbalancer_method = loadbalancer_method
    def validate_LoadbalancerMethodType(self, value):
        # Validate type LoadbalancerMethodType, a restriction on xsd:string.
        error = False
        if isinstance(value, list):
            error = set(value) - set([u'ROUND_ROBIN', u'LEAST_CONNECTIONS', u'SOURCE_IP'])
        else:
            error = value not in [u'ROUND_ROBIN', u'LEAST_CONNECTIONS', u'SOURCE_IP']
        if error:
            raise ValueError("LoadbalancerMethodType must be one of [u'ROUND_ROBIN', u'LEAST_CONNECTIONS', u'SOURCE_IP']")
    def get_subnet_id(self): return self.subnet_id
    def set_subnet_id(self, subnet_id): self.subnet_id = subnet_id
    def validate_UuidStringType(self, value):
        # Validate type UuidStringType, a restriction on xsd:string.
        pass
    def get_session_persistence(self): return self.session_persistence
    def set_session_persistence(self, session_persistence): self.session_persistence = session_persistence
    def validate_SessionPersistenceType(self, value):
        # Validate type SessionPersistenceType, a restriction on xsd:string.
        error = False
        if isinstance(value, list):
            error = set(value) - set([u'SOURCE_IP', u'HTTP_COOKIE', u'APP_COOKIE'])
        else:
            error = value not in [u'SOURCE_IP', u'HTTP_COOKIE', u'APP_COOKIE']
        if error:
            raise ValueError("SessionPersistenceType must be one of [u'SOURCE_IP', u'HTTP_COOKIE', u'APP_COOKIE']")
    def get_persistence_cookie_name(self): return self.persistence_cookie_name
    def set_persistence_cookie_name(self, persistence_cookie_name): self.persistence_cookie_name = persistence_cookie_name
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.status == other.status and
                    self.status_description == other.status_description and
                    self.admin_state == other.admin_state and
                    self.protocol == other.protocol and
                    self.loadbalancer_method == other.loadbalancer_method and
                    self.subnet_id == other.subnet_id and
                    self.session_persistence == other.session_persistence and
                    self.persistence_cookie_name == other.persistence_cookie_name)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.status if self.status is not None else -7985492147856592190,
                     self.status_description if self.status_description is not None else -7985492147856592190,
                     self.admin_state if self.admin_state is not None else -7985492147856592190,
                     self.protocol if self.protocol is not None else -7985492147856592190,
                     self.loadbalancer_method if self.loadbalancer_method is not None else -7985492147856592190,
                     self.subnet_id if self.subnet_id is not None else -7985492147856592190,
                     self.session_persistence if self.session_persistence is not None else -7985492147856592190,
                     self.persistence_cookie_name if self.persistence_cookie_name is not None else -7985492147856592190))

    def __repr__(self):
        return ("status = " + str(self.status) + ", " +
                "status_description = " + str(self.status_description) + ", " +
                "admin_state = " + str(self.admin_state) + ", " +
                "protocol = " + str(self.protocol) + ", " +
                "loadbalancer_method = " + str(self.loadbalancer_method) + ", " +
                "subnet_id = " + str(self.subnet_id) + ", " +
                "session_persistence = " + str(self.session_persistence) + ", " +
                "persistence_cookie_name = " + str(self.persistence_cookie_name))

    def copy(self):
        cp = LoadbalancerPoolType()
        if self.status is not None:
            cp.status = self.status
        if self.status_description is not None:
            cp.status_description = self.status_description
        if self.admin_state is not None:
            cp.admin_state = self.admin_state
        if self.protocol is not None:
            cp.protocol = self.protocol
        if self.loadbalancer_method is not None:
            cp.loadbalancer_method = self.loadbalancer_method
        if self.subnet_id is not None:
            cp.subnet_id = self.subnet_id
        if self.session_persistence is not None:
            cp.session_persistence = self.session_persistence
        if self.persistence_cookie_name is not None:
            cp.persistence_cookie_name = self.persistence_cookie_name
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_status (obj.populate_string ("status"))
        obj.set_status_description (obj.populate_string ("status_description"))
        obj.set_admin_state (obj.populate_boolean ("admin_state"))
        obj.set_protocol (obj.populate_string ("protocol"))
        obj.set_loadbalancer_method (obj.populate_string ("loadbalancer_method"))
        obj.set_subnet_id (obj.populate_string ("subnet_id"))
        obj.set_session_persistence (obj.populate_string ("session_persistence"))
        obj.set_persistence_cookie_name (obj.populate_string ("persistence_cookie_name"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='LoadbalancerPoolType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LoadbalancerPoolType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LoadbalancerPoolType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LoadbalancerPoolType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.status is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstatus>%s</%sstatus>%s' % (namespace_, self.gds_format_string(quote_xml(self.status).encode(ExternalEncoding), input_name='status'), namespace_, eol_))
        if self.status_description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstatus-description>%s</%sstatus-description>%s' % (namespace_, self.gds_format_string(quote_xml(self.status_description).encode(ExternalEncoding), input_name='status-description'), namespace_, eol_))
        if self.admin_state is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sadmin-state>%s</%sadmin-state>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.admin_state)), input_name='admin-state'), namespace_, eol_))
        if self.protocol is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprotocol>%s</%sprotocol>%s' % (namespace_, self.gds_format_string(quote_xml(self.protocol).encode(ExternalEncoding), input_name='protocol'), namespace_, eol_))
        if self.loadbalancer_method is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sloadbalancer-method>%s</%sloadbalancer-method>%s' % (namespace_, self.gds_format_string(quote_xml(self.loadbalancer_method).encode(ExternalEncoding), input_name='loadbalancer-method'), namespace_, eol_))
        if self.subnet_id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssubnet-id>%s</%ssubnet-id>%s' % (namespace_, self.gds_format_string(quote_xml(self.subnet_id).encode(ExternalEncoding), input_name='subnet-id'), namespace_, eol_))
        if self.session_persistence is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssession-persistence>%s</%ssession-persistence>%s' % (namespace_, self.gds_format_string(quote_xml(self.session_persistence).encode(ExternalEncoding), input_name='session-persistence'), namespace_, eol_))
        if self.persistence_cookie_name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spersistence-cookie-name>%s</%spersistence-cookie-name>%s' % (namespace_, self.gds_format_string(quote_xml(self.persistence_cookie_name).encode(ExternalEncoding), input_name='persistence-cookie-name'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.status is not None or
            self.status_description is not None or
            self.admin_state is not None or
            self.protocol is not None or
            self.loadbalancer_method is not None or
            self.subnet_id is not None or
            self.session_persistence is not None or
            self.persistence_cookie_name is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LoadbalancerPoolType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.status is not None:
            showIndent(outfile, level)
            outfile.write('status=%s,\n' % quote_python(self.status).encode(ExternalEncoding))
        if self.status_description is not None:
            showIndent(outfile, level)
            outfile.write('status_description=%s,\n' % quote_python(self.status_description).encode(ExternalEncoding))
        if self.admin_state is not None:
            showIndent(outfile, level)
            outfile.write('admin_state=%s,\n' % self.admin_state)
        if self.protocol is not None:
            showIndent(outfile, level)
            outfile.write('protocol=%s,\n' % quote_python(self.protocol).encode(ExternalEncoding))
        if self.loadbalancer_method is not None:
            showIndent(outfile, level)
            outfile.write('loadbalancer_method=%s,\n' % quote_python(self.loadbalancer_method).encode(ExternalEncoding))
        if self.subnet_id is not None:
            showIndent(outfile, level)
            outfile.write('subnet_id=%s,\n' % quote_python(self.subnet_id).encode(ExternalEncoding))
        if self.session_persistence is not None:
            showIndent(outfile, level)
            outfile.write('session_persistence=%s,\n' % quote_python(self.session_persistence).encode(ExternalEncoding))
        if self.persistence_cookie_name is not None:
            showIndent(outfile, level)
            outfile.write('persistence_cookie_name=%s,\n' % quote_python(self.persistence_cookie_name).encode(ExternalEncoding))
    def exportDict(self, name_='LoadbalancerPoolType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'status':
            status_ = child_.text
            status_ = self.gds_validate_string(status_, node, 'status')
            self.status = status_
        elif nodeName_ == 'status-description':
            status_description_ = child_.text
            status_description_ = self.gds_validate_string(status_description_, node, 'status_description')
            self.status_description = status_description_
        elif nodeName_ == 'admin-state':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'admin_state')
            self.admin_state = ival_
        elif nodeName_ == 'protocol':
            protocol_ = child_.text
            protocol_ = self.gds_validate_string(protocol_, node, 'protocol')
            self.protocol = protocol_
            self.validate_LoadbalancerProtocolType(self.protocol)    # validate type LoadbalancerProtocolType
        elif nodeName_ == 'loadbalancer-method':
            loadbalancer_method_ = child_.text
            loadbalancer_method_ = self.gds_validate_string(loadbalancer_method_, node, 'loadbalancer_method')
            self.loadbalancer_method = loadbalancer_method_
            self.validate_LoadbalancerMethodType(self.loadbalancer_method)    # validate type LoadbalancerMethodType
        elif nodeName_ == 'subnet-id':
            subnet_id_ = child_.text
            subnet_id_ = self.gds_validate_string(subnet_id_, node, 'subnet_id')
            self.subnet_id = subnet_id_
            self.validate_UuidStringType(self.subnet_id)    # validate type UuidStringType
        elif nodeName_ == 'session-persistence':
            session_persistence_ = child_.text
            session_persistence_ = self.gds_validate_string(session_persistence_, node, 'session_persistence')
            self.session_persistence = session_persistence_
            self.validate_SessionPersistenceType(self.session_persistence)    # validate type SessionPersistenceType
        elif nodeName_ == 'persistence-cookie-name':
            persistence_cookie_name_ = child_.text
            persistence_cookie_name_ = self.gds_validate_string(persistence_cookie_name_, node, 'persistence_cookie_name')
            self.persistence_cookie_name = persistence_cookie_name_
# end class LoadbalancerPoolType


class LoadbalancerMemberType(GeneratedsSuper):
    """
    Attributes:
    * admin_state
        Type:           bool

        Created By:           User (optional)

        Description:
          Administrative up or down.

    * status
        Type:           str

        Description:
          Operational status of the member.

    * status_description
        Type:           str

        Description:
          Operational status description of the member.

    * protocol_port
        Type:           int

        Created By:           User (optional)

        Description:
          Destination port for the application on the member.

    * weight
        Type:           int

        Created By:           User (optional)

        Description:
          Weight for load balancing

    * address
        Type:           str, *one-of* xsd:string

        Created By:           User (optional)

        Description:
          Ip address of the member

    * subnet_id
        Type:           str, *one-of* xsd:string

        Created By:           User (optional)

        Description:
          UUID of the subnet from where the members are reachable.

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'admin_state', u'status', u'status_description', u'protocol_port', u'weight', u'address', u'subnet_id']
    attr_field_type_vals = {u'status': {'restrictions': None, 'description': [u'Operational status of the member.'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'system-only', 'attr_type': u'string'}, u'status_description': {'restrictions': None, 'description': [u'Operational status description of the member.'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'system-only', 'attr_type': u'string'}, u'weight': {'restrictions': None, 'description': [u'Weight for load balancing'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'subnet_id': {'restrictions': [], 'description': [u'UUID of the subnet from where the members are reachable.'], 'simple_type': u'UuidStringType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'admin_state': {'restrictions': None, 'description': [u'Administrative up or down.'], 'simple_type': u'xsd:boolean', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'boolean'}, u'address': {'restrictions': [], 'description': [u'Ip address of the member'], 'simple_type': u'IpAddressType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'required', 'attr_type': u'string'}, u'protocol_port': {'restrictions': None, 'description': [u'Destination port for the application on the member.'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}}
    def __init__(self, admin_state=True, status=None, status_description=None, protocol_port=None, weight=1, address=None, subnet_id=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _admin_state = params_dict[u"admin_state"]
        except KeyError:
            _admin_state = admin_state
        self.admin_state = _admin_state
        try:
            _status = params_dict[u"status"]
        except KeyError:
            _status = status
        self.status = _status
        try:
            _status_description = params_dict[u"status_description"]
        except KeyError:
            _status_description = status_description
        self.status_description = _status_description
        try:
            _protocol_port = params_dict[u"protocol_port"]
        except KeyError:
            _protocol_port = protocol_port
        self.protocol_port = _protocol_port
        try:
            _weight = params_dict[u"weight"]
        except KeyError:
            _weight = weight
        self.weight = _weight
        try:
            _address = params_dict[u"address"]
        except KeyError:
            _address = address
        self.address = _address
        try:
            _subnet_id = params_dict[u"subnet_id"]
        except KeyError:
            _subnet_id = subnet_id
        self.subnet_id = _subnet_id
    def factory(*args_, **kwargs_):
        if LoadbalancerMemberType.subclass:
            return LoadbalancerMemberType.subclass(*args_, **kwargs_)
        else:
            return LoadbalancerMemberType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_admin_state(self): return self.admin_state
    def set_admin_state(self, admin_state): self.admin_state = admin_state
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_status_description(self): return self.status_description
    def set_status_description(self, status_description): self.status_description = status_description
    def get_protocol_port(self): return self.protocol_port
    def set_protocol_port(self, protocol_port): self.protocol_port = protocol_port
    def get_weight(self): return self.weight
    def set_weight(self, weight): self.weight = weight
    def get_address(self): return self.address
    def set_address(self, address): self.address = address
    def validate_IpAddressType(self, value):
        # Validate type IpAddressType, a restriction on xsd:string.
        pass
    def get_subnet_id(self): return self.subnet_id
    def set_subnet_id(self, subnet_id): self.subnet_id = subnet_id
    def validate_UuidStringType(self, value):
        # Validate type UuidStringType, a restriction on xsd:string.
        pass
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.admin_state == other.admin_state and
                    self.status == other.status and
                    self.status_description == other.status_description and
                    self.protocol_port == other.protocol_port and
                    self.weight == other.weight and
                    self.address == other.address and
                    self.subnet_id == other.subnet_id)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.admin_state if self.admin_state is not None else -7985492147856592190,
                     self.status if self.status is not None else -7985492147856592190,
                     self.status_description if self.status_description is not None else -7985492147856592190,
                     self.protocol_port if self.protocol_port is not None else -7985492147856592190,
                     self.weight if self.weight is not None else -7985492147856592190,
                     self.address if self.address is not None else -7985492147856592190,
                     self.subnet_id if self.subnet_id is not None else -7985492147856592190))

    def __repr__(self):
        return ("admin_state = " + str(self.admin_state) + ", " +
                "status = " + str(self.status) + ", " +
                "status_description = " + str(self.status_description) + ", " +
                "protocol_port = " + str(self.protocol_port) + ", " +
                "weight = " + str(self.weight) + ", " +
                "address = " + str(self.address) + ", " +
                "subnet_id = " + str(self.subnet_id))

    def copy(self):
        cp = LoadbalancerMemberType()
        if self.admin_state is not None:
            cp.admin_state = self.admin_state
        if self.status is not None:
            cp.status = self.status
        if self.status_description is not None:
            cp.status_description = self.status_description
        if self.protocol_port is not None:
            cp.protocol_port = self.protocol_port
        if self.weight is not None:
            cp.weight = self.weight
        if self.address is not None:
            cp.address = self.address
        if self.subnet_id is not None:
            cp.subnet_id = self.subnet_id
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_admin_state (obj.populate_boolean ("admin_state"))
        obj.set_status (obj.populate_string ("status"))
        obj.set_status_description (obj.populate_string ("status_description"))
        obj.set_protocol_port (obj.populate_integer ("protocol_port"))
        obj.set_weight (obj.populate_integer ("weight"))
        obj.set_address (obj.populate_string ("address"))
        obj.set_subnet_id (obj.populate_string ("subnet_id"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='LoadbalancerMemberType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LoadbalancerMemberType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LoadbalancerMemberType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LoadbalancerMemberType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.admin_state is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sadmin-state>%s</%sadmin-state>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.admin_state)), input_name='admin-state'), namespace_, eol_))
        if self.status is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstatus>%s</%sstatus>%s' % (namespace_, self.gds_format_string(quote_xml(self.status).encode(ExternalEncoding), input_name='status'), namespace_, eol_))
        if self.status_description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstatus-description>%s</%sstatus-description>%s' % (namespace_, self.gds_format_string(quote_xml(self.status_description).encode(ExternalEncoding), input_name='status-description'), namespace_, eol_))
        if self.protocol_port is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprotocol-port>%s</%sprotocol-port>%s' % (namespace_, self.gds_format_integer(self.protocol_port, input_name='protocol-port'), namespace_, eol_))
        if self.weight is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sweight>%s</%sweight>%s' % (namespace_, self.gds_format_integer(self.weight, input_name='weight'), namespace_, eol_))
        if self.address is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saddress>%s</%saddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.address).encode(ExternalEncoding), input_name='address'), namespace_, eol_))
        if self.subnet_id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssubnet-id>%s</%ssubnet-id>%s' % (namespace_, self.gds_format_string(quote_xml(self.subnet_id).encode(ExternalEncoding), input_name='subnet-id'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.admin_state is not None or
            self.status is not None or
            self.status_description is not None or
            self.protocol_port is not None or
            self.weight is not None or
            self.address is not None or
            self.subnet_id is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LoadbalancerMemberType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.admin_state is not None:
            showIndent(outfile, level)
            outfile.write('admin_state=%s,\n' % self.admin_state)
        if self.status is not None:
            showIndent(outfile, level)
            outfile.write('status=%s,\n' % quote_python(self.status).encode(ExternalEncoding))
        if self.status_description is not None:
            showIndent(outfile, level)
            outfile.write('status_description=%s,\n' % quote_python(self.status_description).encode(ExternalEncoding))
        if self.protocol_port is not None:
            showIndent(outfile, level)
            outfile.write('protocol_port=%d,\n' % self.protocol_port)
        if self.weight is not None:
            showIndent(outfile, level)
            outfile.write('weight=%d,\n' % self.weight)
        if self.address is not None:
            showIndent(outfile, level)
            outfile.write('address=%s,\n' % quote_python(self.address).encode(ExternalEncoding))
        if self.subnet_id is not None:
            showIndent(outfile, level)
            outfile.write('subnet_id=%s,\n' % quote_python(self.subnet_id).encode(ExternalEncoding))
    def exportDict(self, name_='LoadbalancerMemberType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'admin-state':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'admin_state')
            self.admin_state = ival_
        elif nodeName_ == 'status':
            status_ = child_.text
            status_ = self.gds_validate_string(status_, node, 'status')
            self.status = status_
        elif nodeName_ == 'status-description':
            status_description_ = child_.text
            status_description_ = self.gds_validate_string(status_description_, node, 'status_description')
            self.status_description = status_description_
        elif nodeName_ == 'protocol-port':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'protocol_port')
            self.protocol_port = ival_
        elif nodeName_ == 'weight':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'weight')
            self.weight = ival_
        elif nodeName_ == 'address':
            address_ = child_.text
            address_ = self.gds_validate_string(address_, node, 'address')
            self.address = address_
            self.validate_IpAddressType(self.address)    # validate type IpAddressType
        elif nodeName_ == 'subnet-id':
            subnet_id_ = child_.text
            subnet_id_ = self.gds_validate_string(subnet_id_, node, 'subnet_id')
            self.subnet_id = subnet_id_
            self.validate_UuidStringType(self.subnet_id)    # validate type UuidStringType
# end class LoadbalancerMemberType


class LoadbalancerHealthmonitorType(GeneratedsSuper):
    """
    Attributes:
    * admin_state
        Type:           bool

        Created By:           User (optional)

        Description:
          Administratively up or dowm.

    * monitor_type
        Type:           str, *one-of* [u'PING', u'TCP', u'HTTP', u'HTTPS']

        Created By:           User (required)

        Description:
          Protocol used to monitor health, PING, HTTP, HTTPS or TCP

    * delay
        Type:           int

        Created By:           User (required)

        Description:
          Time in seconds  at which health check is repeated

    * timeout
        Type:           int

        Created By:           User (required)

        Description:
          Time in seconds to wait for response

    * max_retries
        Type:           int

        Created By:           User (required)

        Description:
          Number of failures before declaring health bad

    * http_method
        Type:           str

        Created By:           User (optional)

        Description:
          In case monitor protocol is HTTP, type of http method used like GET, PUT, POST

          etc

    * url_path
        Type:           str

        Created By:           User (optional)

        Description:
          In case monitor protocol is HTTP, URL to be used. In case of ICMP, ip address

    * expected_codes
        Type:           str

        Created By:           User (optional)

        Description:
          In case monitor protocol is HTTP, expected return code for HTTP operations like

          200 ok.

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'admin_state', u'monitor_type', u'delay', u'timeout', u'max_retries', u'http_method', u'url_path', u'expected_codes']
    attr_field_type_vals = {u'delay': {'restrictions': None, 'description': [u'Time in seconds  at which health check is repeated'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'true', 'attr_type': u'integer'}, u'expected_codes': {'restrictions': None, 'description': [u'In case monitor protocol is HTTP, expected return code for HTTP operations like 200 ok.'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'max_retries': {'restrictions': None, 'description': [u'Number of failures before declaring health bad'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'true', 'attr_type': u'integer'}, u'http_method': {'restrictions': None, 'description': [u'In case monitor protocol is HTTP, type of http method used like GET, PUT, POST etc'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'admin_state': {'restrictions': None, 'description': [u'Administratively up or dowm.'], 'simple_type': u'xsd:boolean', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'boolean'}, u'timeout': {'restrictions': None, 'description': [u'Time in seconds to wait for response'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'true', 'attr_type': u'integer'}, u'url_path': {'restrictions': None, 'description': [u'In case monitor protocol is HTTP, URL to be used. In case of ICMP, ip address'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'monitor_type': {'restrictions': [u'PING', u'TCP', u'HTTP', u'HTTPS'], 'description': [u'Protocol used to monitor health, PING, HTTP, HTTPS or TCP'], 'simple_type': u'HealthmonitorType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'true', 'attr_type': u'string'}}
    def __init__(self, admin_state=True, monitor_type=None, delay=None, timeout=None, max_retries=None, http_method=None, url_path=None, expected_codes=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _admin_state = params_dict[u"admin_state"]
        except KeyError:
            _admin_state = admin_state
        self.admin_state = _admin_state
        try:
            _monitor_type = params_dict[u"monitor_type"]
        except KeyError:
            _monitor_type = monitor_type
        self.monitor_type = _monitor_type
        try:
            _delay = params_dict[u"delay"]
        except KeyError:
            _delay = delay
        self.delay = _delay
        try:
            _timeout = params_dict[u"timeout"]
        except KeyError:
            _timeout = timeout
        self.timeout = _timeout
        try:
            _max_retries = params_dict[u"max_retries"]
        except KeyError:
            _max_retries = max_retries
        self.max_retries = _max_retries
        try:
            _http_method = params_dict[u"http_method"]
        except KeyError:
            _http_method = http_method
        self.http_method = _http_method
        try:
            _url_path = params_dict[u"url_path"]
        except KeyError:
            _url_path = url_path
        self.url_path = _url_path
        try:
            _expected_codes = params_dict[u"expected_codes"]
        except KeyError:
            _expected_codes = expected_codes
        self.expected_codes = _expected_codes
    def factory(*args_, **kwargs_):
        if LoadbalancerHealthmonitorType.subclass:
            return LoadbalancerHealthmonitorType.subclass(*args_, **kwargs_)
        else:
            return LoadbalancerHealthmonitorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_admin_state(self): return self.admin_state
    def set_admin_state(self, admin_state): self.admin_state = admin_state
    def get_monitor_type(self): return self.monitor_type
    def set_monitor_type(self, monitor_type): self.monitor_type = monitor_type
    def validate_HealthmonitorType(self, value):
        # Validate type HealthmonitorType, a restriction on xsd:string.
        error = False
        if isinstance(value, list):
            error = set(value) - set([u'PING', u'TCP', u'HTTP', u'HTTPS'])
        else:
            error = value not in [u'PING', u'TCP', u'HTTP', u'HTTPS']
        if error:
            raise ValueError("HealthmonitorType must be one of [u'PING', u'TCP', u'HTTP', u'HTTPS']")
    def get_delay(self): return self.delay
    def set_delay(self, delay): self.delay = delay
    def get_timeout(self): return self.timeout
    def set_timeout(self, timeout): self.timeout = timeout
    def get_max_retries(self): return self.max_retries
    def set_max_retries(self, max_retries): self.max_retries = max_retries
    def get_http_method(self): return self.http_method
    def set_http_method(self, http_method): self.http_method = http_method
    def get_url_path(self): return self.url_path
    def set_url_path(self, url_path): self.url_path = url_path
    def get_expected_codes(self): return self.expected_codes
    def set_expected_codes(self, expected_codes): self.expected_codes = expected_codes
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.admin_state == other.admin_state and
                    self.monitor_type == other.monitor_type and
                    self.delay == other.delay and
                    self.timeout == other.timeout and
                    self.max_retries == other.max_retries and
                    self.http_method == other.http_method and
                    self.url_path == other.url_path and
                    self.expected_codes == other.expected_codes)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.admin_state if self.admin_state is not None else -7985492147856592190,
                     self.monitor_type if self.monitor_type is not None else -7985492147856592190,
                     self.delay if self.delay is not None else -7985492147856592190,
                     self.timeout if self.timeout is not None else -7985492147856592190,
                     self.max_retries if self.max_retries is not None else -7985492147856592190,
                     self.http_method if self.http_method is not None else -7985492147856592190,
                     self.url_path if self.url_path is not None else -7985492147856592190,
                     self.expected_codes if self.expected_codes is not None else -7985492147856592190))

    def __repr__(self):
        return ("admin_state = " + str(self.admin_state) + ", " +
                "monitor_type = " + str(self.monitor_type) + ", " +
                "delay = " + str(self.delay) + ", " +
                "timeout = " + str(self.timeout) + ", " +
                "max_retries = " + str(self.max_retries) + ", " +
                "http_method = " + str(self.http_method) + ", " +
                "url_path = " + str(self.url_path) + ", " +
                "expected_codes = " + str(self.expected_codes))

    def copy(self):
        cp = LoadbalancerHealthmonitorType()
        if self.admin_state is not None:
            cp.admin_state = self.admin_state
        if self.monitor_type is not None:
            cp.monitor_type = self.monitor_type
        if self.delay is not None:
            cp.delay = self.delay
        if self.timeout is not None:
            cp.timeout = self.timeout
        if self.max_retries is not None:
            cp.max_retries = self.max_retries
        if self.http_method is not None:
            cp.http_method = self.http_method
        if self.url_path is not None:
            cp.url_path = self.url_path
        if self.expected_codes is not None:
            cp.expected_codes = self.expected_codes
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_admin_state (obj.populate_boolean ("admin_state"))
        obj.set_monitor_type (obj.populate_string ("monitor_type"))
        obj.set_delay (obj.populate_integer ("delay"))
        obj.set_timeout (obj.populate_integer ("timeout"))
        obj.set_max_retries (obj.populate_integer ("max_retries"))
        obj.set_http_method (obj.populate_string ("http_method"))
        obj.set_url_path (obj.populate_string ("url_path"))
        obj.set_expected_codes (obj.populate_string ("expected_codes"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='LoadbalancerHealthmonitorType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LoadbalancerHealthmonitorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LoadbalancerHealthmonitorType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LoadbalancerHealthmonitorType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.admin_state is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sadmin-state>%s</%sadmin-state>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.admin_state)), input_name='admin-state'), namespace_, eol_))
        if self.monitor_type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smonitor-type>%s</%smonitor-type>%s' % (namespace_, self.gds_format_string(quote_xml(self.monitor_type).encode(ExternalEncoding), input_name='monitor-type'), namespace_, eol_))
        if self.delay is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdelay>%s</%sdelay>%s' % (namespace_, self.gds_format_integer(self.delay, input_name='delay'), namespace_, eol_))
        if self.timeout is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stimeout>%s</%stimeout>%s' % (namespace_, self.gds_format_integer(self.timeout, input_name='timeout'), namespace_, eol_))
        if self.max_retries is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smax-retries>%s</%smax-retries>%s' % (namespace_, self.gds_format_integer(self.max_retries, input_name='max-retries'), namespace_, eol_))
        if self.http_method is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shttp-method>%s</%shttp-method>%s' % (namespace_, self.gds_format_string(quote_xml(self.http_method).encode(ExternalEncoding), input_name='http-method'), namespace_, eol_))
        if self.url_path is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%surl-path>%s</%surl-path>%s' % (namespace_, self.gds_format_string(quote_xml(self.url_path).encode(ExternalEncoding), input_name='url-path'), namespace_, eol_))
        if self.expected_codes is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexpected-codes>%s</%sexpected-codes>%s' % (namespace_, self.gds_format_string(quote_xml(self.expected_codes).encode(ExternalEncoding), input_name='expected-codes'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.admin_state is not None or
            self.monitor_type is not None or
            self.delay is not None or
            self.timeout is not None or
            self.max_retries is not None or
            self.http_method is not None or
            self.url_path is not None or
            self.expected_codes is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LoadbalancerHealthmonitorType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.admin_state is not None:
            showIndent(outfile, level)
            outfile.write('admin_state=%s,\n' % self.admin_state)
        if self.monitor_type is not None:
            showIndent(outfile, level)
            outfile.write('monitor_type=%s,\n' % quote_python(self.monitor_type).encode(ExternalEncoding))
        if self.delay is not None:
            showIndent(outfile, level)
            outfile.write('delay=%d,\n' % self.delay)
        if self.timeout is not None:
            showIndent(outfile, level)
            outfile.write('timeout=%d,\n' % self.timeout)
        if self.max_retries is not None:
            showIndent(outfile, level)
            outfile.write('max_retries=%d,\n' % self.max_retries)
        if self.http_method is not None:
            showIndent(outfile, level)
            outfile.write('http_method=%s,\n' % quote_python(self.http_method).encode(ExternalEncoding))
        if self.url_path is not None:
            showIndent(outfile, level)
            outfile.write('url_path=%s,\n' % quote_python(self.url_path).encode(ExternalEncoding))
        if self.expected_codes is not None:
            showIndent(outfile, level)
            outfile.write('expected_codes=%s,\n' % quote_python(self.expected_codes).encode(ExternalEncoding))
    def exportDict(self, name_='LoadbalancerHealthmonitorType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'admin-state':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'admin_state')
            self.admin_state = ival_
        elif nodeName_ == 'monitor-type':
            monitor_type_ = child_.text
            monitor_type_ = self.gds_validate_string(monitor_type_, node, 'monitor_type')
            self.monitor_type = monitor_type_
            self.validate_HealthmonitorType(self.monitor_type)    # validate type HealthmonitorType
        elif nodeName_ == 'delay':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'delay')
            self.delay = ival_
        elif nodeName_ == 'timeout':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'timeout')
            self.timeout = ival_
        elif nodeName_ == 'max-retries':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'max_retries')
            self.max_retries = ival_
        elif nodeName_ == 'http-method':
            http_method_ = child_.text
            http_method_ = self.gds_validate_string(http_method_, node, 'http_method')
            self.http_method = http_method_
        elif nodeName_ == 'url-path':
            url_path_ = child_.text
            url_path_ = self.gds_validate_string(url_path_, node, 'url_path')
            self.url_path = url_path_
        elif nodeName_ == 'expected-codes':
            expected_codes_ = child_.text
            expected_codes_ = self.gds_validate_string(expected_codes_, node, 'expected_codes')
            self.expected_codes = expected_codes_
# end class LoadbalancerHealthmonitorType


class VirtualIpType(GeneratedsSuper):
    """
    Attributes:
    * address
        Type:           str, *one-of* xsd:string

        Description:
          IP address automatically allocated by system.

    * status
        Type:           str

        Description:
          Operating status for this virtual ip.

    * status_description
        Type:           str

        Description:
          Operating status description this virtual ip.

    * admin_state
        Type:           bool

        Created By:           User (optional)

        Description:
          Administrative up or down.

    * protocol
        Type:           str, *one-of* [u'HTTP', u'HTTPS', u'TCP', u'UDP', u'TERMINATED_HTTPS']

        Created By:           User (optional)

        Description:
          IP protocol string like http, https or tcp.

    * protocol_port
        Type:           int

        Created By:           User (optional)

        Description:
          Layer 4 protocol destination port.

    * connection_limit
        Type:           int

        Created By:           User (optional)

        Description:
          Maximum number of concurrent connections

    * subnet_id
        Type:           str, *one-of* xsd:string

        Created By:           User (optional)

        Description:
          UUID of subnet in which to allocate the Virtual IP.

    * persistence_cookie_name
        Type:           str

        Created By:           User (optional)

        Description:
          Set this string if the relation of client and server(pool member) need to

          persist.

    * persistence_type
        Type:           str, *one-of* [u'SOURCE_IP', u'HTTP_COOKIE', u'APP_COOKIE']

        Created By:           User (optional)

        Description:
          Method for persistence. HTTP_COOKIE, SOURCE_IP or APP_COOKIE.

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'address', u'status', u'status_description', u'admin_state', u'protocol', u'protocol_port', u'connection_limit', u'subnet_id', u'persistence_cookie_name', u'persistence_type']
    attr_field_type_vals = {u'status': {'restrictions': None, 'description': [u'Operating status for this virtual ip.'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'system-only', 'attr_type': u'string'}, u'status_description': {'restrictions': None, 'description': [u'Operating status description this virtual ip.'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'system-only', 'attr_type': u'string'}, u'protocol': {'restrictions': [u'HTTP', u'HTTPS', u'TCP', u'UDP', u'TERMINATED_HTTPS'], 'description': [u'IP protocol string like http, https or tcp.'], 'simple_type': u'LoadbalancerProtocolType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'required', 'attr_type': u'string'}, u'subnet_id': {'restrictions': [], 'description': [u'UUID of subnet in which to allocate the Virtual IP.'], 'simple_type': u'UuidStringType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'required', 'attr_type': u'string'}, u'persistence_cookie_name': {'restrictions': None, 'description': [u'Set this string if the relation of client and server(pool member) need to persist.'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'connection_limit': {'restrictions': None, 'description': [u'Maximum number of concurrent connections'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'persistence_type': {'restrictions': [u'SOURCE_IP', u'HTTP_COOKIE', u'APP_COOKIE'], 'description': [u'Method for persistence. HTTP_COOKIE, SOURCE_IP or APP_COOKIE.'], 'simple_type': u'SessionPersistenceType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'admin_state': {'restrictions': None, 'description': [u'Administrative up or down.'], 'simple_type': u'xsd:boolean', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'boolean'}, u'address': {'restrictions': [], 'description': [u'IP address automatically allocated by system.'], 'simple_type': u'IpAddressType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'system-only', 'attr_type': u'string'}, u'protocol_port': {'restrictions': None, 'description': [u'Layer 4 protocol destination port.'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'required', 'attr_type': u'integer'}}
    def __init__(self, address=None, status=None, status_description=None, admin_state=True, protocol=None, protocol_port=None, connection_limit=None, subnet_id=None, persistence_cookie_name=None, persistence_type=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _address = params_dict[u"address"]
        except KeyError:
            _address = address
        self.address = _address
        try:
            _status = params_dict[u"status"]
        except KeyError:
            _status = status
        self.status = _status
        try:
            _status_description = params_dict[u"status_description"]
        except KeyError:
            _status_description = status_description
        self.status_description = _status_description
        try:
            _admin_state = params_dict[u"admin_state"]
        except KeyError:
            _admin_state = admin_state
        self.admin_state = _admin_state
        try:
            _protocol = params_dict[u"protocol"]
        except KeyError:
            _protocol = protocol
        self.protocol = _protocol
        try:
            _protocol_port = params_dict[u"protocol_port"]
        except KeyError:
            _protocol_port = protocol_port
        self.protocol_port = _protocol_port
        try:
            _connection_limit = params_dict[u"connection_limit"]
        except KeyError:
            _connection_limit = connection_limit
        self.connection_limit = _connection_limit
        try:
            _subnet_id = params_dict[u"subnet_id"]
        except KeyError:
            _subnet_id = subnet_id
        self.subnet_id = _subnet_id
        try:
            _persistence_cookie_name = params_dict[u"persistence_cookie_name"]
        except KeyError:
            _persistence_cookie_name = persistence_cookie_name
        self.persistence_cookie_name = _persistence_cookie_name
        try:
            _persistence_type = params_dict[u"persistence_type"]
        except KeyError:
            _persistence_type = persistence_type
        self.persistence_type = _persistence_type
    def factory(*args_, **kwargs_):
        if VirtualIpType.subclass:
            return VirtualIpType.subclass(*args_, **kwargs_)
        else:
            return VirtualIpType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_address(self): return self.address
    def set_address(self, address): self.address = address
    def validate_IpAddressType(self, value):
        # Validate type IpAddressType, a restriction on xsd:string.
        pass
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_status_description(self): return self.status_description
    def set_status_description(self, status_description): self.status_description = status_description
    def get_admin_state(self): return self.admin_state
    def set_admin_state(self, admin_state): self.admin_state = admin_state
    def get_protocol(self): return self.protocol
    def set_protocol(self, protocol): self.protocol = protocol
    def validate_LoadbalancerProtocolType(self, value):
        # Validate type LoadbalancerProtocolType, a restriction on xsd:string.
        error = False
        if isinstance(value, list):
            error = set(value) - set([u'HTTP', u'HTTPS', u'TCP', u'UDP', u'TERMINATED_HTTPS'])
        else:
            error = value not in [u'HTTP', u'HTTPS', u'TCP', u'UDP', u'TERMINATED_HTTPS']
        if error:
            raise ValueError("LoadbalancerProtocolType must be one of [u'HTTP', u'HTTPS', u'TCP', u'UDP', u'TERMINATED_HTTPS']")
    def get_protocol_port(self): return self.protocol_port
    def set_protocol_port(self, protocol_port): self.protocol_port = protocol_port
    def get_connection_limit(self): return self.connection_limit
    def set_connection_limit(self, connection_limit): self.connection_limit = connection_limit
    def get_subnet_id(self): return self.subnet_id
    def set_subnet_id(self, subnet_id): self.subnet_id = subnet_id
    def validate_UuidStringType(self, value):
        # Validate type UuidStringType, a restriction on xsd:string.
        pass
    def get_persistence_cookie_name(self): return self.persistence_cookie_name
    def set_persistence_cookie_name(self, persistence_cookie_name): self.persistence_cookie_name = persistence_cookie_name
    def get_persistence_type(self): return self.persistence_type
    def set_persistence_type(self, persistence_type): self.persistence_type = persistence_type
    def validate_SessionPersistenceType(self, value):
        # Validate type SessionPersistenceType, a restriction on xsd:string.
        error = False
        if isinstance(value, list):
            error = set(value) - set([u'SOURCE_IP', u'HTTP_COOKIE', u'APP_COOKIE'])
        else:
            error = value not in [u'SOURCE_IP', u'HTTP_COOKIE', u'APP_COOKIE']
        if error:
            raise ValueError("SessionPersistenceType must be one of [u'SOURCE_IP', u'HTTP_COOKIE', u'APP_COOKIE']")
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.address == other.address and
                    self.status == other.status and
                    self.status_description == other.status_description and
                    self.admin_state == other.admin_state and
                    self.protocol == other.protocol and
                    self.protocol_port == other.protocol_port and
                    self.connection_limit == other.connection_limit and
                    self.subnet_id == other.subnet_id and
                    self.persistence_cookie_name == other.persistence_cookie_name and
                    self.persistence_type == other.persistence_type)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.address if self.address is not None else -7985492147856592190,
                     self.status if self.status is not None else -7985492147856592190,
                     self.status_description if self.status_description is not None else -7985492147856592190,
                     self.admin_state if self.admin_state is not None else -7985492147856592190,
                     self.protocol if self.protocol is not None else -7985492147856592190,
                     self.protocol_port if self.protocol_port is not None else -7985492147856592190,
                     self.connection_limit if self.connection_limit is not None else -7985492147856592190,
                     self.subnet_id if self.subnet_id is not None else -7985492147856592190,
                     self.persistence_cookie_name if self.persistence_cookie_name is not None else -7985492147856592190,
                     self.persistence_type if self.persistence_type is not None else -7985492147856592190))

    def __repr__(self):
        return ("address = " + str(self.address) + ", " +
                "status = " + str(self.status) + ", " +
                "status_description = " + str(self.status_description) + ", " +
                "admin_state = " + str(self.admin_state) + ", " +
                "protocol = " + str(self.protocol) + ", " +
                "protocol_port = " + str(self.protocol_port) + ", " +
                "connection_limit = " + str(self.connection_limit) + ", " +
                "subnet_id = " + str(self.subnet_id) + ", " +
                "persistence_cookie_name = " + str(self.persistence_cookie_name) + ", " +
                "persistence_type = " + str(self.persistence_type))

    def copy(self):
        cp = VirtualIpType()
        if self.address is not None:
            cp.address = self.address
        if self.status is not None:
            cp.status = self.status
        if self.status_description is not None:
            cp.status_description = self.status_description
        if self.admin_state is not None:
            cp.admin_state = self.admin_state
        if self.protocol is not None:
            cp.protocol = self.protocol
        if self.protocol_port is not None:
            cp.protocol_port = self.protocol_port
        if self.connection_limit is not None:
            cp.connection_limit = self.connection_limit
        if self.subnet_id is not None:
            cp.subnet_id = self.subnet_id
        if self.persistence_cookie_name is not None:
            cp.persistence_cookie_name = self.persistence_cookie_name
        if self.persistence_type is not None:
            cp.persistence_type = self.persistence_type
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_address (obj.populate_string ("address"))
        obj.set_status (obj.populate_string ("status"))
        obj.set_status_description (obj.populate_string ("status_description"))
        obj.set_admin_state (obj.populate_boolean ("admin_state"))
        obj.set_protocol (obj.populate_string ("protocol"))
        obj.set_protocol_port (obj.populate_integer ("protocol_port"))
        obj.set_connection_limit (obj.populate_integer ("connection_limit"))
        obj.set_subnet_id (obj.populate_string ("subnet_id"))
        obj.set_persistence_cookie_name (obj.populate_string ("persistence_cookie_name"))
        obj.set_persistence_type (obj.populate_string ("persistence_type"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='VirtualIpType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VirtualIpType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VirtualIpType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VirtualIpType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.address is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saddress>%s</%saddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.address).encode(ExternalEncoding), input_name='address'), namespace_, eol_))
        if self.status is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstatus>%s</%sstatus>%s' % (namespace_, self.gds_format_string(quote_xml(self.status).encode(ExternalEncoding), input_name='status'), namespace_, eol_))
        if self.status_description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstatus-description>%s</%sstatus-description>%s' % (namespace_, self.gds_format_string(quote_xml(self.status_description).encode(ExternalEncoding), input_name='status-description'), namespace_, eol_))
        if self.admin_state is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sadmin-state>%s</%sadmin-state>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.admin_state)), input_name='admin-state'), namespace_, eol_))
        if self.protocol is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprotocol>%s</%sprotocol>%s' % (namespace_, self.gds_format_string(quote_xml(self.protocol).encode(ExternalEncoding), input_name='protocol'), namespace_, eol_))
        if self.protocol_port is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprotocol-port>%s</%sprotocol-port>%s' % (namespace_, self.gds_format_integer(self.protocol_port, input_name='protocol-port'), namespace_, eol_))
        if self.connection_limit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sconnection-limit>%s</%sconnection-limit>%s' % (namespace_, self.gds_format_integer(self.connection_limit, input_name='connection-limit'), namespace_, eol_))
        if self.subnet_id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssubnet-id>%s</%ssubnet-id>%s' % (namespace_, self.gds_format_string(quote_xml(self.subnet_id).encode(ExternalEncoding), input_name='subnet-id'), namespace_, eol_))
        if self.persistence_cookie_name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spersistence-cookie-name>%s</%spersistence-cookie-name>%s' % (namespace_, self.gds_format_string(quote_xml(self.persistence_cookie_name).encode(ExternalEncoding), input_name='persistence-cookie-name'), namespace_, eol_))
        if self.persistence_type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spersistence-type>%s</%spersistence-type>%s' % (namespace_, self.gds_format_string(quote_xml(self.persistence_type).encode(ExternalEncoding), input_name='persistence-type'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.address is not None or
            self.status is not None or
            self.status_description is not None or
            self.admin_state is not None or
            self.protocol is not None or
            self.protocol_port is not None or
            self.connection_limit is not None or
            self.subnet_id is not None or
            self.persistence_cookie_name is not None or
            self.persistence_type is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='VirtualIpType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.address is not None:
            showIndent(outfile, level)
            outfile.write('address=%s,\n' % quote_python(self.address).encode(ExternalEncoding))
        if self.status is not None:
            showIndent(outfile, level)
            outfile.write('status=%s,\n' % quote_python(self.status).encode(ExternalEncoding))
        if self.status_description is not None:
            showIndent(outfile, level)
            outfile.write('status_description=%s,\n' % quote_python(self.status_description).encode(ExternalEncoding))
        if self.admin_state is not None:
            showIndent(outfile, level)
            outfile.write('admin_state=%s,\n' % self.admin_state)
        if self.protocol is not None:
            showIndent(outfile, level)
            outfile.write('protocol=%s,\n' % quote_python(self.protocol).encode(ExternalEncoding))
        if self.protocol_port is not None:
            showIndent(outfile, level)
            outfile.write('protocol_port=%d,\n' % self.protocol_port)
        if self.connection_limit is not None:
            showIndent(outfile, level)
            outfile.write('connection_limit=%d,\n' % self.connection_limit)
        if self.subnet_id is not None:
            showIndent(outfile, level)
            outfile.write('subnet_id=%s,\n' % quote_python(self.subnet_id).encode(ExternalEncoding))
        if self.persistence_cookie_name is not None:
            showIndent(outfile, level)
            outfile.write('persistence_cookie_name=%s,\n' % quote_python(self.persistence_cookie_name).encode(ExternalEncoding))
        if self.persistence_type is not None:
            showIndent(outfile, level)
            outfile.write('persistence_type=%s,\n' % quote_python(self.persistence_type).encode(ExternalEncoding))
    def exportDict(self, name_='VirtualIpType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'address':
            address_ = child_.text
            address_ = self.gds_validate_string(address_, node, 'address')
            self.address = address_
            self.validate_IpAddressType(self.address)    # validate type IpAddressType
        elif nodeName_ == 'status':
            status_ = child_.text
            status_ = self.gds_validate_string(status_, node, 'status')
            self.status = status_
        elif nodeName_ == 'status-description':
            status_description_ = child_.text
            status_description_ = self.gds_validate_string(status_description_, node, 'status_description')
            self.status_description = status_description_
        elif nodeName_ == 'admin-state':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'admin_state')
            self.admin_state = ival_
        elif nodeName_ == 'protocol':
            protocol_ = child_.text
            protocol_ = self.gds_validate_string(protocol_, node, 'protocol')
            self.protocol = protocol_
            self.validate_LoadbalancerProtocolType(self.protocol)    # validate type LoadbalancerProtocolType
        elif nodeName_ == 'protocol-port':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'protocol_port')
            self.protocol_port = ival_
        elif nodeName_ == 'connection-limit':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'connection_limit')
            self.connection_limit = ival_
        elif nodeName_ == 'subnet-id':
            subnet_id_ = child_.text
            subnet_id_ = self.gds_validate_string(subnet_id_, node, 'subnet_id')
            self.subnet_id = subnet_id_
            self.validate_UuidStringType(self.subnet_id)    # validate type UuidStringType
        elif nodeName_ == 'persistence-cookie-name':
            persistence_cookie_name_ = child_.text
            persistence_cookie_name_ = self.gds_validate_string(persistence_cookie_name_, node, 'persistence_cookie_name')
            self.persistence_cookie_name = persistence_cookie_name_
        elif nodeName_ == 'persistence-type':
            persistence_type_ = child_.text
            persistence_type_ = self.gds_validate_string(persistence_type_, node, 'persistence_type')
            self.persistence_type = persistence_type_
            self.validate_SessionPersistenceType(self.persistence_type)    # validate type SessionPersistenceType
# end class VirtualIpType


class LoadbalancerListenerType(GeneratedsSuper):
    """
    Attributes:
    * protocol
        Type:           str, *one-of* [u'HTTP', u'HTTPS', u'TCP', u'UDP', u'TERMINATED_HTTPS']

    * protocol_port
        Type:           int

    * admin_state
        Type:           bool

    * connection_limit
        Type:           int

    * default_tls_container
        Type:           str

    * sni_containers
        Type:           str

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'protocol', u'protocol_port', u'admin_state', u'connection_limit', u'default_tls_container', u'sni_containers']
    attr_field_type_vals = {u'default_tls_container': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'protocol': {'restrictions': [u'HTTP', u'HTTPS', u'TCP', u'UDP', u'TERMINATED_HTTPS'], 'description': [], 'simple_type': u'LoadbalancerProtocolType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': None, 'attr_type': u'string'}, u'connection_limit': {'restrictions': None, 'description': [], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'integer'}, u'admin_state': {'restrictions': None, 'description': [], 'simple_type': u'xsd:boolean', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'boolean'}, u'sni_containers': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': True, 'required': None, 'attr_type': u'string'}, u'protocol_port': {'restrictions': None, 'description': [], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'integer'}}
    def __init__(self, protocol=None, protocol_port=None, admin_state=True, connection_limit=None, default_tls_container=None, sni_containers=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _protocol = params_dict[u"protocol"]
        except KeyError:
            _protocol = protocol
        self.protocol = _protocol
        try:
            _protocol_port = params_dict[u"protocol_port"]
        except KeyError:
            _protocol_port = protocol_port
        self.protocol_port = _protocol_port
        try:
            _admin_state = params_dict[u"admin_state"]
        except KeyError:
            _admin_state = admin_state
        self.admin_state = _admin_state
        try:
            _connection_limit = params_dict[u"connection_limit"]
        except KeyError:
            _connection_limit = connection_limit
        self.connection_limit = _connection_limit
        try:
            _default_tls_container = params_dict[u"default_tls_container"]
        except KeyError:
            _default_tls_container = default_tls_container
        self.default_tls_container = _default_tls_container
        try:
            _sni_containers = params_dict[u"sni_containers"]
        except KeyError:
            _sni_containers = sni_containers
        if not _sni_containers:
            self.sni_containers = []
        else:
            self.sni_containers = _sni_containers
    def factory(*args_, **kwargs_):
        if LoadbalancerListenerType.subclass:
            return LoadbalancerListenerType.subclass(*args_, **kwargs_)
        else:
            return LoadbalancerListenerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_protocol(self): return self.protocol
    def set_protocol(self, protocol): self.protocol = protocol
    def validate_LoadbalancerProtocolType(self, value):
        # Validate type LoadbalancerProtocolType, a restriction on xsd:string.
        error = False
        if isinstance(value, list):
            error = set(value) - set([u'HTTP', u'HTTPS', u'TCP', u'UDP', u'TERMINATED_HTTPS'])
        else:
            error = value not in [u'HTTP', u'HTTPS', u'TCP', u'UDP', u'TERMINATED_HTTPS']
        if error:
            raise ValueError("LoadbalancerProtocolType must be one of [u'HTTP', u'HTTPS', u'TCP', u'UDP', u'TERMINATED_HTTPS']")
    def get_protocol_port(self): return self.protocol_port
    def set_protocol_port(self, protocol_port): self.protocol_port = protocol_port
    def get_admin_state(self): return self.admin_state
    def set_admin_state(self, admin_state): self.admin_state = admin_state
    def get_connection_limit(self): return self.connection_limit
    def set_connection_limit(self, connection_limit): self.connection_limit = connection_limit
    def get_default_tls_container(self): return self.default_tls_container
    def set_default_tls_container(self, default_tls_container): self.default_tls_container = default_tls_container
    def get_sni_containers(self): return self.sni_containers
    def set_sni_containers(self, sni_containers): self.sni_containers = sni_containers
    def add_sni_containers(self, value): self.sni_containers.append(value)
    def insert_sni_containers(self, index, value): self.sni_containers[index] = value
    def delete_sni_containers(self, value): self.sni_containers.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.protocol == other.protocol and
                    self.protocol_port == other.protocol_port and
                    self.admin_state == other.admin_state and
                    self.connection_limit == other.connection_limit and
                    self.default_tls_container == other.default_tls_container and
                    self.sni_containers == other.sni_containers)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.protocol if self.protocol is not None else -7985492147856592190,
                     self.protocol_port if self.protocol_port is not None else -7985492147856592190,
                     self.admin_state if self.admin_state is not None else -7985492147856592190,
                     self.connection_limit if self.connection_limit is not None else -7985492147856592190,
                     self.default_tls_container if self.default_tls_container is not None else -7985492147856592190,
                     tuple(self.sni_containers or [])))

    def __repr__(self):
        return ("protocol = " + str(self.protocol) + ", " +
                "protocol_port = " + str(self.protocol_port) + ", " +
                "admin_state = " + str(self.admin_state) + ", " +
                "connection_limit = " + str(self.connection_limit) + ", " +
                "default_tls_container = " + str(self.default_tls_container) + ", " +
                "sni_containers = " + str(self.sni_containers))

    def copy(self):
        cp = LoadbalancerListenerType()
        if self.protocol is not None:
            cp.protocol = self.protocol
        if self.protocol_port is not None:
            cp.protocol_port = self.protocol_port
        if self.admin_state is not None:
            cp.admin_state = self.admin_state
        if self.connection_limit is not None:
            cp.connection_limit = self.connection_limit
        if self.default_tls_container is not None:
            cp.default_tls_container = self.default_tls_container
        if self.sni_containers is not None:
            cp.sni_containers = list(self.sni_containers)
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_protocol (obj.populate_string ("protocol"))
        obj.set_protocol_port (obj.populate_integer ("protocol_port"))
        obj.set_admin_state (obj.populate_boolean ("admin_state"))
        obj.set_connection_limit (obj.populate_integer ("connection_limit"))
        obj.set_default_tls_container (obj.populate_string ("default_tls_container"))
        obj.set_sni_containers ([obj.populate_string ("sni_containers")])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='LoadbalancerListenerType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LoadbalancerListenerType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LoadbalancerListenerType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LoadbalancerListenerType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.protocol is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprotocol>%s</%sprotocol>%s' % (namespace_, self.gds_format_string(quote_xml(self.protocol).encode(ExternalEncoding), input_name='protocol'), namespace_, eol_))
        if self.protocol_port is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprotocol-port>%s</%sprotocol-port>%s' % (namespace_, self.gds_format_integer(self.protocol_port, input_name='protocol-port'), namespace_, eol_))
        if self.admin_state is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sadmin-state>%s</%sadmin-state>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.admin_state)), input_name='admin-state'), namespace_, eol_))
        if self.connection_limit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sconnection-limit>%s</%sconnection-limit>%s' % (namespace_, self.gds_format_integer(self.connection_limit, input_name='connection-limit'), namespace_, eol_))
        if self.default_tls_container is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdefault-tls-container>%s</%sdefault-tls-container>%s' % (namespace_, self.gds_format_string(quote_xml(self.default_tls_container).encode(ExternalEncoding), input_name='default-tls-container'), namespace_, eol_))
        for sni_containers_ in self.sni_containers:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssni-containers>%s</%ssni-containers>%s' % (namespace_, self.gds_format_string(quote_xml(sni_containers_).encode(ExternalEncoding), input_name='sni-containers'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.protocol is not None or
            self.protocol_port is not None or
            self.admin_state is not None or
            self.connection_limit is not None or
            self.default_tls_container is not None or
            self.sni_containers
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LoadbalancerListenerType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.protocol is not None:
            showIndent(outfile, level)
            outfile.write('protocol=%s,\n' % quote_python(self.protocol).encode(ExternalEncoding))
        if self.protocol_port is not None:
            showIndent(outfile, level)
            outfile.write('protocol_port=%d,\n' % self.protocol_port)
        if self.admin_state is not None:
            showIndent(outfile, level)
            outfile.write('admin_state=%s,\n' % self.admin_state)
        if self.connection_limit is not None:
            showIndent(outfile, level)
            outfile.write('connection_limit=%d,\n' % self.connection_limit)
        if self.default_tls_container is not None:
            showIndent(outfile, level)
            outfile.write('default_tls_container=%s,\n' % quote_python(self.default_tls_container).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('sni_containers=[\n')
        level += 1
        for sni_containers_ in self.sni_containers:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(sni_containers_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='LoadbalancerListenerType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'protocol':
            protocol_ = child_.text
            protocol_ = self.gds_validate_string(protocol_, node, 'protocol')
            self.protocol = protocol_
            self.validate_LoadbalancerProtocolType(self.protocol)    # validate type LoadbalancerProtocolType
        elif nodeName_ == 'protocol-port':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'protocol_port')
            self.protocol_port = ival_
        elif nodeName_ == 'admin-state':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'admin_state')
            self.admin_state = ival_
        elif nodeName_ == 'connection-limit':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'connection_limit')
            self.connection_limit = ival_
        elif nodeName_ == 'default-tls-container':
            default_tls_container_ = child_.text
            default_tls_container_ = self.gds_validate_string(default_tls_container_, node, 'default_tls_container')
            self.default_tls_container = default_tls_container_
        elif nodeName_ == 'sni-containers':
            sni_containers_ = child_.text
            sni_containers_ = self.gds_validate_string(sni_containers_, node, 'sni_containers')
            self.sni_containers.append(sni_containers_)
# end class LoadbalancerListenerType


class LoadbalancerType(GeneratedsSuper):
    """
    Attributes:
    * status
        Type:           str

        Created By:           User (optional)

        Description:
          Operational status of the load balancer updated by system.

    * provisioning_status
        Type:           str

        Created By:           User (optional)

        Description:
          Provisioning  status of the load balancer updated by system.

    * operating_status
        Type:           str

        Created By:           User (optional)

        Description:
          Operational status of the load balancer updated by system.

    * vip_subnet_id
        Type:           str, *one-of* xsd:string

        Created By:           User (optional)

        Description:
          Subnet UUID of the subnet of VIP, representing virtual network.

    * vip_address
        Type:           str, *one-of* xsd:string

        Created By:           User (optional)

        Description:
          Virtual ip for this LBaaS

    * admin_state
        Type:           bool

        Created By:           User (optional)

        Description:
          Administrative up or down

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'status', u'provisioning_status', u'operating_status', u'vip_subnet_id', u'vip_address', u'admin_state']
    attr_field_type_vals = {u'status': {'restrictions': None, 'description': [u'Operational status of the load balancer updated by system.'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'provisioning_status': {'restrictions': None, 'description': [u'Provisioning  status of the load balancer updated by system.'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'admin_state': {'restrictions': None, 'description': [u'Administrative up or down'], 'simple_type': u'xsd:boolean', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'boolean'}, u'vip_address': {'restrictions': [], 'description': [u'Virtual ip for this LBaaS'], 'simple_type': u'IpAddressType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'vip_subnet_id': {'restrictions': [], 'description': [u'Subnet UUID of the subnet of VIP, representing virtual network.'], 'simple_type': u'UuidStringType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'required', 'attr_type': u'string'}, u'operating_status': {'restrictions': None, 'description': [u'Operational status of the load balancer updated by system.'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'string'}}
    def __init__(self, status=None, provisioning_status=None, operating_status=None, vip_subnet_id=None, vip_address=None, admin_state=True, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _status = params_dict[u"status"]
        except KeyError:
            _status = status
        self.status = _status
        try:
            _provisioning_status = params_dict[u"provisioning_status"]
        except KeyError:
            _provisioning_status = provisioning_status
        self.provisioning_status = _provisioning_status
        try:
            _operating_status = params_dict[u"operating_status"]
        except KeyError:
            _operating_status = operating_status
        self.operating_status = _operating_status
        try:
            _vip_subnet_id = params_dict[u"vip_subnet_id"]
        except KeyError:
            _vip_subnet_id = vip_subnet_id
        self.vip_subnet_id = _vip_subnet_id
        try:
            _vip_address = params_dict[u"vip_address"]
        except KeyError:
            _vip_address = vip_address
        self.vip_address = _vip_address
        try:
            _admin_state = params_dict[u"admin_state"]
        except KeyError:
            _admin_state = admin_state
        self.admin_state = _admin_state
    def factory(*args_, **kwargs_):
        if LoadbalancerType.subclass:
            return LoadbalancerType.subclass(*args_, **kwargs_)
        else:
            return LoadbalancerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_provisioning_status(self): return self.provisioning_status
    def set_provisioning_status(self, provisioning_status): self.provisioning_status = provisioning_status
    def get_operating_status(self): return self.operating_status
    def set_operating_status(self, operating_status): self.operating_status = operating_status
    def get_vip_subnet_id(self): return self.vip_subnet_id
    def set_vip_subnet_id(self, vip_subnet_id): self.vip_subnet_id = vip_subnet_id
    def validate_UuidStringType(self, value):
        # Validate type UuidStringType, a restriction on xsd:string.
        pass
    def get_vip_address(self): return self.vip_address
    def set_vip_address(self, vip_address): self.vip_address = vip_address
    def validate_IpAddressType(self, value):
        # Validate type IpAddressType, a restriction on xsd:string.
        pass
    def get_admin_state(self): return self.admin_state
    def set_admin_state(self, admin_state): self.admin_state = admin_state
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.status == other.status and
                    self.provisioning_status == other.provisioning_status and
                    self.operating_status == other.operating_status and
                    self.vip_subnet_id == other.vip_subnet_id and
                    self.vip_address == other.vip_address and
                    self.admin_state == other.admin_state)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.status if self.status is not None else -7985492147856592190,
                     self.provisioning_status if self.provisioning_status is not None else -7985492147856592190,
                     self.operating_status if self.operating_status is not None else -7985492147856592190,
                     self.vip_subnet_id if self.vip_subnet_id is not None else -7985492147856592190,
                     self.vip_address if self.vip_address is not None else -7985492147856592190,
                     self.admin_state if self.admin_state is not None else -7985492147856592190))

    def __repr__(self):
        return ("status = " + str(self.status) + ", " +
                "provisioning_status = " + str(self.provisioning_status) + ", " +
                "operating_status = " + str(self.operating_status) + ", " +
                "vip_subnet_id = " + str(self.vip_subnet_id) + ", " +
                "vip_address = " + str(self.vip_address) + ", " +
                "admin_state = " + str(self.admin_state))

    def copy(self):
        cp = LoadbalancerType()
        if self.status is not None:
            cp.status = self.status
        if self.provisioning_status is not None:
            cp.provisioning_status = self.provisioning_status
        if self.operating_status is not None:
            cp.operating_status = self.operating_status
        if self.vip_subnet_id is not None:
            cp.vip_subnet_id = self.vip_subnet_id
        if self.vip_address is not None:
            cp.vip_address = self.vip_address
        if self.admin_state is not None:
            cp.admin_state = self.admin_state
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_status (obj.populate_string ("status"))
        obj.set_provisioning_status (obj.populate_string ("provisioning_status"))
        obj.set_operating_status (obj.populate_string ("operating_status"))
        obj.set_vip_subnet_id (obj.populate_string ("vip_subnet_id"))
        obj.set_vip_address (obj.populate_string ("vip_address"))
        obj.set_admin_state (obj.populate_boolean ("admin_state"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='LoadbalancerType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LoadbalancerType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LoadbalancerType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LoadbalancerType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.status is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstatus>%s</%sstatus>%s' % (namespace_, self.gds_format_string(quote_xml(self.status).encode(ExternalEncoding), input_name='status'), namespace_, eol_))
        if self.provisioning_status is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprovisioning-status>%s</%sprovisioning-status>%s' % (namespace_, self.gds_format_string(quote_xml(self.provisioning_status).encode(ExternalEncoding), input_name='provisioning-status'), namespace_, eol_))
        if self.operating_status is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soperating-status>%s</%soperating-status>%s' % (namespace_, self.gds_format_string(quote_xml(self.operating_status).encode(ExternalEncoding), input_name='operating-status'), namespace_, eol_))
        if self.vip_subnet_id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svip-subnet-id>%s</%svip-subnet-id>%s' % (namespace_, self.gds_format_string(quote_xml(self.vip_subnet_id).encode(ExternalEncoding), input_name='vip-subnet-id'), namespace_, eol_))
        if self.vip_address is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svip-address>%s</%svip-address>%s' % (namespace_, self.gds_format_string(quote_xml(self.vip_address).encode(ExternalEncoding), input_name='vip-address'), namespace_, eol_))
        if self.admin_state is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sadmin-state>%s</%sadmin-state>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.admin_state)), input_name='admin-state'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.status is not None or
            self.provisioning_status is not None or
            self.operating_status is not None or
            self.vip_subnet_id is not None or
            self.vip_address is not None or
            self.admin_state is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LoadbalancerType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.status is not None:
            showIndent(outfile, level)
            outfile.write('status=%s,\n' % quote_python(self.status).encode(ExternalEncoding))
        if self.provisioning_status is not None:
            showIndent(outfile, level)
            outfile.write('provisioning_status=%s,\n' % quote_python(self.provisioning_status).encode(ExternalEncoding))
        if self.operating_status is not None:
            showIndent(outfile, level)
            outfile.write('operating_status=%s,\n' % quote_python(self.operating_status).encode(ExternalEncoding))
        if self.vip_subnet_id is not None:
            showIndent(outfile, level)
            outfile.write('vip_subnet_id=%s,\n' % quote_python(self.vip_subnet_id).encode(ExternalEncoding))
        if self.vip_address is not None:
            showIndent(outfile, level)
            outfile.write('vip_address=%s,\n' % quote_python(self.vip_address).encode(ExternalEncoding))
        if self.admin_state is not None:
            showIndent(outfile, level)
            outfile.write('admin_state=%s,\n' % self.admin_state)
    def exportDict(self, name_='LoadbalancerType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'status':
            status_ = child_.text
            status_ = self.gds_validate_string(status_, node, 'status')
            self.status = status_
        elif nodeName_ == 'provisioning-status':
            provisioning_status_ = child_.text
            provisioning_status_ = self.gds_validate_string(provisioning_status_, node, 'provisioning_status')
            self.provisioning_status = provisioning_status_
        elif nodeName_ == 'operating-status':
            operating_status_ = child_.text
            operating_status_ = self.gds_validate_string(operating_status_, node, 'operating_status')
            self.operating_status = operating_status_
        elif nodeName_ == 'vip-subnet-id':
            vip_subnet_id_ = child_.text
            vip_subnet_id_ = self.gds_validate_string(vip_subnet_id_, node, 'vip_subnet_id')
            self.vip_subnet_id = vip_subnet_id_
            self.validate_UuidStringType(self.vip_subnet_id)    # validate type UuidStringType
        elif nodeName_ == 'vip-address':
            vip_address_ = child_.text
            vip_address_ = self.gds_validate_string(vip_address_, node, 'vip_address')
            self.vip_address = vip_address_
            self.validate_IpAddressType(self.vip_address)    # validate type IpAddressType
        elif nodeName_ == 'admin-state':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'admin_state')
            self.admin_state = ival_
# end class LoadbalancerType


class AlarmOperand2(GeneratedsSuper):
    """
    Attributes:
    * uve_attribute
        Type:           str

        Created By:           User (optional)

        Description:
          UVE attribute specified in the dotted format. Example:

          NodeStatus.process_info.process_state

    * json_value
        Type:           str

        Created By:           User (optional)

        Description:
          json value as string

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'uve_attribute', u'json_value']
    attr_field_type_vals = {u'uve_attribute': {'restrictions': None, 'description': [u'UVE attribute specified in the dotted format. Example: NodeStatus.process_info.process_state'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'exclusive', 'attr_type': u'string'}, u'json_value': {'restrictions': None, 'description': [u'json value as string'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'exclusive', 'attr_type': u'string'}}
    def __init__(self, uve_attribute=None, json_value=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _uve_attribute = params_dict[u"uve_attribute"]
        except KeyError:
            _uve_attribute = uve_attribute
        self.uve_attribute = _uve_attribute
        try:
            _json_value = params_dict[u"json_value"]
        except KeyError:
            _json_value = json_value
        self.json_value = _json_value
    def factory(*args_, **kwargs_):
        if AlarmOperand2.subclass:
            return AlarmOperand2.subclass(*args_, **kwargs_)
        else:
            return AlarmOperand2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uve_attribute(self): return self.uve_attribute
    def set_uve_attribute(self, uve_attribute): self.uve_attribute = uve_attribute
    def get_json_value(self): return self.json_value
    def set_json_value(self, json_value): self.json_value = json_value
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.uve_attribute == other.uve_attribute and
                    self.json_value == other.json_value)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.uve_attribute if self.uve_attribute is not None else -7985492147856592190,
                     self.json_value if self.json_value is not None else -7985492147856592190))

    def __repr__(self):
        return ("uve_attribute = " + str(self.uve_attribute) + ", " +
                "json_value = " + str(self.json_value))

    def copy(self):
        cp = AlarmOperand2()
        if self.uve_attribute is not None:
            cp.uve_attribute = self.uve_attribute
        if self.json_value is not None:
            cp.json_value = self.json_value
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_uve_attribute (obj.populate_string ("uve_attribute"))
        obj.set_json_value (obj.populate_string ("json_value"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='AlarmOperand2', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AlarmOperand2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AlarmOperand2'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AlarmOperand2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.uve_attribute is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%suve_attribute>%s</%suve_attribute>%s' % (namespace_, self.gds_format_string(quote_xml(self.uve_attribute).encode(ExternalEncoding), input_name='uve_attribute'), namespace_, eol_))
        if self.json_value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sjson_value>%s</%sjson_value>%s' % (namespace_, self.gds_format_string(quote_xml(self.json_value).encode(ExternalEncoding), input_name='json_value'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.uve_attribute is not None or
            self.json_value is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AlarmOperand2'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.uve_attribute is not None:
            showIndent(outfile, level)
            outfile.write('uve_attribute=%s,\n' % quote_python(self.uve_attribute).encode(ExternalEncoding))
        if self.json_value is not None:
            showIndent(outfile, level)
            outfile.write('json_value=%s,\n' % quote_python(self.json_value).encode(ExternalEncoding))
    def exportDict(self, name_='AlarmOperand2'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'uve_attribute':
            uve_attribute_ = child_.text
            uve_attribute_ = self.gds_validate_string(uve_attribute_, node, 'uve_attribute')
            self.uve_attribute = uve_attribute_
        elif nodeName_ == 'json_value':
            json_value_ = child_.text
            json_value_ = self.gds_validate_string(json_value_, node, 'json_value')
            self.json_value = json_value_
# end class AlarmOperand2


class AlarmExpression(GeneratedsSuper):
    """
    Attributes:
    * operation
        Type:           str, *one-of* [u'==', u'!=', u'<', u'<=', u'>', u'>=', u'in', u'not in', u'range', u'size==', u'size!=']

        Created By:           User (required)

        Description:
          operation to compare operand1 and operand2

    * operand1
        Type:           str

        Created By:           User (required)

        Description:
          UVE attribute specified in the dotted format. Example:

          NodeStatus.process_info.process_state

    * operand2
        Type:           :class:`.AlarmOperand2`

        Created By:           User (required)

        Description:
          UVE attribute or a json value to compare with the UVE attribute in operand1

    * variables
        Type:           str

        Created By:           User (optional)

        Description:
          List of UVE attributes that would be useful when the alarm is raised. For

          example, user may want to raise an alarm if the

          NodeStatus.process_info.process_state != PROCESS_STATE_RUNNING. But, it would be

          useful to know the process_name whose state != PROCESS_STATE_RUNNING. This UVE

          attribute which is neither part of operand1 nor operand2 may be specified in

          variables

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'operation', u'operand1', u'operand2', u'variables']
    attr_field_type_vals = {u'operation': {'restrictions': [u'==', u'!=', u'<', u'<=', u'>', u'>=', u'in', u'not in', u'range', u'size==', u'size!='], 'description': [u'operation to compare operand1 and operand2'], 'simple_type': u'AlarmOperation', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'true', 'attr_type': u'string'}, u'operand1': {'restrictions': None, 'description': [u'UVE attribute specified in the dotted format. Example: NodeStatus.process_info.process_state'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'true', 'attr_type': u'string'}, u'variables': {'restrictions': None, 'description': [u'List of UVE attributes that would be useful when the alarm is raised. For example, user may want to raise an alarm if the NodeStatus.process_info.process_state != PROCESS_STATE_RUNNING. But, it would be useful to know the process_name whose state != PROCESS_STATE_RUNNING. This UVE attribute which is neither part of operand1 nor operand2 may be specified in variables'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': True, 'required': u'optional', 'attr_type': u'string'}, u'operand2': {'restrictions': None, 'description': [u'UVE attribute or a json value to compare with the UVE attribute in operand1'], 'simple_type': u'AlarmOperand2', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': u'true', 'attr_type': u'AlarmOperand2'}}
    def __init__(self, operation=None, operand1=None, operand2=None, variables=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _operation = params_dict[u"operation"]
        except KeyError:
            _operation = operation
        self.operation = _operation
        try:
            _operand1 = params_dict[u"operand1"]
        except KeyError:
            _operand1 = operand1
        self.operand1 = _operand1
        try:
            _operand2 = params_dict[u"operand2"]
        except KeyError:
            _operand2 = operand2
        if isinstance(_operand2, dict):
            obj = AlarmOperand2(params_dict=_operand2)
            self.operand2 = obj
        else:
            self.operand2 = _operand2
        try:
            _variables = params_dict[u"variables"]
        except KeyError:
            _variables = variables
        if not _variables:
            self.variables = []
        else:
            self.variables = _variables
    def factory(*args_, **kwargs_):
        if AlarmExpression.subclass:
            return AlarmExpression.subclass(*args_, **kwargs_)
        else:
            return AlarmExpression(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_operation(self): return self.operation
    def set_operation(self, operation): self.operation = operation
    def validate_AlarmOperation(self, value):
        # Validate type AlarmOperation, a restriction on xsd:string.
        error = False
        if isinstance(value, list):
            error = set(value) - set([u'==', u'!=', u'<', u'<=', u'>', u'>=', u'in', u'not in', u'range', u'size==', u'size!='])
        else:
            error = value not in [u'==', u'!=', u'<', u'<=', u'>', u'>=', u'in', u'not in', u'range', u'size==', u'size!=']
        if error:
            raise ValueError("AlarmOperation must be one of [u'==', u'!=', u'<', u'<=', u'>', u'>=', u'in', u'not in', u'range', u'size==', u'size!=']")
    def get_operand1(self): return self.operand1
    def set_operand1(self, operand1): self.operand1 = operand1
    def get_operand2(self): return self.operand2
    def set_operand2(self, operand2): self.operand2 = operand2
    def get_variables(self): return self.variables
    def set_variables(self, variables): self.variables = variables
    def add_variables(self, value): self.variables.append(value)
    def insert_variables(self, index, value): self.variables[index] = value
    def delete_variables(self, value): self.variables.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.operation == other.operation and
                    self.operand1 == other.operand1 and
                    self.operand2 == other.operand2 and
                    self.variables == other.variables)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.operation if self.operation is not None else -7985492147856592190,
                     self.operand1 if self.operand1 is not None else -7985492147856592190,
                     self.operand2 if self.operand2 is not None else -7985492147856592190,
                     tuple(self.variables or [])))

    def __repr__(self):
        return ("operation = " + str(self.operation) + ", " +
                "operand1 = " + str(self.operand1) + ", " +
                "operand2 = " + str(self.operand2) + ", " +
                "variables = " + str(self.variables))

    def copy(self):
        cp = AlarmExpression()
        if self.operation is not None:
            cp.operation = self.operation
        if self.operand1 is not None:
            cp.operand1 = self.operand1
        if self.operand2 is not None:
            cp.operand2 = self.operand2.copy()
        if self.variables is not None:
            cp.variables = list(self.variables)
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_operation (obj.populate_string ("operation"))
        obj.set_operand1 (obj.populate_string ("operand1"))
        obj.set_operand2 (AlarmOperand2.populate ())
        obj.set_variables ([obj.populate_string ("variables")])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='AlarmExpression', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AlarmExpression')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AlarmExpression'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AlarmExpression', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.operation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soperation>%s</%soperation>%s' % (namespace_, self.gds_format_string(quote_xml(self.operation).encode(ExternalEncoding), input_name='operation'), namespace_, eol_))
        if self.operand1 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soperand1>%s</%soperand1>%s' % (namespace_, self.gds_format_string(quote_xml(self.operand1).encode(ExternalEncoding), input_name='operand1'), namespace_, eol_))
        if self.operand2 is not None:
            self.operand2.export_xml(outfile, level, namespace_, name_='operand2', pretty_print=pretty_print)
        for variables_ in self.variables:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svariables>%s</%svariables>%s' % (namespace_, self.gds_format_string(quote_xml(variables_).encode(ExternalEncoding), input_name='variables'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.operation is not None or
            self.operand1 is not None or
            self.operand2 is not None or
            self.variables
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AlarmExpression'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.operation is not None:
            showIndent(outfile, level)
            outfile.write('operation=%s,\n' % quote_python(self.operation).encode(ExternalEncoding))
        if self.operand1 is not None:
            showIndent(outfile, level)
            outfile.write('operand1=%s,\n' % quote_python(self.operand1).encode(ExternalEncoding))
        if self.operand2 is not None:
            showIndent(outfile, level)
            outfile.write('operand2=model_.AlarmOperand2(\n')
            self.operand2.exportLiteral(outfile, level, name_='operand2')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('variables=[\n')
        level += 1
        for variables_ in self.variables:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(variables_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='AlarmExpression'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'operation':
            operation_ = child_.text
            operation_ = self.gds_validate_string(operation_, node, 'operation')
            self.operation = operation_
            self.validate_AlarmOperation(self.operation)    # validate type AlarmOperation
        elif nodeName_ == 'operand1':
            operand1_ = child_.text
            operand1_ = self.gds_validate_string(operand1_, node, 'operand1')
            self.operand1 = operand1_
        elif nodeName_ == 'operand2':
            obj_ = AlarmOperand2.factory()
            obj_.build(child_)
            self.set_operand2(obj_)
        elif nodeName_ == 'variables':
            variables_ = child_.text
            variables_ = self.gds_validate_string(variables_, node, 'variables')
            self.variables.append(variables_)
# end class AlarmExpression


class AlarmAndList(GeneratedsSuper):
    """
    Attributes:
    * and_list
        Type:           :class:`.AlarmExpression`

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'and_list']
    attr_field_type_vals = {u'and_list': {'restrictions': None, 'description': [], 'simple_type': u'AlarmExpression', 'is_complex': 1, 'restriction_type': None, 'is_array': True, 'required': None, 'attr_type': u'AlarmExpression'}}
    def __init__(self, and_list=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _and_list = params_dict[u"and_list"]
        except KeyError:
            _and_list = and_list
        if not _and_list:
            self.and_list = []
        else:
            if isinstance(_and_list[0], dict):
                objs = [AlarmExpression(params_dict=elem) for elem in _and_list]
                self.and_list = objs
            else:
                self.and_list = _and_list
    def factory(*args_, **kwargs_):
        if AlarmAndList.subclass:
            return AlarmAndList.subclass(*args_, **kwargs_)
        else:
            return AlarmAndList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_and_list(self): return self.and_list
    def set_and_list(self, and_list): self.and_list = and_list
    def add_and_list(self, value): self.and_list.append(value)
    def insert_and_list(self, index, value): self.and_list[index] = value
    def delete_and_list(self, value): self.and_list.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.and_list == other.and_list)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.and_list or [])))

    def __repr__(self):
        return ("and_list = " + str(self.and_list))

    def copy(self):
        cp = AlarmAndList()
        if self.and_list is not None:
            cp.and_list = [x.copy() for x in self.and_list]
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_and_list ([AlarmExpression.populate ()])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='AlarmAndList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AlarmAndList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AlarmAndList'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AlarmAndList', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for and_list_ in self.and_list:
            if isinstance(and_list_, dict):
                and_list_ = AlarmExpression(**and_list_)
            and_list_.export_xml(outfile, level, namespace_, name_='and_list', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.and_list
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AlarmAndList'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('and_list=[\n')
        level += 1
        for and_list_ in self.and_list:
            showIndent(outfile, level)
            outfile.write('model_.AlarmExpression(\n')
            and_list_.exportLiteral(outfile, level, name_='AlarmExpression')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='AlarmAndList'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'and_list':
            obj_ = AlarmExpression.factory()
            obj_.build(child_)
            self.and_list.append(obj_)
# end class AlarmAndList


class AlarmOrList(GeneratedsSuper):
    """
    Attributes:
    * or_list
        Type:           :class:`.AlarmAndList`

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'or_list']
    attr_field_type_vals = {u'or_list': {'restrictions': None, 'description': [], 'simple_type': u'AlarmAndList', 'is_complex': 1, 'restriction_type': None, 'is_array': True, 'required': None, 'attr_type': u'AlarmAndList'}}
    def __init__(self, or_list=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _or_list = params_dict[u"or_list"]
        except KeyError:
            _or_list = or_list
        if not _or_list:
            self.or_list = []
        else:
            if isinstance(_or_list[0], dict):
                objs = [AlarmAndList(params_dict=elem) for elem in _or_list]
                self.or_list = objs
            else:
                self.or_list = _or_list
    def factory(*args_, **kwargs_):
        if AlarmOrList.subclass:
            return AlarmOrList.subclass(*args_, **kwargs_)
        else:
            return AlarmOrList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_or_list(self): return self.or_list
    def set_or_list(self, or_list): self.or_list = or_list
    def add_or_list(self, value): self.or_list.append(value)
    def insert_or_list(self, index, value): self.or_list[index] = value
    def delete_or_list(self, value): self.or_list.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.or_list == other.or_list)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.or_list or [])))

    def __repr__(self):
        return ("or_list = " + str(self.or_list))

    def copy(self):
        cp = AlarmOrList()
        if self.or_list is not None:
            cp.or_list = [x.copy() for x in self.or_list]
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_or_list ([AlarmAndList.populate ()])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='AlarmOrList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AlarmOrList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AlarmOrList'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AlarmOrList', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for or_list_ in self.or_list:
            if isinstance(or_list_, dict):
                or_list_ = AlarmAndList(**or_list_)
            or_list_.export_xml(outfile, level, namespace_, name_='or_list', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.or_list
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AlarmOrList'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('or_list=[\n')
        level += 1
        for or_list_ in self.or_list:
            showIndent(outfile, level)
            outfile.write('model_.AlarmAndList(\n')
            or_list_.exportLiteral(outfile, level, name_='AlarmAndList')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='AlarmOrList'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'or_list':
            obj_ = AlarmAndList.factory()
            obj_.build(child_)
            self.or_list.append(obj_)
# end class AlarmOrList


class UveKeysType(GeneratedsSuper):
    """
    Attributes:
    * uve_key
        Type:           str

        Created By:           User (required)

        Description:
          List of UVE tables where this alarm config should be applied

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'uve_key']
    attr_field_type_vals = {u'uve_key': {'restrictions': None, 'description': [u'List of UVE tables where this alarm config should be applied'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': True, 'required': u'true', 'attr_type': u'string'}}
    def __init__(self, uve_key=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _uve_key = params_dict[u"uve_key"]
        except KeyError:
            _uve_key = uve_key
        if not _uve_key:
            self.uve_key = []
        else:
            self.uve_key = _uve_key
    def factory(*args_, **kwargs_):
        if UveKeysType.subclass:
            return UveKeysType.subclass(*args_, **kwargs_)
        else:
            return UveKeysType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uve_key(self): return self.uve_key
    def set_uve_key(self, uve_key): self.uve_key = uve_key
    def add_uve_key(self, value): self.uve_key.append(value)
    def insert_uve_key(self, index, value): self.uve_key[index] = value
    def delete_uve_key(self, value): self.uve_key.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.uve_key == other.uve_key)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.uve_key or [])))

    def __repr__(self):
        return ("uve_key = " + str(self.uve_key))

    def copy(self):
        cp = UveKeysType()
        if self.uve_key is not None:
            cp.uve_key = list(self.uve_key)
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_uve_key ([obj.populate_string ("uve_key")])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='UveKeysType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UveKeysType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='UveKeysType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='UveKeysType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for uve_key_ in self.uve_key:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%suve-key>%s</%suve-key>%s' % (namespace_, self.gds_format_string(quote_xml(uve_key_).encode(ExternalEncoding), input_name='uve-key'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.uve_key
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='UveKeysType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('uve_key=[\n')
        level += 1
        for uve_key_ in self.uve_key:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(uve_key_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='UveKeysType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'uve-key':
            uve_key_ = child_.text
            uve_key_ = self.gds_validate_string(uve_key_, node, 'uve_key')
            self.uve_key.append(uve_key_)
# end class UveKeysType


class UserDefinedLogStat(GeneratedsSuper):
    """
    Attributes:
    * name
        Type:           str

        Created By:           User (required)

        Description:
          Name of the stat

    * pattern
        Type:           str

        Created By:           User (required)

        Description:
          Perl type regular expression pattern to match

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'name', u'pattern']
    attr_field_type_vals = {u'pattern': {'restrictions': None, 'description': [u'Perl type regular expression pattern to match'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'true', 'attr_type': u'string'}, u'name': {'restrictions': None, 'description': [u'Name of the stat'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'true', 'attr_type': u'string'}}
    def __init__(self, name=None, pattern=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _name = params_dict[u"name"]
        except KeyError:
            _name = name
        self.name = _name
        try:
            _pattern = params_dict[u"pattern"]
        except KeyError:
            _pattern = pattern
        self.pattern = _pattern
    def factory(*args_, **kwargs_):
        if UserDefinedLogStat.subclass:
            return UserDefinedLogStat.subclass(*args_, **kwargs_)
        else:
            return UserDefinedLogStat(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_pattern(self): return self.pattern
    def set_pattern(self, pattern): self.pattern = pattern
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.name == other.name and
                    self.pattern == other.pattern)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.name if self.name is not None else -7985492147856592190,
                     self.pattern if self.pattern is not None else -7985492147856592190))

    def __repr__(self):
        return ("name = " + str(self.name) + ", " +
                "pattern = " + str(self.pattern))

    def copy(self):
        cp = UserDefinedLogStat()
        if self.name is not None:
            cp.name = self.name
        if self.pattern is not None:
            cp.pattern = self.pattern
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_name (obj.populate_string ("name"))
        obj.set_pattern (obj.populate_string ("pattern"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='UserDefinedLogStat', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UserDefinedLogStat')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='UserDefinedLogStat'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='UserDefinedLogStat', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        if self.pattern is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spattern>%s</%spattern>%s' % (namespace_, self.gds_format_string(quote_xml(self.pattern).encode(ExternalEncoding), input_name='pattern'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.name is not None or
            self.pattern is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='UserDefinedLogStat'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.pattern is not None:
            showIndent(outfile, level)
            outfile.write('pattern=%s,\n' % quote_python(self.pattern).encode(ExternalEncoding))
    def exportDict(self, name_='UserDefinedLogStat'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'pattern':
            pattern_ = child_.text
            pattern_ = self.gds_validate_string(pattern_, node, 'pattern')
            self.pattern = pattern_
# end class UserDefinedLogStat


class UserDefinedLogStatList(GeneratedsSuper):
    """
    Attributes:
    * statlist
        Type:           :class:`.UserDefinedLogStat`

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'statlist']
    attr_field_type_vals = {u'statlist': {'restrictions': None, 'description': [], 'simple_type': u'UserDefinedLogStat', 'is_complex': 1, 'restriction_type': None, 'is_array': True, 'required': None, 'attr_type': u'UserDefinedLogStat'}}
    def __init__(self, statlist=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _statlist = params_dict[u"statlist"]
        except KeyError:
            _statlist = statlist
        if not _statlist:
            self.statlist = []
        else:
            if isinstance(_statlist[0], dict):
                objs = [UserDefinedLogStat(params_dict=elem) for elem in _statlist]
                self.statlist = objs
            else:
                self.statlist = _statlist
    def factory(*args_, **kwargs_):
        if UserDefinedLogStatList.subclass:
            return UserDefinedLogStatList.subclass(*args_, **kwargs_)
        else:
            return UserDefinedLogStatList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_statlist(self): return self.statlist
    def set_statlist(self, statlist): self.statlist = statlist
    def add_statlist(self, value): self.statlist.append(value)
    def insert_statlist(self, index, value): self.statlist[index] = value
    def delete_statlist(self, value): self.statlist.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.statlist == other.statlist)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.statlist or [])))

    def __repr__(self):
        return ("statlist = " + str(self.statlist))

    def copy(self):
        cp = UserDefinedLogStatList()
        if self.statlist is not None:
            cp.statlist = [x.copy() for x in self.statlist]
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_statlist ([UserDefinedLogStat.populate ()])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='UserDefinedLogStatList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UserDefinedLogStatList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='UserDefinedLogStatList'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='UserDefinedLogStatList', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for statlist_ in self.statlist:
            if isinstance(statlist_, dict):
                statlist_ = UserDefinedLogStat(**statlist_)
            statlist_.export_xml(outfile, level, namespace_, name_='statlist', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.statlist
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='UserDefinedLogStatList'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('statlist=[\n')
        level += 1
        for statlist_ in self.statlist:
            showIndent(outfile, level)
            outfile.write('model_.UserDefinedLogStat(\n')
            statlist_.exportLiteral(outfile, level, name_='UserDefinedLogStat')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='UserDefinedLogStatList'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'statlist':
            obj_ = UserDefinedLogStat.factory()
            obj_.build(child_)
            self.statlist.append(obj_)
# end class UserDefinedLogStatList


class SloRateType(GeneratedsSuper):
    """
    Attributes:
    * rate
        Type:           int

        Description:
          Rate at which sessions are logged

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'rate']
    attr_field_type_vals = {u'rate': {'restrictions': None, 'description': [u'Rate at which sessions are logged'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'integer'}}
    def __init__(self, rate=-1, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _rate = params_dict[u"rate"]
        except KeyError:
            _rate = rate
        self.rate = _rate
    def factory(*args_, **kwargs_):
        if SloRateType.subclass:
            return SloRateType.subclass(*args_, **kwargs_)
        else:
            return SloRateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rate(self): return self.rate
    def set_rate(self, rate): self.rate = rate
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.rate == other.rate)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.rate if self.rate is not None else -7985492147856592190))

    def __repr__(self):
        return ("rate = " + str(self.rate))

    def copy(self):
        cp = SloRateType()
        if self.rate is not None:
            cp.rate = self.rate
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_rate (obj.populate_integer ("rate"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='SloRateType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SloRateType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SloRateType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SloRateType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.rate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srate>%s</%srate>%s' % (namespace_, self.gds_format_integer(self.rate, input_name='rate'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.rate is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SloRateType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.rate is not None:
            showIndent(outfile, level)
            outfile.write('rate=%d,\n' % self.rate)
    def exportDict(self, name_='SloRateType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'rate':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'rate')
            self.rate = ival_
# end class SloRateType


class SubnetListType(GeneratedsSuper):
    """
    Attributes:
    * subnet
        Type:           :class:`.SubnetType`

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'subnet']
    attr_field_type_vals = {u'subnet': {'restrictions': None, 'description': [], 'simple_type': u'SubnetType', 'is_complex': 1, 'restriction_type': None, 'is_array': True, 'required': None, 'attr_type': u'SubnetType'}}
    def __init__(self, subnet=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _subnet = params_dict[u"subnet"]
        except KeyError:
            _subnet = subnet
        if not _subnet:
            self.subnet = []
        else:
            if isinstance(_subnet[0], dict):
                objs = [SubnetType(params_dict=elem) for elem in _subnet]
                self.subnet = objs
            else:
                self.subnet = _subnet
    def factory(*args_, **kwargs_):
        if SubnetListType.subclass:
            return SubnetListType.subclass(*args_, **kwargs_)
        else:
            return SubnetListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_subnet(self): return self.subnet
    def set_subnet(self, subnet): self.subnet = subnet
    def add_subnet(self, value): self.subnet.append(value)
    def insert_subnet(self, index, value): self.subnet[index] = value
    def delete_subnet(self, value): self.subnet.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.subnet == other.subnet)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.subnet or [])))

    def __repr__(self):
        return ("subnet = " + str(self.subnet))

    def copy(self):
        cp = SubnetListType()
        if self.subnet is not None:
            cp.subnet = [x.copy() for x in self.subnet]
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_subnet ([SubnetType.populate ()])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='SubnetListType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SubnetListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SubnetListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SubnetListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for subnet_ in self.subnet:
            if isinstance(subnet_, dict):
                subnet_ = SubnetType(**subnet_)
            subnet_.export_xml(outfile, level, namespace_, name_='subnet', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.subnet
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SubnetListType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('subnet=[\n')
        level += 1
        for subnet_ in self.subnet:
            showIndent(outfile, level)
            outfile.write('model_.SubnetType(\n')
            subnet_.exportLiteral(outfile, level, name_='SubnetType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='SubnetListType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'subnet':
            obj_ = SubnetType.factory()
            obj_.build(child_)
            self.subnet.append(obj_)
# end class SubnetListType


class FirewallServiceType(GeneratedsSuper):
    """
    Attributes:
    * protocol
        Type:           str

        Description:
          Layer 4 protocol in ip packet

    * protocol_id
        Type:           int

        Description:
          Layer 4 protocol id in ip packet

    * src_ports
        Type:           :class:`.PortType`

        Description:
          Range of source port for layer 4 protocol

    * dst_ports
        Type:           :class:`.PortType`

        Description:
          Range of destination port for layer 4 protocol

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'protocol', u'protocol_id', u'src_ports', u'dst_ports']
    attr_field_type_vals = {u'protocol': {'restrictions': None, 'description': [u'Layer 4 protocol in ip packet'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'dst_ports': {'restrictions': None, 'description': [u'Range of destination port for layer 4 protocol'], 'simple_type': u'PortType', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'PortType'}, u'src_ports': {'restrictions': None, 'description': [u'Range of source port for layer 4 protocol'], 'simple_type': u'PortType', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'PortType'}, u'protocol_id': {'restrictions': None, 'description': [u'Layer 4 protocol id in ip packet'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'integer'}}
    def __init__(self, protocol=None, protocol_id=None, src_ports=None, dst_ports=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _protocol = params_dict[u"protocol"]
        except KeyError:
            _protocol = protocol
        self.protocol = _protocol
        try:
            _protocol_id = params_dict[u"protocol_id"]
        except KeyError:
            _protocol_id = protocol_id
        self.protocol_id = _protocol_id
        try:
            _src_ports = params_dict[u"src_ports"]
        except KeyError:
            _src_ports = src_ports
        if isinstance(_src_ports, dict):
            obj = PortType(params_dict=_src_ports)
            self.src_ports = obj
        else:
            self.src_ports = _src_ports
        try:
            _dst_ports = params_dict[u"dst_ports"]
        except KeyError:
            _dst_ports = dst_ports
        if isinstance(_dst_ports, dict):
            obj = PortType(params_dict=_dst_ports)
            self.dst_ports = obj
        else:
            self.dst_ports = _dst_ports
    def factory(*args_, **kwargs_):
        if FirewallServiceType.subclass:
            return FirewallServiceType.subclass(*args_, **kwargs_)
        else:
            return FirewallServiceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_protocol(self): return self.protocol
    def set_protocol(self, protocol): self.protocol = protocol
    def get_protocol_id(self): return self.protocol_id
    def set_protocol_id(self, protocol_id): self.protocol_id = protocol_id
    def get_src_ports(self): return self.src_ports
    def set_src_ports(self, src_ports): self.src_ports = src_ports
    def get_dst_ports(self): return self.dst_ports
    def set_dst_ports(self, dst_ports): self.dst_ports = dst_ports
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.protocol == other.protocol and
                    self.protocol_id == other.protocol_id and
                    self.src_ports == other.src_ports and
                    self.dst_ports == other.dst_ports)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.protocol if self.protocol is not None else -7985492147856592190,
                     self.protocol_id if self.protocol_id is not None else -7985492147856592190,
                     self.src_ports if self.src_ports is not None else -7985492147856592190,
                     self.dst_ports if self.dst_ports is not None else -7985492147856592190))

    def __repr__(self):
        return ("protocol = " + str(self.protocol) + ", " +
                "protocol_id = " + str(self.protocol_id) + ", " +
                "src_ports = " + str(self.src_ports) + ", " +
                "dst_ports = " + str(self.dst_ports))

    def copy(self):
        cp = FirewallServiceType()
        if self.protocol is not None:
            cp.protocol = self.protocol
        if self.protocol_id is not None:
            cp.protocol_id = self.protocol_id
        if self.src_ports is not None:
            cp.src_ports = self.src_ports.copy()
        if self.dst_ports is not None:
            cp.dst_ports = self.dst_ports.copy()
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_protocol (obj.populate_string ("protocol"))
        obj.set_protocol_id (obj.populate_integer ("protocol_id"))
        obj.set_src_ports (PortType.populate ())
        obj.set_dst_ports (PortType.populate ())
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='FirewallServiceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FirewallServiceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FirewallServiceType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FirewallServiceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.protocol is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprotocol>%s</%sprotocol>%s' % (namespace_, self.gds_format_string(quote_xml(self.protocol).encode(ExternalEncoding), input_name='protocol'), namespace_, eol_))
        if self.protocol_id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprotocol-id>%s</%sprotocol-id>%s' % (namespace_, self.gds_format_integer(self.protocol_id, input_name='protocol-id'), namespace_, eol_))
        if self.src_ports is not None:
            self.src_ports.export_xml(outfile, level, namespace_, name_='src-ports', pretty_print=pretty_print)
        if self.dst_ports is not None:
            self.dst_ports.export_xml(outfile, level, namespace_, name_='dst-ports', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.protocol is not None or
            self.protocol_id is not None or
            self.src_ports is not None or
            self.dst_ports is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FirewallServiceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.protocol is not None:
            showIndent(outfile, level)
            outfile.write('protocol=%s,\n' % quote_python(self.protocol).encode(ExternalEncoding))
        if self.protocol_id is not None:
            showIndent(outfile, level)
            outfile.write('protocol_id=%d,\n' % self.protocol_id)
        if self.src_ports is not None:
            showIndent(outfile, level)
            outfile.write('src_ports=model_.PortType(\n')
            self.src_ports.exportLiteral(outfile, level, name_='src_ports')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.dst_ports is not None:
            showIndent(outfile, level)
            outfile.write('dst_ports=model_.PortType(\n')
            self.dst_ports.exportLiteral(outfile, level, name_='dst_ports')
            showIndent(outfile, level)
            outfile.write('),\n')
    def exportDict(self, name_='FirewallServiceType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'protocol':
            protocol_ = child_.text
            protocol_ = self.gds_validate_string(protocol_, node, 'protocol')
            self.protocol = protocol_
        elif nodeName_ == 'protocol-id':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'protocol_id')
            self.protocol_id = ival_
        elif nodeName_ == 'src-ports':
            obj_ = PortType.factory()
            obj_.build(child_)
            self.set_src_ports(obj_)
        elif nodeName_ == 'dst-ports':
            obj_ = PortType.factory()
            obj_.build(child_)
            self.set_dst_ports(obj_)
# end class FirewallServiceType


class FirewallServiceGroupType(GeneratedsSuper):
    """
    Attributes:
    * firewall_service
        Type:           :class:`.FirewallServiceType`

        Created By:           User (required)

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'firewall_service']
    attr_field_type_vals = {u'firewall_service': {'restrictions': None, 'description': [], 'simple_type': u'FirewallServiceType', 'is_complex': 1, 'restriction_type': None, 'is_array': True, 'required': u'true', 'attr_type': u'FirewallServiceType'}}
    def __init__(self, firewall_service=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _firewall_service = params_dict[u"firewall_service"]
        except KeyError:
            _firewall_service = firewall_service
        if not _firewall_service:
            self.firewall_service = []
        else:
            if isinstance(_firewall_service[0], dict):
                objs = [FirewallServiceType(params_dict=elem) for elem in _firewall_service]
                self.firewall_service = objs
            else:
                self.firewall_service = _firewall_service
    def factory(*args_, **kwargs_):
        if FirewallServiceGroupType.subclass:
            return FirewallServiceGroupType.subclass(*args_, **kwargs_)
        else:
            return FirewallServiceGroupType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_firewall_service(self): return self.firewall_service
    def set_firewall_service(self, firewall_service): self.firewall_service = firewall_service
    def add_firewall_service(self, value): self.firewall_service.append(value)
    def insert_firewall_service(self, index, value): self.firewall_service[index] = value
    def delete_firewall_service(self, value): self.firewall_service.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.firewall_service == other.firewall_service)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.firewall_service or [])))

    def __repr__(self):
        return ("firewall_service = " + str(self.firewall_service))

    def copy(self):
        cp = FirewallServiceGroupType()
        if self.firewall_service is not None:
            cp.firewall_service = [x.copy() for x in self.firewall_service]
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_firewall_service ([FirewallServiceType.populate ()])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='FirewallServiceGroupType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FirewallServiceGroupType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FirewallServiceGroupType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FirewallServiceGroupType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for firewall_service_ in self.firewall_service:
            if isinstance(firewall_service_, dict):
                firewall_service_ = FirewallServiceType(**firewall_service_)
            firewall_service_.export_xml(outfile, level, namespace_, name_='firewall-service', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.firewall_service
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FirewallServiceGroupType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('firewall_service=[\n')
        level += 1
        for firewall_service_ in self.firewall_service:
            showIndent(outfile, level)
            outfile.write('model_.FirewallServiceType(\n')
            firewall_service_.exportLiteral(outfile, level, name_='FirewallServiceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='FirewallServiceGroupType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'firewall-service':
            obj_ = FirewallServiceType.factory()
            obj_.build(child_)
            self.firewall_service.append(obj_)
# end class FirewallServiceGroupType


class FirewallRuleEndpointType(GeneratedsSuper):
    """
    Attributes:
    * subnet
        Type:           :class:`.SubnetType`

        Created By:           User (optional)

        Description:
          Any workload that belongs to this subnet

    * virtual_network
        Type:           str

        Created By:           User (optional)

        Description:
          Any workload that belongs to this virtual network

    * address_group
        Type:           str

        Created By:           User (optional)

        Description:
          Any workload with interface in this address-group

    * tags
        Type:           str

        Created By:           User (optional)

        Description:
          Any workload with tags matching tags in this list

    * tag_ids
        Type:           int

        Description:
          Any workload with tags ids matching all the tags ids in this list

    * any
        Type:           bool

        Created By:           User (optional)

        Description:
          Match any workload

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'subnet', u'virtual_network', u'address_group', u'tags', u'tag_ids', u'any']
    attr_field_type_vals = {u'address_group': {'restrictions': None, 'description': [u'Any workload with interface in this address-group'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'exclusive', 'attr_type': u'string'}, u'subnet': {'restrictions': None, 'description': [u'Any workload that belongs to this subnet'], 'simple_type': u'SubnetType', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': u'exclusive', 'attr_type': u'SubnetType'}, u'tags': {'restrictions': None, 'description': [u'Any workload with tags matching tags in this list'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': True, 'required': u'exclusive', 'attr_type': u'string'}, u'tag_ids': {'restrictions': None, 'description': [u'Any workload with tags ids matching all the tags ids in this list'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': True, 'required': None, 'attr_type': u'integer'}, u'virtual_network': {'restrictions': None, 'description': [u'Any workload that belongs to this virtual network '], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'exclusive', 'attr_type': u'string'}, u'any': {'restrictions': None, 'description': [u'Match any workload'], 'simple_type': u'xsd:boolean', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'exclusive', 'attr_type': u'boolean'}}
    def __init__(self, subnet=None, virtual_network=None, address_group=None, tags=None, tag_ids=None, any=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _subnet = params_dict[u"subnet"]
        except KeyError:
            _subnet = subnet
        if isinstance(_subnet, dict):
            obj = SubnetType(params_dict=_subnet)
            self.subnet = obj
        else:
            self.subnet = _subnet
        try:
            _virtual_network = params_dict[u"virtual_network"]
        except KeyError:
            _virtual_network = virtual_network
        self.virtual_network = _virtual_network
        try:
            _address_group = params_dict[u"address_group"]
        except KeyError:
            _address_group = address_group
        self.address_group = _address_group
        try:
            _tags = params_dict[u"tags"]
        except KeyError:
            _tags = tags
        if not _tags:
            self.tags = []
        else:
            self.tags = _tags
        try:
            _tag_ids = params_dict[u"tag_ids"]
        except KeyError:
            _tag_ids = tag_ids
        if not _tag_ids:
            self.tag_ids = []
        else:
            self.tag_ids = _tag_ids
        try:
            _any = params_dict[u"any"]
        except KeyError:
            _any = any
        self.any = _any
    def factory(*args_, **kwargs_):
        if FirewallRuleEndpointType.subclass:
            return FirewallRuleEndpointType.subclass(*args_, **kwargs_)
        else:
            return FirewallRuleEndpointType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_subnet(self): return self.subnet
    def set_subnet(self, subnet): self.subnet = subnet
    def get_virtual_network(self): return self.virtual_network
    def set_virtual_network(self, virtual_network): self.virtual_network = virtual_network
    def get_address_group(self): return self.address_group
    def set_address_group(self, address_group): self.address_group = address_group
    def get_tags(self): return self.tags
    def set_tags(self, tags): self.tags = tags
    def add_tags(self, value): self.tags.append(value)
    def insert_tags(self, index, value): self.tags[index] = value
    def delete_tags(self, value): self.tags.remove(value)
    def get_tag_ids(self): return self.tag_ids
    def set_tag_ids(self, tag_ids): self.tag_ids = tag_ids
    def add_tag_ids(self, value): self.tag_ids.append(value)
    def insert_tag_ids(self, index, value): self.tag_ids[index] = value
    def delete_tag_ids(self, value): self.tag_ids.remove(value)
    def get_any(self): return self.any
    def set_any(self, any): self.any = any
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.subnet == other.subnet and
                    self.virtual_network == other.virtual_network and
                    self.address_group == other.address_group and
                    self.tags == other.tags and
                    self.tag_ids == other.tag_ids and
                    self.any == other.any)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.subnet if self.subnet is not None else -7985492147856592190,
                     self.virtual_network if self.virtual_network is not None else -7985492147856592190,
                     self.address_group if self.address_group is not None else -7985492147856592190,
                     tuple(self.tags or []),
                     tuple(self.tag_ids or []),
                     self.any if self.any is not None else -7985492147856592190))

    def __repr__(self):
        return ("subnet = " + str(self.subnet) + ", " +
                "virtual_network = " + str(self.virtual_network) + ", " +
                "address_group = " + str(self.address_group) + ", " +
                "tags = " + str(self.tags) + ", " +
                "tag_ids = " + str(self.tag_ids) + ", " +
                "any = " + str(self.any))

    def copy(self):
        cp = FirewallRuleEndpointType()
        if self.subnet is not None:
            cp.subnet = self.subnet.copy()
        if self.virtual_network is not None:
            cp.virtual_network = self.virtual_network
        if self.address_group is not None:
            cp.address_group = self.address_group
        if self.tags is not None:
            cp.tags = list(self.tags)
        if self.tag_ids is not None:
            cp.tag_ids = list(self.tag_ids)
        if self.any is not None:
            cp.any = self.any
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_subnet (SubnetType.populate ())
        obj.set_virtual_network (obj.populate_string ("virtual_network"))
        obj.set_address_group (obj.populate_string ("address_group"))
        obj.set_tags ([obj.populate_string ("tags")])
        obj.set_tag_ids ([obj.populate_integer ("tag_ids")])
        obj.set_any (obj.populate_boolean ("any"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='FirewallRuleEndpointType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FirewallRuleEndpointType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FirewallRuleEndpointType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FirewallRuleEndpointType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.subnet is not None:
            self.subnet.export_xml(outfile, level, namespace_, name_='subnet', pretty_print=pretty_print)
        if self.virtual_network is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svirtual-network>%s</%svirtual-network>%s' % (namespace_, self.gds_format_string(quote_xml(self.virtual_network).encode(ExternalEncoding), input_name='virtual-network'), namespace_, eol_))
        if self.address_group is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saddress-group>%s</%saddress-group>%s' % (namespace_, self.gds_format_string(quote_xml(self.address_group).encode(ExternalEncoding), input_name='address-group'), namespace_, eol_))
        for tags_ in self.tags:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stags>%s</%stags>%s' % (namespace_, self.gds_format_string(quote_xml(tags_).encode(ExternalEncoding), input_name='tags'), namespace_, eol_))
        for tag_ids_ in self.tag_ids:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stag-ids>%s</%stag-ids>%s' % (namespace_, self.gds_format_integer(tag_ids_, input_name='tag-ids'), namespace_, eol_))
        if self.any is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sany>%s</%sany>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.any)), input_name='any'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.subnet is not None or
            self.virtual_network is not None or
            self.address_group is not None or
            self.tags or
            self.tag_ids or
            self.any is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FirewallRuleEndpointType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.subnet is not None:
            showIndent(outfile, level)
            outfile.write('subnet=model_.SubnetType(\n')
            self.subnet.exportLiteral(outfile, level, name_='subnet')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.virtual_network is not None:
            showIndent(outfile, level)
            outfile.write('virtual_network=%s,\n' % quote_python(self.virtual_network).encode(ExternalEncoding))
        if self.address_group is not None:
            showIndent(outfile, level)
            outfile.write('address_group=%s,\n' % quote_python(self.address_group).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('tags=[\n')
        level += 1
        for tags_ in self.tags:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(tags_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('tag_ids=[\n')
        level += 1
        for tag_ids_ in self.tag_ids:
            showIndent(outfile, level)
            outfile.write('%d,\n' % tag_ids)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.any is not None:
            showIndent(outfile, level)
            outfile.write('any=%s,\n' % self.any)
    def exportDict(self, name_='FirewallRuleEndpointType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'subnet':
            obj_ = SubnetType.factory()
            obj_.build(child_)
            self.set_subnet(obj_)
        elif nodeName_ == 'virtual-network':
            virtual_network_ = child_.text
            virtual_network_ = self.gds_validate_string(virtual_network_, node, 'virtual_network')
            self.virtual_network = virtual_network_
        elif nodeName_ == 'address-group':
            address_group_ = child_.text
            address_group_ = self.gds_validate_string(address_group_, node, 'address_group')
            self.address_group = address_group_
        elif nodeName_ == 'tags':
            tags_ = child_.text
            tags_ = self.gds_validate_string(tags_, node, 'tags')
            self.tags.append(tags_)
        elif nodeName_ == 'tag-ids':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'tag_ids')
            self.tag_ids.append(ival_)
        elif nodeName_ == 'any':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'any')
            self.any = ival_
# end class FirewallRuleEndpointType


class FirewallRuleMatchTagsType(GeneratedsSuper):
    """
    Attributes:
    * tag_list
        Type:           :class:`.TagType`

        Created By:           User (required)

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'tag_list']
    attr_field_type_vals = {u'tag_list': {'restrictions': None, 'description': [], 'simple_type': u'TagType', 'is_complex': 0, 'restriction_type': None, 'is_array': True, 'required': u'true', 'attr_type': u'string'}}
    def __init__(self, tag_list=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _tag_list = params_dict[u"tag_list"]
        except KeyError:
            _tag_list = tag_list
        if not _tag_list:
            self.tag_list = []
        else:
            self.tag_list = _tag_list
    def factory(*args_, **kwargs_):
        if FirewallRuleMatchTagsType.subclass:
            return FirewallRuleMatchTagsType.subclass(*args_, **kwargs_)
        else:
            return FirewallRuleMatchTagsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tag_list(self): return self.tag_list
    def set_tag_list(self, tag_list): self.tag_list = tag_list
    def add_tag_list(self, value): self.tag_list.append(value)
    def insert_tag_list(self, index, value): self.tag_list[index] = value
    def delete_tag_list(self, value): self.tag_list.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.tag_list == other.tag_list)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.tag_list or [])))

    def __repr__(self):
        return ("tag_list = " + str(self.tag_list))

    def copy(self):
        cp = FirewallRuleMatchTagsType()
        if self.tag_list is not None:
            cp.tag_list = list(self.tag_list)
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_tag_list ([obj.populate_string ("tag_list")])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='FirewallRuleMatchTagsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FirewallRuleMatchTagsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FirewallRuleMatchTagsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FirewallRuleMatchTagsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for tag_list_ in self.tag_list:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stag-list>%s</%stag-list>%s' % (namespace_, self.gds_format_string(quote_xml(tag_list_).encode(ExternalEncoding), input_name='tag-list'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.tag_list
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FirewallRuleMatchTagsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('tag_list=[\n')
        level += 1
        for tag_list_ in self.tag_list:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(tag_list_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='FirewallRuleMatchTagsType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tag-list':
            tag_list_ = child_.text
            tag_list_ = self.gds_validate_string(tag_list_, node, 'tag_list')
            self.tag_list.append(tag_list_)
# end class FirewallRuleMatchTagsType


class FirewallRuleMatchTagsTypeIdList(GeneratedsSuper):
    """
    Attributes:
    * tag_type
        Type:           int

        Created By:           User (required)

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'tag_type']
    attr_field_type_vals = {u'tag_type': {'restrictions': None, 'description': [], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': True, 'required': u'true', 'attr_type': u'integer'}}
    def __init__(self, tag_type=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _tag_type = params_dict[u"tag_type"]
        except KeyError:
            _tag_type = tag_type
        if not _tag_type:
            self.tag_type = []
        else:
            self.tag_type = _tag_type
    def factory(*args_, **kwargs_):
        if FirewallRuleMatchTagsTypeIdList.subclass:
            return FirewallRuleMatchTagsTypeIdList.subclass(*args_, **kwargs_)
        else:
            return FirewallRuleMatchTagsTypeIdList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tag_type(self): return self.tag_type
    def set_tag_type(self, tag_type): self.tag_type = tag_type
    def add_tag_type(self, value): self.tag_type.append(value)
    def insert_tag_type(self, index, value): self.tag_type[index] = value
    def delete_tag_type(self, value): self.tag_type.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.tag_type == other.tag_type)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.tag_type or [])))

    def __repr__(self):
        return ("tag_type = " + str(self.tag_type))

    def copy(self):
        cp = FirewallRuleMatchTagsTypeIdList()
        if self.tag_type is not None:
            cp.tag_type = list(self.tag_type)
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_tag_type ([obj.populate_integer ("tag_type")])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='FirewallRuleMatchTagsTypeIdList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FirewallRuleMatchTagsTypeIdList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FirewallRuleMatchTagsTypeIdList'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FirewallRuleMatchTagsTypeIdList', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for tag_type_ in self.tag_type:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stag-type>%s</%stag-type>%s' % (namespace_, self.gds_format_integer(tag_type_, input_name='tag-type'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.tag_type
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FirewallRuleMatchTagsTypeIdList'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('tag_type=[\n')
        level += 1
        for tag_type_ in self.tag_type:
            showIndent(outfile, level)
            outfile.write('%d,\n' % tag_type)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='FirewallRuleMatchTagsTypeIdList'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tag-type':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'tag_type')
            self.tag_type.append(ival_)
# end class FirewallRuleMatchTagsTypeIdList


class FirewallSequence(GeneratedsSuper):
    """
    Attributes:
    * sequence
        Type:           str, *one-of* xsd:string

        Created By:           User (required)

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'sequence']
    attr_field_type_vals = {u'sequence': {'restrictions': [], 'description': [], 'simple_type': u'SequenceNumberType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'true', 'attr_type': u'string'}}
    def __init__(self, sequence=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _sequence = params_dict[u"sequence"]
        except KeyError:
            _sequence = sequence
        self.sequence = _sequence
    def factory(*args_, **kwargs_):
        if FirewallSequence.subclass:
            return FirewallSequence.subclass(*args_, **kwargs_)
        else:
            return FirewallSequence(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_sequence(self): return self.sequence
    def set_sequence(self, sequence): self.sequence = sequence
    def validate_SequenceNumberType(self, value):
        # Validate type SequenceNumberType, a restriction on xsd:string.
        pass
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.sequence == other.sequence)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.sequence if self.sequence is not None else -7985492147856592190))

    def __repr__(self):
        return ("sequence = " + str(self.sequence))

    def copy(self):
        cp = FirewallSequence()
        if self.sequence is not None:
            cp.sequence = self.sequence
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_sequence (obj.populate_string ("sequence"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='FirewallSequence', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FirewallSequence')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FirewallSequence'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FirewallSequence', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.sequence is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssequence>%s</%ssequence>%s' % (namespace_, self.gds_format_string(quote_xml(self.sequence).encode(ExternalEncoding), input_name='sequence'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.sequence is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FirewallSequence'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.sequence is not None:
            showIndent(outfile, level)
            outfile.write('sequence=%s,\n' % quote_python(self.sequence).encode(ExternalEncoding))
    def exportDict(self, name_='FirewallSequence'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'sequence':
            sequence_ = child_.text
            sequence_ = self.gds_validate_string(sequence_, node, 'sequence')
            self.sequence = sequence_
            self.validate_SequenceNumberType(self.sequence)    # validate type SequenceNumberType
# end class FirewallSequence


class ExecutableInfoType(GeneratedsSuper):
    """
    Attributes:
    * executable_path
        Type:           str

        Created By:           User (required)

        Description:
          absolute path of the binary to execute

    * executable_args
        Type:           str

        Created By:           User (optional)

        Description:
          Optional arguments to be passed to the executable

    * job_completion_weightage
        Type:           int

        Description:
          Job percentage completion when this executable is completed.

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'executable_path', u'executable_args', u'job_completion_weightage']
    attr_field_type_vals = {u'executable_args': {'restrictions': None, 'description': [u'Optional arguments to be passed to the executable'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'executable_path': {'restrictions': None, 'description': [u'absolute path of the binary to execute'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'true', 'attr_type': u'string'}, u'job_completion_weightage': {'restrictions': None, 'description': [u'Job percentage completion when this executable is completed.'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'integer'}}
    def __init__(self, executable_path=None, executable_args=None, job_completion_weightage=100, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _executable_path = params_dict[u"executable_path"]
        except KeyError:
            _executable_path = executable_path
        self.executable_path = _executable_path
        try:
            _executable_args = params_dict[u"executable_args"]
        except KeyError:
            _executable_args = executable_args
        self.executable_args = _executable_args
        try:
            _job_completion_weightage = params_dict[u"job_completion_weightage"]
        except KeyError:
            _job_completion_weightage = job_completion_weightage
        self.job_completion_weightage = _job_completion_weightage
    def factory(*args_, **kwargs_):
        if ExecutableInfoType.subclass:
            return ExecutableInfoType.subclass(*args_, **kwargs_)
        else:
            return ExecutableInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_executable_path(self): return self.executable_path
    def set_executable_path(self, executable_path): self.executable_path = executable_path
    def get_executable_args(self): return self.executable_args
    def set_executable_args(self, executable_args): self.executable_args = executable_args
    def get_job_completion_weightage(self): return self.job_completion_weightage
    def set_job_completion_weightage(self, job_completion_weightage): self.job_completion_weightage = job_completion_weightage
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.executable_path == other.executable_path and
                    self.executable_args == other.executable_args and
                    self.job_completion_weightage == other.job_completion_weightage)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.executable_path if self.executable_path is not None else -7985492147856592190,
                     self.executable_args if self.executable_args is not None else -7985492147856592190,
                     self.job_completion_weightage if self.job_completion_weightage is not None else -7985492147856592190))

    def __repr__(self):
        return ("executable_path = " + str(self.executable_path) + ", " +
                "executable_args = " + str(self.executable_args) + ", " +
                "job_completion_weightage = " + str(self.job_completion_weightage))

    def copy(self):
        cp = ExecutableInfoType()
        if self.executable_path is not None:
            cp.executable_path = self.executable_path
        if self.executable_args is not None:
            cp.executable_args = self.executable_args
        if self.job_completion_weightage is not None:
            cp.job_completion_weightage = self.job_completion_weightage
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_executable_path (obj.populate_string ("executable_path"))
        obj.set_executable_args (obj.populate_string ("executable_args"))
        obj.set_job_completion_weightage (obj.populate_integer ("job_completion_weightage"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='ExecutableInfoType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExecutableInfoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExecutableInfoType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ExecutableInfoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.executable_path is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexecutable-path>%s</%sexecutable-path>%s' % (namespace_, self.gds_format_string(quote_xml(self.executable_path).encode(ExternalEncoding), input_name='executable-path'), namespace_, eol_))
        if self.executable_args is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexecutable-args>%s</%sexecutable-args>%s' % (namespace_, self.gds_format_string(quote_xml(self.executable_args).encode(ExternalEncoding), input_name='executable-args'), namespace_, eol_))
        if self.job_completion_weightage is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sjob-completion-weightage>%s</%sjob-completion-weightage>%s' % (namespace_, self.gds_format_integer(self.job_completion_weightage, input_name='job-completion-weightage'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.executable_path is not None or
            self.executable_args is not None or
            self.job_completion_weightage is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ExecutableInfoType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.executable_path is not None:
            showIndent(outfile, level)
            outfile.write('executable_path=%s,\n' % quote_python(self.executable_path).encode(ExternalEncoding))
        if self.executable_args is not None:
            showIndent(outfile, level)
            outfile.write('executable_args=%s,\n' % quote_python(self.executable_args).encode(ExternalEncoding))
        if self.job_completion_weightage is not None:
            showIndent(outfile, level)
            outfile.write('job_completion_weightage=%d,\n' % self.job_completion_weightage)
    def exportDict(self, name_='ExecutableInfoType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'executable-path':
            executable_path_ = child_.text
            executable_path_ = self.gds_validate_string(executable_path_, node, 'executable_path')
            self.executable_path = executable_path_
        elif nodeName_ == 'executable-args':
            executable_args_ = child_.text
            executable_args_ = self.gds_validate_string(executable_args_, node, 'executable_args')
            self.executable_args = executable_args_
        elif nodeName_ == 'job-completion-weightage':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'job_completion_weightage')
            self.job_completion_weightage = ival_
# end class ExecutableInfoType


class ExecutableInfoListType(GeneratedsSuper):
    """
    Attributes:
    * executable_info
        Type:           :class:`.ExecutableInfoType`

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'executable_info']
    attr_field_type_vals = {u'executable_info': {'restrictions': None, 'description': [], 'simple_type': u'ExecutableInfoType', 'is_complex': 1, 'restriction_type': None, 'is_array': True, 'required': None, 'attr_type': u'ExecutableInfoType'}}
    def __init__(self, executable_info=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _executable_info = params_dict[u"executable_info"]
        except KeyError:
            _executable_info = executable_info
        if not _executable_info:
            self.executable_info = []
        else:
            if isinstance(_executable_info[0], dict):
                objs = [ExecutableInfoType(params_dict=elem) for elem in _executable_info]
                self.executable_info = objs
            else:
                self.executable_info = _executable_info
    def factory(*args_, **kwargs_):
        if ExecutableInfoListType.subclass:
            return ExecutableInfoListType.subclass(*args_, **kwargs_)
        else:
            return ExecutableInfoListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_executable_info(self): return self.executable_info
    def set_executable_info(self, executable_info): self.executable_info = executable_info
    def add_executable_info(self, value): self.executable_info.append(value)
    def insert_executable_info(self, index, value): self.executable_info[index] = value
    def delete_executable_info(self, value): self.executable_info.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.executable_info == other.executable_info)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.executable_info or [])))

    def __repr__(self):
        return ("executable_info = " + str(self.executable_info))

    def copy(self):
        cp = ExecutableInfoListType()
        if self.executable_info is not None:
            cp.executable_info = [x.copy() for x in self.executable_info]
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_executable_info ([ExecutableInfoType.populate ()])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='ExecutableInfoListType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExecutableInfoListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExecutableInfoListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ExecutableInfoListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for executable_info_ in self.executable_info:
            if isinstance(executable_info_, dict):
                executable_info_ = ExecutableInfoType(**executable_info_)
            executable_info_.export_xml(outfile, level, namespace_, name_='executable-info', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.executable_info
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ExecutableInfoListType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('executable_info=[\n')
        level += 1
        for executable_info_ in self.executable_info:
            showIndent(outfile, level)
            outfile.write('model_.ExecutableInfoType(\n')
            executable_info_.exportLiteral(outfile, level, name_='ExecutableInfoType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='ExecutableInfoListType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'executable-info':
            obj_ = ExecutableInfoType.factory()
            obj_.build(child_)
            self.executable_info.append(obj_)
# end class ExecutableInfoListType


class PlaybookInfoType(GeneratedsSuper):
    """
    Attributes:
    * playbook_uri
        Type:           str

        Created By:           User (required)

        Description:
          uri to the playbook location on the file server

    * multi_device_playbook
        Type:           bool

        Description:
          if set to true, the execute-job action url uses the job-template parameter

          'device-list' to execute the playbook in parallel

    * vendor
        Type:           str

        Created By:           User (optional)

        Description:
          Vendor name

    * device_family
        Type:           str

        Created By:           User (optional)

        Description:
          Device family name

    * job_completion_weightage
        Type:           int

        Description:
          Job percentage completion when this playbook is completed. This attribute value

          should 100 if there is only one playbook defined in the job template. The job-

          completion-weigtages for all playbooks in the same job-template should add up to

          100 exact.

    * sequence_no
        Type:           int

        Created By:           User (optional)

        Description:
          Sequence number of the playbook

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'playbook_uri', u'multi_device_playbook', u'vendor', u'device_family', u'job_completion_weightage', u'sequence_no']
    attr_field_type_vals = {u'vendor': {'restrictions': None, 'description': [u'Vendor name'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'job_completion_weightage': {'restrictions': None, 'description': [u'Job percentage completion when this playbook is completed. This attribute value should 100 if there is only one playbook defined in the job template. The job-completion-weigtages for all playbooks in the same job-template should add up to 100 exact.'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'integer'}, u'sequence_no': {'restrictions': None, 'description': [u'Sequence number of the playbook'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'device_family': {'restrictions': None, 'description': [u'Device family name'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'multi_device_playbook': {'restrictions': None, 'description': [u"if set to true, the execute-job action url uses the job-template parameter 'device-list' to execute the playbook in parallel"], 'simple_type': u'xsd:boolean', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'boolean'}, u'playbook_uri': {'restrictions': None, 'description': [u'uri to the playbook location on the file server'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'true', 'attr_type': u'string'}}
    def __init__(self, playbook_uri=None, multi_device_playbook=False, vendor=None, device_family=None, job_completion_weightage=100, sequence_no=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _playbook_uri = params_dict[u"playbook_uri"]
        except KeyError:
            _playbook_uri = playbook_uri
        self.playbook_uri = _playbook_uri
        try:
            _multi_device_playbook = params_dict[u"multi_device_playbook"]
        except KeyError:
            _multi_device_playbook = multi_device_playbook
        self.multi_device_playbook = _multi_device_playbook
        try:
            _vendor = params_dict[u"vendor"]
        except KeyError:
            _vendor = vendor
        self.vendor = _vendor
        try:
            _device_family = params_dict[u"device_family"]
        except KeyError:
            _device_family = device_family
        self.device_family = _device_family
        try:
            _job_completion_weightage = params_dict[u"job_completion_weightage"]
        except KeyError:
            _job_completion_weightage = job_completion_weightage
        self.job_completion_weightage = _job_completion_weightage
        try:
            _sequence_no = params_dict[u"sequence_no"]
        except KeyError:
            _sequence_no = sequence_no
        self.sequence_no = _sequence_no
    def factory(*args_, **kwargs_):
        if PlaybookInfoType.subclass:
            return PlaybookInfoType.subclass(*args_, **kwargs_)
        else:
            return PlaybookInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_playbook_uri(self): return self.playbook_uri
    def set_playbook_uri(self, playbook_uri): self.playbook_uri = playbook_uri
    def get_multi_device_playbook(self): return self.multi_device_playbook
    def set_multi_device_playbook(self, multi_device_playbook): self.multi_device_playbook = multi_device_playbook
    def get_vendor(self): return self.vendor
    def set_vendor(self, vendor): self.vendor = vendor
    def get_device_family(self): return self.device_family
    def set_device_family(self, device_family): self.device_family = device_family
    def get_job_completion_weightage(self): return self.job_completion_weightage
    def set_job_completion_weightage(self, job_completion_weightage): self.job_completion_weightage = job_completion_weightage
    def get_sequence_no(self): return self.sequence_no
    def set_sequence_no(self, sequence_no): self.sequence_no = sequence_no
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.playbook_uri == other.playbook_uri and
                    self.multi_device_playbook == other.multi_device_playbook and
                    self.vendor == other.vendor and
                    self.device_family == other.device_family and
                    self.job_completion_weightage == other.job_completion_weightage and
                    self.sequence_no == other.sequence_no)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.playbook_uri if self.playbook_uri is not None else -7985492147856592190,
                     self.multi_device_playbook if self.multi_device_playbook is not None else -7985492147856592190,
                     self.vendor if self.vendor is not None else -7985492147856592190,
                     self.device_family if self.device_family is not None else -7985492147856592190,
                     self.job_completion_weightage if self.job_completion_weightage is not None else -7985492147856592190,
                     self.sequence_no if self.sequence_no is not None else -7985492147856592190))

    def __repr__(self):
        return ("playbook_uri = " + str(self.playbook_uri) + ", " +
                "multi_device_playbook = " + str(self.multi_device_playbook) + ", " +
                "vendor = " + str(self.vendor) + ", " +
                "device_family = " + str(self.device_family) + ", " +
                "job_completion_weightage = " + str(self.job_completion_weightage) + ", " +
                "sequence_no = " + str(self.sequence_no))

    def copy(self):
        cp = PlaybookInfoType()
        if self.playbook_uri is not None:
            cp.playbook_uri = self.playbook_uri
        if self.multi_device_playbook is not None:
            cp.multi_device_playbook = self.multi_device_playbook
        if self.vendor is not None:
            cp.vendor = self.vendor
        if self.device_family is not None:
            cp.device_family = self.device_family
        if self.job_completion_weightage is not None:
            cp.job_completion_weightage = self.job_completion_weightage
        if self.sequence_no is not None:
            cp.sequence_no = self.sequence_no
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_playbook_uri (obj.populate_string ("playbook_uri"))
        obj.set_multi_device_playbook (obj.populate_boolean ("multi_device_playbook"))
        obj.set_vendor (obj.populate_string ("vendor"))
        obj.set_device_family (obj.populate_string ("device_family"))
        obj.set_job_completion_weightage (obj.populate_integer ("job_completion_weightage"))
        obj.set_sequence_no (obj.populate_integer ("sequence_no"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='PlaybookInfoType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PlaybookInfoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PlaybookInfoType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PlaybookInfoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.playbook_uri is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%splaybook-uri>%s</%splaybook-uri>%s' % (namespace_, self.gds_format_string(quote_xml(self.playbook_uri).encode(ExternalEncoding), input_name='playbook-uri'), namespace_, eol_))
        if self.multi_device_playbook is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smulti-device-playbook>%s</%smulti-device-playbook>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.multi_device_playbook)), input_name='multi-device-playbook'), namespace_, eol_))
        if self.vendor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svendor>%s</%svendor>%s' % (namespace_, self.gds_format_string(quote_xml(self.vendor).encode(ExternalEncoding), input_name='vendor'), namespace_, eol_))
        if self.device_family is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdevice-family>%s</%sdevice-family>%s' % (namespace_, self.gds_format_string(quote_xml(self.device_family).encode(ExternalEncoding), input_name='device-family'), namespace_, eol_))
        if self.job_completion_weightage is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sjob-completion-weightage>%s</%sjob-completion-weightage>%s' % (namespace_, self.gds_format_integer(self.job_completion_weightage, input_name='job-completion-weightage'), namespace_, eol_))
        if self.sequence_no is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssequence-no>%s</%ssequence-no>%s' % (namespace_, self.gds_format_integer(self.sequence_no, input_name='sequence-no'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.playbook_uri is not None or
            self.multi_device_playbook is not None or
            self.vendor is not None or
            self.device_family is not None or
            self.job_completion_weightage is not None or
            self.sequence_no is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PlaybookInfoType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.playbook_uri is not None:
            showIndent(outfile, level)
            outfile.write('playbook_uri=%s,\n' % quote_python(self.playbook_uri).encode(ExternalEncoding))
        if self.multi_device_playbook is not None:
            showIndent(outfile, level)
            outfile.write('multi_device_playbook=%s,\n' % self.multi_device_playbook)
        if self.vendor is not None:
            showIndent(outfile, level)
            outfile.write('vendor=%s,\n' % quote_python(self.vendor).encode(ExternalEncoding))
        if self.device_family is not None:
            showIndent(outfile, level)
            outfile.write('device_family=%s,\n' % quote_python(self.device_family).encode(ExternalEncoding))
        if self.job_completion_weightage is not None:
            showIndent(outfile, level)
            outfile.write('job_completion_weightage=%d,\n' % self.job_completion_weightage)
        if self.sequence_no is not None:
            showIndent(outfile, level)
            outfile.write('sequence_no=%d,\n' % self.sequence_no)
    def exportDict(self, name_='PlaybookInfoType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'playbook-uri':
            playbook_uri_ = child_.text
            playbook_uri_ = self.gds_validate_string(playbook_uri_, node, 'playbook_uri')
            self.playbook_uri = playbook_uri_
        elif nodeName_ == 'multi-device-playbook':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'multi_device_playbook')
            self.multi_device_playbook = ival_
        elif nodeName_ == 'vendor':
            vendor_ = child_.text
            vendor_ = self.gds_validate_string(vendor_, node, 'vendor')
            self.vendor = vendor_
        elif nodeName_ == 'device-family':
            device_family_ = child_.text
            device_family_ = self.gds_validate_string(device_family_, node, 'device_family')
            self.device_family = device_family_
        elif nodeName_ == 'job-completion-weightage':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'job_completion_weightage')
            self.job_completion_weightage = ival_
        elif nodeName_ == 'sequence-no':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'sequence_no')
            self.sequence_no = ival_
# end class PlaybookInfoType


class PlaybookInfoListType(GeneratedsSuper):
    """
    Attributes:
    * playbook_info
        Type:           :class:`.PlaybookInfoType`

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'playbook_info']
    attr_field_type_vals = {u'playbook_info': {'restrictions': None, 'description': [], 'simple_type': u'PlaybookInfoType', 'is_complex': 1, 'restriction_type': None, 'is_array': True, 'required': None, 'attr_type': u'PlaybookInfoType'}}
    def __init__(self, playbook_info=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _playbook_info = params_dict[u"playbook_info"]
        except KeyError:
            _playbook_info = playbook_info
        if not _playbook_info:
            self.playbook_info = []
        else:
            if isinstance(_playbook_info[0], dict):
                objs = [PlaybookInfoType(params_dict=elem) for elem in _playbook_info]
                self.playbook_info = objs
            else:
                self.playbook_info = _playbook_info
    def factory(*args_, **kwargs_):
        if PlaybookInfoListType.subclass:
            return PlaybookInfoListType.subclass(*args_, **kwargs_)
        else:
            return PlaybookInfoListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_playbook_info(self): return self.playbook_info
    def set_playbook_info(self, playbook_info): self.playbook_info = playbook_info
    def add_playbook_info(self, value): self.playbook_info.append(value)
    def insert_playbook_info(self, index, value): self.playbook_info[index] = value
    def delete_playbook_info(self, value): self.playbook_info.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.playbook_info == other.playbook_info)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.playbook_info or [])))

    def __repr__(self):
        return ("playbook_info = " + str(self.playbook_info))

    def copy(self):
        cp = PlaybookInfoListType()
        if self.playbook_info is not None:
            cp.playbook_info = [x.copy() for x in self.playbook_info]
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_playbook_info ([PlaybookInfoType.populate ()])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='PlaybookInfoListType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PlaybookInfoListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PlaybookInfoListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PlaybookInfoListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for playbook_info_ in self.playbook_info:
            if isinstance(playbook_info_, dict):
                playbook_info_ = PlaybookInfoType(**playbook_info_)
            playbook_info_.export_xml(outfile, level, namespace_, name_='playbook-info', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.playbook_info
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PlaybookInfoListType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('playbook_info=[\n')
        level += 1
        for playbook_info_ in self.playbook_info:
            showIndent(outfile, level)
            outfile.write('model_.PlaybookInfoType(\n')
            playbook_info_.exportLiteral(outfile, level, name_='PlaybookInfoType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='PlaybookInfoListType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'playbook-info':
            obj_ = PlaybookInfoType.factory()
            obj_.build(child_)
            self.playbook_info.append(obj_)
# end class PlaybookInfoListType


class VpgInterfaceParametersType(GeneratedsSuper):
    """
    Attributes:
    * ae_num
        Type:           int

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'ae_num']
    attr_field_type_vals = {u'ae_num': {'restrictions': None, 'description': [], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'integer'}}
    def __init__(self, ae_num=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _ae_num = params_dict[u"ae_num"]
        except KeyError:
            _ae_num = ae_num
        self.ae_num = _ae_num
    def factory(*args_, **kwargs_):
        if VpgInterfaceParametersType.subclass:
            return VpgInterfaceParametersType.subclass(*args_, **kwargs_)
        else:
            return VpgInterfaceParametersType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ae_num(self): return self.ae_num
    def set_ae_num(self, ae_num): self.ae_num = ae_num
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.ae_num == other.ae_num)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.ae_num if self.ae_num is not None else -7985492147856592190))

    def __repr__(self):
        return ("ae_num = " + str(self.ae_num))

    def copy(self):
        cp = VpgInterfaceParametersType()
        if self.ae_num is not None:
            cp.ae_num = self.ae_num
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_ae_num (obj.populate_integer ("ae_num"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='VpgInterfaceParametersType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VpgInterfaceParametersType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VpgInterfaceParametersType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VpgInterfaceParametersType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ae_num is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sae-num>%s</%sae-num>%s' % (namespace_, self.gds_format_integer(self.ae_num, input_name='ae-num'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.ae_num is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='VpgInterfaceParametersType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ae_num is not None:
            showIndent(outfile, level)
            outfile.write('ae_num=%d,\n' % self.ae_num)
    def exportDict(self, name_='VpgInterfaceParametersType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ae-num':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ae_num')
            self.ae_num = ival_
# end class VpgInterfaceParametersType


class DeviceCredential(GeneratedsSuper):
    """
    Attributes:
    * credential
        Type:           :class:`.UserCredentials`

        Created By:           User (required)

    * vendor
        Type:           str

        Created By:           User (optional)

    * device_family
        Type:           str

        Created By:           User (optional)

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'credential', u'vendor', u'device_family']
    attr_field_type_vals = {u'device_family': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'credential': {'restrictions': None, 'description': [], 'simple_type': u'UserCredentials', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': u'true', 'attr_type': u'UserCredentials'}, u'vendor': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'string'}}
    def __init__(self, credential=None, vendor=None, device_family=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _credential = params_dict[u"credential"]
        except KeyError:
            _credential = credential
        if isinstance(_credential, dict):
            obj = UserCredentials(params_dict=_credential)
            self.credential = obj
        else:
            self.credential = _credential
        try:
            _vendor = params_dict[u"vendor"]
        except KeyError:
            _vendor = vendor
        self.vendor = _vendor
        try:
            _device_family = params_dict[u"device_family"]
        except KeyError:
            _device_family = device_family
        self.device_family = _device_family
    def factory(*args_, **kwargs_):
        if DeviceCredential.subclass:
            return DeviceCredential.subclass(*args_, **kwargs_)
        else:
            return DeviceCredential(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_credential(self): return self.credential
    def set_credential(self, credential): self.credential = credential
    def get_vendor(self): return self.vendor
    def set_vendor(self, vendor): self.vendor = vendor
    def get_device_family(self): return self.device_family
    def set_device_family(self, device_family): self.device_family = device_family
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.credential == other.credential and
                    self.vendor == other.vendor and
                    self.device_family == other.device_family)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.credential if self.credential is not None else -7985492147856592190,
                     self.vendor if self.vendor is not None else -7985492147856592190,
                     self.device_family if self.device_family is not None else -7985492147856592190))

    def __repr__(self):
        return ("credential = " + str(self.credential) + ", " +
                "vendor = " + str(self.vendor) + ", " +
                "device_family = " + str(self.device_family))

    def copy(self):
        cp = DeviceCredential()
        if self.credential is not None:
            cp.credential = self.credential.copy()
        if self.vendor is not None:
            cp.vendor = self.vendor
        if self.device_family is not None:
            cp.device_family = self.device_family
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_credential (UserCredentials.populate ())
        obj.set_vendor (obj.populate_string ("vendor"))
        obj.set_device_family (obj.populate_string ("device_family"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='DeviceCredential', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DeviceCredential')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DeviceCredential'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DeviceCredential', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.credential is not None:
            self.credential.export_xml(outfile, level, namespace_, name_='credential', pretty_print=pretty_print)
        if self.vendor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svendor>%s</%svendor>%s' % (namespace_, self.gds_format_string(quote_xml(self.vendor).encode(ExternalEncoding), input_name='vendor'), namespace_, eol_))
        if self.device_family is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdevice-family>%s</%sdevice-family>%s' % (namespace_, self.gds_format_string(quote_xml(self.device_family).encode(ExternalEncoding), input_name='device-family'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.credential is not None or
            self.vendor is not None or
            self.device_family is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DeviceCredential'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.credential is not None:
            showIndent(outfile, level)
            outfile.write('credential=model_.UserCredentials(\n')
            self.credential.exportLiteral(outfile, level, name_='credential')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.vendor is not None:
            showIndent(outfile, level)
            outfile.write('vendor=%s,\n' % quote_python(self.vendor).encode(ExternalEncoding))
        if self.device_family is not None:
            showIndent(outfile, level)
            outfile.write('device_family=%s,\n' % quote_python(self.device_family).encode(ExternalEncoding))
    def exportDict(self, name_='DeviceCredential'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'credential':
            obj_ = UserCredentials.factory()
            obj_.build(child_)
            self.set_credential(obj_)
        elif nodeName_ == 'vendor':
            vendor_ = child_.text
            vendor_ = self.gds_validate_string(vendor_, node, 'vendor')
            self.vendor = vendor_
        elif nodeName_ == 'device-family':
            device_family_ = child_.text
            device_family_ = self.gds_validate_string(device_family_, node, 'device_family')
            self.device_family = device_family_
# end class DeviceCredential


class DeviceCredentialList(GeneratedsSuper):
    """
    Attributes:
    * device_credential
        Type:           :class:`.DeviceCredential`

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'device_credential']
    attr_field_type_vals = {u'device_credential': {'restrictions': None, 'description': [], 'simple_type': u'DeviceCredential', 'is_complex': 1, 'restriction_type': None, 'is_array': True, 'required': None, 'attr_type': u'DeviceCredential'}}
    def __init__(self, device_credential=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _device_credential = params_dict[u"device_credential"]
        except KeyError:
            _device_credential = device_credential
        if not _device_credential:
            self.device_credential = []
        else:
            if isinstance(_device_credential[0], dict):
                objs = [DeviceCredential(params_dict=elem) for elem in _device_credential]
                self.device_credential = objs
            else:
                self.device_credential = _device_credential
    def factory(*args_, **kwargs_):
        if DeviceCredentialList.subclass:
            return DeviceCredentialList.subclass(*args_, **kwargs_)
        else:
            return DeviceCredentialList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_device_credential(self): return self.device_credential
    def set_device_credential(self, device_credential): self.device_credential = device_credential
    def add_device_credential(self, value): self.device_credential.append(value)
    def insert_device_credential(self, index, value): self.device_credential[index] = value
    def delete_device_credential(self, value): self.device_credential.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.device_credential == other.device_credential)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.device_credential or [])))

    def __repr__(self):
        return ("device_credential = " + str(self.device_credential))

    def copy(self):
        cp = DeviceCredentialList()
        if self.device_credential is not None:
            cp.device_credential = [x.copy() for x in self.device_credential]
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_device_credential ([DeviceCredential.populate ()])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='DeviceCredentialList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DeviceCredentialList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DeviceCredentialList'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DeviceCredentialList', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for device_credential_ in self.device_credential:
            if isinstance(device_credential_, dict):
                device_credential_ = DeviceCredential(**device_credential_)
            device_credential_.export_xml(outfile, level, namespace_, name_='device-credential', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.device_credential
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DeviceCredentialList'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('device_credential=[\n')
        level += 1
        for device_credential_ in self.device_credential:
            showIndent(outfile, level)
            outfile.write('model_.DeviceCredential(\n')
            device_credential_.exportLiteral(outfile, level, name_='DeviceCredential')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='DeviceCredentialList'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'device-credential':
            obj_ = DeviceCredential.factory()
            obj_.build(child_)
            self.device_credential.append(obj_)
# end class DeviceCredentialList


class CliDiffInfoType(GeneratedsSuper):
    """
    Attributes:
    * username
        Type:           str

    * time
        Type:           str

    * config_changes
        Type:           str

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'username', u'time', u'config_changes']
    attr_field_type_vals = {u'username': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'config_changes': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'time': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}}
    def __init__(self, username=None, time=None, config_changes=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _username = params_dict[u"username"]
        except KeyError:
            _username = username
        self.username = _username
        try:
            _time = params_dict[u"time"]
        except KeyError:
            _time = time
        self.time = _time
        try:
            _config_changes = params_dict[u"config_changes"]
        except KeyError:
            _config_changes = config_changes
        self.config_changes = _config_changes
    def factory(*args_, **kwargs_):
        if CliDiffInfoType.subclass:
            return CliDiffInfoType.subclass(*args_, **kwargs_)
        else:
            return CliDiffInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_username(self): return self.username
    def set_username(self, username): self.username = username
    def get_time(self): return self.time
    def set_time(self, time): self.time = time
    def get_config_changes(self): return self.config_changes
    def set_config_changes(self, config_changes): self.config_changes = config_changes
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.username == other.username and
                    self.time == other.time and
                    self.config_changes == other.config_changes)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.username if self.username is not None else -7985492147856592190,
                     self.time if self.time is not None else -7985492147856592190,
                     self.config_changes if self.config_changes is not None else -7985492147856592190))

    def __repr__(self):
        return ("username = " + str(self.username) + ", " +
                "time = " + str(self.time) + ", " +
                "config_changes = " + str(self.config_changes))

    def copy(self):
        cp = CliDiffInfoType()
        if self.username is not None:
            cp.username = self.username
        if self.time is not None:
            cp.time = self.time
        if self.config_changes is not None:
            cp.config_changes = self.config_changes
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_username (obj.populate_string ("username"))
        obj.set_time (obj.populate_string ("time"))
        obj.set_config_changes (obj.populate_string ("config_changes"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='CliDiffInfoType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CliDiffInfoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CliDiffInfoType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CliDiffInfoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.username is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%susername>%s</%susername>%s' % (namespace_, self.gds_format_string(quote_xml(self.username).encode(ExternalEncoding), input_name='username'), namespace_, eol_))
        if self.time is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stime>%s</%stime>%s' % (namespace_, self.gds_format_string(quote_xml(self.time).encode(ExternalEncoding), input_name='time'), namespace_, eol_))
        if self.config_changes is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sconfig_changes>%s</%sconfig_changes>%s' % (namespace_, self.gds_format_string(quote_xml(self.config_changes).encode(ExternalEncoding), input_name='config_changes'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.username is not None or
            self.time is not None or
            self.config_changes is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CliDiffInfoType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.username is not None:
            showIndent(outfile, level)
            outfile.write('username=%s,\n' % quote_python(self.username).encode(ExternalEncoding))
        if self.time is not None:
            showIndent(outfile, level)
            outfile.write('time=%s,\n' % quote_python(self.time).encode(ExternalEncoding))
        if self.config_changes is not None:
            showIndent(outfile, level)
            outfile.write('config_changes=%s,\n' % quote_python(self.config_changes).encode(ExternalEncoding))
    def exportDict(self, name_='CliDiffInfoType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'username':
            username_ = child_.text
            username_ = self.gds_validate_string(username_, node, 'username')
            self.username = username_
        elif nodeName_ == 'time':
            time_ = child_.text
            time_ = self.gds_validate_string(time_, node, 'time')
            self.time = time_
        elif nodeName_ == 'config_changes':
            config_changes_ = child_.text
            config_changes_ = self.gds_validate_string(config_changes_, node, 'config_changes')
            self.config_changes = config_changes_
# end class CliDiffInfoType


class CliDiffListType(GeneratedsSuper):
    """
    Attributes:
    * commit_diff_info
        Type:           :class:`.CliDiffInfoType`

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'commit_diff_info']
    attr_field_type_vals = {u'commit_diff_info': {'restrictions': None, 'description': [], 'simple_type': u'CliDiffInfoType', 'is_complex': 1, 'restriction_type': None, 'is_array': True, 'required': None, 'attr_type': u'CliDiffInfoType'}}
    def __init__(self, commit_diff_info=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _commit_diff_info = params_dict[u"commit_diff_info"]
        except KeyError:
            _commit_diff_info = commit_diff_info
        if not _commit_diff_info:
            self.commit_diff_info = []
        else:
            if isinstance(_commit_diff_info[0], dict):
                objs = [CliDiffInfoType(params_dict=elem) for elem in _commit_diff_info]
                self.commit_diff_info = objs
            else:
                self.commit_diff_info = _commit_diff_info
    def factory(*args_, **kwargs_):
        if CliDiffListType.subclass:
            return CliDiffListType.subclass(*args_, **kwargs_)
        else:
            return CliDiffListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_commit_diff_info(self): return self.commit_diff_info
    def set_commit_diff_info(self, commit_diff_info): self.commit_diff_info = commit_diff_info
    def add_commit_diff_info(self, value): self.commit_diff_info.append(value)
    def insert_commit_diff_info(self, index, value): self.commit_diff_info[index] = value
    def delete_commit_diff_info(self, value): self.commit_diff_info.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.commit_diff_info == other.commit_diff_info)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.commit_diff_info or [])))

    def __repr__(self):
        return ("commit_diff_info = " + str(self.commit_diff_info))

    def copy(self):
        cp = CliDiffListType()
        if self.commit_diff_info is not None:
            cp.commit_diff_info = [x.copy() for x in self.commit_diff_info]
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_commit_diff_info ([CliDiffInfoType.populate ()])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='CliDiffListType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CliDiffListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CliDiffListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CliDiffListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for commit_diff_info_ in self.commit_diff_info:
            if isinstance(commit_diff_info_, dict):
                commit_diff_info_ = CliDiffInfoType(**commit_diff_info_)
            commit_diff_info_.export_xml(outfile, level, namespace_, name_='commit-diff-info', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.commit_diff_info
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CliDiffListType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('commit_diff_info=[\n')
        level += 1
        for commit_diff_info_ in self.commit_diff_info:
            showIndent(outfile, level)
            outfile.write('model_.CliDiffInfoType(\n')
            commit_diff_info_.exportLiteral(outfile, level, name_='CliDiffInfoType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='CliDiffListType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'commit-diff-info':
            obj_ = CliDiffInfoType.factory()
            obj_.build(child_)
            self.commit_diff_info.append(obj_)
# end class CliDiffListType


class StormControlParameters(GeneratedsSuper):
    """
    Attributes:
    * storm_control_actions
        Type:           str, *one-of* [u'interface-shutdown']

        Description:
          Default action (Discard) is implicit. In addition, other list of actions can be

          specified here

    * recovery_timeout
        Type:           int

        Created By:           User (optional)

        Description:
          Timeout in seconds. This enables the affected interface to recover automatically

          from the error condition after the specified period of time

    * no_unregistered_multicast
        Type:           bool

        Description:
          if set to true, disable unregistered multicast traffic storm control

    * no_registered_multicast
        Type:           bool

        Description:
          if set to true, disable registered multicast traffic storm control

    * no_unknown_unicast
        Type:           bool

        Description:
          if set to true, disable unknown unicast traffic storm control

    * no_multicast
        Type:           bool

        Description:
          if set to true, disable muticast traffic storm control

    * no_broadcast
        Type:           bool

        Description:
          if set to true, disable broadcast traffic storm control

    * bandwidth_percent
        Type:           int

        Created By:           User (required)

        Description:
          Configure storm control bandwidth level as percentage

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'storm_control_actions', u'recovery_timeout', u'no_unregistered_multicast', u'no_registered_multicast', u'no_unknown_unicast', u'no_multicast', u'no_broadcast', u'bandwidth_percent']
    attr_field_type_vals = {u'storm_control_actions': {'restrictions': [u'interface-shutdown'], 'description': [u'Default action (Discard) is implicit. In addition, other list of actions can be specified here'], 'simple_type': u'StormControlActionType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': True, 'required': None, 'attr_type': u'string'}, u'no_broadcast': {'restrictions': None, 'description': [u'if set to true, disable broadcast traffic storm control'], 'simple_type': u'xsd:boolean', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'boolean'}, u'no_multicast': {'restrictions': None, 'description': [u'if set to true, disable muticast traffic storm control'], 'simple_type': u'xsd:boolean', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'boolean'}, u'bandwidth_percent': {'restrictions': None, 'description': [u'Configure storm control bandwidth level as percentage'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'true', 'attr_type': u'integer'}, u'no_registered_multicast': {'restrictions': None, 'description': [u'if set to true, disable registered multicast traffic storm control'], 'simple_type': u'xsd:boolean', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'boolean'}, u'recovery_timeout': {'restrictions': None, 'description': [u'Timeout in seconds. This enables the affected interface to recover automatically from the error condition after the specified period of time'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'no_unregistered_multicast': {'restrictions': None, 'description': [u'if set to true, disable unregistered multicast traffic storm control'], 'simple_type': u'xsd:boolean', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'boolean'}, u'no_unknown_unicast': {'restrictions': None, 'description': [u'if set to true, disable unknown unicast traffic storm control'], 'simple_type': u'xsd:boolean', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'boolean'}}
    def __init__(self, storm_control_actions=None, recovery_timeout=None, no_unregistered_multicast=False, no_registered_multicast=False, no_unknown_unicast=False, no_multicast=False, no_broadcast=False, bandwidth_percent=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _storm_control_actions = params_dict[u"storm_control_actions"]
        except KeyError:
            _storm_control_actions = storm_control_actions
        if not _storm_control_actions:
            self.storm_control_actions = []
        else:
            self.storm_control_actions = _storm_control_actions
        try:
            _recovery_timeout = params_dict[u"recovery_timeout"]
        except KeyError:
            _recovery_timeout = recovery_timeout
        self.recovery_timeout = _recovery_timeout
        try:
            _no_unregistered_multicast = params_dict[u"no_unregistered_multicast"]
        except KeyError:
            _no_unregistered_multicast = no_unregistered_multicast
        self.no_unregistered_multicast = _no_unregistered_multicast
        try:
            _no_registered_multicast = params_dict[u"no_registered_multicast"]
        except KeyError:
            _no_registered_multicast = no_registered_multicast
        self.no_registered_multicast = _no_registered_multicast
        try:
            _no_unknown_unicast = params_dict[u"no_unknown_unicast"]
        except KeyError:
            _no_unknown_unicast = no_unknown_unicast
        self.no_unknown_unicast = _no_unknown_unicast
        try:
            _no_multicast = params_dict[u"no_multicast"]
        except KeyError:
            _no_multicast = no_multicast
        self.no_multicast = _no_multicast
        try:
            _no_broadcast = params_dict[u"no_broadcast"]
        except KeyError:
            _no_broadcast = no_broadcast
        self.no_broadcast = _no_broadcast
        try:
            _bandwidth_percent = params_dict[u"bandwidth_percent"]
        except KeyError:
            _bandwidth_percent = bandwidth_percent
        self.bandwidth_percent = _bandwidth_percent
    def factory(*args_, **kwargs_):
        if StormControlParameters.subclass:
            return StormControlParameters.subclass(*args_, **kwargs_)
        else:
            return StormControlParameters(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_storm_control_actions(self): return self.storm_control_actions
    def set_storm_control_actions(self, storm_control_actions): self.storm_control_actions = storm_control_actions
    def add_storm_control_actions(self, value): self.storm_control_actions.append(value)
    def insert_storm_control_actions(self, index, value): self.storm_control_actions[index] = value
    def delete_storm_control_actions(self, value): self.storm_control_actions.remove(value)
    def validate_StormControlActionType(self, value):
        # Validate type StormControlActionType, a restriction on xsd:string.
        error = False
        if isinstance(value, list):
            error = set(value) - set([u'interface-shutdown'])
        else:
            error = value not in [u'interface-shutdown']
        if error:
            raise ValueError("StormControlActionType must be one of [u'interface-shutdown']")
    def get_recovery_timeout(self): return self.recovery_timeout
    def set_recovery_timeout(self, recovery_timeout): self.recovery_timeout = recovery_timeout
    def get_no_unregistered_multicast(self): return self.no_unregistered_multicast
    def set_no_unregistered_multicast(self, no_unregistered_multicast): self.no_unregistered_multicast = no_unregistered_multicast
    def get_no_registered_multicast(self): return self.no_registered_multicast
    def set_no_registered_multicast(self, no_registered_multicast): self.no_registered_multicast = no_registered_multicast
    def get_no_unknown_unicast(self): return self.no_unknown_unicast
    def set_no_unknown_unicast(self, no_unknown_unicast): self.no_unknown_unicast = no_unknown_unicast
    def get_no_multicast(self): return self.no_multicast
    def set_no_multicast(self, no_multicast): self.no_multicast = no_multicast
    def get_no_broadcast(self): return self.no_broadcast
    def set_no_broadcast(self, no_broadcast): self.no_broadcast = no_broadcast
    def get_bandwidth_percent(self): return self.bandwidth_percent
    def set_bandwidth_percent(self, bandwidth_percent): self.bandwidth_percent = bandwidth_percent
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.storm_control_actions == other.storm_control_actions and
                    self.recovery_timeout == other.recovery_timeout and
                    self.no_unregistered_multicast == other.no_unregistered_multicast and
                    self.no_registered_multicast == other.no_registered_multicast and
                    self.no_unknown_unicast == other.no_unknown_unicast and
                    self.no_multicast == other.no_multicast and
                    self.no_broadcast == other.no_broadcast and
                    self.bandwidth_percent == other.bandwidth_percent)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.storm_control_actions or []),
                     self.recovery_timeout if self.recovery_timeout is not None else -7985492147856592190,
                     self.no_unregistered_multicast if self.no_unregistered_multicast is not None else -7985492147856592190,
                     self.no_registered_multicast if self.no_registered_multicast is not None else -7985492147856592190,
                     self.no_unknown_unicast if self.no_unknown_unicast is not None else -7985492147856592190,
                     self.no_multicast if self.no_multicast is not None else -7985492147856592190,
                     self.no_broadcast if self.no_broadcast is not None else -7985492147856592190,
                     self.bandwidth_percent if self.bandwidth_percent is not None else -7985492147856592190))

    def __repr__(self):
        return ("storm_control_actions = " + str(self.storm_control_actions) + ", " +
                "recovery_timeout = " + str(self.recovery_timeout) + ", " +
                "no_unregistered_multicast = " + str(self.no_unregistered_multicast) + ", " +
                "no_registered_multicast = " + str(self.no_registered_multicast) + ", " +
                "no_unknown_unicast = " + str(self.no_unknown_unicast) + ", " +
                "no_multicast = " + str(self.no_multicast) + ", " +
                "no_broadcast = " + str(self.no_broadcast) + ", " +
                "bandwidth_percent = " + str(self.bandwidth_percent))

    def copy(self):
        cp = StormControlParameters()
        if self.storm_control_actions is not None:
            cp.storm_control_actions = list(self.storm_control_actions)
        if self.recovery_timeout is not None:
            cp.recovery_timeout = self.recovery_timeout
        if self.no_unregistered_multicast is not None:
            cp.no_unregistered_multicast = self.no_unregistered_multicast
        if self.no_registered_multicast is not None:
            cp.no_registered_multicast = self.no_registered_multicast
        if self.no_unknown_unicast is not None:
            cp.no_unknown_unicast = self.no_unknown_unicast
        if self.no_multicast is not None:
            cp.no_multicast = self.no_multicast
        if self.no_broadcast is not None:
            cp.no_broadcast = self.no_broadcast
        if self.bandwidth_percent is not None:
            cp.bandwidth_percent = self.bandwidth_percent
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_storm_control_actions ([obj.populate_string ("storm_control_actions")])
        obj.set_recovery_timeout (obj.populate_integer ("recovery_timeout"))
        obj.set_no_unregistered_multicast (obj.populate_boolean ("no_unregistered_multicast"))
        obj.set_no_registered_multicast (obj.populate_boolean ("no_registered_multicast"))
        obj.set_no_unknown_unicast (obj.populate_boolean ("no_unknown_unicast"))
        obj.set_no_multicast (obj.populate_boolean ("no_multicast"))
        obj.set_no_broadcast (obj.populate_boolean ("no_broadcast"))
        obj.set_bandwidth_percent (obj.populate_integer ("bandwidth_percent"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='StormControlParameters', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StormControlParameters')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StormControlParameters'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='StormControlParameters', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for storm_control_actions_ in self.storm_control_actions:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstorm-control-actions>%s</%sstorm-control-actions>%s' % (namespace_, self.gds_format_string(quote_xml(storm_control_actions_).encode(ExternalEncoding), input_name='storm-control-actions'), namespace_, eol_))
        if self.recovery_timeout is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srecovery-timeout>%s</%srecovery-timeout>%s' % (namespace_, self.gds_format_integer(self.recovery_timeout, input_name='recovery-timeout'), namespace_, eol_))
        if self.no_unregistered_multicast is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sno-unregistered-multicast>%s</%sno-unregistered-multicast>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.no_unregistered_multicast)), input_name='no-unregistered-multicast'), namespace_, eol_))
        if self.no_registered_multicast is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sno-registered-multicast>%s</%sno-registered-multicast>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.no_registered_multicast)), input_name='no-registered-multicast'), namespace_, eol_))
        if self.no_unknown_unicast is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sno-unknown-unicast>%s</%sno-unknown-unicast>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.no_unknown_unicast)), input_name='no-unknown-unicast'), namespace_, eol_))
        if self.no_multicast is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sno-multicast>%s</%sno-multicast>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.no_multicast)), input_name='no-multicast'), namespace_, eol_))
        if self.no_broadcast is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sno-broadcast>%s</%sno-broadcast>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.no_broadcast)), input_name='no-broadcast'), namespace_, eol_))
        if self.bandwidth_percent is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbandwidth-percent>%s</%sbandwidth-percent>%s' % (namespace_, self.gds_format_integer(self.bandwidth_percent, input_name='bandwidth-percent'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.storm_control_actions or
            self.recovery_timeout is not None or
            self.no_unregistered_multicast is not None or
            self.no_registered_multicast is not None or
            self.no_unknown_unicast is not None or
            self.no_multicast is not None or
            self.no_broadcast is not None or
            self.bandwidth_percent is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StormControlParameters'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('storm_control_actions=[\n')
        level += 1
        for storm_control_actions_ in self.storm_control_actions:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(storm_control_actions_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.recovery_timeout is not None:
            showIndent(outfile, level)
            outfile.write('recovery_timeout=%d,\n' % self.recovery_timeout)
        if self.no_unregistered_multicast is not None:
            showIndent(outfile, level)
            outfile.write('no_unregistered_multicast=%s,\n' % self.no_unregistered_multicast)
        if self.no_registered_multicast is not None:
            showIndent(outfile, level)
            outfile.write('no_registered_multicast=%s,\n' % self.no_registered_multicast)
        if self.no_unknown_unicast is not None:
            showIndent(outfile, level)
            outfile.write('no_unknown_unicast=%s,\n' % self.no_unknown_unicast)
        if self.no_multicast is not None:
            showIndent(outfile, level)
            outfile.write('no_multicast=%s,\n' % self.no_multicast)
        if self.no_broadcast is not None:
            showIndent(outfile, level)
            outfile.write('no_broadcast=%s,\n' % self.no_broadcast)
        if self.bandwidth_percent is not None:
            showIndent(outfile, level)
            outfile.write('bandwidth_percent=%d,\n' % self.bandwidth_percent)
    def exportDict(self, name_='StormControlParameters'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'storm-control-actions':
            storm_control_actions_ = child_.text
            storm_control_actions_ = self.gds_validate_string(storm_control_actions_, node, 'storm_control_actions')
            self.storm_control_actions.append(storm_control_actions_)
            self.validate_StormControlActionType(self.storm_control_actions)    # validate type StormControlActionType
        elif nodeName_ == 'recovery-timeout':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'recovery_timeout')
            self.recovery_timeout = ival_
        elif nodeName_ == 'no-unregistered-multicast':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'no_unregistered_multicast')
            self.no_unregistered_multicast = ival_
        elif nodeName_ == 'no-registered-multicast':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'no_registered_multicast')
            self.no_registered_multicast = ival_
        elif nodeName_ == 'no-unknown-unicast':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'no_unknown_unicast')
            self.no_unknown_unicast = ival_
        elif nodeName_ == 'no-multicast':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'no_multicast')
            self.no_multicast = ival_
        elif nodeName_ == 'no-broadcast':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'no_broadcast')
            self.no_broadcast = ival_
        elif nodeName_ == 'bandwidth-percent':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'bandwidth_percent')
            self.bandwidth_percent = ival_
# end class StormControlParameters


class StatsCollectionFrequency(GeneratedsSuper):
    """
    Attributes:
    * sample_rate
        Type:           int, *within* [1, 16777215]

        Created By:           User (optional)

    * polling_interval
        Type:           int, *within* [0, 3600]

        Created By:           User (optional)

    * direction
        Type:           str, *one-of* [u'ingress', u'egress']

        Created By:           User (optional)

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'sample_rate', u'polling_interval', u'direction']
    attr_field_type_vals = {u'direction': {'restrictions': [u'ingress', u'egress'], 'description': [], 'simple_type': u'SampleDirection', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'sample_rate': {'restrictions': [1, 16777215], 'description': [], 'simple_type': u'SampleRate', 'is_complex': 0, 'restriction_type': 'range', 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'polling_interval': {'restrictions': [0, 3600], 'description': [], 'simple_type': u'PollingInterval', 'is_complex': 0, 'restriction_type': 'range', 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}}
    def __init__(self, sample_rate=2000, polling_interval=0, direction=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _sample_rate = params_dict[u"sample_rate"]
        except KeyError:
            _sample_rate = sample_rate
        self.sample_rate = _sample_rate
        try:
            _polling_interval = params_dict[u"polling_interval"]
        except KeyError:
            _polling_interval = polling_interval
        self.polling_interval = _polling_interval
        try:
            _direction = params_dict[u"direction"]
        except KeyError:
            _direction = direction
        self.direction = _direction
    def factory(*args_, **kwargs_):
        if StatsCollectionFrequency.subclass:
            return StatsCollectionFrequency.subclass(*args_, **kwargs_)
        else:
            return StatsCollectionFrequency(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_sample_rate(self): return self.sample_rate
    def set_sample_rate(self, sample_rate): self.sample_rate = sample_rate
    def validate_SampleRate(self, value):
        # Validate type SampleRate, a restriction on xsd:integer.
        error = False
        if isinstance(value, list):
            v_int = list(map(int, value))
            v1, v2 = min(v_int), max(v_int)
        else:
            v1, v2 = int(value), int(value)
        error = (1 > v1)
        error |= (v2 > 16777215)
        if error:
            raise ValueError("SampleRate must be in the range {'minimum': 1}-{'maximum': 16777215}")
    def get_polling_interval(self): return self.polling_interval
    def set_polling_interval(self, polling_interval): self.polling_interval = polling_interval
    def validate_PollingInterval(self, value):
        # Validate type PollingInterval, a restriction on xsd:integer.
        error = False
        if isinstance(value, list):
            v_int = list(map(int, value))
            v1, v2 = min(v_int), max(v_int)
        else:
            v1, v2 = int(value), int(value)
        error |= (v2 > 3600)
        if error:
            raise ValueError("PollingInterval must be in the range {'minimum': 0}-{'maximum': 3600}")
    def get_direction(self): return self.direction
    def set_direction(self, direction): self.direction = direction
    def validate_SampleDirection(self, value):
        # Validate type SampleDirection, a restriction on xsd:string.
        error = False
        if isinstance(value, list):
            error = set(value) - set([u'ingress', u'egress'])
        else:
            error = value not in [u'ingress', u'egress']
        if error:
            raise ValueError("SampleDirection must be one of [u'ingress', u'egress']")
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.sample_rate == other.sample_rate and
                    self.polling_interval == other.polling_interval and
                    self.direction == other.direction)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.sample_rate if self.sample_rate is not None else -7985492147856592190,
                     self.polling_interval if self.polling_interval is not None else -7985492147856592190,
                     self.direction if self.direction is not None else -7985492147856592190))

    def __repr__(self):
        return ("sample_rate = " + str(self.sample_rate) + ", " +
                "polling_interval = " + str(self.polling_interval) + ", " +
                "direction = " + str(self.direction))

    def copy(self):
        cp = StatsCollectionFrequency()
        if self.sample_rate is not None:
            cp.sample_rate = self.sample_rate
        if self.polling_interval is not None:
            cp.polling_interval = self.polling_interval
        if self.direction is not None:
            cp.direction = self.direction
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_sample_rate (obj.populate_integer ("sample_rate"))
        obj.set_polling_interval (obj.populate_integer ("polling_interval"))
        obj.set_direction (obj.populate_string ("direction"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='StatsCollectionFrequency', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StatsCollectionFrequency')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StatsCollectionFrequency'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='StatsCollectionFrequency', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.sample_rate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssample-rate>%s</%ssample-rate>%s' % (namespace_, self.gds_format_integer(self.sample_rate, input_name='sample-rate'), namespace_, eol_))
        if self.polling_interval is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spolling-interval>%s</%spolling-interval>%s' % (namespace_, self.gds_format_integer(self.polling_interval, input_name='polling-interval'), namespace_, eol_))
        if self.direction is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdirection>%s</%sdirection>%s' % (namespace_, self.gds_format_string(quote_xml(self.direction).encode(ExternalEncoding), input_name='direction'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.sample_rate is not None or
            self.polling_interval is not None or
            self.direction is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StatsCollectionFrequency'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.sample_rate is not None:
            showIndent(outfile, level)
            outfile.write('sample_rate=%d,\n' % self.sample_rate)
        if self.polling_interval is not None:
            showIndent(outfile, level)
            outfile.write('polling_interval=%d,\n' % self.polling_interval)
        if self.direction is not None:
            showIndent(outfile, level)
            outfile.write('direction=%s,\n' % quote_python(self.direction).encode(ExternalEncoding))
    def exportDict(self, name_='StatsCollectionFrequency'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'sample-rate':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'sample_rate')
            self.sample_rate = ival_
            self.validate_SampleRate(self.sample_rate)    # validate type SampleRate
        elif nodeName_ == 'polling-interval':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'polling_interval')
            self.polling_interval = ival_
            self.validate_PollingInterval(self.polling_interval)    # validate type PollingInterval
        elif nodeName_ == 'direction':
            direction_ = child_.text
            direction_ = self.gds_validate_string(direction_, node, 'direction')
            self.direction = direction_
            self.validate_SampleDirection(self.direction)    # validate type SampleDirection
# end class StatsCollectionFrequency


class EnabledInterfaceParams(GeneratedsSuper):
    """
    Attributes:
    * name
        Type:           str

    * stats_collection_frequency
        Type:           :class:`.StatsCollectionFrequency`

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'name', u'stats_collection_frequency']
    attr_field_type_vals = {u'stats_collection_frequency': {'restrictions': None, 'description': [], 'simple_type': u'StatsCollectionFrequency', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'StatsCollectionFrequency'}, u'name': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}}
    def __init__(self, name=None, stats_collection_frequency=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _name = params_dict[u"name"]
        except KeyError:
            _name = name
        self.name = _name
        try:
            _stats_collection_frequency = params_dict[u"stats_collection_frequency"]
        except KeyError:
            _stats_collection_frequency = stats_collection_frequency
        if isinstance(_stats_collection_frequency, dict):
            obj = StatsCollectionFrequency(params_dict=_stats_collection_frequency)
            self.stats_collection_frequency = obj
        else:
            self.stats_collection_frequency = _stats_collection_frequency
    def factory(*args_, **kwargs_):
        if EnabledInterfaceParams.subclass:
            return EnabledInterfaceParams.subclass(*args_, **kwargs_)
        else:
            return EnabledInterfaceParams(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_stats_collection_frequency(self): return self.stats_collection_frequency
    def set_stats_collection_frequency(self, stats_collection_frequency): self.stats_collection_frequency = stats_collection_frequency
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.name == other.name and
                    self.stats_collection_frequency == other.stats_collection_frequency)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.name if self.name is not None else -7985492147856592190,
                     self.stats_collection_frequency if self.stats_collection_frequency is not None else -7985492147856592190))

    def __repr__(self):
        return ("name = " + str(self.name) + ", " +
                "stats_collection_frequency = " + str(self.stats_collection_frequency))

    def copy(self):
        cp = EnabledInterfaceParams()
        if self.name is not None:
            cp.name = self.name
        if self.stats_collection_frequency is not None:
            cp.stats_collection_frequency = self.stats_collection_frequency.copy()
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_name (obj.populate_string ("name"))
        obj.set_stats_collection_frequency (StatsCollectionFrequency.populate ())
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='EnabledInterfaceParams', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EnabledInterfaceParams')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EnabledInterfaceParams'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='EnabledInterfaceParams', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        if self.stats_collection_frequency is not None:
            self.stats_collection_frequency.export_xml(outfile, level, namespace_, name_='stats-collection-frequency', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.name is not None or
            self.stats_collection_frequency is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EnabledInterfaceParams'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.stats_collection_frequency is not None:
            showIndent(outfile, level)
            outfile.write('stats_collection_frequency=model_.StatsCollectionFrequency(\n')
            self.stats_collection_frequency.exportLiteral(outfile, level, name_='stats_collection_frequency')
            showIndent(outfile, level)
            outfile.write('),\n')
    def exportDict(self, name_='EnabledInterfaceParams'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'stats-collection-frequency':
            obj_ = StatsCollectionFrequency.factory()
            obj_.build(child_)
            self.set_stats_collection_frequency(obj_)
# end class EnabledInterfaceParams


class SflowParameters(GeneratedsSuper):
    """
    Attributes:
    * stats_collection_frequency
        Type:           :class:`.StatsCollectionFrequency`

        Description:
          Represents polling interval and sample rate either at the global level or at per

          interface level. Polling interval is specified in seconds that the device waits

          between port statistics update messages. Sample rate is specified as a number

          (one packet out of number).

    * agent_id
        Type:           str, *one-of* xsd:string

        Description:
          IP address to be assigned as the agent ID for the sFlow agent.

    * adaptive_sample_rate
        Type:           int, *within* [300, 900]

        Created By:           User (optional)

        Description:
          Represents  maximum number of samples that should be generated per line card.

    * enabled_interface_type
        Type:           str, *one-of* [u'all', u'fabric', u'service', u'access', u'custom']

        Description:
          User can enable sflow either on all interfaces or all fabric ports or all access

          ports or custom list of interfaces.

    * enabled_interface_params
        Type:           :class:`.EnabledInterfaceParams`

        Description:
          If interface type is set to custom, this represents the list of physical

          interfaces to be enabled for sflow. User can specify polling interval and sample

          rate for each interface in this custom list.

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'stats_collection_frequency', u'agent_id', u'adaptive_sample_rate', u'enabled_interface_type', u'enabled_interface_params']
    attr_field_type_vals = {u'enabled_interface_type': {'restrictions': [u'all', u'fabric', u'service', u'access', u'custom'], 'description': [u'User can enable sflow either on all interfaces or all fabric ports or all access ports or custom list of interfaces.'], 'simple_type': u'EnabledInterfaceType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': None, 'attr_type': u'string'}, u'stats_collection_frequency': {'restrictions': None, 'description': [u'Represents polling interval and sample rate either at the global level or at per interface level. Polling interval is specified in seconds that the device waits between port statistics update messages. Sample rate is specified as a number (one packet out of number).'], 'simple_type': u'StatsCollectionFrequency', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'StatsCollectionFrequency'}, u'adaptive_sample_rate': {'restrictions': [300, 900], 'description': [u'Represents  maximum number of samples that should be generated per line card.'], 'simple_type': u'AdativeSampleRate', 'is_complex': 0, 'restriction_type': 'range', 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'agent_id': {'restrictions': [], 'description': [u'IP address to be assigned as the agent ID for the sFlow agent.'], 'simple_type': u'IpAddress', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': None, 'attr_type': u'string'}, u'enabled_interface_params': {'restrictions': None, 'description': [u'If interface type is set to custom, this represents the list of physical interfaces to be enabled for sflow. User can specify polling interval and sample rate for each interface in this custom list.'], 'simple_type': u'EnabledInterfaceParams', 'is_complex': 1, 'restriction_type': None, 'is_array': True, 'required': None, 'attr_type': u'EnabledInterfaceParams'}}
    def __init__(self, stats_collection_frequency=None, agent_id=None, adaptive_sample_rate=300, enabled_interface_type=None, enabled_interface_params=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _stats_collection_frequency = params_dict[u"stats_collection_frequency"]
        except KeyError:
            _stats_collection_frequency = stats_collection_frequency
        if isinstance(_stats_collection_frequency, dict):
            obj = StatsCollectionFrequency(params_dict=_stats_collection_frequency)
            self.stats_collection_frequency = obj
        else:
            self.stats_collection_frequency = _stats_collection_frequency
        try:
            _agent_id = params_dict[u"agent_id"]
        except KeyError:
            _agent_id = agent_id
        self.agent_id = _agent_id
        try:
            _adaptive_sample_rate = params_dict[u"adaptive_sample_rate"]
        except KeyError:
            _adaptive_sample_rate = adaptive_sample_rate
        self.adaptive_sample_rate = _adaptive_sample_rate
        try:
            _enabled_interface_type = params_dict[u"enabled_interface_type"]
        except KeyError:
            _enabled_interface_type = enabled_interface_type
        self.enabled_interface_type = _enabled_interface_type
        try:
            _enabled_interface_params = params_dict[u"enabled_interface_params"]
        except KeyError:
            _enabled_interface_params = enabled_interface_params
        if not _enabled_interface_params:
            self.enabled_interface_params = []
        else:
            if isinstance(_enabled_interface_params[0], dict):
                objs = [EnabledInterfaceParams(params_dict=elem) for elem in _enabled_interface_params]
                self.enabled_interface_params = objs
            else:
                self.enabled_interface_params = _enabled_interface_params
    def factory(*args_, **kwargs_):
        if SflowParameters.subclass:
            return SflowParameters.subclass(*args_, **kwargs_)
        else:
            return SflowParameters(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_stats_collection_frequency(self): return self.stats_collection_frequency
    def set_stats_collection_frequency(self, stats_collection_frequency): self.stats_collection_frequency = stats_collection_frequency
    def get_agent_id(self): return self.agent_id
    def set_agent_id(self, agent_id): self.agent_id = agent_id
    def validate_IpAddress(self, value):
        # Validate type IpAddress, a restriction on xsd:string.
        pass
    def get_adaptive_sample_rate(self): return self.adaptive_sample_rate
    def set_adaptive_sample_rate(self, adaptive_sample_rate): self.adaptive_sample_rate = adaptive_sample_rate
    def validate_AdativeSampleRate(self, value):
        # Validate type AdativeSampleRate, a restriction on xsd:integer.
        error = False
        if isinstance(value, list):
            v_int = list(map(int, value))
            v1, v2 = min(v_int), max(v_int)
        else:
            v1, v2 = int(value), int(value)
        error = (300 > v1)
        error |= (v2 > 900)
        if error:
            raise ValueError("AdativeSampleRate must be in the range {'minimum': 300}-{'maximum': 900}")
    def get_enabled_interface_type(self): return self.enabled_interface_type
    def set_enabled_interface_type(self, enabled_interface_type): self.enabled_interface_type = enabled_interface_type
    def validate_EnabledInterfaceType(self, value):
        # Validate type EnabledInterfaceType, a restriction on xsd:string.
        error = False
        if isinstance(value, list):
            error = set(value) - set([u'all', u'fabric', u'service', u'access', u'custom'])
        else:
            error = value not in [u'all', u'fabric', u'service', u'access', u'custom']
        if error:
            raise ValueError("EnabledInterfaceType must be one of [u'all', u'fabric', u'service', u'access', u'custom']")
    def get_enabled_interface_params(self): return self.enabled_interface_params
    def set_enabled_interface_params(self, enabled_interface_params): self.enabled_interface_params = enabled_interface_params
    def add_enabled_interface_params(self, value): self.enabled_interface_params.append(value)
    def insert_enabled_interface_params(self, index, value): self.enabled_interface_params[index] = value
    def delete_enabled_interface_params(self, value): self.enabled_interface_params.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.stats_collection_frequency == other.stats_collection_frequency and
                    self.agent_id == other.agent_id and
                    self.adaptive_sample_rate == other.adaptive_sample_rate and
                    self.enabled_interface_type == other.enabled_interface_type and
                    self.enabled_interface_params == other.enabled_interface_params)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.stats_collection_frequency if self.stats_collection_frequency is not None else -7985492147856592190,
                     self.agent_id if self.agent_id is not None else -7985492147856592190,
                     self.adaptive_sample_rate if self.adaptive_sample_rate is not None else -7985492147856592190,
                     self.enabled_interface_type if self.enabled_interface_type is not None else -7985492147856592190,
                     tuple(self.enabled_interface_params or [])))

    def __repr__(self):
        return ("stats_collection_frequency = " + str(self.stats_collection_frequency) + ", " +
                "agent_id = " + str(self.agent_id) + ", " +
                "adaptive_sample_rate = " + str(self.adaptive_sample_rate) + ", " +
                "enabled_interface_type = " + str(self.enabled_interface_type) + ", " +
                "enabled_interface_params = " + str(self.enabled_interface_params))

    def copy(self):
        cp = SflowParameters()
        if self.stats_collection_frequency is not None:
            cp.stats_collection_frequency = self.stats_collection_frequency.copy()
        if self.agent_id is not None:
            cp.agent_id = self.agent_id
        if self.adaptive_sample_rate is not None:
            cp.adaptive_sample_rate = self.adaptive_sample_rate
        if self.enabled_interface_type is not None:
            cp.enabled_interface_type = self.enabled_interface_type
        if self.enabled_interface_params is not None:
            cp.enabled_interface_params = [x.copy() for x in self.enabled_interface_params]
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_stats_collection_frequency (StatsCollectionFrequency.populate ())
        obj.set_agent_id (obj.populate_string ("agent_id"))
        obj.set_adaptive_sample_rate (obj.populate_integer ("adaptive_sample_rate"))
        obj.set_enabled_interface_type (obj.populate_string ("enabled_interface_type"))
        obj.set_enabled_interface_params ([EnabledInterfaceParams.populate ()])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='SflowParameters', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SflowParameters')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SflowParameters'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SflowParameters', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.stats_collection_frequency is not None:
            self.stats_collection_frequency.export_xml(outfile, level, namespace_, name_='stats-collection-frequency', pretty_print=pretty_print)
        if self.agent_id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sagent-id>%s</%sagent-id>%s' % (namespace_, self.gds_format_string(quote_xml(self.agent_id).encode(ExternalEncoding), input_name='agent-id'), namespace_, eol_))
        if self.adaptive_sample_rate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sadaptive-sample-rate>%s</%sadaptive-sample-rate>%s' % (namespace_, self.gds_format_integer(self.adaptive_sample_rate, input_name='adaptive-sample-rate'), namespace_, eol_))
        if self.enabled_interface_type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%senabled-interface-type>%s</%senabled-interface-type>%s' % (namespace_, self.gds_format_string(quote_xml(self.enabled_interface_type).encode(ExternalEncoding), input_name='enabled-interface-type'), namespace_, eol_))
        for enabled_interface_params_ in self.enabled_interface_params:
            if isinstance(enabled_interface_params_, dict):
                enabled_interface_params_ = EnabledInterfaceParams(**enabled_interface_params_)
            enabled_interface_params_.export_xml(outfile, level, namespace_, name_='enabled-interface-params', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.stats_collection_frequency is not None or
            self.agent_id is not None or
            self.adaptive_sample_rate is not None or
            self.enabled_interface_type is not None or
            self.enabled_interface_params
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SflowParameters'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.stats_collection_frequency is not None:
            showIndent(outfile, level)
            outfile.write('stats_collection_frequency=model_.StatsCollectionFrequency(\n')
            self.stats_collection_frequency.exportLiteral(outfile, level, name_='stats_collection_frequency')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.agent_id is not None:
            showIndent(outfile, level)
            outfile.write('agent_id=%s,\n' % quote_python(self.agent_id).encode(ExternalEncoding))
        if self.adaptive_sample_rate is not None:
            showIndent(outfile, level)
            outfile.write('adaptive_sample_rate=%d,\n' % self.adaptive_sample_rate)
        if self.enabled_interface_type is not None:
            showIndent(outfile, level)
            outfile.write('enabled_interface_type=%s,\n' % quote_python(self.enabled_interface_type).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('enabled_interface_params=[\n')
        level += 1
        for enabled_interface_params_ in self.enabled_interface_params:
            showIndent(outfile, level)
            outfile.write('model_.EnabledInterfaceParams(\n')
            enabled_interface_params_.exportLiteral(outfile, level, name_='EnabledInterfaceParams')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='SflowParameters'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'stats-collection-frequency':
            obj_ = StatsCollectionFrequency.factory()
            obj_.build(child_)
            self.set_stats_collection_frequency(obj_)
        elif nodeName_ == 'agent-id':
            agent_id_ = child_.text
            agent_id_ = self.gds_validate_string(agent_id_, node, 'agent_id')
            self.agent_id = agent_id_
            self.validate_IpAddress(self.agent_id)    # validate type IpAddress
        elif nodeName_ == 'adaptive-sample-rate':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'adaptive_sample_rate')
            self.adaptive_sample_rate = ival_
            self.validate_AdativeSampleRate(self.adaptive_sample_rate)    # validate type AdativeSampleRate
        elif nodeName_ == 'enabled-interface-type':
            enabled_interface_type_ = child_.text
            enabled_interface_type_ = self.gds_validate_string(enabled_interface_type_, node, 'enabled_interface_type')
            self.enabled_interface_type = enabled_interface_type_
            self.validate_EnabledInterfaceType(self.enabled_interface_type)    # validate type EnabledInterfaceType
        elif nodeName_ == 'enabled-interface-params':
            obj_ = EnabledInterfaceParams.factory()
            obj_.build(child_)
            self.enabled_interface_params.append(obj_)
# end class SflowParameters


class FabricNetworkTag(GeneratedsSuper):
    """
    Attributes:
    * network_type
        Type:           str, *one-of* [u'management', u'loopback', u'ip-fabric', u'pnf-servicechain', u'overlay-loopback']

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'network_type']
    attr_field_type_vals = {u'network_type': {'restrictions': [u'management', u'loopback', u'ip-fabric', u'pnf-servicechain', u'overlay-loopback'], 'description': [], 'simple_type': u'FabricNetworkType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': None, 'attr_type': u'string'}}
    def __init__(self, network_type=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _network_type = params_dict[u"network_type"]
        except KeyError:
            _network_type = network_type
        self.network_type = _network_type
    def factory(*args_, **kwargs_):
        if FabricNetworkTag.subclass:
            return FabricNetworkTag.subclass(*args_, **kwargs_)
        else:
            return FabricNetworkTag(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_network_type(self): return self.network_type
    def set_network_type(self, network_type): self.network_type = network_type
    def validate_FabricNetworkType(self, value):
        # Validate type FabricNetworkType, a restriction on xsd:string.
        error = False
        if isinstance(value, list):
            error = set(value) - set([u'management', u'loopback', u'ip-fabric', u'pnf-servicechain', u'overlay-loopback'])
        else:
            error = value not in [u'management', u'loopback', u'ip-fabric', u'pnf-servicechain', u'overlay-loopback']
        if error:
            raise ValueError("FabricNetworkType must be one of [u'management', u'loopback', u'ip-fabric', u'pnf-servicechain', u'overlay-loopback']")
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.network_type == other.network_type)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.network_type if self.network_type is not None else -7985492147856592190))

    def __repr__(self):
        return ("network_type = " + str(self.network_type))

    def copy(self):
        cp = FabricNetworkTag()
        if self.network_type is not None:
            cp.network_type = self.network_type
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_network_type (obj.populate_string ("network_type"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='FabricNetworkTag', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FabricNetworkTag')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FabricNetworkTag'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FabricNetworkTag', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.network_type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snetwork-type>%s</%snetwork-type>%s' % (namespace_, self.gds_format_string(quote_xml(self.network_type).encode(ExternalEncoding), input_name='network-type'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.network_type is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FabricNetworkTag'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.network_type is not None:
            showIndent(outfile, level)
            outfile.write('network_type=%s,\n' % quote_python(self.network_type).encode(ExternalEncoding))
    def exportDict(self, name_='FabricNetworkTag'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'network-type':
            network_type_ = child_.text
            network_type_ = self.gds_validate_string(network_type_, node, 'network_type')
            self.network_type = network_type_
            self.validate_FabricNetworkType(self.network_type)    # validate type FabricNetworkType
# end class FabricNetworkTag


class SerialNumListType(GeneratedsSuper):
    """
    Attributes:
    * serial_num
        Type:           str

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'serial_num']
    attr_field_type_vals = {u'serial_num': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': True, 'required': None, 'attr_type': u'string'}}
    def __init__(self, serial_num=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _serial_num = params_dict[u"serial_num"]
        except KeyError:
            _serial_num = serial_num
        if not _serial_num:
            self.serial_num = []
        else:
            self.serial_num = _serial_num
    def factory(*args_, **kwargs_):
        if SerialNumListType.subclass:
            return SerialNumListType.subclass(*args_, **kwargs_)
        else:
            return SerialNumListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_serial_num(self): return self.serial_num
    def set_serial_num(self, serial_num): self.serial_num = serial_num
    def add_serial_num(self, value): self.serial_num.append(value)
    def insert_serial_num(self, index, value): self.serial_num[index] = value
    def delete_serial_num(self, value): self.serial_num.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.serial_num == other.serial_num)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.serial_num or [])))

    def __repr__(self):
        return ("serial_num = " + str(self.serial_num))

    def copy(self):
        cp = SerialNumListType()
        if self.serial_num is not None:
            cp.serial_num = list(self.serial_num)
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_serial_num ([obj.populate_string ("serial_num")])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='SerialNumListType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SerialNumListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SerialNumListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SerialNumListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for serial_num_ in self.serial_num:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sserial-num>%s</%sserial-num>%s' % (namespace_, self.gds_format_string(quote_xml(serial_num_).encode(ExternalEncoding), input_name='serial-num'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.serial_num
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SerialNumListType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('serial_num=[\n')
        level += 1
        for serial_num_ in self.serial_num:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(serial_num_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='SerialNumListType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'serial-num':
            serial_num_ = child_.text
            serial_num_ = self.gds_validate_string(serial_num_, node, 'serial_num')
            self.serial_num.append(serial_num_)
# end class SerialNumListType


class AsnRangeType(GeneratedsSuper):
    """
    Attributes:
    * asn_min
        Type:           int

    * asn_max
        Type:           int

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'asn_min', u'asn_max']
    attr_field_type_vals = {u'asn_max': {'restrictions': None, 'description': [], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'integer'}, u'asn_min': {'restrictions': None, 'description': [], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'integer'}}
    def __init__(self, asn_min=None, asn_max=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _asn_min = params_dict[u"asn_min"]
        except KeyError:
            _asn_min = asn_min
        self.asn_min = _asn_min
        try:
            _asn_max = params_dict[u"asn_max"]
        except KeyError:
            _asn_max = asn_max
        self.asn_max = _asn_max
    def factory(*args_, **kwargs_):
        if AsnRangeType.subclass:
            return AsnRangeType.subclass(*args_, **kwargs_)
        else:
            return AsnRangeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_asn_min(self): return self.asn_min
    def set_asn_min(self, asn_min): self.asn_min = asn_min
    def get_asn_max(self): return self.asn_max
    def set_asn_max(self, asn_max): self.asn_max = asn_max
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.asn_min == other.asn_min and
                    self.asn_max == other.asn_max)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.asn_min if self.asn_min is not None else -7985492147856592190,
                     self.asn_max if self.asn_max is not None else -7985492147856592190))

    def __repr__(self):
        return ("asn_min = " + str(self.asn_min) + ", " +
                "asn_max = " + str(self.asn_max))

    def copy(self):
        cp = AsnRangeType()
        if self.asn_min is not None:
            cp.asn_min = self.asn_min
        if self.asn_max is not None:
            cp.asn_max = self.asn_max
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_asn_min (obj.populate_integer ("asn_min"))
        obj.set_asn_max (obj.populate_integer ("asn_max"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='AsnRangeType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AsnRangeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AsnRangeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AsnRangeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.asn_min is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sasn_min>%s</%sasn_min>%s' % (namespace_, self.gds_format_integer(self.asn_min, input_name='asn_min'), namespace_, eol_))
        if self.asn_max is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sasn_max>%s</%sasn_max>%s' % (namespace_, self.gds_format_integer(self.asn_max, input_name='asn_max'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.asn_min is not None or
            self.asn_max is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AsnRangeType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.asn_min is not None:
            showIndent(outfile, level)
            outfile.write('asn_min=%d,\n' % self.asn_min)
        if self.asn_max is not None:
            showIndent(outfile, level)
            outfile.write('asn_max=%d,\n' % self.asn_max)
    def exportDict(self, name_='AsnRangeType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'asn_min':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'asn_min')
            self.asn_min = ival_
        elif nodeName_ == 'asn_max':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'asn_max')
            self.asn_max = ival_
# end class AsnRangeType


class NamespaceValue(GeneratedsSuper):
    """
    Attributes:
    * ipv4_cidr
        Type:           :class:`.SubnetListType`

        Created By:           User (optional)

        Description:
          Namespace as IPV4 CIDR addresses

    * asn
        Type:           :class:`.AutonomousSystemsType`

        Created By:           User (optional)

        Description:
          Namespace as Autonomous System Numbers

    * mac_addr
        Type:           :class:`.MacAddressesType`

        Created By:           User (optional)

        Description:
          Namespace as MAC addresses

    * asn_ranges
        Type:           :class:`.AsnRangeType`

        Created By:           User (optional)

        Description:
          Namespace as ASN ranges

    * serial_nums
        Type:           str

        Created By:           User (optional)

        Description:
          Namespace as MAC addresses

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'ipv4_cidr', u'asn', u'mac_addr', u'asn_ranges', u'serial_nums']
    attr_field_type_vals = {u'asn_ranges': {'restrictions': None, 'description': [u'Namespace as ASN ranges'], 'simple_type': u'AsnRangeType', 'is_complex': 1, 'restriction_type': None, 'is_array': True, 'required': u'optional', 'attr_type': u'AsnRangeType'}, u'serial_nums': {'restrictions': None, 'description': [u'Namespace as MAC addresses'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': True, 'required': u'optional', 'attr_type': u'string'}, u'ipv4_cidr': {'restrictions': None, 'description': [u'Namespace as IPV4 CIDR addresses'], 'simple_type': u'SubnetListType', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'SubnetListType'}, u'asn': {'restrictions': None, 'description': [u'Namespace as Autonomous System Numbers'], 'simple_type': u'AutonomousSystemsType', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'AutonomousSystemsType'}, u'mac_addr': {'restrictions': None, 'description': [u'Namespace as MAC addresses'], 'simple_type': u'MacAddressesType', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'MacAddressesType'}}
    def __init__(self, ipv4_cidr=None, asn=None, mac_addr=None, asn_ranges=None, serial_nums=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _ipv4_cidr = params_dict[u"ipv4_cidr"]
        except KeyError:
            _ipv4_cidr = ipv4_cidr
        if isinstance(_ipv4_cidr, dict):
            obj = SubnetListType(params_dict=_ipv4_cidr)
            self.ipv4_cidr = obj
        else:
            self.ipv4_cidr = _ipv4_cidr
        try:
            _asn = params_dict[u"asn"]
        except KeyError:
            _asn = asn
        if isinstance(_asn, dict):
            obj = AutonomousSystemsType(params_dict=_asn)
            self.asn = obj
        else:
            self.asn = _asn
        try:
            _mac_addr = params_dict[u"mac_addr"]
        except KeyError:
            _mac_addr = mac_addr
        if isinstance(_mac_addr, dict):
            obj = MacAddressesType(params_dict=_mac_addr)
            self.mac_addr = obj
        else:
            self.mac_addr = _mac_addr
        try:
            _asn_ranges = params_dict[u"asn_ranges"]
        except KeyError:
            _asn_ranges = asn_ranges
        if not _asn_ranges:
            self.asn_ranges = []
        else:
            if isinstance(_asn_ranges[0], dict):
                objs = [AsnRangeType(params_dict=elem) for elem in _asn_ranges]
                self.asn_ranges = objs
            else:
                self.asn_ranges = _asn_ranges
        try:
            _serial_nums = params_dict[u"serial_nums"]
        except KeyError:
            _serial_nums = serial_nums
        if not _serial_nums:
            self.serial_nums = []
        else:
            self.serial_nums = _serial_nums
    def factory(*args_, **kwargs_):
        if NamespaceValue.subclass:
            return NamespaceValue.subclass(*args_, **kwargs_)
        else:
            return NamespaceValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ipv4_cidr(self): return self.ipv4_cidr
    def set_ipv4_cidr(self, ipv4_cidr): self.ipv4_cidr = ipv4_cidr
    def get_asn(self): return self.asn
    def set_asn(self, asn): self.asn = asn
    def get_mac_addr(self): return self.mac_addr
    def set_mac_addr(self, mac_addr): self.mac_addr = mac_addr
    def get_asn_ranges(self): return self.asn_ranges
    def set_asn_ranges(self, asn_ranges): self.asn_ranges = asn_ranges
    def add_asn_ranges(self, value): self.asn_ranges.append(value)
    def insert_asn_ranges(self, index, value): self.asn_ranges[index] = value
    def delete_asn_ranges(self, value): self.asn_ranges.remove(value)
    def get_serial_nums(self): return self.serial_nums
    def set_serial_nums(self, serial_nums): self.serial_nums = serial_nums
    def add_serial_nums(self, value): self.serial_nums.append(value)
    def insert_serial_nums(self, index, value): self.serial_nums[index] = value
    def delete_serial_nums(self, value): self.serial_nums.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.ipv4_cidr == other.ipv4_cidr and
                    self.asn == other.asn and
                    self.mac_addr == other.mac_addr and
                    self.asn_ranges == other.asn_ranges and
                    self.serial_nums == other.serial_nums)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.ipv4_cidr if self.ipv4_cidr is not None else -7985492147856592190,
                     self.asn if self.asn is not None else -7985492147856592190,
                     self.mac_addr if self.mac_addr is not None else -7985492147856592190,
                     tuple(self.asn_ranges or []),
                     tuple(self.serial_nums or [])))

    def __repr__(self):
        return ("ipv4_cidr = " + str(self.ipv4_cidr) + ", " +
                "asn = " + str(self.asn) + ", " +
                "mac_addr = " + str(self.mac_addr) + ", " +
                "asn_ranges = " + str(self.asn_ranges) + ", " +
                "serial_nums = " + str(self.serial_nums))

    def copy(self):
        cp = NamespaceValue()
        if self.ipv4_cidr is not None:
            cp.ipv4_cidr = self.ipv4_cidr.copy()
        if self.asn is not None:
            cp.asn = self.asn.copy()
        if self.mac_addr is not None:
            cp.mac_addr = self.mac_addr.copy()
        if self.asn_ranges is not None:
            cp.asn_ranges = [x.copy() for x in self.asn_ranges]
        if self.serial_nums is not None:
            cp.serial_nums = list(self.serial_nums)
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_ipv4_cidr (SubnetListType.populate ())
        obj.set_asn (AutonomousSystemsType.populate ())
        obj.set_mac_addr (MacAddressesType.populate ())
        obj.set_asn_ranges ([AsnRangeType.populate ()])
        obj.set_serial_nums ([obj.populate_string ("serial_nums")])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='NamespaceValue', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NamespaceValue')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NamespaceValue'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='NamespaceValue', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ipv4_cidr is not None:
            self.ipv4_cidr.export_xml(outfile, level, namespace_, name_='ipv4-cidr', pretty_print=pretty_print)
        if self.asn is not None:
            self.asn.export_xml(outfile, level, namespace_, name_='asn', pretty_print=pretty_print)
        if self.mac_addr is not None:
            self.mac_addr.export_xml(outfile, level, namespace_, name_='mac-addr', pretty_print=pretty_print)
        for asn_ranges_ in self.asn_ranges:
            if isinstance(asn_ranges_, dict):
                asn_ranges_ = AsnRangeType(**asn_ranges_)
            asn_ranges_.export_xml(outfile, level, namespace_, name_='asn-ranges', pretty_print=pretty_print)
        for serial_nums_ in self.serial_nums:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sserial-nums>%s</%sserial-nums>%s' % (namespace_, self.gds_format_string(quote_xml(serial_nums_).encode(ExternalEncoding), input_name='serial-nums'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.ipv4_cidr is not None or
            self.asn is not None or
            self.mac_addr is not None or
            self.asn_ranges or
            self.serial_nums
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='NamespaceValue'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ipv4_cidr is not None:
            showIndent(outfile, level)
            outfile.write('ipv4_cidr=model_.SubnetListType(\n')
            self.ipv4_cidr.exportLiteral(outfile, level, name_='ipv4_cidr')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.asn is not None:
            showIndent(outfile, level)
            outfile.write('asn=model_.AutonomousSystemsType(\n')
            self.asn.exportLiteral(outfile, level, name_='asn')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.mac_addr is not None:
            showIndent(outfile, level)
            outfile.write('mac_addr=model_.MacAddressesType(\n')
            self.mac_addr.exportLiteral(outfile, level, name_='mac_addr')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('asn_ranges=[\n')
        level += 1
        for asn_ranges_ in self.asn_ranges:
            showIndent(outfile, level)
            outfile.write('model_.AsnRangeType(\n')
            asn_ranges_.exportLiteral(outfile, level, name_='AsnRangeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('serial_nums=[\n')
        level += 1
        for serial_nums_ in self.serial_nums:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(serial_nums_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='NamespaceValue'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ipv4-cidr':
            obj_ = SubnetListType.factory()
            obj_.build(child_)
            self.set_ipv4_cidr(obj_)
        elif nodeName_ == 'asn':
            obj_ = AutonomousSystemsType.factory()
            obj_.build(child_)
            self.set_asn(obj_)
        elif nodeName_ == 'mac-addr':
            obj_ = MacAddressesType.factory()
            obj_.build(child_)
            self.set_mac_addr(obj_)
        elif nodeName_ == 'asn-ranges':
            obj_ = AsnRangeType.factory()
            obj_.build(child_)
            self.asn_ranges.append(obj_)
        elif nodeName_ == 'serial-nums':
            serial_nums_ = child_.text
            serial_nums_ = self.gds_validate_string(serial_nums_, node, 'serial_nums')
            self.serial_nums.append(serial_nums_)
# end class NamespaceValue


class DevicePlatformListType(GeneratedsSuper):
    """
    Attributes:
    * platform_name
        Type:           str

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'platform_name']
    attr_field_type_vals = {u'platform_name': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': True, 'required': None, 'attr_type': u'string'}}
    def __init__(self, platform_name=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _platform_name = params_dict[u"platform_name"]
        except KeyError:
            _platform_name = platform_name
        if not _platform_name:
            self.platform_name = []
        else:
            self.platform_name = _platform_name
    def factory(*args_, **kwargs_):
        if DevicePlatformListType.subclass:
            return DevicePlatformListType.subclass(*args_, **kwargs_)
        else:
            return DevicePlatformListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_platform_name(self): return self.platform_name
    def set_platform_name(self, platform_name): self.platform_name = platform_name
    def add_platform_name(self, value): self.platform_name.append(value)
    def insert_platform_name(self, index, value): self.platform_name[index] = value
    def delete_platform_name(self, value): self.platform_name.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.platform_name == other.platform_name)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.platform_name or [])))

    def __repr__(self):
        return ("platform_name = " + str(self.platform_name))

    def copy(self):
        cp = DevicePlatformListType()
        if self.platform_name is not None:
            cp.platform_name = list(self.platform_name)
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_platform_name ([obj.populate_string ("platform_name")])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='DevicePlatformListType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DevicePlatformListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DevicePlatformListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DevicePlatformListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for platform_name_ in self.platform_name:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%splatform-name>%s</%splatform-name>%s' % (namespace_, self.gds_format_string(quote_xml(platform_name_).encode(ExternalEncoding), input_name='platform-name'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.platform_name
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DevicePlatformListType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('platform_name=[\n')
        level += 1
        for platform_name_ in self.platform_name:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(platform_name_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='DevicePlatformListType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'platform-name':
            platform_name_ = child_.text
            platform_name_ = self.gds_validate_string(platform_name_, node, 'platform_name')
            self.platform_name.append(platform_name_)
# end class DevicePlatformListType


class PortInfoType(GeneratedsSuper):
    """
    Attributes:
    * name
        Type:           str

    * type
        Type:           str, *one-of* [u'fc', u'ge', u'xe', u'xle', u'et', u'fte', u'me', u'em']

    * port_speed
        Type:           str, *one-of* [u'1G', u'10G', u'40G', u'100G']

    * channelized
        Type:           bool

    * channelized_port_speed
        Type:           str, *one-of* [u'1G', u'10G', u'40G', u'100G']

    * port_group
        Type:           str

    * labels
        Type:           str

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'name', 'type_', u'port_speed', u'channelized', u'channelized_port_speed', u'port_group', u'labels']
    attr_field_type_vals = {u'channelized_port_speed': {'restrictions': [u'1G', u'10G', u'40G', u'100G'], 'description': [], 'simple_type': u'PortSpeedType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': None, 'attr_type': u'string'}, u'name': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'labels': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': True, 'required': None, 'attr_type': u'string'}, u'port_group': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, 'type_': {'restrictions': [u'fc', u'ge', u'xe', u'xle', u'et', u'fte', u'me', u'em'], 'description': [], 'simple_type': u'InterfaceType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': None, 'attr_type': u'string'}, u'port_speed': {'restrictions': [u'1G', u'10G', u'40G', u'100G'], 'description': [], 'simple_type': u'PortSpeedType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': None, 'attr_type': u'string'}, u'channelized': {'restrictions': None, 'description': [], 'simple_type': u'xsd:boolean', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'boolean'}}
    def __init__(self, name=None, type_=None, port_speed=None, channelized=False, channelized_port_speed=None, port_group=None, labels=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _name = params_dict[u"name"]
        except KeyError:
            _name = name
        self.name = _name
        try:
            _type_ = params_dict[u"type_"]
        except KeyError:
            _type_ = type_
        self.type_ = _type_
        try:
            _port_speed = params_dict[u"port_speed"]
        except KeyError:
            _port_speed = port_speed
        self.port_speed = _port_speed
        try:
            _channelized = params_dict[u"channelized"]
        except KeyError:
            _channelized = channelized
        self.channelized = _channelized
        try:
            _channelized_port_speed = params_dict[u"channelized_port_speed"]
        except KeyError:
            _channelized_port_speed = channelized_port_speed
        self.channelized_port_speed = _channelized_port_speed
        try:
            _port_group = params_dict[u"port_group"]
        except KeyError:
            _port_group = port_group
        self.port_group = _port_group
        try:
            _labels = params_dict[u"labels"]
        except KeyError:
            _labels = labels
        if not _labels:
            self.labels = []
        else:
            self.labels = _labels
    def factory(*args_, **kwargs_):
        if PortInfoType.subclass:
            return PortInfoType.subclass(*args_, **kwargs_)
        else:
            return PortInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def validate_InterfaceType(self, value):
        # Validate type InterfaceType, a restriction on xsd:string.
        error = False
        if isinstance(value, list):
            error = set(value) - set([u'fc', u'ge', u'xe', u'xle', u'et', u'fte', u'me', u'em'])
        else:
            error = value not in [u'fc', u'ge', u'xe', u'xle', u'et', u'fte', u'me', u'em']
        if error:
            raise ValueError("InterfaceType must be one of [u'fc', u'ge', u'xe', u'xle', u'et', u'fte', u'me', u'em']")
    def get_port_speed(self): return self.port_speed
    def set_port_speed(self, port_speed): self.port_speed = port_speed
    def validate_PortSpeedType(self, value):
        # Validate type PortSpeedType, a restriction on xsd:string.
        error = False
        if isinstance(value, list):
            error = set(value) - set([u'1G', u'10G', u'40G', u'100G'])
        else:
            error = value not in [u'1G', u'10G', u'40G', u'100G']
        if error:
            raise ValueError("PortSpeedType must be one of [u'1G', u'10G', u'40G', u'100G']")
    def get_channelized(self): return self.channelized
    def set_channelized(self, channelized): self.channelized = channelized
    def get_channelized_port_speed(self): return self.channelized_port_speed
    def set_channelized_port_speed(self, channelized_port_speed): self.channelized_port_speed = channelized_port_speed
    def get_port_group(self): return self.port_group
    def set_port_group(self, port_group): self.port_group = port_group
    def get_labels(self): return self.labels
    def set_labels(self, labels): self.labels = labels
    def add_labels(self, value): self.labels.append(value)
    def insert_labels(self, index, value): self.labels[index] = value
    def delete_labels(self, value): self.labels.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.name == other.name and
                    self.type_ == other.type_ and
                    self.port_speed == other.port_speed and
                    self.channelized == other.channelized and
                    self.channelized_port_speed == other.channelized_port_speed and
                    self.port_group == other.port_group and
                    self.labels == other.labels)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.name if self.name is not None else -7985492147856592190,
                     self.type_ if self.type_ is not None else -7985492147856592190,
                     self.port_speed if self.port_speed is not None else -7985492147856592190,
                     self.channelized if self.channelized is not None else -7985492147856592190,
                     self.channelized_port_speed if self.channelized_port_speed is not None else -7985492147856592190,
                     self.port_group if self.port_group is not None else -7985492147856592190,
                     tuple(self.labels or [])))

    def __repr__(self):
        return ("name = " + str(self.name) + ", " +
                "type_ = " + str(self.type_) + ", " +
                "port_speed = " + str(self.port_speed) + ", " +
                "channelized = " + str(self.channelized) + ", " +
                "channelized_port_speed = " + str(self.channelized_port_speed) + ", " +
                "port_group = " + str(self.port_group) + ", " +
                "labels = " + str(self.labels))

    def copy(self):
        cp = PortInfoType()
        if self.name is not None:
            cp.name = self.name
        if self.type_ is not None:
            cp.type_ = self.type_
        if self.port_speed is not None:
            cp.port_speed = self.port_speed
        if self.channelized is not None:
            cp.channelized = self.channelized
        if self.channelized_port_speed is not None:
            cp.channelized_port_speed = self.channelized_port_speed
        if self.port_group is not None:
            cp.port_group = self.port_group
        if self.labels is not None:
            cp.labels = list(self.labels)
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_name (obj.populate_string ("name"))
        obj.set_type_ (obj.populate_string ("type_"))
        obj.set_port_speed (obj.populate_string ("port_speed"))
        obj.set_channelized (obj.populate_boolean ("channelized"))
        obj.set_channelized_port_speed (obj.populate_string ("channelized_port_speed"))
        obj.set_port_group (obj.populate_string ("port_group"))
        obj.set_labels ([obj.populate_string ("labels")])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='PortInfoType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PortInfoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PortInfoType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PortInfoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        if self.type_ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stype>%s</%stype>%s' % (namespace_, self.gds_format_string(quote_xml(self.type_).encode(ExternalEncoding), input_name='type'), namespace_, eol_))
        if self.port_speed is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sport-speed>%s</%sport-speed>%s' % (namespace_, self.gds_format_string(quote_xml(self.port_speed).encode(ExternalEncoding), input_name='port-speed'), namespace_, eol_))
        if self.channelized is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%schannelized>%s</%schannelized>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.channelized)), input_name='channelized'), namespace_, eol_))
        if self.channelized_port_speed is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%schannelized-port-speed>%s</%schannelized-port-speed>%s' % (namespace_, self.gds_format_string(quote_xml(self.channelized_port_speed).encode(ExternalEncoding), input_name='channelized-port-speed'), namespace_, eol_))
        if self.port_group is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sport-group>%s</%sport-group>%s' % (namespace_, self.gds_format_string(quote_xml(self.port_group).encode(ExternalEncoding), input_name='port-group'), namespace_, eol_))
        for labels_ in self.labels:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slabels>%s</%slabels>%s' % (namespace_, self.gds_format_string(quote_xml(labels_).encode(ExternalEncoding), input_name='labels'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.name is not None or
            self.type_ is not None or
            self.port_speed is not None or
            self.channelized is not None or
            self.channelized_port_speed is not None or
            self.port_group is not None or
            self.labels
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PortInfoType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.type_ is not None:
            showIndent(outfile, level)
            outfile.write('type_=%s,\n' % quote_python(self.type_).encode(ExternalEncoding))
        if self.port_speed is not None:
            showIndent(outfile, level)
            outfile.write('port_speed=%s,\n' % quote_python(self.port_speed).encode(ExternalEncoding))
        if self.channelized is not None:
            showIndent(outfile, level)
            outfile.write('channelized=%s,\n' % self.channelized)
        if self.channelized_port_speed is not None:
            showIndent(outfile, level)
            outfile.write('channelized_port_speed=%s,\n' % quote_python(self.channelized_port_speed).encode(ExternalEncoding))
        if self.port_group is not None:
            showIndent(outfile, level)
            outfile.write('port_group=%s,\n' % quote_python(self.port_group).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('labels=[\n')
        level += 1
        for labels_ in self.labels:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(labels_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='PortInfoType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'type':
            type_ = child_.text
            type_ = self.gds_validate_string(type_, node, 'type')
            self.type_ = type_
            self.validate_InterfaceType(self.type_)    # validate type InterfaceType
        elif nodeName_ == 'port-speed':
            port_speed_ = child_.text
            port_speed_ = self.gds_validate_string(port_speed_, node, 'port_speed')
            self.port_speed = port_speed_
            self.validate_PortSpeedType(self.port_speed)    # validate type PortSpeedType
        elif nodeName_ == 'channelized':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'channelized')
            self.channelized = ival_
        elif nodeName_ == 'channelized-port-speed':
            channelized_port_speed_ = child_.text
            channelized_port_speed_ = self.gds_validate_string(channelized_port_speed_, node, 'channelized_port_speed')
            self.channelized_port_speed = channelized_port_speed_
            self.validate_PortSpeedType(self.channelized_port_speed)    # validate type PortSpeedType
        elif nodeName_ == 'port-group':
            port_group_ = child_.text
            port_group_ = self.gds_validate_string(port_group_, node, 'port_group')
            self.port_group = port_group_
        elif nodeName_ == 'labels':
            labels_ = child_.text
            labels_ = self.gds_validate_string(labels_, node, 'labels')
            self.labels.append(labels_)
# end class PortInfoType


class InterfaceMapType(GeneratedsSuper):
    """
    Attributes:
    * port_info
        Type:           :class:`.PortInfoType`

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'port_info']
    attr_field_type_vals = {u'port_info': {'restrictions': None, 'description': [], 'simple_type': u'PortInfoType', 'is_complex': 1, 'restriction_type': None, 'is_array': True, 'required': None, 'attr_type': u'PortInfoType'}}
    def __init__(self, port_info=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _port_info = params_dict[u"port_info"]
        except KeyError:
            _port_info = port_info
        if not _port_info:
            self.port_info = []
        else:
            if isinstance(_port_info[0], dict):
                objs = [PortInfoType(params_dict=elem) for elem in _port_info]
                self.port_info = objs
            else:
                self.port_info = _port_info
    def factory(*args_, **kwargs_):
        if InterfaceMapType.subclass:
            return InterfaceMapType.subclass(*args_, **kwargs_)
        else:
            return InterfaceMapType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_port_info(self): return self.port_info
    def set_port_info(self, port_info): self.port_info = port_info
    def add_port_info(self, value): self.port_info.append(value)
    def insert_port_info(self, index, value): self.port_info[index] = value
    def delete_port_info(self, value): self.port_info.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.port_info == other.port_info)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.port_info or [])))

    def __repr__(self):
        return ("port_info = " + str(self.port_info))

    def copy(self):
        cp = InterfaceMapType()
        if self.port_info is not None:
            cp.port_info = [x.copy() for x in self.port_info]
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_port_info ([PortInfoType.populate ()])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='InterfaceMapType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InterfaceMapType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InterfaceMapType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='InterfaceMapType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for port_info_ in self.port_info:
            if isinstance(port_info_, dict):
                port_info_ = PortInfoType(**port_info_)
            port_info_.export_xml(outfile, level, namespace_, name_='port-info', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.port_info
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='InterfaceMapType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('port_info=[\n')
        level += 1
        for port_info_ in self.port_info:
            showIndent(outfile, level)
            outfile.write('model_.PortInfoType(\n')
            port_info_.exportLiteral(outfile, level, name_='PortInfoType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='InterfaceMapType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'port-info':
            obj_ = PortInfoType.factory()
            obj_.build(child_)
            self.port_info.append(obj_)
# end class InterfaceMapType


class RoutingBridgingRolesType(GeneratedsSuper):
    """
    Attributes:
    * rb_roles
        Type:           str

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'rb_roles']
    attr_field_type_vals = {u'rb_roles': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': True, 'required': None, 'attr_type': u'string'}}
    def __init__(self, rb_roles=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _rb_roles = params_dict[u"rb_roles"]
        except KeyError:
            _rb_roles = rb_roles
        if not _rb_roles:
            self.rb_roles = []
        else:
            self.rb_roles = _rb_roles
    def factory(*args_, **kwargs_):
        if RoutingBridgingRolesType.subclass:
            return RoutingBridgingRolesType.subclass(*args_, **kwargs_)
        else:
            return RoutingBridgingRolesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rb_roles(self): return self.rb_roles
    def set_rb_roles(self, rb_roles): self.rb_roles = rb_roles
    def add_rb_roles(self, value): self.rb_roles.append(value)
    def insert_rb_roles(self, index, value): self.rb_roles[index] = value
    def delete_rb_roles(self, value): self.rb_roles.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.rb_roles == other.rb_roles)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.rb_roles or [])))

    def __repr__(self):
        return ("rb_roles = " + str(self.rb_roles))

    def copy(self):
        cp = RoutingBridgingRolesType()
        if self.rb_roles is not None:
            cp.rb_roles = list(self.rb_roles)
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_rb_roles ([obj.populate_string ("rb_roles")])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='RoutingBridgingRolesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RoutingBridgingRolesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RoutingBridgingRolesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RoutingBridgingRolesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for rb_roles_ in self.rb_roles:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srb-roles>%s</%srb-roles>%s' % (namespace_, self.gds_format_string(quote_xml(rb_roles_).encode(ExternalEncoding), input_name='rb-roles'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.rb_roles
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RoutingBridgingRolesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('rb_roles=[\n')
        level += 1
        for rb_roles_ in self.rb_roles:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(rb_roles_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='RoutingBridgingRolesType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'rb-roles':
            rb_roles_ = child_.text
            rb_roles_ = self.gds_validate_string(rb_roles_, node, 'rb_roles')
            self.rb_roles.append(rb_roles_)
# end class RoutingBridgingRolesType


class NodeProfileRolesType(GeneratedsSuper):
    """
    Attributes:
    * role_mappings
        Type:           :class:`.NodeProfileRoleType`

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'role_mappings']
    attr_field_type_vals = {u'role_mappings': {'restrictions': None, 'description': [], 'simple_type': u'NodeProfileRoleType', 'is_complex': 1, 'restriction_type': None, 'is_array': True, 'required': None, 'attr_type': u'NodeProfileRoleType'}}
    def __init__(self, role_mappings=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _role_mappings = params_dict[u"role_mappings"]
        except KeyError:
            _role_mappings = role_mappings
        if not _role_mappings:
            self.role_mappings = []
        else:
            if isinstance(_role_mappings[0], dict):
                objs = [NodeProfileRoleType(params_dict=elem) for elem in _role_mappings]
                self.role_mappings = objs
            else:
                self.role_mappings = _role_mappings
    def factory(*args_, **kwargs_):
        if NodeProfileRolesType.subclass:
            return NodeProfileRolesType.subclass(*args_, **kwargs_)
        else:
            return NodeProfileRolesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_role_mappings(self): return self.role_mappings
    def set_role_mappings(self, role_mappings): self.role_mappings = role_mappings
    def add_role_mappings(self, value): self.role_mappings.append(value)
    def insert_role_mappings(self, index, value): self.role_mappings[index] = value
    def delete_role_mappings(self, value): self.role_mappings.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.role_mappings == other.role_mappings)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.role_mappings or [])))

    def __repr__(self):
        return ("role_mappings = " + str(self.role_mappings))

    def copy(self):
        cp = NodeProfileRolesType()
        if self.role_mappings is not None:
            cp.role_mappings = [x.copy() for x in self.role_mappings]
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_role_mappings ([NodeProfileRoleType.populate ()])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='NodeProfileRolesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NodeProfileRolesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NodeProfileRolesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='NodeProfileRolesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for role_mappings_ in self.role_mappings:
            if isinstance(role_mappings_, dict):
                role_mappings_ = NodeProfileRoleType(**role_mappings_)
            role_mappings_.export_xml(outfile, level, namespace_, name_='role-mappings', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.role_mappings
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='NodeProfileRolesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('role_mappings=[\n')
        level += 1
        for role_mappings_ in self.role_mappings:
            showIndent(outfile, level)
            outfile.write('model_.NodeProfileRoleType(\n')
            role_mappings_.exportLiteral(outfile, level, name_='NodeProfileRoleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='NodeProfileRolesType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'role-mappings':
            obj_ = NodeProfileRoleType.factory()
            obj_.build(child_)
            self.role_mappings.append(obj_)
# end class NodeProfileRolesType


class NodeProfileRoleType(GeneratedsSuper):
    """
    Attributes:
    * physical_role
        Type:           str

    * rb_roles
        Type:           str

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'physical_role', u'rb_roles']
    attr_field_type_vals = {u'rb_roles': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': True, 'required': None, 'attr_type': u'string'}, u'physical_role': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}}
    def __init__(self, physical_role=None, rb_roles=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _physical_role = params_dict[u"physical_role"]
        except KeyError:
            _physical_role = physical_role
        self.physical_role = _physical_role
        try:
            _rb_roles = params_dict[u"rb_roles"]
        except KeyError:
            _rb_roles = rb_roles
        if not _rb_roles:
            self.rb_roles = []
        else:
            self.rb_roles = _rb_roles
    def factory(*args_, **kwargs_):
        if NodeProfileRoleType.subclass:
            return NodeProfileRoleType.subclass(*args_, **kwargs_)
        else:
            return NodeProfileRoleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_physical_role(self): return self.physical_role
    def set_physical_role(self, physical_role): self.physical_role = physical_role
    def get_rb_roles(self): return self.rb_roles
    def set_rb_roles(self, rb_roles): self.rb_roles = rb_roles
    def add_rb_roles(self, value): self.rb_roles.append(value)
    def insert_rb_roles(self, index, value): self.rb_roles[index] = value
    def delete_rb_roles(self, value): self.rb_roles.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.physical_role == other.physical_role and
                    self.rb_roles == other.rb_roles)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.physical_role if self.physical_role is not None else -7985492147856592190,
                     tuple(self.rb_roles or [])))

    def __repr__(self):
        return ("physical_role = " + str(self.physical_role) + ", " +
                "rb_roles = " + str(self.rb_roles))

    def copy(self):
        cp = NodeProfileRoleType()
        if self.physical_role is not None:
            cp.physical_role = self.physical_role
        if self.rb_roles is not None:
            cp.rb_roles = list(self.rb_roles)
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_physical_role (obj.populate_string ("physical_role"))
        obj.set_rb_roles ([obj.populate_string ("rb_roles")])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='NodeProfileRoleType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NodeProfileRoleType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NodeProfileRoleType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='NodeProfileRoleType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.physical_role is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sphysical-role>%s</%sphysical-role>%s' % (namespace_, self.gds_format_string(quote_xml(self.physical_role).encode(ExternalEncoding), input_name='physical-role'), namespace_, eol_))
        for rb_roles_ in self.rb_roles:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srb-roles>%s</%srb-roles>%s' % (namespace_, self.gds_format_string(quote_xml(rb_roles_).encode(ExternalEncoding), input_name='rb-roles'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.physical_role is not None or
            self.rb_roles
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='NodeProfileRoleType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.physical_role is not None:
            showIndent(outfile, level)
            outfile.write('physical_role=%s,\n' % quote_python(self.physical_role).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('rb_roles=[\n')
        level += 1
        for rb_roles_ in self.rb_roles:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(rb_roles_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='NodeProfileRoleType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'physical-role':
            physical_role_ = child_.text
            physical_role_ = self.gds_validate_string(physical_role_, node, 'physical_role')
            self.physical_role = physical_role_
        elif nodeName_ == 'rb-roles':
            rb_roles_ = child_.text
            rb_roles_ = self.gds_validate_string(rb_roles_, node, 'rb_roles')
            self.rb_roles.append(rb_roles_)
# end class NodeProfileRoleType


class UserCredentials(GeneratedsSuper):
    """
    Attributes:
    * username
        Type:           str

    * password
        Type:           str

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'username', u'password']
    attr_field_type_vals = {u'username': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'password': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}}
    def __init__(self, username=None, password=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _username = params_dict[u"username"]
        except KeyError:
            _username = username
        self.username = _username
        try:
            _password = params_dict[u"password"]
        except KeyError:
            _password = password
        self.password = _password
    def factory(*args_, **kwargs_):
        if UserCredentials.subclass:
            return UserCredentials.subclass(*args_, **kwargs_)
        else:
            return UserCredentials(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_username(self): return self.username
    def set_username(self, username): self.username = username
    def get_password(self): return self.password
    def set_password(self, password): self.password = password
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.username == other.username and
                    self.password == other.password)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.username if self.username is not None else -7985492147856592190,
                     self.password if self.password is not None else -7985492147856592190))

    def __repr__(self):
        return ("username = " + str(self.username) + ", " +
                "password = " + str(self.password))

    def copy(self):
        cp = UserCredentials()
        if self.username is not None:
            cp.username = self.username
        if self.password is not None:
            cp.password = self.password
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_username (obj.populate_string ("username"))
        obj.set_password (obj.populate_string ("password"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='UserCredentials', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UserCredentials')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='UserCredentials'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='UserCredentials', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.username is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%susername>%s</%susername>%s' % (namespace_, self.gds_format_string(quote_xml(self.username).encode(ExternalEncoding), input_name='username'), namespace_, eol_))
        if self.password is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spassword>%s</%spassword>%s' % (namespace_, self.gds_format_string(quote_xml(self.password).encode(ExternalEncoding), input_name='password'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.username is not None or
            self.password is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='UserCredentials'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.username is not None:
            showIndent(outfile, level)
            outfile.write('username=%s,\n' % quote_python(self.username).encode(ExternalEncoding))
        if self.password is not None:
            showIndent(outfile, level)
            outfile.write('password=%s,\n' % quote_python(self.password).encode(ExternalEncoding))
    def exportDict(self, name_='UserCredentials'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'username':
            username_ = child_.text
            username_ = self.gds_validate_string(username_, node, 'username')
            self.username = username_
        elif nodeName_ == 'password':
            password_ = child_.text
            password_ = self.gds_validate_string(password_, node, 'password')
            self.password = password_
# end class UserCredentials


class SNMPCredentials(GeneratedsSuper):
    """
    Attributes:
    * version
        Type:           int

    * local_port
        Type:           int

    * retries
        Type:           int

    * timeout
        Type:           int

    * v2_community
        Type:           str

    * v3_security_name
        Type:           str

    * v3_security_level
        Type:           str

    * v3_security_engine_id
        Type:           str

    * v3_context
        Type:           str

    * v3_context_engine_id
        Type:           str

    * v3_authentication_protocol
        Type:           str

    * v3_authentication_password
        Type:           str

    * v3_privacy_protocol
        Type:           str

    * v3_privacy_password
        Type:           str

    * v3_engine_id
        Type:           str

    * v3_engine_boots
        Type:           int

    * v3_engine_time
        Type:           int

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'version', u'local_port', u'retries', u'timeout', u'v2_community', u'v3_security_name', u'v3_security_level', u'v3_security_engine_id', u'v3_context', u'v3_context_engine_id', u'v3_authentication_protocol', u'v3_authentication_password', u'v3_privacy_protocol', u'v3_privacy_password', u'v3_engine_id', u'v3_engine_boots', u'v3_engine_time']
    attr_field_type_vals = {u'v3_privacy_protocol': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'retries': {'restrictions': None, 'description': [], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'integer'}, u'v3_authentication_password': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'v3_engine_time': {'restrictions': None, 'description': [], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'integer'}, u'v3_engine_id': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'local_port': {'restrictions': None, 'description': [], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'integer'}, u'v3_security_level': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'v3_context': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'v3_security_name': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'v3_authentication_protocol': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'v2_community': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'v3_security_engine_id': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'v3_context_engine_id': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'version': {'restrictions': None, 'description': [], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'integer'}, u'timeout': {'restrictions': None, 'description': [], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'integer'}, u'v3_privacy_password': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'v3_engine_boots': {'restrictions': None, 'description': [], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'integer'}}
    def __init__(self, version=2, local_port=None, retries=None, timeout=None, v2_community=None, v3_security_name=None, v3_security_level=None, v3_security_engine_id=None, v3_context=None, v3_context_engine_id=None, v3_authentication_protocol=None, v3_authentication_password=None, v3_privacy_protocol=None, v3_privacy_password=None, v3_engine_id=None, v3_engine_boots=None, v3_engine_time=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _version = params_dict[u"version"]
        except KeyError:
            _version = version
        self.version = _version
        try:
            _local_port = params_dict[u"local_port"]
        except KeyError:
            _local_port = local_port
        self.local_port = _local_port
        try:
            _retries = params_dict[u"retries"]
        except KeyError:
            _retries = retries
        self.retries = _retries
        try:
            _timeout = params_dict[u"timeout"]
        except KeyError:
            _timeout = timeout
        self.timeout = _timeout
        try:
            _v2_community = params_dict[u"v2_community"]
        except KeyError:
            _v2_community = v2_community
        self.v2_community = _v2_community
        try:
            _v3_security_name = params_dict[u"v3_security_name"]
        except KeyError:
            _v3_security_name = v3_security_name
        self.v3_security_name = _v3_security_name
        try:
            _v3_security_level = params_dict[u"v3_security_level"]
        except KeyError:
            _v3_security_level = v3_security_level
        self.v3_security_level = _v3_security_level
        try:
            _v3_security_engine_id = params_dict[u"v3_security_engine_id"]
        except KeyError:
            _v3_security_engine_id = v3_security_engine_id
        self.v3_security_engine_id = _v3_security_engine_id
        try:
            _v3_context = params_dict[u"v3_context"]
        except KeyError:
            _v3_context = v3_context
        self.v3_context = _v3_context
        try:
            _v3_context_engine_id = params_dict[u"v3_context_engine_id"]
        except KeyError:
            _v3_context_engine_id = v3_context_engine_id
        self.v3_context_engine_id = _v3_context_engine_id
        try:
            _v3_authentication_protocol = params_dict[u"v3_authentication_protocol"]
        except KeyError:
            _v3_authentication_protocol = v3_authentication_protocol
        self.v3_authentication_protocol = _v3_authentication_protocol
        try:
            _v3_authentication_password = params_dict[u"v3_authentication_password"]
        except KeyError:
            _v3_authentication_password = v3_authentication_password
        self.v3_authentication_password = _v3_authentication_password
        try:
            _v3_privacy_protocol = params_dict[u"v3_privacy_protocol"]
        except KeyError:
            _v3_privacy_protocol = v3_privacy_protocol
        self.v3_privacy_protocol = _v3_privacy_protocol
        try:
            _v3_privacy_password = params_dict[u"v3_privacy_password"]
        except KeyError:
            _v3_privacy_password = v3_privacy_password
        self.v3_privacy_password = _v3_privacy_password
        try:
            _v3_engine_id = params_dict[u"v3_engine_id"]
        except KeyError:
            _v3_engine_id = v3_engine_id
        self.v3_engine_id = _v3_engine_id
        try:
            _v3_engine_boots = params_dict[u"v3_engine_boots"]
        except KeyError:
            _v3_engine_boots = v3_engine_boots
        self.v3_engine_boots = _v3_engine_boots
        try:
            _v3_engine_time = params_dict[u"v3_engine_time"]
        except KeyError:
            _v3_engine_time = v3_engine_time
        self.v3_engine_time = _v3_engine_time
    def factory(*args_, **kwargs_):
        if SNMPCredentials.subclass:
            return SNMPCredentials.subclass(*args_, **kwargs_)
        else:
            return SNMPCredentials(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_local_port(self): return self.local_port
    def set_local_port(self, local_port): self.local_port = local_port
    def get_retries(self): return self.retries
    def set_retries(self, retries): self.retries = retries
    def get_timeout(self): return self.timeout
    def set_timeout(self, timeout): self.timeout = timeout
    def get_v2_community(self): return self.v2_community
    def set_v2_community(self, v2_community): self.v2_community = v2_community
    def get_v3_security_name(self): return self.v3_security_name
    def set_v3_security_name(self, v3_security_name): self.v3_security_name = v3_security_name
    def get_v3_security_level(self): return self.v3_security_level
    def set_v3_security_level(self, v3_security_level): self.v3_security_level = v3_security_level
    def get_v3_security_engine_id(self): return self.v3_security_engine_id
    def set_v3_security_engine_id(self, v3_security_engine_id): self.v3_security_engine_id = v3_security_engine_id
    def get_v3_context(self): return self.v3_context
    def set_v3_context(self, v3_context): self.v3_context = v3_context
    def get_v3_context_engine_id(self): return self.v3_context_engine_id
    def set_v3_context_engine_id(self, v3_context_engine_id): self.v3_context_engine_id = v3_context_engine_id
    def get_v3_authentication_protocol(self): return self.v3_authentication_protocol
    def set_v3_authentication_protocol(self, v3_authentication_protocol): self.v3_authentication_protocol = v3_authentication_protocol
    def get_v3_authentication_password(self): return self.v3_authentication_password
    def set_v3_authentication_password(self, v3_authentication_password): self.v3_authentication_password = v3_authentication_password
    def get_v3_privacy_protocol(self): return self.v3_privacy_protocol
    def set_v3_privacy_protocol(self, v3_privacy_protocol): self.v3_privacy_protocol = v3_privacy_protocol
    def get_v3_privacy_password(self): return self.v3_privacy_password
    def set_v3_privacy_password(self, v3_privacy_password): self.v3_privacy_password = v3_privacy_password
    def get_v3_engine_id(self): return self.v3_engine_id
    def set_v3_engine_id(self, v3_engine_id): self.v3_engine_id = v3_engine_id
    def get_v3_engine_boots(self): return self.v3_engine_boots
    def set_v3_engine_boots(self, v3_engine_boots): self.v3_engine_boots = v3_engine_boots
    def get_v3_engine_time(self): return self.v3_engine_time
    def set_v3_engine_time(self, v3_engine_time): self.v3_engine_time = v3_engine_time
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.version == other.version and
                    self.local_port == other.local_port and
                    self.retries == other.retries and
                    self.timeout == other.timeout and
                    self.v2_community == other.v2_community and
                    self.v3_security_name == other.v3_security_name and
                    self.v3_security_level == other.v3_security_level and
                    self.v3_security_engine_id == other.v3_security_engine_id and
                    self.v3_context == other.v3_context and
                    self.v3_context_engine_id == other.v3_context_engine_id and
                    self.v3_authentication_protocol == other.v3_authentication_protocol and
                    self.v3_authentication_password == other.v3_authentication_password and
                    self.v3_privacy_protocol == other.v3_privacy_protocol and
                    self.v3_privacy_password == other.v3_privacy_password and
                    self.v3_engine_id == other.v3_engine_id and
                    self.v3_engine_boots == other.v3_engine_boots and
                    self.v3_engine_time == other.v3_engine_time)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.version if self.version is not None else -7985492147856592190,
                     self.local_port if self.local_port is not None else -7985492147856592190,
                     self.retries if self.retries is not None else -7985492147856592190,
                     self.timeout if self.timeout is not None else -7985492147856592190,
                     self.v2_community if self.v2_community is not None else -7985492147856592190,
                     self.v3_security_name if self.v3_security_name is not None else -7985492147856592190,
                     self.v3_security_level if self.v3_security_level is not None else -7985492147856592190,
                     self.v3_security_engine_id if self.v3_security_engine_id is not None else -7985492147856592190,
                     self.v3_context if self.v3_context is not None else -7985492147856592190,
                     self.v3_context_engine_id if self.v3_context_engine_id is not None else -7985492147856592190,
                     self.v3_authentication_protocol if self.v3_authentication_protocol is not None else -7985492147856592190,
                     self.v3_authentication_password if self.v3_authentication_password is not None else -7985492147856592190,
                     self.v3_privacy_protocol if self.v3_privacy_protocol is not None else -7985492147856592190,
                     self.v3_privacy_password if self.v3_privacy_password is not None else -7985492147856592190,
                     self.v3_engine_id if self.v3_engine_id is not None else -7985492147856592190,
                     self.v3_engine_boots if self.v3_engine_boots is not None else -7985492147856592190,
                     self.v3_engine_time if self.v3_engine_time is not None else -7985492147856592190))

    def __repr__(self):
        return ("version = " + str(self.version) + ", " +
                "local_port = " + str(self.local_port) + ", " +
                "retries = " + str(self.retries) + ", " +
                "timeout = " + str(self.timeout) + ", " +
                "v2_community = " + str(self.v2_community) + ", " +
                "v3_security_name = " + str(self.v3_security_name) + ", " +
                "v3_security_level = " + str(self.v3_security_level) + ", " +
                "v3_security_engine_id = " + str(self.v3_security_engine_id) + ", " +
                "v3_context = " + str(self.v3_context) + ", " +
                "v3_context_engine_id = " + str(self.v3_context_engine_id) + ", " +
                "v3_authentication_protocol = " + str(self.v3_authentication_protocol) + ", " +
                "v3_authentication_password = " + str(self.v3_authentication_password) + ", " +
                "v3_privacy_protocol = " + str(self.v3_privacy_protocol) + ", " +
                "v3_privacy_password = " + str(self.v3_privacy_password) + ", " +
                "v3_engine_id = " + str(self.v3_engine_id) + ", " +
                "v3_engine_boots = " + str(self.v3_engine_boots) + ", " +
                "v3_engine_time = " + str(self.v3_engine_time))

    def copy(self):
        cp = SNMPCredentials()
        if self.version is not None:
            cp.version = self.version
        if self.local_port is not None:
            cp.local_port = self.local_port
        if self.retries is not None:
            cp.retries = self.retries
        if self.timeout is not None:
            cp.timeout = self.timeout
        if self.v2_community is not None:
            cp.v2_community = self.v2_community
        if self.v3_security_name is not None:
            cp.v3_security_name = self.v3_security_name
        if self.v3_security_level is not None:
            cp.v3_security_level = self.v3_security_level
        if self.v3_security_engine_id is not None:
            cp.v3_security_engine_id = self.v3_security_engine_id
        if self.v3_context is not None:
            cp.v3_context = self.v3_context
        if self.v3_context_engine_id is not None:
            cp.v3_context_engine_id = self.v3_context_engine_id
        if self.v3_authentication_protocol is not None:
            cp.v3_authentication_protocol = self.v3_authentication_protocol
        if self.v3_authentication_password is not None:
            cp.v3_authentication_password = self.v3_authentication_password
        if self.v3_privacy_protocol is not None:
            cp.v3_privacy_protocol = self.v3_privacy_protocol
        if self.v3_privacy_password is not None:
            cp.v3_privacy_password = self.v3_privacy_password
        if self.v3_engine_id is not None:
            cp.v3_engine_id = self.v3_engine_id
        if self.v3_engine_boots is not None:
            cp.v3_engine_boots = self.v3_engine_boots
        if self.v3_engine_time is not None:
            cp.v3_engine_time = self.v3_engine_time
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_version (obj.populate_integer ("version"))
        obj.set_local_port (obj.populate_integer ("local_port"))
        obj.set_retries (obj.populate_integer ("retries"))
        obj.set_timeout (obj.populate_integer ("timeout"))
        obj.set_v2_community (obj.populate_string ("v2_community"))
        obj.set_v3_security_name (obj.populate_string ("v3_security_name"))
        obj.set_v3_security_level (obj.populate_string ("v3_security_level"))
        obj.set_v3_security_engine_id (obj.populate_string ("v3_security_engine_id"))
        obj.set_v3_context (obj.populate_string ("v3_context"))
        obj.set_v3_context_engine_id (obj.populate_string ("v3_context_engine_id"))
        obj.set_v3_authentication_protocol (obj.populate_string ("v3_authentication_protocol"))
        obj.set_v3_authentication_password (obj.populate_string ("v3_authentication_password"))
        obj.set_v3_privacy_protocol (obj.populate_string ("v3_privacy_protocol"))
        obj.set_v3_privacy_password (obj.populate_string ("v3_privacy_password"))
        obj.set_v3_engine_id (obj.populate_string ("v3_engine_id"))
        obj.set_v3_engine_boots (obj.populate_integer ("v3_engine_boots"))
        obj.set_v3_engine_time (obj.populate_integer ("v3_engine_time"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='SNMPCredentials', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SNMPCredentials')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SNMPCredentials'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SNMPCredentials', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sversion>%s</%sversion>%s' % (namespace_, self.gds_format_integer(self.version, input_name='version'), namespace_, eol_))
        if self.local_port is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slocal-port>%s</%slocal-port>%s' % (namespace_, self.gds_format_integer(self.local_port, input_name='local-port'), namespace_, eol_))
        if self.retries is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sretries>%s</%sretries>%s' % (namespace_, self.gds_format_integer(self.retries, input_name='retries'), namespace_, eol_))
        if self.timeout is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stimeout>%s</%stimeout>%s' % (namespace_, self.gds_format_integer(self.timeout, input_name='timeout'), namespace_, eol_))
        if self.v2_community is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sv2-community>%s</%sv2-community>%s' % (namespace_, self.gds_format_string(quote_xml(self.v2_community).encode(ExternalEncoding), input_name='v2-community'), namespace_, eol_))
        if self.v3_security_name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sv3-security-name>%s</%sv3-security-name>%s' % (namespace_, self.gds_format_string(quote_xml(self.v3_security_name).encode(ExternalEncoding), input_name='v3-security-name'), namespace_, eol_))
        if self.v3_security_level is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sv3-security-level>%s</%sv3-security-level>%s' % (namespace_, self.gds_format_string(quote_xml(self.v3_security_level).encode(ExternalEncoding), input_name='v3-security-level'), namespace_, eol_))
        if self.v3_security_engine_id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sv3-security-engine-id>%s</%sv3-security-engine-id>%s' % (namespace_, self.gds_format_string(quote_xml(self.v3_security_engine_id).encode(ExternalEncoding), input_name='v3-security-engine-id'), namespace_, eol_))
        if self.v3_context is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sv3-context>%s</%sv3-context>%s' % (namespace_, self.gds_format_string(quote_xml(self.v3_context).encode(ExternalEncoding), input_name='v3-context'), namespace_, eol_))
        if self.v3_context_engine_id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sv3-context-engine-id>%s</%sv3-context-engine-id>%s' % (namespace_, self.gds_format_string(quote_xml(self.v3_context_engine_id).encode(ExternalEncoding), input_name='v3-context-engine-id'), namespace_, eol_))
        if self.v3_authentication_protocol is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sv3-authentication-protocol>%s</%sv3-authentication-protocol>%s' % (namespace_, self.gds_format_string(quote_xml(self.v3_authentication_protocol).encode(ExternalEncoding), input_name='v3-authentication-protocol'), namespace_, eol_))
        if self.v3_authentication_password is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sv3-authentication-password>%s</%sv3-authentication-password>%s' % (namespace_, self.gds_format_string(quote_xml(self.v3_authentication_password).encode(ExternalEncoding), input_name='v3-authentication-password'), namespace_, eol_))
        if self.v3_privacy_protocol is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sv3-privacy-protocol>%s</%sv3-privacy-protocol>%s' % (namespace_, self.gds_format_string(quote_xml(self.v3_privacy_protocol).encode(ExternalEncoding), input_name='v3-privacy-protocol'), namespace_, eol_))
        if self.v3_privacy_password is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sv3-privacy-password>%s</%sv3-privacy-password>%s' % (namespace_, self.gds_format_string(quote_xml(self.v3_privacy_password).encode(ExternalEncoding), input_name='v3-privacy-password'), namespace_, eol_))
        if self.v3_engine_id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sv3-engine-id>%s</%sv3-engine-id>%s' % (namespace_, self.gds_format_string(quote_xml(self.v3_engine_id).encode(ExternalEncoding), input_name='v3-engine-id'), namespace_, eol_))
        if self.v3_engine_boots is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sv3-engine-boots>%s</%sv3-engine-boots>%s' % (namespace_, self.gds_format_integer(self.v3_engine_boots, input_name='v3-engine-boots'), namespace_, eol_))
        if self.v3_engine_time is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sv3-engine-time>%s</%sv3-engine-time>%s' % (namespace_, self.gds_format_integer(self.v3_engine_time, input_name='v3-engine-time'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.version is not None or
            self.local_port is not None or
            self.retries is not None or
            self.timeout is not None or
            self.v2_community is not None or
            self.v3_security_name is not None or
            self.v3_security_level is not None or
            self.v3_security_engine_id is not None or
            self.v3_context is not None or
            self.v3_context_engine_id is not None or
            self.v3_authentication_protocol is not None or
            self.v3_authentication_password is not None or
            self.v3_privacy_protocol is not None or
            self.v3_privacy_password is not None or
            self.v3_engine_id is not None or
            self.v3_engine_boots is not None or
            self.v3_engine_time is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SNMPCredentials'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.version is not None:
            showIndent(outfile, level)
            outfile.write('version=%d,\n' % self.version)
        if self.local_port is not None:
            showIndent(outfile, level)
            outfile.write('local_port=%d,\n' % self.local_port)
        if self.retries is not None:
            showIndent(outfile, level)
            outfile.write('retries=%d,\n' % self.retries)
        if self.timeout is not None:
            showIndent(outfile, level)
            outfile.write('timeout=%d,\n' % self.timeout)
        if self.v2_community is not None:
            showIndent(outfile, level)
            outfile.write('v2_community=%s,\n' % quote_python(self.v2_community).encode(ExternalEncoding))
        if self.v3_security_name is not None:
            showIndent(outfile, level)
            outfile.write('v3_security_name=%s,\n' % quote_python(self.v3_security_name).encode(ExternalEncoding))
        if self.v3_security_level is not None:
            showIndent(outfile, level)
            outfile.write('v3_security_level=%s,\n' % quote_python(self.v3_security_level).encode(ExternalEncoding))
        if self.v3_security_engine_id is not None:
            showIndent(outfile, level)
            outfile.write('v3_security_engine_id=%s,\n' % quote_python(self.v3_security_engine_id).encode(ExternalEncoding))
        if self.v3_context is not None:
            showIndent(outfile, level)
            outfile.write('v3_context=%s,\n' % quote_python(self.v3_context).encode(ExternalEncoding))
        if self.v3_context_engine_id is not None:
            showIndent(outfile, level)
            outfile.write('v3_context_engine_id=%s,\n' % quote_python(self.v3_context_engine_id).encode(ExternalEncoding))
        if self.v3_authentication_protocol is not None:
            showIndent(outfile, level)
            outfile.write('v3_authentication_protocol=%s,\n' % quote_python(self.v3_authentication_protocol).encode(ExternalEncoding))
        if self.v3_authentication_password is not None:
            showIndent(outfile, level)
            outfile.write('v3_authentication_password=%s,\n' % quote_python(self.v3_authentication_password).encode(ExternalEncoding))
        if self.v3_privacy_protocol is not None:
            showIndent(outfile, level)
            outfile.write('v3_privacy_protocol=%s,\n' % quote_python(self.v3_privacy_protocol).encode(ExternalEncoding))
        if self.v3_privacy_password is not None:
            showIndent(outfile, level)
            outfile.write('v3_privacy_password=%s,\n' % quote_python(self.v3_privacy_password).encode(ExternalEncoding))
        if self.v3_engine_id is not None:
            showIndent(outfile, level)
            outfile.write('v3_engine_id=%s,\n' % quote_python(self.v3_engine_id).encode(ExternalEncoding))
        if self.v3_engine_boots is not None:
            showIndent(outfile, level)
            outfile.write('v3_engine_boots=%d,\n' % self.v3_engine_boots)
        if self.v3_engine_time is not None:
            showIndent(outfile, level)
            outfile.write('v3_engine_time=%d,\n' % self.v3_engine_time)
    def exportDict(self, name_='SNMPCredentials'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'version':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'version')
            self.version = ival_
        elif nodeName_ == 'local-port':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'local_port')
            self.local_port = ival_
        elif nodeName_ == 'retries':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'retries')
            self.retries = ival_
        elif nodeName_ == 'timeout':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'timeout')
            self.timeout = ival_
        elif nodeName_ == 'v2-community':
            v2_community_ = child_.text
            v2_community_ = self.gds_validate_string(v2_community_, node, 'v2_community')
            self.v2_community = v2_community_
        elif nodeName_ == 'v3-security-name':
            v3_security_name_ = child_.text
            v3_security_name_ = self.gds_validate_string(v3_security_name_, node, 'v3_security_name')
            self.v3_security_name = v3_security_name_
        elif nodeName_ == 'v3-security-level':
            v3_security_level_ = child_.text
            v3_security_level_ = self.gds_validate_string(v3_security_level_, node, 'v3_security_level')
            self.v3_security_level = v3_security_level_
        elif nodeName_ == 'v3-security-engine-id':
            v3_security_engine_id_ = child_.text
            v3_security_engine_id_ = self.gds_validate_string(v3_security_engine_id_, node, 'v3_security_engine_id')
            self.v3_security_engine_id = v3_security_engine_id_
        elif nodeName_ == 'v3-context':
            v3_context_ = child_.text
            v3_context_ = self.gds_validate_string(v3_context_, node, 'v3_context')
            self.v3_context = v3_context_
        elif nodeName_ == 'v3-context-engine-id':
            v3_context_engine_id_ = child_.text
            v3_context_engine_id_ = self.gds_validate_string(v3_context_engine_id_, node, 'v3_context_engine_id')
            self.v3_context_engine_id = v3_context_engine_id_
        elif nodeName_ == 'v3-authentication-protocol':
            v3_authentication_protocol_ = child_.text
            v3_authentication_protocol_ = self.gds_validate_string(v3_authentication_protocol_, node, 'v3_authentication_protocol')
            self.v3_authentication_protocol = v3_authentication_protocol_
        elif nodeName_ == 'v3-authentication-password':
            v3_authentication_password_ = child_.text
            v3_authentication_password_ = self.gds_validate_string(v3_authentication_password_, node, 'v3_authentication_password')
            self.v3_authentication_password = v3_authentication_password_
        elif nodeName_ == 'v3-privacy-protocol':
            v3_privacy_protocol_ = child_.text
            v3_privacy_protocol_ = self.gds_validate_string(v3_privacy_protocol_, node, 'v3_privacy_protocol')
            self.v3_privacy_protocol = v3_privacy_protocol_
        elif nodeName_ == 'v3-privacy-password':
            v3_privacy_password_ = child_.text
            v3_privacy_password_ = self.gds_validate_string(v3_privacy_password_, node, 'v3_privacy_password')
            self.v3_privacy_password = v3_privacy_password_
        elif nodeName_ == 'v3-engine-id':
            v3_engine_id_ = child_.text
            v3_engine_id_ = self.gds_validate_string(v3_engine_id_, node, 'v3_engine_id')
            self.v3_engine_id = v3_engine_id_
        elif nodeName_ == 'v3-engine-boots':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'v3_engine_boots')
            self.v3_engine_boots = ival_
        elif nodeName_ == 'v3-engine-time':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'v3_engine_time')
            self.v3_engine_time = ival_
# end class SNMPCredentials


class DnsmasqLeaseParameters(GeneratedsSuper):
    """
    Attributes:
    * lease_expiry_time
        Type:           int

    * client_id
        Type:           str

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'lease_expiry_time', u'client_id']
    attr_field_type_vals = {u'lease_expiry_time': {'restrictions': None, 'description': [], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'integer'}, u'client_id': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}}
    def __init__(self, lease_expiry_time=None, client_id=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _lease_expiry_time = params_dict[u"lease_expiry_time"]
        except KeyError:
            _lease_expiry_time = lease_expiry_time
        self.lease_expiry_time = _lease_expiry_time
        try:
            _client_id = params_dict[u"client_id"]
        except KeyError:
            _client_id = client_id
        self.client_id = _client_id
    def factory(*args_, **kwargs_):
        if DnsmasqLeaseParameters.subclass:
            return DnsmasqLeaseParameters.subclass(*args_, **kwargs_)
        else:
            return DnsmasqLeaseParameters(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lease_expiry_time(self): return self.lease_expiry_time
    def set_lease_expiry_time(self, lease_expiry_time): self.lease_expiry_time = lease_expiry_time
    def get_client_id(self): return self.client_id
    def set_client_id(self, client_id): self.client_id = client_id
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.lease_expiry_time == other.lease_expiry_time and
                    self.client_id == other.client_id)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.lease_expiry_time if self.lease_expiry_time is not None else -7985492147856592190,
                     self.client_id if self.client_id is not None else -7985492147856592190))

    def __repr__(self):
        return ("lease_expiry_time = " + str(self.lease_expiry_time) + ", " +
                "client_id = " + str(self.client_id))

    def copy(self):
        cp = DnsmasqLeaseParameters()
        if self.lease_expiry_time is not None:
            cp.lease_expiry_time = self.lease_expiry_time
        if self.client_id is not None:
            cp.client_id = self.client_id
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_lease_expiry_time (obj.populate_integer ("lease_expiry_time"))
        obj.set_client_id (obj.populate_string ("client_id"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='DnsmasqLeaseParameters', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DnsmasqLeaseParameters')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DnsmasqLeaseParameters'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DnsmasqLeaseParameters', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.lease_expiry_time is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slease_expiry_time>%s</%slease_expiry_time>%s' % (namespace_, self.gds_format_integer(self.lease_expiry_time, input_name='lease_expiry_time'), namespace_, eol_))
        if self.client_id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sclient_id>%s</%sclient_id>%s' % (namespace_, self.gds_format_string(quote_xml(self.client_id).encode(ExternalEncoding), input_name='client_id'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.lease_expiry_time is not None or
            self.client_id is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DnsmasqLeaseParameters'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.lease_expiry_time is not None:
            showIndent(outfile, level)
            outfile.write('lease_expiry_time=%d,\n' % self.lease_expiry_time)
        if self.client_id is not None:
            showIndent(outfile, level)
            outfile.write('client_id=%s,\n' % quote_python(self.client_id).encode(ExternalEncoding))
    def exportDict(self, name_='DnsmasqLeaseParameters'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'lease_expiry_time':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'lease_expiry_time')
            self.lease_expiry_time = ival_
        elif nodeName_ == 'client_id':
            client_id_ = child_.text
            client_id_ = self.gds_validate_string(client_id_, node, 'client_id')
            self.client_id = client_id_
# end class DnsmasqLeaseParameters


class LogicalRouterPRListType(GeneratedsSuper):
    """
    Attributes:
    * logical_router_list
        Type:           :class:`.LogicalRouterPRListParams`

        Description:
          List of Destination LRs properties

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'logical_router_list']
    attr_field_type_vals = {u'logical_router_list': {'restrictions': None, 'description': [u'List of Destination LRs properties'], 'simple_type': u'LogicalRouterPRListParams', 'is_complex': 1, 'restriction_type': None, 'is_array': True, 'required': None, 'attr_type': u'LogicalRouterPRListParams'}}
    def __init__(self, logical_router_list=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _logical_router_list = params_dict[u"logical_router_list"]
        except KeyError:
            _logical_router_list = logical_router_list
        if not _logical_router_list:
            self.logical_router_list = []
        else:
            if isinstance(_logical_router_list[0], dict):
                objs = [LogicalRouterPRListParams(params_dict=elem) for elem in _logical_router_list]
                self.logical_router_list = objs
            else:
                self.logical_router_list = _logical_router_list
    def factory(*args_, **kwargs_):
        if LogicalRouterPRListType.subclass:
            return LogicalRouterPRListType.subclass(*args_, **kwargs_)
        else:
            return LogicalRouterPRListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_logical_router_list(self): return self.logical_router_list
    def set_logical_router_list(self, logical_router_list): self.logical_router_list = logical_router_list
    def add_logical_router_list(self, value): self.logical_router_list.append(value)
    def insert_logical_router_list(self, index, value): self.logical_router_list[index] = value
    def delete_logical_router_list(self, value): self.logical_router_list.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.logical_router_list == other.logical_router_list)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.logical_router_list or [])))

    def __repr__(self):
        return ("logical_router_list = " + str(self.logical_router_list))

    def copy(self):
        cp = LogicalRouterPRListType()
        if self.logical_router_list is not None:
            cp.logical_router_list = [x.copy() for x in self.logical_router_list]
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_logical_router_list ([LogicalRouterPRListParams.populate ()])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='LogicalRouterPRListType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LogicalRouterPRListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LogicalRouterPRListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LogicalRouterPRListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for logical_router_list_ in self.logical_router_list:
            if isinstance(logical_router_list_, dict):
                logical_router_list_ = LogicalRouterPRListParams(**logical_router_list_)
            logical_router_list_.export_xml(outfile, level, namespace_, name_='logical-router-list', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.logical_router_list
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LogicalRouterPRListType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('logical_router_list=[\n')
        level += 1
        for logical_router_list_ in self.logical_router_list:
            showIndent(outfile, level)
            outfile.write('model_.LogicalRouterPRListParams(\n')
            logical_router_list_.exportLiteral(outfile, level, name_='LogicalRouterPRListParams')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='LogicalRouterPRListType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'logical-router-list':
            obj_ = LogicalRouterPRListParams.factory()
            obj_.build(child_)
            self.logical_router_list.append(obj_)
# end class LogicalRouterPRListType


class LogicalRouterPRListParams(GeneratedsSuper):
    """
    Attributes:
    * logical_router_uuid
        Type:           str

        Created By:           User (required)

        Description:
          stores destination logical router uuid for dci intra-fabric type.

    * physical_router_uuid_list
        Type:           str

        Created By:           User (required)

        Description:
          list of physical routers uuid exists in current destination logical-router and

          user has selected this PR for dci intra-fabric route leaks.

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'logical_router_uuid', u'physical_router_uuid_list']
    attr_field_type_vals = {u'logical_router_uuid': {'restrictions': None, 'description': [u'stores destination logical router uuid for dci intra-fabric type.'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'true', 'attr_type': u'string'}, u'physical_router_uuid_list': {'restrictions': None, 'description': [u'list of physical routers uuid exists in current destination logical-router and user has selected this PR for dci intra-fabric route leaks.'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': True, 'required': u'true', 'attr_type': u'string'}}
    def __init__(self, logical_router_uuid=None, physical_router_uuid_list=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _logical_router_uuid = params_dict[u"logical_router_uuid"]
        except KeyError:
            _logical_router_uuid = logical_router_uuid
        self.logical_router_uuid = _logical_router_uuid
        try:
            _physical_router_uuid_list = params_dict[u"physical_router_uuid_list"]
        except KeyError:
            _physical_router_uuid_list = physical_router_uuid_list
        if not _physical_router_uuid_list:
            self.physical_router_uuid_list = []
        else:
            self.physical_router_uuid_list = _physical_router_uuid_list
    def factory(*args_, **kwargs_):
        if LogicalRouterPRListParams.subclass:
            return LogicalRouterPRListParams.subclass(*args_, **kwargs_)
        else:
            return LogicalRouterPRListParams(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_logical_router_uuid(self): return self.logical_router_uuid
    def set_logical_router_uuid(self, logical_router_uuid): self.logical_router_uuid = logical_router_uuid
    def get_physical_router_uuid_list(self): return self.physical_router_uuid_list
    def set_physical_router_uuid_list(self, physical_router_uuid_list): self.physical_router_uuid_list = physical_router_uuid_list
    def add_physical_router_uuid_list(self, value): self.physical_router_uuid_list.append(value)
    def insert_physical_router_uuid_list(self, index, value): self.physical_router_uuid_list[index] = value
    def delete_physical_router_uuid_list(self, value): self.physical_router_uuid_list.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.logical_router_uuid == other.logical_router_uuid and
                    self.physical_router_uuid_list == other.physical_router_uuid_list)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.logical_router_uuid if self.logical_router_uuid is not None else -7985492147856592190,
                     tuple(self.physical_router_uuid_list or [])))

    def __repr__(self):
        return ("logical_router_uuid = " + str(self.logical_router_uuid) + ", " +
                "physical_router_uuid_list = " + str(self.physical_router_uuid_list))

    def copy(self):
        cp = LogicalRouterPRListParams()
        if self.logical_router_uuid is not None:
            cp.logical_router_uuid = self.logical_router_uuid
        if self.physical_router_uuid_list is not None:
            cp.physical_router_uuid_list = list(self.physical_router_uuid_list)
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_logical_router_uuid (obj.populate_string ("logical_router_uuid"))
        obj.set_physical_router_uuid_list ([obj.populate_string ("physical_router_uuid_list")])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='LogicalRouterPRListParams', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LogicalRouterPRListParams')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LogicalRouterPRListParams'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LogicalRouterPRListParams', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.logical_router_uuid is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slogical-router-uuid>%s</%slogical-router-uuid>%s' % (namespace_, self.gds_format_string(quote_xml(self.logical_router_uuid).encode(ExternalEncoding), input_name='logical-router-uuid'), namespace_, eol_))
        for physical_router_uuid_list_ in self.physical_router_uuid_list:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sphysical-router-uuid-list>%s</%sphysical-router-uuid-list>%s' % (namespace_, self.gds_format_string(quote_xml(physical_router_uuid_list_).encode(ExternalEncoding), input_name='physical-router-uuid-list'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.logical_router_uuid is not None or
            self.physical_router_uuid_list
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LogicalRouterPRListParams'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.logical_router_uuid is not None:
            showIndent(outfile, level)
            outfile.write('logical_router_uuid=%s,\n' % quote_python(self.logical_router_uuid).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('physical_router_uuid_list=[\n')
        level += 1
        for physical_router_uuid_list_ in self.physical_router_uuid_list:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(physical_router_uuid_list_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='LogicalRouterPRListParams'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'logical-router-uuid':
            logical_router_uuid_ = child_.text
            logical_router_uuid_ = self.gds_validate_string(logical_router_uuid_, node, 'logical_router_uuid')
            self.logical_router_uuid = logical_router_uuid_
        elif nodeName_ == 'physical-router-uuid-list':
            physical_router_uuid_list_ = child_.text
            physical_router_uuid_list_ = self.gds_validate_string(physical_router_uuid_list_, node, 'physical_router_uuid_list')
            self.physical_router_uuid_list.append(physical_router_uuid_list_)
# end class LogicalRouterPRListParams


class BaremetalProperties(GeneratedsSuper):
    """
    Attributes:
    * memory_mb
        Type:           int

        Description:
          RAM of the Baremetal server (in MB)

    * cpu_arch
        Type:           str

        Description:
          Architecture of the baremetal server

    * local_gb
        Type:           int

        Description:
          Disk size of root device (in GB)

    * cpus
        Type:           int

        Description:
          Number of CPU cores on the baremetal

    * capabilities
        Type:           str

        Description:
          Boot option

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'memory_mb', u'cpu_arch', u'local_gb', u'cpus', u'capabilities']
    attr_field_type_vals = {u'memory_mb': {'restrictions': None, 'description': [u'RAM of the Baremetal server (in MB)'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'integer'}, u'cpu_arch': {'restrictions': None, 'description': [u'Architecture of the baremetal server'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'local_gb': {'restrictions': None, 'description': [u'Disk size of root device (in GB)'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'integer'}, u'cpus': {'restrictions': None, 'description': [u'Number of CPU cores on the baremetal'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'integer'}, u'capabilities': {'restrictions': None, 'description': [u'Boot option'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}}
    def __init__(self, memory_mb=None, cpu_arch=None, local_gb=None, cpus=None, capabilities=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _memory_mb = params_dict[u"memory_mb"]
        except KeyError:
            _memory_mb = memory_mb
        self.memory_mb = _memory_mb
        try:
            _cpu_arch = params_dict[u"cpu_arch"]
        except KeyError:
            _cpu_arch = cpu_arch
        self.cpu_arch = _cpu_arch
        try:
            _local_gb = params_dict[u"local_gb"]
        except KeyError:
            _local_gb = local_gb
        self.local_gb = _local_gb
        try:
            _cpus = params_dict[u"cpus"]
        except KeyError:
            _cpus = cpus
        self.cpus = _cpus
        try:
            _capabilities = params_dict[u"capabilities"]
        except KeyError:
            _capabilities = capabilities
        self.capabilities = _capabilities
    def factory(*args_, **kwargs_):
        if BaremetalProperties.subclass:
            return BaremetalProperties.subclass(*args_, **kwargs_)
        else:
            return BaremetalProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_memory_mb(self): return self.memory_mb
    def set_memory_mb(self, memory_mb): self.memory_mb = memory_mb
    def get_cpu_arch(self): return self.cpu_arch
    def set_cpu_arch(self, cpu_arch): self.cpu_arch = cpu_arch
    def get_local_gb(self): return self.local_gb
    def set_local_gb(self, local_gb): self.local_gb = local_gb
    def get_cpus(self): return self.cpus
    def set_cpus(self, cpus): self.cpus = cpus
    def get_capabilities(self): return self.capabilities
    def set_capabilities(self, capabilities): self.capabilities = capabilities
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.memory_mb == other.memory_mb and
                    self.cpu_arch == other.cpu_arch and
                    self.local_gb == other.local_gb and
                    self.cpus == other.cpus and
                    self.capabilities == other.capabilities)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.memory_mb if self.memory_mb is not None else -7985492147856592190,
                     self.cpu_arch if self.cpu_arch is not None else -7985492147856592190,
                     self.local_gb if self.local_gb is not None else -7985492147856592190,
                     self.cpus if self.cpus is not None else -7985492147856592190,
                     self.capabilities if self.capabilities is not None else -7985492147856592190))

    def __repr__(self):
        return ("memory_mb = " + str(self.memory_mb) + ", " +
                "cpu_arch = " + str(self.cpu_arch) + ", " +
                "local_gb = " + str(self.local_gb) + ", " +
                "cpus = " + str(self.cpus) + ", " +
                "capabilities = " + str(self.capabilities))

    def copy(self):
        cp = BaremetalProperties()
        if self.memory_mb is not None:
            cp.memory_mb = self.memory_mb
        if self.cpu_arch is not None:
            cp.cpu_arch = self.cpu_arch
        if self.local_gb is not None:
            cp.local_gb = self.local_gb
        if self.cpus is not None:
            cp.cpus = self.cpus
        if self.capabilities is not None:
            cp.capabilities = self.capabilities
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_memory_mb (obj.populate_integer ("memory_mb"))
        obj.set_cpu_arch (obj.populate_string ("cpu_arch"))
        obj.set_local_gb (obj.populate_integer ("local_gb"))
        obj.set_cpus (obj.populate_integer ("cpus"))
        obj.set_capabilities (obj.populate_string ("capabilities"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='BaremetalProperties', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BaremetalProperties')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BaremetalProperties'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='BaremetalProperties', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.memory_mb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smemory-mb>%s</%smemory-mb>%s' % (namespace_, self.gds_format_integer(self.memory_mb, input_name='memory-mb'), namespace_, eol_))
        if self.cpu_arch is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scpu-arch>%s</%scpu-arch>%s' % (namespace_, self.gds_format_string(quote_xml(self.cpu_arch).encode(ExternalEncoding), input_name='cpu-arch'), namespace_, eol_))
        if self.local_gb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slocal-gb>%s</%slocal-gb>%s' % (namespace_, self.gds_format_integer(self.local_gb, input_name='local-gb'), namespace_, eol_))
        if self.cpus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scpus>%s</%scpus>%s' % (namespace_, self.gds_format_integer(self.cpus, input_name='cpus'), namespace_, eol_))
        if self.capabilities is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scapabilities>%s</%scapabilities>%s' % (namespace_, self.gds_format_string(quote_xml(self.capabilities).encode(ExternalEncoding), input_name='capabilities'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.memory_mb is not None or
            self.cpu_arch is not None or
            self.local_gb is not None or
            self.cpus is not None or
            self.capabilities is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BaremetalProperties'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.memory_mb is not None:
            showIndent(outfile, level)
            outfile.write('memory_mb=%d,\n' % self.memory_mb)
        if self.cpu_arch is not None:
            showIndent(outfile, level)
            outfile.write('cpu_arch=%s,\n' % quote_python(self.cpu_arch).encode(ExternalEncoding))
        if self.local_gb is not None:
            showIndent(outfile, level)
            outfile.write('local_gb=%d,\n' % self.local_gb)
        if self.cpus is not None:
            showIndent(outfile, level)
            outfile.write('cpus=%d,\n' % self.cpus)
        if self.capabilities is not None:
            showIndent(outfile, level)
            outfile.write('capabilities=%s,\n' % quote_python(self.capabilities).encode(ExternalEncoding))
    def exportDict(self, name_='BaremetalProperties'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'memory-mb':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'memory_mb')
            self.memory_mb = ival_
        elif nodeName_ == 'cpu-arch':
            cpu_arch_ = child_.text
            cpu_arch_ = self.gds_validate_string(cpu_arch_, node, 'cpu_arch')
            self.cpu_arch = cpu_arch_
        elif nodeName_ == 'local-gb':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'local_gb')
            self.local_gb = ival_
        elif nodeName_ == 'cpus':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'cpus')
            self.cpus = ival_
        elif nodeName_ == 'capabilities':
            capabilities_ = child_.text
            capabilities_ = self.gds_validate_string(capabilities_, node, 'capabilities')
            self.capabilities = capabilities_
# end class BaremetalProperties


class PortGroupProperties(GeneratedsSuper):
    """
    Attributes:
    * miimon
        Type:           int

        Description:
          Specifies the MII link monitoring frequency in milliseconds.

    * xmit_hash_policy
        Type:           str

        Description:
          Transmit hash policy to use for slave selection in balance-xor, 802.3ad, and tlb

          modes.

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'miimon', u'xmit_hash_policy']
    attr_field_type_vals = {u'miimon': {'restrictions': None, 'description': [u'Specifies the MII link monitoring frequency in milliseconds.'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'integer'}, u'xmit_hash_policy': {'restrictions': None, 'description': [u'Transmit hash policy to use for slave selection in balance-xor, 802.3ad, and tlb modes.'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}}
    def __init__(self, miimon=None, xmit_hash_policy=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _miimon = params_dict[u"miimon"]
        except KeyError:
            _miimon = miimon
        self.miimon = _miimon
        try:
            _xmit_hash_policy = params_dict[u"xmit_hash_policy"]
        except KeyError:
            _xmit_hash_policy = xmit_hash_policy
        self.xmit_hash_policy = _xmit_hash_policy
    def factory(*args_, **kwargs_):
        if PortGroupProperties.subclass:
            return PortGroupProperties.subclass(*args_, **kwargs_)
        else:
            return PortGroupProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_miimon(self): return self.miimon
    def set_miimon(self, miimon): self.miimon = miimon
    def get_xmit_hash_policy(self): return self.xmit_hash_policy
    def set_xmit_hash_policy(self, xmit_hash_policy): self.xmit_hash_policy = xmit_hash_policy
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.miimon == other.miimon and
                    self.xmit_hash_policy == other.xmit_hash_policy)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.miimon if self.miimon is not None else -7985492147856592190,
                     self.xmit_hash_policy if self.xmit_hash_policy is not None else -7985492147856592190))

    def __repr__(self):
        return ("miimon = " + str(self.miimon) + ", " +
                "xmit_hash_policy = " + str(self.xmit_hash_policy))

    def copy(self):
        cp = PortGroupProperties()
        if self.miimon is not None:
            cp.miimon = self.miimon
        if self.xmit_hash_policy is not None:
            cp.xmit_hash_policy = self.xmit_hash_policy
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_miimon (obj.populate_integer ("miimon"))
        obj.set_xmit_hash_policy (obj.populate_string ("xmit_hash_policy"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='PortGroupProperties', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PortGroupProperties')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PortGroupProperties'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PortGroupProperties', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.miimon is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smiimon>%s</%smiimon>%s' % (namespace_, self.gds_format_integer(self.miimon, input_name='miimon'), namespace_, eol_))
        if self.xmit_hash_policy is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxmit-hash-policy>%s</%sxmit-hash-policy>%s' % (namespace_, self.gds_format_string(quote_xml(self.xmit_hash_policy).encode(ExternalEncoding), input_name='xmit-hash-policy'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.miimon is not None or
            self.xmit_hash_policy is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PortGroupProperties'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.miimon is not None:
            showIndent(outfile, level)
            outfile.write('miimon=%d,\n' % self.miimon)
        if self.xmit_hash_policy is not None:
            showIndent(outfile, level)
            outfile.write('xmit_hash_policy=%s,\n' % quote_python(self.xmit_hash_policy).encode(ExternalEncoding))
    def exportDict(self, name_='PortGroupProperties'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'miimon':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'miimon')
            self.miimon = ival_
        elif nodeName_ == 'xmit-hash-policy':
            xmit_hash_policy_ = child_.text
            xmit_hash_policy_ = self.gds_validate_string(xmit_hash_policy_, node, 'xmit_hash_policy')
            self.xmit_hash_policy = xmit_hash_policy_
# end class PortGroupProperties


class ESXIProperties(GeneratedsSuper):
    """
    Attributes:
    * dvs_name
        Type:           str

        Description:
          Name of the Distributed Virtual Switch(DVS) assigned to Port.

    * dvs_id
        Type:           str

        Description:
          MOid of the Distributed Virtual Switch(DVS) assigned to Port.

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'dvs_name', u'dvs_id']
    attr_field_type_vals = {u'dvs_name': {'restrictions': None, 'description': [u'Name of the Distributed Virtual Switch(DVS) assigned to Port.'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'dvs_id': {'restrictions': None, 'description': [u'MOid of the Distributed Virtual Switch(DVS) assigned to Port.'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}}
    def __init__(self, dvs_name=None, dvs_id=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _dvs_name = params_dict[u"dvs_name"]
        except KeyError:
            _dvs_name = dvs_name
        self.dvs_name = _dvs_name
        try:
            _dvs_id = params_dict[u"dvs_id"]
        except KeyError:
            _dvs_id = dvs_id
        self.dvs_id = _dvs_id
    def factory(*args_, **kwargs_):
        if ESXIProperties.subclass:
            return ESXIProperties.subclass(*args_, **kwargs_)
        else:
            return ESXIProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dvs_name(self): return self.dvs_name
    def set_dvs_name(self, dvs_name): self.dvs_name = dvs_name
    def get_dvs_id(self): return self.dvs_id
    def set_dvs_id(self, dvs_id): self.dvs_id = dvs_id
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.dvs_name == other.dvs_name and
                    self.dvs_id == other.dvs_id)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.dvs_name if self.dvs_name is not None else -7985492147856592190,
                     self.dvs_id if self.dvs_id is not None else -7985492147856592190))

    def __repr__(self):
        return ("dvs_name = " + str(self.dvs_name) + ", " +
                "dvs_id = " + str(self.dvs_id))

    def copy(self):
        cp = ESXIProperties()
        if self.dvs_name is not None:
            cp.dvs_name = self.dvs_name
        if self.dvs_id is not None:
            cp.dvs_id = self.dvs_id
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_dvs_name (obj.populate_string ("dvs_name"))
        obj.set_dvs_id (obj.populate_string ("dvs_id"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='ESXIProperties', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ESXIProperties')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ESXIProperties'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ESXIProperties', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.dvs_name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdvs_name>%s</%sdvs_name>%s' % (namespace_, self.gds_format_string(quote_xml(self.dvs_name).encode(ExternalEncoding), input_name='dvs_name'), namespace_, eol_))
        if self.dvs_id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdvs_id>%s</%sdvs_id>%s' % (namespace_, self.gds_format_string(quote_xml(self.dvs_id).encode(ExternalEncoding), input_name='dvs_id'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.dvs_name is not None or
            self.dvs_id is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ESXIProperties'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.dvs_name is not None:
            showIndent(outfile, level)
            outfile.write('dvs_name=%s,\n' % quote_python(self.dvs_name).encode(ExternalEncoding))
        if self.dvs_id is not None:
            showIndent(outfile, level)
            outfile.write('dvs_id=%s,\n' % quote_python(self.dvs_id).encode(ExternalEncoding))
    def exportDict(self, name_='ESXIProperties'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dvs_name':
            dvs_name_ = child_.text
            dvs_name_ = self.gds_validate_string(dvs_name_, node, 'dvs_name')
            self.dvs_name = dvs_name_
        elif nodeName_ == 'dvs_id':
            dvs_id_ = child_.text
            dvs_id_ = self.gds_validate_string(dvs_id_, node, 'dvs_id')
            self.dvs_id = dvs_id_
# end class ESXIProperties


class BaremetalPortInfo(GeneratedsSuper):
    """
    Attributes:
    * pxe_enabled
        Type:           bool

        Description:
          Indicates whether PXE is enabled or disabled on the Port.

    * local_link_connection
        Type:           :class:`.LocalLinkConnection`

        Description:
          The Port binding profile

    * node_uuid
        Type:           str

        Description:
          UUID of the parent node where this port is connected

    * address
        Type:           str

        Description:
          Mac Address of the NIC in Node

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'pxe_enabled', u'local_link_connection', u'node_uuid', u'address']
    attr_field_type_vals = {u'pxe_enabled': {'restrictions': None, 'description': [u'Indicates whether PXE is enabled or disabled on the Port.'], 'simple_type': u'xsd:boolean', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'boolean'}, u'local_link_connection': {'restrictions': None, 'description': [u'The Port binding profile'], 'simple_type': u'LocalLinkConnection', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'LocalLinkConnection'}, u'node_uuid': {'restrictions': None, 'description': [u'UUID of the parent node where this port is connected'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'address': {'restrictions': None, 'description': [u'Mac Address of the NIC in Node'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}}
    def __init__(self, pxe_enabled=None, local_link_connection=None, node_uuid=None, address=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _pxe_enabled = params_dict[u"pxe_enabled"]
        except KeyError:
            _pxe_enabled = pxe_enabled
        self.pxe_enabled = _pxe_enabled
        try:
            _local_link_connection = params_dict[u"local_link_connection"]
        except KeyError:
            _local_link_connection = local_link_connection
        if isinstance(_local_link_connection, dict):
            obj = LocalLinkConnection(params_dict=_local_link_connection)
            self.local_link_connection = obj
        else:
            self.local_link_connection = _local_link_connection
        try:
            _node_uuid = params_dict[u"node_uuid"]
        except KeyError:
            _node_uuid = node_uuid
        self.node_uuid = _node_uuid
        try:
            _address = params_dict[u"address"]
        except KeyError:
            _address = address
        self.address = _address
    def factory(*args_, **kwargs_):
        if BaremetalPortInfo.subclass:
            return BaremetalPortInfo.subclass(*args_, **kwargs_)
        else:
            return BaremetalPortInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pxe_enabled(self): return self.pxe_enabled
    def set_pxe_enabled(self, pxe_enabled): self.pxe_enabled = pxe_enabled
    def get_local_link_connection(self): return self.local_link_connection
    def set_local_link_connection(self, local_link_connection): self.local_link_connection = local_link_connection
    def get_node_uuid(self): return self.node_uuid
    def set_node_uuid(self, node_uuid): self.node_uuid = node_uuid
    def get_address(self): return self.address
    def set_address(self, address): self.address = address
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.pxe_enabled == other.pxe_enabled and
                    self.local_link_connection == other.local_link_connection and
                    self.node_uuid == other.node_uuid and
                    self.address == other.address)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.pxe_enabled if self.pxe_enabled is not None else -7985492147856592190,
                     self.local_link_connection if self.local_link_connection is not None else -7985492147856592190,
                     self.node_uuid if self.node_uuid is not None else -7985492147856592190,
                     self.address if self.address is not None else -7985492147856592190))

    def __repr__(self):
        return ("pxe_enabled = " + str(self.pxe_enabled) + ", " +
                "local_link_connection = " + str(self.local_link_connection) + ", " +
                "node_uuid = " + str(self.node_uuid) + ", " +
                "address = " + str(self.address))

    def copy(self):
        cp = BaremetalPortInfo()
        if self.pxe_enabled is not None:
            cp.pxe_enabled = self.pxe_enabled
        if self.local_link_connection is not None:
            cp.local_link_connection = self.local_link_connection.copy()
        if self.node_uuid is not None:
            cp.node_uuid = self.node_uuid
        if self.address is not None:
            cp.address = self.address
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_pxe_enabled (obj.populate_boolean ("pxe_enabled"))
        obj.set_local_link_connection (LocalLinkConnection.populate ())
        obj.set_node_uuid (obj.populate_string ("node_uuid"))
        obj.set_address (obj.populate_string ("address"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='BaremetalPortInfo', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BaremetalPortInfo')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BaremetalPortInfo'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='BaremetalPortInfo', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.pxe_enabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spxe-enabled>%s</%spxe-enabled>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.pxe_enabled)), input_name='pxe-enabled'), namespace_, eol_))
        if self.local_link_connection is not None:
            self.local_link_connection.export_xml(outfile, level, namespace_, name_='local-link-connection', pretty_print=pretty_print)
        if self.node_uuid is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snode-uuid>%s</%snode-uuid>%s' % (namespace_, self.gds_format_string(quote_xml(self.node_uuid).encode(ExternalEncoding), input_name='node-uuid'), namespace_, eol_))
        if self.address is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saddress>%s</%saddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.address).encode(ExternalEncoding), input_name='address'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.pxe_enabled is not None or
            self.local_link_connection is not None or
            self.node_uuid is not None or
            self.address is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BaremetalPortInfo'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.pxe_enabled is not None:
            showIndent(outfile, level)
            outfile.write('pxe_enabled=%s,\n' % self.pxe_enabled)
        if self.local_link_connection is not None:
            showIndent(outfile, level)
            outfile.write('local_link_connection=model_.LocalLinkConnection(\n')
            self.local_link_connection.exportLiteral(outfile, level, name_='local_link_connection')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.node_uuid is not None:
            showIndent(outfile, level)
            outfile.write('node_uuid=%s,\n' % quote_python(self.node_uuid).encode(ExternalEncoding))
        if self.address is not None:
            showIndent(outfile, level)
            outfile.write('address=%s,\n' % quote_python(self.address).encode(ExternalEncoding))
    def exportDict(self, name_='BaremetalPortInfo'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'pxe-enabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'pxe_enabled')
            self.pxe_enabled = ival_
        elif nodeName_ == 'local-link-connection':
            obj_ = LocalLinkConnection.factory()
            obj_.build(child_)
            self.set_local_link_connection(obj_)
        elif nodeName_ == 'node-uuid':
            node_uuid_ = child_.text
            node_uuid_ = self.gds_validate_string(node_uuid_, node, 'node_uuid')
            self.node_uuid = node_uuid_
        elif nodeName_ == 'address':
            address_ = child_.text
            address_ = self.gds_validate_string(address_, node, 'address')
            self.address = address_
# end class BaremetalPortInfo


class CloudInstanceInfo(GeneratedsSuper):
    """
    Attributes:
    * os_version
        Type:           str

        Description:
          specific version of operating system

    * operating_system
        Type:           str

        Description:
          Name of operating system, ex - centos7 or ubuntu16

    * roles
        Type:           :class:`.None`

        Description:
          Roles of the cloud instance

    * availability_zone
        Type:           str

        Description:
          Availability zone to which the instance belongs to

    * instance_type
        Type:           str

        Description:
          size of instance

    * machine_id
        Type:           str

        Description:
          image (ami) id of instance

    * volume_size
        Type:           int

        Description:
          Size of the volume for the cloud instance

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'os_version', u'operating_system', u'roles', u'availability_zone', u'instance_type', u'machine_id', u'volume_size']
    attr_field_type_vals = {u'operating_system': {'restrictions': None, 'description': [u'Name of operating system, ex - centos7 or ubuntu16'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'roles': {'restrictions': None, 'description': [u'Roles of the cloud instance'], 'simple_type': None, 'is_complex': 0, 'restriction_type': None, 'is_array': True, 'required': None, 'attr_type': u'string'}, u'instance_type': {'restrictions': None, 'description': [u'size of instance'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'availability_zone': {'restrictions': None, 'description': [u'Availability zone to which the instance belongs to'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'os_version': {'restrictions': None, 'description': [u'specific version of operating system'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'machine_id': {'restrictions': None, 'description': [u'image (ami) id of instance'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'volume_size': {'restrictions': None, 'description': [u'Size of the volume for the cloud instance'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'integer'}}
    def __init__(self, os_version=None, operating_system=None, roles=None, availability_zone=None, instance_type=None, machine_id=None, volume_size=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _os_version = params_dict[u"os_version"]
        except KeyError:
            _os_version = os_version
        self.os_version = _os_version
        try:
            _operating_system = params_dict[u"operating_system"]
        except KeyError:
            _operating_system = operating_system
        self.operating_system = _operating_system
        try:
            _roles = params_dict[u"roles"]
        except KeyError:
            _roles = roles
        if not _roles:
            self.roles = []
        else:
            self.roles = _roles
        try:
            _availability_zone = params_dict[u"availability_zone"]
        except KeyError:
            _availability_zone = availability_zone
        self.availability_zone = _availability_zone
        try:
            _instance_type = params_dict[u"instance_type"]
        except KeyError:
            _instance_type = instance_type
        self.instance_type = _instance_type
        try:
            _machine_id = params_dict[u"machine_id"]
        except KeyError:
            _machine_id = machine_id
        self.machine_id = _machine_id
        try:
            _volume_size = params_dict[u"volume_size"]
        except KeyError:
            _volume_size = volume_size
        self.volume_size = _volume_size
    def factory(*args_, **kwargs_):
        if CloudInstanceInfo.subclass:
            return CloudInstanceInfo.subclass(*args_, **kwargs_)
        else:
            return CloudInstanceInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_os_version(self): return self.os_version
    def set_os_version(self, os_version): self.os_version = os_version
    def get_operating_system(self): return self.operating_system
    def set_operating_system(self, operating_system): self.operating_system = operating_system
    def get_roles(self): return self.roles
    def set_roles(self, roles): self.roles = roles
    def add_roles(self, value): self.roles.append(value)
    def insert_roles(self, index, value): self.roles[index] = value
    def delete_roles(self, value): self.roles.remove(value)
    def get_availability_zone(self): return self.availability_zone
    def set_availability_zone(self, availability_zone): self.availability_zone = availability_zone
    def get_instance_type(self): return self.instance_type
    def set_instance_type(self, instance_type): self.instance_type = instance_type
    def get_machine_id(self): return self.machine_id
    def set_machine_id(self, machine_id): self.machine_id = machine_id
    def get_volume_size(self): return self.volume_size
    def set_volume_size(self, volume_size): self.volume_size = volume_size
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.os_version == other.os_version and
                    self.operating_system == other.operating_system and
                    self.roles == other.roles and
                    self.availability_zone == other.availability_zone and
                    self.instance_type == other.instance_type and
                    self.machine_id == other.machine_id and
                    self.volume_size == other.volume_size)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.os_version if self.os_version is not None else -7985492147856592190,
                     self.operating_system if self.operating_system is not None else -7985492147856592190,
                     tuple(self.roles or []),
                     self.availability_zone if self.availability_zone is not None else -7985492147856592190,
                     self.instance_type if self.instance_type is not None else -7985492147856592190,
                     self.machine_id if self.machine_id is not None else -7985492147856592190,
                     self.volume_size if self.volume_size is not None else -7985492147856592190))

    def __repr__(self):
        return ("os_version = " + str(self.os_version) + ", " +
                "operating_system = " + str(self.operating_system) + ", " +
                "roles = " + str(self.roles) + ", " +
                "availability_zone = " + str(self.availability_zone) + ", " +
                "instance_type = " + str(self.instance_type) + ", " +
                "machine_id = " + str(self.machine_id) + ", " +
                "volume_size = " + str(self.volume_size))

    def copy(self):
        cp = CloudInstanceInfo()
        if self.os_version is not None:
            cp.os_version = self.os_version
        if self.operating_system is not None:
            cp.operating_system = self.operating_system
        if self.roles is not None:
            cp.roles = list(self.roles)
        if self.availability_zone is not None:
            cp.availability_zone = self.availability_zone
        if self.instance_type is not None:
            cp.instance_type = self.instance_type
        if self.machine_id is not None:
            cp.machine_id = self.machine_id
        if self.volume_size is not None:
            cp.volume_size = self.volume_size
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_os_version (obj.populate_string ("os_version"))
        obj.set_operating_system (obj.populate_string ("operating_system"))
        obj.set_roles ([obj.populate_string ("roles")])
        obj.set_availability_zone (obj.populate_string ("availability_zone"))
        obj.set_instance_type (obj.populate_string ("instance_type"))
        obj.set_machine_id (obj.populate_string ("machine_id"))
        obj.set_volume_size (obj.populate_integer ("volume_size"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='CloudInstanceInfo', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CloudInstanceInfo')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CloudInstanceInfo'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CloudInstanceInfo', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.os_version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sos-version>%s</%sos-version>%s' % (namespace_, self.gds_format_string(quote_xml(self.os_version).encode(ExternalEncoding), input_name='os-version'), namespace_, eol_))
        if self.operating_system is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soperating-system>%s</%soperating-system>%s' % (namespace_, self.gds_format_string(quote_xml(self.operating_system).encode(ExternalEncoding), input_name='operating-system'), namespace_, eol_))
        for roles_ in self.roles:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sroles>%s</%sroles>%s' % (namespace_, self.gds_format_string(quote_xml(roles_).encode(ExternalEncoding), input_name='roles'), namespace_, eol_))
        if self.availability_zone is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%savailability-zone>%s</%savailability-zone>%s' % (namespace_, self.gds_format_string(quote_xml(self.availability_zone).encode(ExternalEncoding), input_name='availability-zone'), namespace_, eol_))
        if self.instance_type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinstance-type>%s</%sinstance-type>%s' % (namespace_, self.gds_format_string(quote_xml(self.instance_type).encode(ExternalEncoding), input_name='instance-type'), namespace_, eol_))
        if self.machine_id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smachine-id>%s</%smachine-id>%s' % (namespace_, self.gds_format_string(quote_xml(self.machine_id).encode(ExternalEncoding), input_name='machine-id'), namespace_, eol_))
        if self.volume_size is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svolume-size>%s</%svolume-size>%s' % (namespace_, self.gds_format_integer(self.volume_size, input_name='volume-size'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.os_version is not None or
            self.operating_system is not None or
            self.roles or
            self.availability_zone is not None or
            self.instance_type is not None or
            self.machine_id is not None or
            self.volume_size is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CloudInstanceInfo'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.os_version is not None:
            showIndent(outfile, level)
            outfile.write('os_version=%s,\n' % quote_python(self.os_version).encode(ExternalEncoding))
        if self.operating_system is not None:
            showIndent(outfile, level)
            outfile.write('operating_system=%s,\n' % quote_python(self.operating_system).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('roles=[\n')
        level += 1
        for roles_ in self.roles:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(roles_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.availability_zone is not None:
            showIndent(outfile, level)
            outfile.write('availability_zone=%s,\n' % quote_python(self.availability_zone).encode(ExternalEncoding))
        if self.instance_type is not None:
            showIndent(outfile, level)
            outfile.write('instance_type=%s,\n' % quote_python(self.instance_type).encode(ExternalEncoding))
        if self.machine_id is not None:
            showIndent(outfile, level)
            outfile.write('machine_id=%s,\n' % quote_python(self.machine_id).encode(ExternalEncoding))
        if self.volume_size is not None:
            showIndent(outfile, level)
            outfile.write('volume_size=%d,\n' % self.volume_size)
    def exportDict(self, name_='CloudInstanceInfo'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'os-version':
            os_version_ = child_.text
            os_version_ = self.gds_validate_string(os_version_, node, 'os_version')
            self.os_version = os_version_
        elif nodeName_ == 'operating-system':
            operating_system_ = child_.text
            operating_system_ = self.gds_validate_string(operating_system_, node, 'operating_system')
            self.operating_system = operating_system_
        elif nodeName_ == 'roles':
            roles_ = child_.text
            roles_ = self.gds_validate_string(roles_, node, 'roles')
            self.roles.append(roles_)
        elif nodeName_ == 'availability-zone':
            availability_zone_ = child_.text
            availability_zone_ = self.gds_validate_string(availability_zone_, node, 'availability_zone')
            self.availability_zone = availability_zone_
        elif nodeName_ == 'instance-type':
            instance_type_ = child_.text
            instance_type_ = self.gds_validate_string(instance_type_, node, 'instance_type')
            self.instance_type = instance_type_
        elif nodeName_ == 'machine-id':
            machine_id_ = child_.text
            machine_id_ = self.gds_validate_string(machine_id_, node, 'machine_id')
            self.machine_id = machine_id_
        elif nodeName_ == 'volume-size':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'volume_size')
            self.volume_size = ival_
# end class CloudInstanceInfo


class LocalLinkConnection(GeneratedsSuper):
    """
    Attributes:
    * switch_info
        Type:           str

        Description:
          UUID of the Physical-Port with contrail database

    * port_index
        Type:           str

        Description:
          Port-Id provided by LLDP, This usually maps to SnmpIndex

    * port_id
        Type:           str

        Description:
          Port ID of switch where Baremetal is connected

    * switch_id
        Type:           str

        Description:
          Switch hostname

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'switch_info', u'port_index', u'port_id', u'switch_id']
    attr_field_type_vals = {u'switch_info': {'restrictions': None, 'description': [u'UUID of the Physical-Port with contrail database'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'port_index': {'restrictions': None, 'description': [u'Port-Id provided by LLDP, This usually maps to SnmpIndex'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'port_id': {'restrictions': None, 'description': [u'Port ID of switch where Baremetal is connected'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'switch_id': {'restrictions': None, 'description': [u'Switch hostname'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}}
    def __init__(self, switch_info=None, port_index=None, port_id=None, switch_id=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _switch_info = params_dict[u"switch_info"]
        except KeyError:
            _switch_info = switch_info
        self.switch_info = _switch_info
        try:
            _port_index = params_dict[u"port_index"]
        except KeyError:
            _port_index = port_index
        self.port_index = _port_index
        try:
            _port_id = params_dict[u"port_id"]
        except KeyError:
            _port_id = port_id
        self.port_id = _port_id
        try:
            _switch_id = params_dict[u"switch_id"]
        except KeyError:
            _switch_id = switch_id
        self.switch_id = _switch_id
    def factory(*args_, **kwargs_):
        if LocalLinkConnection.subclass:
            return LocalLinkConnection.subclass(*args_, **kwargs_)
        else:
            return LocalLinkConnection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_switch_info(self): return self.switch_info
    def set_switch_info(self, switch_info): self.switch_info = switch_info
    def get_port_index(self): return self.port_index
    def set_port_index(self, port_index): self.port_index = port_index
    def get_port_id(self): return self.port_id
    def set_port_id(self, port_id): self.port_id = port_id
    def get_switch_id(self): return self.switch_id
    def set_switch_id(self, switch_id): self.switch_id = switch_id
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.switch_info == other.switch_info and
                    self.port_index == other.port_index and
                    self.port_id == other.port_id and
                    self.switch_id == other.switch_id)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.switch_info if self.switch_info is not None else -7985492147856592190,
                     self.port_index if self.port_index is not None else -7985492147856592190,
                     self.port_id if self.port_id is not None else -7985492147856592190,
                     self.switch_id if self.switch_id is not None else -7985492147856592190))

    def __repr__(self):
        return ("switch_info = " + str(self.switch_info) + ", " +
                "port_index = " + str(self.port_index) + ", " +
                "port_id = " + str(self.port_id) + ", " +
                "switch_id = " + str(self.switch_id))

    def copy(self):
        cp = LocalLinkConnection()
        if self.switch_info is not None:
            cp.switch_info = self.switch_info
        if self.port_index is not None:
            cp.port_index = self.port_index
        if self.port_id is not None:
            cp.port_id = self.port_id
        if self.switch_id is not None:
            cp.switch_id = self.switch_id
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_switch_info (obj.populate_string ("switch_info"))
        obj.set_port_index (obj.populate_string ("port_index"))
        obj.set_port_id (obj.populate_string ("port_id"))
        obj.set_switch_id (obj.populate_string ("switch_id"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='LocalLinkConnection', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LocalLinkConnection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LocalLinkConnection'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LocalLinkConnection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.switch_info is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sswitch-info>%s</%sswitch-info>%s' % (namespace_, self.gds_format_string(quote_xml(self.switch_info).encode(ExternalEncoding), input_name='switch-info'), namespace_, eol_))
        if self.port_index is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sport-index>%s</%sport-index>%s' % (namespace_, self.gds_format_string(quote_xml(self.port_index).encode(ExternalEncoding), input_name='port-index'), namespace_, eol_))
        if self.port_id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sport-id>%s</%sport-id>%s' % (namespace_, self.gds_format_string(quote_xml(self.port_id).encode(ExternalEncoding), input_name='port-id'), namespace_, eol_))
        if self.switch_id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sswitch-id>%s</%sswitch-id>%s' % (namespace_, self.gds_format_string(quote_xml(self.switch_id).encode(ExternalEncoding), input_name='switch-id'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.switch_info is not None or
            self.port_index is not None or
            self.port_id is not None or
            self.switch_id is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LocalLinkConnection'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.switch_info is not None:
            showIndent(outfile, level)
            outfile.write('switch_info=%s,\n' % quote_python(self.switch_info).encode(ExternalEncoding))
        if self.port_index is not None:
            showIndent(outfile, level)
            outfile.write('port_index=%s,\n' % quote_python(self.port_index).encode(ExternalEncoding))
        if self.port_id is not None:
            showIndent(outfile, level)
            outfile.write('port_id=%s,\n' % quote_python(self.port_id).encode(ExternalEncoding))
        if self.switch_id is not None:
            showIndent(outfile, level)
            outfile.write('switch_id=%s,\n' % quote_python(self.switch_id).encode(ExternalEncoding))
    def exportDict(self, name_='LocalLinkConnection'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'switch-info':
            switch_info_ = child_.text
            switch_info_ = self.gds_validate_string(switch_info_, node, 'switch_info')
            self.switch_info = switch_info_
        elif nodeName_ == 'port-index':
            port_index_ = child_.text
            port_index_ = self.gds_validate_string(port_index_, node, 'port_index')
            self.port_index = port_index_
        elif nodeName_ == 'port-id':
            port_id_ = child_.text
            port_id_ = self.gds_validate_string(port_id_, node, 'port_id')
            self.port_id = port_id_
        elif nodeName_ == 'switch-id':
            switch_id_ = child_.text
            switch_id_ = self.gds_validate_string(switch_id_, node, 'switch_id')
            self.switch_id = switch_id_
# end class LocalLinkConnection


class ESXIHostInfo(GeneratedsSuper):
    """
    Attributes:
    * username
        Type:           str

        Description:
          username

    * datacenter
        Type:           str

        Description:
          datacenter in vCenter

    * esxi_name
        Type:           str

        Description:
          ESXI host name(ip)

    * cluster
        Type:           str

        Description:
          cluster in vCenter

    * mac
        Type:           str

        Description:
          mac address for contrailvm

    * datastore
        Type:           str

        Description:
          datastore in vCenter

    * password
        Type:           str

        Description:
          ESXI host password

    * vcenter_server
        Type:           str

        Description:
          vCenter server

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'username', u'datacenter', u'esxi_name', u'cluster', u'mac', u'datastore', u'password', u'vcenter_server']
    attr_field_type_vals = {u'username': {'restrictions': None, 'description': [u'username'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'datacenter': {'restrictions': None, 'description': [u'datacenter in vCenter'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'esxi_name': {'restrictions': None, 'description': [u'ESXI host name(ip)'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'cluster': {'restrictions': None, 'description': [u'cluster in vCenter'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'mac': {'restrictions': None, 'description': [u'mac address for contrailvm'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'datastore': {'restrictions': None, 'description': [u'datastore in vCenter'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'password': {'restrictions': None, 'description': [u'ESXI host password'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'vcenter_server': {'restrictions': None, 'description': [u'vCenter server'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}}
    def __init__(self, username=None, datacenter=None, esxi_name=None, cluster=None, mac=None, datastore=None, password=None, vcenter_server=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _username = params_dict[u"username"]
        except KeyError:
            _username = username
        self.username = _username
        try:
            _datacenter = params_dict[u"datacenter"]
        except KeyError:
            _datacenter = datacenter
        self.datacenter = _datacenter
        try:
            _esxi_name = params_dict[u"esxi_name"]
        except KeyError:
            _esxi_name = esxi_name
        self.esxi_name = _esxi_name
        try:
            _cluster = params_dict[u"cluster"]
        except KeyError:
            _cluster = cluster
        self.cluster = _cluster
        try:
            _mac = params_dict[u"mac"]
        except KeyError:
            _mac = mac
        self.mac = _mac
        try:
            _datastore = params_dict[u"datastore"]
        except KeyError:
            _datastore = datastore
        self.datastore = _datastore
        try:
            _password = params_dict[u"password"]
        except KeyError:
            _password = password
        self.password = _password
        try:
            _vcenter_server = params_dict[u"vcenter_server"]
        except KeyError:
            _vcenter_server = vcenter_server
        self.vcenter_server = _vcenter_server
    def factory(*args_, **kwargs_):
        if ESXIHostInfo.subclass:
            return ESXIHostInfo.subclass(*args_, **kwargs_)
        else:
            return ESXIHostInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_username(self): return self.username
    def set_username(self, username): self.username = username
    def get_datacenter(self): return self.datacenter
    def set_datacenter(self, datacenter): self.datacenter = datacenter
    def get_esxi_name(self): return self.esxi_name
    def set_esxi_name(self, esxi_name): self.esxi_name = esxi_name
    def get_cluster(self): return self.cluster
    def set_cluster(self, cluster): self.cluster = cluster
    def get_mac(self): return self.mac
    def set_mac(self, mac): self.mac = mac
    def get_datastore(self): return self.datastore
    def set_datastore(self, datastore): self.datastore = datastore
    def get_password(self): return self.password
    def set_password(self, password): self.password = password
    def get_vcenter_server(self): return self.vcenter_server
    def set_vcenter_server(self, vcenter_server): self.vcenter_server = vcenter_server
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.username == other.username and
                    self.datacenter == other.datacenter and
                    self.esxi_name == other.esxi_name and
                    self.cluster == other.cluster and
                    self.mac == other.mac and
                    self.datastore == other.datastore and
                    self.password == other.password and
                    self.vcenter_server == other.vcenter_server)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.username if self.username is not None else -7985492147856592190,
                     self.datacenter if self.datacenter is not None else -7985492147856592190,
                     self.esxi_name if self.esxi_name is not None else -7985492147856592190,
                     self.cluster if self.cluster is not None else -7985492147856592190,
                     self.mac if self.mac is not None else -7985492147856592190,
                     self.datastore if self.datastore is not None else -7985492147856592190,
                     self.password if self.password is not None else -7985492147856592190,
                     self.vcenter_server if self.vcenter_server is not None else -7985492147856592190))

    def __repr__(self):
        return ("username = " + str(self.username) + ", " +
                "datacenter = " + str(self.datacenter) + ", " +
                "esxi_name = " + str(self.esxi_name) + ", " +
                "cluster = " + str(self.cluster) + ", " +
                "mac = " + str(self.mac) + ", " +
                "datastore = " + str(self.datastore) + ", " +
                "password = " + str(self.password) + ", " +
                "vcenter_server = " + str(self.vcenter_server))

    def copy(self):
        cp = ESXIHostInfo()
        if self.username is not None:
            cp.username = self.username
        if self.datacenter is not None:
            cp.datacenter = self.datacenter
        if self.esxi_name is not None:
            cp.esxi_name = self.esxi_name
        if self.cluster is not None:
            cp.cluster = self.cluster
        if self.mac is not None:
            cp.mac = self.mac
        if self.datastore is not None:
            cp.datastore = self.datastore
        if self.password is not None:
            cp.password = self.password
        if self.vcenter_server is not None:
            cp.vcenter_server = self.vcenter_server
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_username (obj.populate_string ("username"))
        obj.set_datacenter (obj.populate_string ("datacenter"))
        obj.set_esxi_name (obj.populate_string ("esxi_name"))
        obj.set_cluster (obj.populate_string ("cluster"))
        obj.set_mac (obj.populate_string ("mac"))
        obj.set_datastore (obj.populate_string ("datastore"))
        obj.set_password (obj.populate_string ("password"))
        obj.set_vcenter_server (obj.populate_string ("vcenter_server"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='ESXIHostInfo', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ESXIHostInfo')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ESXIHostInfo'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ESXIHostInfo', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.username is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%susername>%s</%susername>%s' % (namespace_, self.gds_format_string(quote_xml(self.username).encode(ExternalEncoding), input_name='username'), namespace_, eol_))
        if self.datacenter is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdatacenter>%s</%sdatacenter>%s' % (namespace_, self.gds_format_string(quote_xml(self.datacenter).encode(ExternalEncoding), input_name='datacenter'), namespace_, eol_))
        if self.esxi_name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sesxi-name>%s</%sesxi-name>%s' % (namespace_, self.gds_format_string(quote_xml(self.esxi_name).encode(ExternalEncoding), input_name='esxi-name'), namespace_, eol_))
        if self.cluster is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scluster>%s</%scluster>%s' % (namespace_, self.gds_format_string(quote_xml(self.cluster).encode(ExternalEncoding), input_name='cluster'), namespace_, eol_))
        if self.mac is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smac>%s</%smac>%s' % (namespace_, self.gds_format_string(quote_xml(self.mac).encode(ExternalEncoding), input_name='mac'), namespace_, eol_))
        if self.datastore is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdatastore>%s</%sdatastore>%s' % (namespace_, self.gds_format_string(quote_xml(self.datastore).encode(ExternalEncoding), input_name='datastore'), namespace_, eol_))
        if self.password is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spassword>%s</%spassword>%s' % (namespace_, self.gds_format_string(quote_xml(self.password).encode(ExternalEncoding), input_name='password'), namespace_, eol_))
        if self.vcenter_server is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svcenter-server>%s</%svcenter-server>%s' % (namespace_, self.gds_format_string(quote_xml(self.vcenter_server).encode(ExternalEncoding), input_name='vcenter-server'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.username is not None or
            self.datacenter is not None or
            self.esxi_name is not None or
            self.cluster is not None or
            self.mac is not None or
            self.datastore is not None or
            self.password is not None or
            self.vcenter_server is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ESXIHostInfo'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.username is not None:
            showIndent(outfile, level)
            outfile.write('username=%s,\n' % quote_python(self.username).encode(ExternalEncoding))
        if self.datacenter is not None:
            showIndent(outfile, level)
            outfile.write('datacenter=%s,\n' % quote_python(self.datacenter).encode(ExternalEncoding))
        if self.esxi_name is not None:
            showIndent(outfile, level)
            outfile.write('esxi_name=%s,\n' % quote_python(self.esxi_name).encode(ExternalEncoding))
        if self.cluster is not None:
            showIndent(outfile, level)
            outfile.write('cluster=%s,\n' % quote_python(self.cluster).encode(ExternalEncoding))
        if self.mac is not None:
            showIndent(outfile, level)
            outfile.write('mac=%s,\n' % quote_python(self.mac).encode(ExternalEncoding))
        if self.datastore is not None:
            showIndent(outfile, level)
            outfile.write('datastore=%s,\n' % quote_python(self.datastore).encode(ExternalEncoding))
        if self.password is not None:
            showIndent(outfile, level)
            outfile.write('password=%s,\n' % quote_python(self.password).encode(ExternalEncoding))
        if self.vcenter_server is not None:
            showIndent(outfile, level)
            outfile.write('vcenter_server=%s,\n' % quote_python(self.vcenter_server).encode(ExternalEncoding))
    def exportDict(self, name_='ESXIHostInfo'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'username':
            username_ = child_.text
            username_ = self.gds_validate_string(username_, node, 'username')
            self.username = username_
        elif nodeName_ == 'datacenter':
            datacenter_ = child_.text
            datacenter_ = self.gds_validate_string(datacenter_, node, 'datacenter')
            self.datacenter = datacenter_
        elif nodeName_ == 'esxi-name':
            esxi_name_ = child_.text
            esxi_name_ = self.gds_validate_string(esxi_name_, node, 'esxi_name')
            self.esxi_name = esxi_name_
        elif nodeName_ == 'cluster':
            cluster_ = child_.text
            cluster_ = self.gds_validate_string(cluster_, node, 'cluster')
            self.cluster = cluster_
        elif nodeName_ == 'mac':
            mac_ = child_.text
            mac_ = self.gds_validate_string(mac_, node, 'mac')
            self.mac = mac_
        elif nodeName_ == 'datastore':
            datastore_ = child_.text
            datastore_ = self.gds_validate_string(datastore_, node, 'datastore')
            self.datastore = datastore_
        elif nodeName_ == 'password':
            password_ = child_.text
            password_ = self.gds_validate_string(password_, node, 'password')
            self.password = password_
        elif nodeName_ == 'vcenter-server':
            vcenter_server_ = child_.text
            vcenter_server_ = self.gds_validate_string(vcenter_server_, node, 'vcenter_server')
            self.vcenter_server = vcenter_server_
# end class ESXIHostInfo


class DriverInfo(GeneratedsSuper):
    """
    Attributes:
    * ipmi_address
        Type:           str

        Description:
          IPMI address of the server to manage boot device and power management

    * deploy_ramdisk
        Type:           str

        Description:
          UUID of the deploy initrd/ramdisk

    * ipmi_password
        Type:           str

        Description:
          Password to access IPMI

    * ipmi_port
        Type:           str

        Description:
          Remote IPMI RMCP port

    * ipmi_username
        Type:           str

        Description:
          Username to access IPMI

    * deploy_kernel
        Type:           str

        Description:
          UUID of the deploy kernel

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'ipmi_address', u'deploy_ramdisk', u'ipmi_password', u'ipmi_port', u'ipmi_username', u'deploy_kernel']
    attr_field_type_vals = {u'ipmi_port': {'restrictions': None, 'description': [u'Remote IPMI RMCP port'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'ipmi_username': {'restrictions': None, 'description': [u'Username to access IPMI'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'deploy_kernel': {'restrictions': None, 'description': [u'UUID of the deploy kernel'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'ipmi_address': {'restrictions': None, 'description': [u'IPMI address of the server to manage boot device and power management'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'deploy_ramdisk': {'restrictions': None, 'description': [u'UUID of the deploy initrd/ramdisk'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'ipmi_password': {'restrictions': None, 'description': [u'Password to access IPMI'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}}
    def __init__(self, ipmi_address=None, deploy_ramdisk=None, ipmi_password=None, ipmi_port=None, ipmi_username=None, deploy_kernel=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _ipmi_address = params_dict[u"ipmi_address"]
        except KeyError:
            _ipmi_address = ipmi_address
        self.ipmi_address = _ipmi_address
        try:
            _deploy_ramdisk = params_dict[u"deploy_ramdisk"]
        except KeyError:
            _deploy_ramdisk = deploy_ramdisk
        self.deploy_ramdisk = _deploy_ramdisk
        try:
            _ipmi_password = params_dict[u"ipmi_password"]
        except KeyError:
            _ipmi_password = ipmi_password
        self.ipmi_password = _ipmi_password
        try:
            _ipmi_port = params_dict[u"ipmi_port"]
        except KeyError:
            _ipmi_port = ipmi_port
        self.ipmi_port = _ipmi_port
        try:
            _ipmi_username = params_dict[u"ipmi_username"]
        except KeyError:
            _ipmi_username = ipmi_username
        self.ipmi_username = _ipmi_username
        try:
            _deploy_kernel = params_dict[u"deploy_kernel"]
        except KeyError:
            _deploy_kernel = deploy_kernel
        self.deploy_kernel = _deploy_kernel
    def factory(*args_, **kwargs_):
        if DriverInfo.subclass:
            return DriverInfo.subclass(*args_, **kwargs_)
        else:
            return DriverInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ipmi_address(self): return self.ipmi_address
    def set_ipmi_address(self, ipmi_address): self.ipmi_address = ipmi_address
    def get_deploy_ramdisk(self): return self.deploy_ramdisk
    def set_deploy_ramdisk(self, deploy_ramdisk): self.deploy_ramdisk = deploy_ramdisk
    def get_ipmi_password(self): return self.ipmi_password
    def set_ipmi_password(self, ipmi_password): self.ipmi_password = ipmi_password
    def get_ipmi_port(self): return self.ipmi_port
    def set_ipmi_port(self, ipmi_port): self.ipmi_port = ipmi_port
    def get_ipmi_username(self): return self.ipmi_username
    def set_ipmi_username(self, ipmi_username): self.ipmi_username = ipmi_username
    def get_deploy_kernel(self): return self.deploy_kernel
    def set_deploy_kernel(self, deploy_kernel): self.deploy_kernel = deploy_kernel
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.ipmi_address == other.ipmi_address and
                    self.deploy_ramdisk == other.deploy_ramdisk and
                    self.ipmi_password == other.ipmi_password and
                    self.ipmi_port == other.ipmi_port and
                    self.ipmi_username == other.ipmi_username and
                    self.deploy_kernel == other.deploy_kernel)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.ipmi_address if self.ipmi_address is not None else -7985492147856592190,
                     self.deploy_ramdisk if self.deploy_ramdisk is not None else -7985492147856592190,
                     self.ipmi_password if self.ipmi_password is not None else -7985492147856592190,
                     self.ipmi_port if self.ipmi_port is not None else -7985492147856592190,
                     self.ipmi_username if self.ipmi_username is not None else -7985492147856592190,
                     self.deploy_kernel if self.deploy_kernel is not None else -7985492147856592190))

    def __repr__(self):
        return ("ipmi_address = " + str(self.ipmi_address) + ", " +
                "deploy_ramdisk = " + str(self.deploy_ramdisk) + ", " +
                "ipmi_password = " + str(self.ipmi_password) + ", " +
                "ipmi_port = " + str(self.ipmi_port) + ", " +
                "ipmi_username = " + str(self.ipmi_username) + ", " +
                "deploy_kernel = " + str(self.deploy_kernel))

    def copy(self):
        cp = DriverInfo()
        if self.ipmi_address is not None:
            cp.ipmi_address = self.ipmi_address
        if self.deploy_ramdisk is not None:
            cp.deploy_ramdisk = self.deploy_ramdisk
        if self.ipmi_password is not None:
            cp.ipmi_password = self.ipmi_password
        if self.ipmi_port is not None:
            cp.ipmi_port = self.ipmi_port
        if self.ipmi_username is not None:
            cp.ipmi_username = self.ipmi_username
        if self.deploy_kernel is not None:
            cp.deploy_kernel = self.deploy_kernel
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_ipmi_address (obj.populate_string ("ipmi_address"))
        obj.set_deploy_ramdisk (obj.populate_string ("deploy_ramdisk"))
        obj.set_ipmi_password (obj.populate_string ("ipmi_password"))
        obj.set_ipmi_port (obj.populate_string ("ipmi_port"))
        obj.set_ipmi_username (obj.populate_string ("ipmi_username"))
        obj.set_deploy_kernel (obj.populate_string ("deploy_kernel"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='DriverInfo', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DriverInfo')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DriverInfo'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DriverInfo', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ipmi_address is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sipmi-address>%s</%sipmi-address>%s' % (namespace_, self.gds_format_string(quote_xml(self.ipmi_address).encode(ExternalEncoding), input_name='ipmi-address'), namespace_, eol_))
        if self.deploy_ramdisk is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdeploy-ramdisk>%s</%sdeploy-ramdisk>%s' % (namespace_, self.gds_format_string(quote_xml(self.deploy_ramdisk).encode(ExternalEncoding), input_name='deploy-ramdisk'), namespace_, eol_))
        if self.ipmi_password is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sipmi-password>%s</%sipmi-password>%s' % (namespace_, self.gds_format_string(quote_xml(self.ipmi_password).encode(ExternalEncoding), input_name='ipmi-password'), namespace_, eol_))
        if self.ipmi_port is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sipmi-port>%s</%sipmi-port>%s' % (namespace_, self.gds_format_string(quote_xml(self.ipmi_port).encode(ExternalEncoding), input_name='ipmi-port'), namespace_, eol_))
        if self.ipmi_username is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sipmi-username>%s</%sipmi-username>%s' % (namespace_, self.gds_format_string(quote_xml(self.ipmi_username).encode(ExternalEncoding), input_name='ipmi-username'), namespace_, eol_))
        if self.deploy_kernel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdeploy-kernel>%s</%sdeploy-kernel>%s' % (namespace_, self.gds_format_string(quote_xml(self.deploy_kernel).encode(ExternalEncoding), input_name='deploy-kernel'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.ipmi_address is not None or
            self.deploy_ramdisk is not None or
            self.ipmi_password is not None or
            self.ipmi_port is not None or
            self.ipmi_username is not None or
            self.deploy_kernel is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DriverInfo'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ipmi_address is not None:
            showIndent(outfile, level)
            outfile.write('ipmi_address=%s,\n' % quote_python(self.ipmi_address).encode(ExternalEncoding))
        if self.deploy_ramdisk is not None:
            showIndent(outfile, level)
            outfile.write('deploy_ramdisk=%s,\n' % quote_python(self.deploy_ramdisk).encode(ExternalEncoding))
        if self.ipmi_password is not None:
            showIndent(outfile, level)
            outfile.write('ipmi_password=%s,\n' % quote_python(self.ipmi_password).encode(ExternalEncoding))
        if self.ipmi_port is not None:
            showIndent(outfile, level)
            outfile.write('ipmi_port=%s,\n' % quote_python(self.ipmi_port).encode(ExternalEncoding))
        if self.ipmi_username is not None:
            showIndent(outfile, level)
            outfile.write('ipmi_username=%s,\n' % quote_python(self.ipmi_username).encode(ExternalEncoding))
        if self.deploy_kernel is not None:
            showIndent(outfile, level)
            outfile.write('deploy_kernel=%s,\n' % quote_python(self.deploy_kernel).encode(ExternalEncoding))
    def exportDict(self, name_='DriverInfo'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ipmi-address':
            ipmi_address_ = child_.text
            ipmi_address_ = self.gds_validate_string(ipmi_address_, node, 'ipmi_address')
            self.ipmi_address = ipmi_address_
        elif nodeName_ == 'deploy-ramdisk':
            deploy_ramdisk_ = child_.text
            deploy_ramdisk_ = self.gds_validate_string(deploy_ramdisk_, node, 'deploy_ramdisk')
            self.deploy_ramdisk = deploy_ramdisk_
        elif nodeName_ == 'ipmi-password':
            ipmi_password_ = child_.text
            ipmi_password_ = self.gds_validate_string(ipmi_password_, node, 'ipmi_password')
            self.ipmi_password = ipmi_password_
        elif nodeName_ == 'ipmi-port':
            ipmi_port_ = child_.text
            ipmi_port_ = self.gds_validate_string(ipmi_port_, node, 'ipmi_port')
            self.ipmi_port = ipmi_port_
        elif nodeName_ == 'ipmi-username':
            ipmi_username_ = child_.text
            ipmi_username_ = self.gds_validate_string(ipmi_username_, node, 'ipmi_username')
            self.ipmi_username = ipmi_username_
        elif nodeName_ == 'deploy-kernel':
            deploy_kernel_ = child_.text
            deploy_kernel_ = self.gds_validate_string(deploy_kernel_, node, 'deploy_kernel')
            self.deploy_kernel = deploy_kernel_
# end class DriverInfo


class SriovInfo(GeneratedsSuper):
    """
    Attributes:
    * sriov_physical_interface
        Type:           str

        Description:
          SRIOV Physical Interface

    * sriov_vf
        Type:           int

        Description:
          SRIOV Virtual Function

    * sriov_physical_net
        Type:           str

        Description:
          SRIOV Physical Network

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'sriov_physical_interface', u'sriov_vf', u'sriov_physical_net']
    attr_field_type_vals = {u'sriov_physical_interface': {'restrictions': None, 'description': [u'SRIOV Physical Interface'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'sriov_vf': {'restrictions': None, 'description': [u'SRIOV Virtual Function'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'integer'}, u'sriov_physical_net': {'restrictions': None, 'description': [u'SRIOV Physical Network'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}}
    def __init__(self, sriov_physical_interface=None, sriov_vf=None, sriov_physical_net=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _sriov_physical_interface = params_dict[u"sriov_physical_interface"]
        except KeyError:
            _sriov_physical_interface = sriov_physical_interface
        self.sriov_physical_interface = _sriov_physical_interface
        try:
            _sriov_vf = params_dict[u"sriov_vf"]
        except KeyError:
            _sriov_vf = sriov_vf
        self.sriov_vf = _sriov_vf
        try:
            _sriov_physical_net = params_dict[u"sriov_physical_net"]
        except KeyError:
            _sriov_physical_net = sriov_physical_net
        self.sriov_physical_net = _sriov_physical_net
    def factory(*args_, **kwargs_):
        if SriovInfo.subclass:
            return SriovInfo.subclass(*args_, **kwargs_)
        else:
            return SriovInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_sriov_physical_interface(self): return self.sriov_physical_interface
    def set_sriov_physical_interface(self, sriov_physical_interface): self.sriov_physical_interface = sriov_physical_interface
    def get_sriov_vf(self): return self.sriov_vf
    def set_sriov_vf(self, sriov_vf): self.sriov_vf = sriov_vf
    def get_sriov_physical_net(self): return self.sriov_physical_net
    def set_sriov_physical_net(self, sriov_physical_net): self.sriov_physical_net = sriov_physical_net
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.sriov_physical_interface == other.sriov_physical_interface and
                    self.sriov_vf == other.sriov_vf and
                    self.sriov_physical_net == other.sriov_physical_net)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.sriov_physical_interface if self.sriov_physical_interface is not None else -7985492147856592190,
                     self.sriov_vf if self.sriov_vf is not None else -7985492147856592190,
                     self.sriov_physical_net if self.sriov_physical_net is not None else -7985492147856592190))

    def __repr__(self):
        return ("sriov_physical_interface = " + str(self.sriov_physical_interface) + ", " +
                "sriov_vf = " + str(self.sriov_vf) + ", " +
                "sriov_physical_net = " + str(self.sriov_physical_net))

    def copy(self):
        cp = SriovInfo()
        if self.sriov_physical_interface is not None:
            cp.sriov_physical_interface = self.sriov_physical_interface
        if self.sriov_vf is not None:
            cp.sriov_vf = self.sriov_vf
        if self.sriov_physical_net is not None:
            cp.sriov_physical_net = self.sriov_physical_net
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_sriov_physical_interface (obj.populate_string ("sriov_physical_interface"))
        obj.set_sriov_vf (obj.populate_integer ("sriov_vf"))
        obj.set_sriov_physical_net (obj.populate_string ("sriov_physical_net"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='SriovInfo', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SriovInfo')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SriovInfo'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SriovInfo', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.sriov_physical_interface is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssriov-physical-interface>%s</%ssriov-physical-interface>%s' % (namespace_, self.gds_format_string(quote_xml(self.sriov_physical_interface).encode(ExternalEncoding), input_name='sriov-physical-interface'), namespace_, eol_))
        if self.sriov_vf is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssriov-vf>%s</%ssriov-vf>%s' % (namespace_, self.gds_format_integer(self.sriov_vf, input_name='sriov-vf'), namespace_, eol_))
        if self.sriov_physical_net is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssriov-physical-net>%s</%ssriov-physical-net>%s' % (namespace_, self.gds_format_string(quote_xml(self.sriov_physical_net).encode(ExternalEncoding), input_name='sriov-physical-net'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.sriov_physical_interface is not None or
            self.sriov_vf is not None or
            self.sriov_physical_net is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SriovInfo'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.sriov_physical_interface is not None:
            showIndent(outfile, level)
            outfile.write('sriov_physical_interface=%s,\n' % quote_python(self.sriov_physical_interface).encode(ExternalEncoding))
        if self.sriov_vf is not None:
            showIndent(outfile, level)
            outfile.write('sriov_vf=%d,\n' % self.sriov_vf)
        if self.sriov_physical_net is not None:
            showIndent(outfile, level)
            outfile.write('sriov_physical_net=%s,\n' % quote_python(self.sriov_physical_net).encode(ExternalEncoding))
    def exportDict(self, name_='SriovInfo'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'sriov-physical-interface':
            sriov_physical_interface_ = child_.text
            sriov_physical_interface_ = self.gds_validate_string(sriov_physical_interface_, node, 'sriov_physical_interface')
            self.sriov_physical_interface = sriov_physical_interface_
        elif nodeName_ == 'sriov-vf':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'sriov_vf')
            self.sriov_vf = ival_
        elif nodeName_ == 'sriov-physical-net':
            sriov_physical_net_ = child_.text
            sriov_physical_net_ = self.gds_validate_string(sriov_physical_net_, node, 'sriov_physical_net')
            self.sriov_physical_net = sriov_physical_net_
# end class SriovInfo


class BaremetalPortGroupInfo(GeneratedsSuper):
    """
    Attributes:
    * standalone_ports_supported
        Type:           bool

        Description:
          Indicates whether ports that are members of this portgroup can be used as stand-

          alone ports.

    * node_uuid
        Type:           str

        Description:
          UUID of the parent node where this port is connected

    * properties
        Type:           :class:`.PortGroupProperties`

        Description:
          Key/value properties related to the port group's configuration.

    * address
        Type:           str

        Description:
          Mac Address of the NIC in Node

    * mode
        Type:           str

        Description:
          Mode of the port group

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'standalone_ports_supported', u'node_uuid', u'properties', u'address', u'mode']
    attr_field_type_vals = {u'standalone_ports_supported': {'restrictions': None, 'description': [u'Indicates whether ports that are members of this portgroup can be used as stand-alone ports.'], 'simple_type': u'xsd:boolean', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'boolean'}, u'mode': {'restrictions': None, 'description': [u'Mode of the port group'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'node_uuid': {'restrictions': None, 'description': [u'UUID of the parent node where this port is connected'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'properties': {'restrictions': None, 'description': [u"Key/value properties related to the port group's configuration."], 'simple_type': u'PortGroupProperties', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'PortGroupProperties'}, u'address': {'restrictions': None, 'description': [u'Mac Address of the NIC in Node'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}}
    def __init__(self, standalone_ports_supported=None, node_uuid=None, properties=None, address=None, mode=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _standalone_ports_supported = params_dict[u"standalone_ports_supported"]
        except KeyError:
            _standalone_ports_supported = standalone_ports_supported
        self.standalone_ports_supported = _standalone_ports_supported
        try:
            _node_uuid = params_dict[u"node_uuid"]
        except KeyError:
            _node_uuid = node_uuid
        self.node_uuid = _node_uuid
        try:
            _properties = params_dict[u"properties"]
        except KeyError:
            _properties = properties
        if isinstance(_properties, dict):
            obj = PortGroupProperties(params_dict=_properties)
            self.properties = obj
        else:
            self.properties = _properties
        try:
            _address = params_dict[u"address"]
        except KeyError:
            _address = address
        self.address = _address
        try:
            _mode = params_dict[u"mode"]
        except KeyError:
            _mode = mode
        self.mode = _mode
    def factory(*args_, **kwargs_):
        if BaremetalPortGroupInfo.subclass:
            return BaremetalPortGroupInfo.subclass(*args_, **kwargs_)
        else:
            return BaremetalPortGroupInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_standalone_ports_supported(self): return self.standalone_ports_supported
    def set_standalone_ports_supported(self, standalone_ports_supported): self.standalone_ports_supported = standalone_ports_supported
    def get_node_uuid(self): return self.node_uuid
    def set_node_uuid(self, node_uuid): self.node_uuid = node_uuid
    def get_properties(self): return self.properties
    def set_properties(self, properties): self.properties = properties
    def get_address(self): return self.address
    def set_address(self, address): self.address = address
    def get_mode(self): return self.mode
    def set_mode(self, mode): self.mode = mode
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.standalone_ports_supported == other.standalone_ports_supported and
                    self.node_uuid == other.node_uuid and
                    self.properties == other.properties and
                    self.address == other.address and
                    self.mode == other.mode)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.standalone_ports_supported if self.standalone_ports_supported is not None else -7985492147856592190,
                     self.node_uuid if self.node_uuid is not None else -7985492147856592190,
                     self.properties if self.properties is not None else -7985492147856592190,
                     self.address if self.address is not None else -7985492147856592190,
                     self.mode if self.mode is not None else -7985492147856592190))

    def __repr__(self):
        return ("standalone_ports_supported = " + str(self.standalone_ports_supported) + ", " +
                "node_uuid = " + str(self.node_uuid) + ", " +
                "properties = " + str(self.properties) + ", " +
                "address = " + str(self.address) + ", " +
                "mode = " + str(self.mode))

    def copy(self):
        cp = BaremetalPortGroupInfo()
        if self.standalone_ports_supported is not None:
            cp.standalone_ports_supported = self.standalone_ports_supported
        if self.node_uuid is not None:
            cp.node_uuid = self.node_uuid
        if self.properties is not None:
            cp.properties = self.properties.copy()
        if self.address is not None:
            cp.address = self.address
        if self.mode is not None:
            cp.mode = self.mode
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_standalone_ports_supported (obj.populate_boolean ("standalone_ports_supported"))
        obj.set_node_uuid (obj.populate_string ("node_uuid"))
        obj.set_properties (PortGroupProperties.populate ())
        obj.set_address (obj.populate_string ("address"))
        obj.set_mode (obj.populate_string ("mode"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='BaremetalPortGroupInfo', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BaremetalPortGroupInfo')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BaremetalPortGroupInfo'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='BaremetalPortGroupInfo', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.standalone_ports_supported is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstandalone-ports-supported>%s</%sstandalone-ports-supported>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.standalone_ports_supported)), input_name='standalone-ports-supported'), namespace_, eol_))
        if self.node_uuid is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snode-uuid>%s</%snode-uuid>%s' % (namespace_, self.gds_format_string(quote_xml(self.node_uuid).encode(ExternalEncoding), input_name='node-uuid'), namespace_, eol_))
        if self.properties is not None:
            self.properties.export_xml(outfile, level, namespace_, name_='properties', pretty_print=pretty_print)
        if self.address is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saddress>%s</%saddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.address).encode(ExternalEncoding), input_name='address'), namespace_, eol_))
        if self.mode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smode>%s</%smode>%s' % (namespace_, self.gds_format_string(quote_xml(self.mode).encode(ExternalEncoding), input_name='mode'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.standalone_ports_supported is not None or
            self.node_uuid is not None or
            self.properties is not None or
            self.address is not None or
            self.mode is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BaremetalPortGroupInfo'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.standalone_ports_supported is not None:
            showIndent(outfile, level)
            outfile.write('standalone_ports_supported=%s,\n' % self.standalone_ports_supported)
        if self.node_uuid is not None:
            showIndent(outfile, level)
            outfile.write('node_uuid=%s,\n' % quote_python(self.node_uuid).encode(ExternalEncoding))
        if self.properties is not None:
            showIndent(outfile, level)
            outfile.write('properties=model_.PortGroupProperties(\n')
            self.properties.exportLiteral(outfile, level, name_='properties')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.address is not None:
            showIndent(outfile, level)
            outfile.write('address=%s,\n' % quote_python(self.address).encode(ExternalEncoding))
        if self.mode is not None:
            showIndent(outfile, level)
            outfile.write('mode=%s,\n' % quote_python(self.mode).encode(ExternalEncoding))
    def exportDict(self, name_='BaremetalPortGroupInfo'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'standalone-ports-supported':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'standalone_ports_supported')
            self.standalone_ports_supported = ival_
        elif nodeName_ == 'node-uuid':
            node_uuid_ = child_.text
            node_uuid_ = self.gds_validate_string(node_uuid_, node, 'node_uuid')
            self.node_uuid = node_uuid_
        elif nodeName_ == 'properties':
            obj_ = PortGroupProperties.factory()
            obj_.build(child_)
            self.set_properties(obj_)
        elif nodeName_ == 'address':
            address_ = child_.text
            address_ = self.gds_validate_string(address_, node, 'address')
            self.address = address_
        elif nodeName_ == 'mode':
            mode_ = child_.text
            mode_ = self.gds_validate_string(mode_, node, 'mode')
            self.mode = mode_
# end class BaremetalPortGroupInfo


class DpdkInfo(GeneratedsSuper):
    """
    Attributes:
    * cpu_core_mask
        Type:           str

        Description:
          CPU Core Mask

    * dpdk_uio_driver
        Type:           str

        Description:
          UIO Driver

    * huge_pages
        Type:           int

        Description:
          Hugepages Size

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'cpu_core_mask', u'dpdk_uio_driver', u'huge_pages']
    attr_field_type_vals = {u'cpu_core_mask': {'restrictions': None, 'description': [u'CPU Core Mask'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'dpdk_uio_driver': {'restrictions': None, 'description': [u'UIO Driver'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'huge_pages': {'restrictions': None, 'description': [u'Hugepages Size'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'integer'}}
    def __init__(self, cpu_core_mask=None, dpdk_uio_driver=None, huge_pages=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _cpu_core_mask = params_dict[u"cpu_core_mask"]
        except KeyError:
            _cpu_core_mask = cpu_core_mask
        self.cpu_core_mask = _cpu_core_mask
        try:
            _dpdk_uio_driver = params_dict[u"dpdk_uio_driver"]
        except KeyError:
            _dpdk_uio_driver = dpdk_uio_driver
        self.dpdk_uio_driver = _dpdk_uio_driver
        try:
            _huge_pages = params_dict[u"huge_pages"]
        except KeyError:
            _huge_pages = huge_pages
        self.huge_pages = _huge_pages
    def factory(*args_, **kwargs_):
        if DpdkInfo.subclass:
            return DpdkInfo.subclass(*args_, **kwargs_)
        else:
            return DpdkInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cpu_core_mask(self): return self.cpu_core_mask
    def set_cpu_core_mask(self, cpu_core_mask): self.cpu_core_mask = cpu_core_mask
    def get_dpdk_uio_driver(self): return self.dpdk_uio_driver
    def set_dpdk_uio_driver(self, dpdk_uio_driver): self.dpdk_uio_driver = dpdk_uio_driver
    def get_huge_pages(self): return self.huge_pages
    def set_huge_pages(self, huge_pages): self.huge_pages = huge_pages
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.cpu_core_mask == other.cpu_core_mask and
                    self.dpdk_uio_driver == other.dpdk_uio_driver and
                    self.huge_pages == other.huge_pages)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.cpu_core_mask if self.cpu_core_mask is not None else -7985492147856592190,
                     self.dpdk_uio_driver if self.dpdk_uio_driver is not None else -7985492147856592190,
                     self.huge_pages if self.huge_pages is not None else -7985492147856592190))

    def __repr__(self):
        return ("cpu_core_mask = " + str(self.cpu_core_mask) + ", " +
                "dpdk_uio_driver = " + str(self.dpdk_uio_driver) + ", " +
                "huge_pages = " + str(self.huge_pages))

    def copy(self):
        cp = DpdkInfo()
        if self.cpu_core_mask is not None:
            cp.cpu_core_mask = self.cpu_core_mask
        if self.dpdk_uio_driver is not None:
            cp.dpdk_uio_driver = self.dpdk_uio_driver
        if self.huge_pages is not None:
            cp.huge_pages = self.huge_pages
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_cpu_core_mask (obj.populate_string ("cpu_core_mask"))
        obj.set_dpdk_uio_driver (obj.populate_string ("dpdk_uio_driver"))
        obj.set_huge_pages (obj.populate_integer ("huge_pages"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='DpdkInfo', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DpdkInfo')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DpdkInfo'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DpdkInfo', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cpu_core_mask is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scpu-core-mask>%s</%scpu-core-mask>%s' % (namespace_, self.gds_format_string(quote_xml(self.cpu_core_mask).encode(ExternalEncoding), input_name='cpu-core-mask'), namespace_, eol_))
        if self.dpdk_uio_driver is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdpdk-uio-driver>%s</%sdpdk-uio-driver>%s' % (namespace_, self.gds_format_string(quote_xml(self.dpdk_uio_driver).encode(ExternalEncoding), input_name='dpdk-uio-driver'), namespace_, eol_))
        if self.huge_pages is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shuge-pages>%s</%shuge-pages>%s' % (namespace_, self.gds_format_integer(self.huge_pages, input_name='huge-pages'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.cpu_core_mask is not None or
            self.dpdk_uio_driver is not None or
            self.huge_pages is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DpdkInfo'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.cpu_core_mask is not None:
            showIndent(outfile, level)
            outfile.write('cpu_core_mask=%s,\n' % quote_python(self.cpu_core_mask).encode(ExternalEncoding))
        if self.dpdk_uio_driver is not None:
            showIndent(outfile, level)
            outfile.write('dpdk_uio_driver=%s,\n' % quote_python(self.dpdk_uio_driver).encode(ExternalEncoding))
        if self.huge_pages is not None:
            showIndent(outfile, level)
            outfile.write('huge_pages=%d,\n' % self.huge_pages)
    def exportDict(self, name_='DpdkInfo'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cpu-core-mask':
            cpu_core_mask_ = child_.text
            cpu_core_mask_ = self.gds_validate_string(cpu_core_mask_, node, 'cpu_core_mask')
            self.cpu_core_mask = cpu_core_mask_
        elif nodeName_ == 'dpdk-uio-driver':
            dpdk_uio_driver_ = child_.text
            dpdk_uio_driver_ = self.gds_validate_string(dpdk_uio_driver_, node, 'dpdk_uio_driver')
            self.dpdk_uio_driver = dpdk_uio_driver_
        elif nodeName_ == 'huge-pages':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'huge_pages')
            self.huge_pages = ival_
# end class DpdkInfo


class BaremetalServerInfo(GeneratedsSuper):
    """
    Attributes:
    * network_interface
        Type:           str

        Description:
          Networking interface

    * driver
        Type:           str

        Description:
          IPMI driver

    * properties
        Type:           :class:`.BaremetalProperties`

        Description:
          Details of baremetal hardware for scheduler

    * driver_info
        Type:           :class:`.DriverInfo`

        Description:
          Details of the driver for power management

    * name
        Type:           str

        Description:
          Name of the Baremetal server

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'network_interface', u'driver', u'properties', u'driver_info', u'name']
    attr_field_type_vals = {u'name': {'restrictions': None, 'description': [u'Name of the Baremetal server'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'driver': {'restrictions': None, 'description': [u'IPMI driver'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'properties': {'restrictions': None, 'description': [u'Details of baremetal hardware for scheduler'], 'simple_type': u'BaremetalProperties', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'BaremetalProperties'}, u'driver_info': {'restrictions': None, 'description': [u'Details of the driver for power management'], 'simple_type': u'DriverInfo', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'DriverInfo'}, u'network_interface': {'restrictions': None, 'description': [u'Networking interface'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}}
    def __init__(self, network_interface=None, driver=None, properties=None, driver_info=None, name=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _network_interface = params_dict[u"network_interface"]
        except KeyError:
            _network_interface = network_interface
        self.network_interface = _network_interface
        try:
            _driver = params_dict[u"driver"]
        except KeyError:
            _driver = driver
        self.driver = _driver
        try:
            _properties = params_dict[u"properties"]
        except KeyError:
            _properties = properties
        if isinstance(_properties, dict):
            obj = BaremetalProperties(params_dict=_properties)
            self.properties = obj
        else:
            self.properties = _properties
        try:
            _driver_info = params_dict[u"driver_info"]
        except KeyError:
            _driver_info = driver_info
        if isinstance(_driver_info, dict):
            obj = DriverInfo(params_dict=_driver_info)
            self.driver_info = obj
        else:
            self.driver_info = _driver_info
        try:
            _name = params_dict[u"name"]
        except KeyError:
            _name = name
        self.name = _name
    def factory(*args_, **kwargs_):
        if BaremetalServerInfo.subclass:
            return BaremetalServerInfo.subclass(*args_, **kwargs_)
        else:
            return BaremetalServerInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_network_interface(self): return self.network_interface
    def set_network_interface(self, network_interface): self.network_interface = network_interface
    def get_driver(self): return self.driver
    def set_driver(self, driver): self.driver = driver
    def get_properties(self): return self.properties
    def set_properties(self, properties): self.properties = properties
    def get_driver_info(self): return self.driver_info
    def set_driver_info(self, driver_info): self.driver_info = driver_info
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.network_interface == other.network_interface and
                    self.driver == other.driver and
                    self.properties == other.properties and
                    self.driver_info == other.driver_info and
                    self.name == other.name)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.network_interface if self.network_interface is not None else -7985492147856592190,
                     self.driver if self.driver is not None else -7985492147856592190,
                     self.properties if self.properties is not None else -7985492147856592190,
                     self.driver_info if self.driver_info is not None else -7985492147856592190,
                     self.name if self.name is not None else -7985492147856592190))

    def __repr__(self):
        return ("network_interface = " + str(self.network_interface) + ", " +
                "driver = " + str(self.driver) + ", " +
                "properties = " + str(self.properties) + ", " +
                "driver_info = " + str(self.driver_info) + ", " +
                "name = " + str(self.name))

    def copy(self):
        cp = BaremetalServerInfo()
        if self.network_interface is not None:
            cp.network_interface = self.network_interface
        if self.driver is not None:
            cp.driver = self.driver
        if self.properties is not None:
            cp.properties = self.properties.copy()
        if self.driver_info is not None:
            cp.driver_info = self.driver_info.copy()
        if self.name is not None:
            cp.name = self.name
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_network_interface (obj.populate_string ("network_interface"))
        obj.set_driver (obj.populate_string ("driver"))
        obj.set_properties (BaremetalProperties.populate ())
        obj.set_driver_info (DriverInfo.populate ())
        obj.set_name (obj.populate_string ("name"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='BaremetalServerInfo', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BaremetalServerInfo')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BaremetalServerInfo'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='BaremetalServerInfo', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.network_interface is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snetwork-interface>%s</%snetwork-interface>%s' % (namespace_, self.gds_format_string(quote_xml(self.network_interface).encode(ExternalEncoding), input_name='network-interface'), namespace_, eol_))
        if self.driver is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdriver>%s</%sdriver>%s' % (namespace_, self.gds_format_string(quote_xml(self.driver).encode(ExternalEncoding), input_name='driver'), namespace_, eol_))
        if self.properties is not None:
            self.properties.export_xml(outfile, level, namespace_, name_='properties', pretty_print=pretty_print)
        if self.driver_info is not None:
            self.driver_info.export_xml(outfile, level, namespace_, name_='driver-info', pretty_print=pretty_print)
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.network_interface is not None or
            self.driver is not None or
            self.properties is not None or
            self.driver_info is not None or
            self.name is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BaremetalServerInfo'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.network_interface is not None:
            showIndent(outfile, level)
            outfile.write('network_interface=%s,\n' % quote_python(self.network_interface).encode(ExternalEncoding))
        if self.driver is not None:
            showIndent(outfile, level)
            outfile.write('driver=%s,\n' % quote_python(self.driver).encode(ExternalEncoding))
        if self.properties is not None:
            showIndent(outfile, level)
            outfile.write('properties=model_.BaremetalProperties(\n')
            self.properties.exportLiteral(outfile, level, name_='properties')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.driver_info is not None:
            showIndent(outfile, level)
            outfile.write('driver_info=model_.DriverInfo(\n')
            self.driver_info.exportLiteral(outfile, level, name_='driver_info')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
    def exportDict(self, name_='BaremetalServerInfo'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'network-interface':
            network_interface_ = child_.text
            network_interface_ = self.gds_validate_string(network_interface_, node, 'network_interface')
            self.network_interface = network_interface_
        elif nodeName_ == 'driver':
            driver_ = child_.text
            driver_ = self.gds_validate_string(driver_, node, 'driver')
            self.driver = driver_
        elif nodeName_ == 'properties':
            obj_ = BaremetalProperties.factory()
            obj_.build(child_)
            self.set_properties(obj_)
        elif nodeName_ == 'driver-info':
            obj_ = DriverInfo.factory()
            obj_.build(child_)
            self.set_driver_info(obj_)
        elif nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
# end class BaremetalServerInfo


class ServiceVirtualNetworkType(GeneratedsSuper):
    """
    Attributes:
    * virtual_network_type
        Type:           str, *one-of* xsd:string

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'virtual_network_type']
    attr_field_type_vals = {u'virtual_network_type': {'restrictions': [], 'description': [], 'simple_type': u'ServiceInterfaceType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': None, 'attr_type': u'string'}}
    def __init__(self, virtual_network_type=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _virtual_network_type = params_dict[u"virtual_network_type"]
        except KeyError:
            _virtual_network_type = virtual_network_type
        self.virtual_network_type = _virtual_network_type
    def factory(*args_, **kwargs_):
        if ServiceVirtualNetworkType.subclass:
            return ServiceVirtualNetworkType.subclass(*args_, **kwargs_)
        else:
            return ServiceVirtualNetworkType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_virtual_network_type(self): return self.virtual_network_type
    def set_virtual_network_type(self, virtual_network_type): self.virtual_network_type = virtual_network_type
    def validate_ServiceInterfaceType(self, value):
        # Validate type ServiceInterfaceType, a restriction on xsd:string.
        pass
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.virtual_network_type == other.virtual_network_type)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.virtual_network_type if self.virtual_network_type is not None else -7985492147856592190))

    def __repr__(self):
        return ("virtual_network_type = " + str(self.virtual_network_type))

    def copy(self):
        cp = ServiceVirtualNetworkType()
        if self.virtual_network_type is not None:
            cp.virtual_network_type = self.virtual_network_type
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_virtual_network_type (obj.populate_string ("virtual_network_type"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='ServiceVirtualNetworkType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ServiceVirtualNetworkType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ServiceVirtualNetworkType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ServiceVirtualNetworkType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.virtual_network_type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svirtual-network-type>%s</%svirtual-network-type>%s' % (namespace_, self.gds_format_string(quote_xml(self.virtual_network_type).encode(ExternalEncoding), input_name='virtual-network-type'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.virtual_network_type is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ServiceVirtualNetworkType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.virtual_network_type is not None:
            showIndent(outfile, level)
            outfile.write('virtual_network_type=%s,\n' % quote_python(self.virtual_network_type).encode(ExternalEncoding))
    def exportDict(self, name_='ServiceVirtualNetworkType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'virtual-network-type':
            virtual_network_type_ = child_.text
            virtual_network_type_ = self.gds_validate_string(virtual_network_type_, node, 'virtual_network_type')
            self.virtual_network_type = virtual_network_type_
            self.validate_ServiceInterfaceType(self.virtual_network_type)    # validate type ServiceInterfaceType
# end class ServiceVirtualNetworkType


class RouteListType(GeneratedsSuper):
    """
    Attributes:
    * route
        Type:           str

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'route']
    attr_field_type_vals = {u'route': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': True, 'required': None, 'attr_type': u'string'}}
    def __init__(self, route=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _route = params_dict[u"route"]
        except KeyError:
            _route = route
        if not _route:
            self.route = []
        else:
            self.route = _route
    def factory(*args_, **kwargs_):
        if RouteListType.subclass:
            return RouteListType.subclass(*args_, **kwargs_)
        else:
            return RouteListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_route(self): return self.route
    def set_route(self, route): self.route = route
    def add_route(self, value): self.route.append(value)
    def insert_route(self, index, value): self.route[index] = value
    def delete_route(self, value): self.route.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.route == other.route)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.route or [])))

    def __repr__(self):
        return ("route = " + str(self.route))

    def copy(self):
        cp = RouteListType()
        if self.route is not None:
            cp.route = list(self.route)
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_route ([obj.populate_string ("route")])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='RouteListType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RouteListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RouteListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RouteListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for route_ in self.route:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sroute>%s</%sroute>%s' % (namespace_, self.gds_format_string(quote_xml(route_).encode(ExternalEncoding), input_name='route'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.route
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RouteListType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('route=[\n')
        level += 1
        for route_ in self.route:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(route_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='RouteListType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'route':
            route_ = child_.text
            route_ = self.gds_validate_string(route_, node, 'route')
            self.route.append(route_)
# end class RouteListType


class RoutingPolicyType(GeneratedsSuper):
    """
    Attributes:
    * sequence
        Type:           str, *one-of* xsd:string

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'sequence']
    attr_field_type_vals = {u'sequence': {'restrictions': [], 'description': [], 'simple_type': u'SequenceNumberType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': None, 'attr_type': u'string'}}
    def __init__(self, sequence=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _sequence = params_dict[u"sequence"]
        except KeyError:
            _sequence = sequence
        self.sequence = _sequence
    def factory(*args_, **kwargs_):
        if RoutingPolicyType.subclass:
            return RoutingPolicyType.subclass(*args_, **kwargs_)
        else:
            return RoutingPolicyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_sequence(self): return self.sequence
    def set_sequence(self, sequence): self.sequence = sequence
    def validate_SequenceNumberType(self, value):
        # Validate type SequenceNumberType, a restriction on xsd:string.
        pass
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.sequence == other.sequence)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.sequence if self.sequence is not None else -7985492147856592190))

    def __repr__(self):
        return ("sequence = " + str(self.sequence))

    def copy(self):
        cp = RoutingPolicyType()
        if self.sequence is not None:
            cp.sequence = self.sequence
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_sequence (obj.populate_string ("sequence"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='RoutingPolicyType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RoutingPolicyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RoutingPolicyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RoutingPolicyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.sequence is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssequence>%s</%ssequence>%s' % (namespace_, self.gds_format_string(quote_xml(self.sequence).encode(ExternalEncoding), input_name='sequence'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.sequence is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RoutingPolicyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.sequence is not None:
            showIndent(outfile, level)
            outfile.write('sequence=%s,\n' % quote_python(self.sequence).encode(ExternalEncoding))
    def exportDict(self, name_='RoutingPolicyType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'sequence':
            sequence_ = child_.text
            sequence_ = self.gds_validate_string(sequence_, node, 'sequence')
            self.sequence = sequence_
            self.validate_SequenceNumberType(self.sequence)    # validate type SequenceNumberType
# end class RoutingPolicyType


class BgpRouterParams(GeneratedsSuper):
    """
    Attributes:
    * admin_down
        Type:           bool

        Created By:           User (optional)

        Description:
          Administratively up or down.

    * vendor
        Type:           str

        Created By:           User (optional)

        Description:
          Vendor name for this BGP router, contrail, juniper or cisco etc.

    * cluster_id
        Type:           int

        Created By:           User (optional)

        Description:
          Cluster Id for this BGP router.

    * autonomous_system
        Type:           int

        Created By:           User (required)

        Description:
          Autonomous System number for this BGP router. Currently only 16 bit AS number is

          supported. For contrail control nodes this has to be equal to global AS number.

    * identifier
        Type:           str, *one-of* xsd:string

        Created By:           User (required)

        Description:
          Router ID for this BGP router. Dotted ip notation. For contrail control-nodes

          System will automatically assign value of address field.

    * address
        Type:           str, *one-of* xsd:string

        Created By:           User (required)

        Description:
          Ip address used to reach this BGP router by the system.

    * port
        Type:           int

        Created By:           User (optional)

        Description:
          TCP port number on which BGP protocol connections are accepted. default is based

          on standareds.

    * source_port
        Type:           int

        Description:
          For system internal use in BGPaaS service.

    * hold_time
        Type:           int, *within* [0, 65535]

        Created By:           User (optional)

        Description:
          BGP hold time in seconds [0-65535], Max time to detect liveliness to peer. Value

          0 will result in default value of 90 seconds

    * address_families
        Type:           :class:`.AddressFamilies`

        Created By:           User (optional)

        Description:
          BGP address families supported by BGP router

    * auth_data
        Type:           :class:`.AuthenticationData`

        Created By:           User (optional)

        Description:
          Authentication related configuration like type, keys etc.

    * local_autonomous_system
        Type:           int

        Created By:           User (optional)

        Description:
          BgpRouter specific Autonomous System number if different from global AS number.

          Typically used when clusters of control nodes in same contrail system are in

          different locations. Currently only 16 bit AS number is supported.

    * router_type
        Type:           str, *one-of* [u'control-node', u'external-control-node', u'router', u'bgpaas-server', u'bgpaas-client']

        Created By:           User (optional)

        Description:
          BGP router type.

    * gateway_address
        Type:           str, *one-of* xsd:string

        Created By:           User (optional)

        Description:
          gateway-address field is used only for router-type bgpaas-client. It holds the

          ipv4 gateway address for the ipv4 subnet from which the client has IP address.

          The value is used as nexthop when advertising routes to the client via bgp.

    * ipv6_gateway_address
        Type:           str, *one-of* xsd:string

        Created By:           User (optional)

        Description:
          The ipv6-gateway-address field is used only for router-type bgpaas-client. It

          holds ipv6 gateway address for ipv6 subnet from which the client has IP address.

          The value is used as nexthop when advertising routes to the client via bgp.

          Note that the ipv6-gateway-address can be a regular ipv6 address or a ipv4

          -mapped-ipv6 adddress.

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'admin_down', u'vendor', u'cluster_id', u'autonomous_system', u'identifier', u'address', u'port', u'source_port', u'hold_time', u'address_families', u'auth_data', u'local_autonomous_system', u'router_type', u'gateway_address', u'ipv6_gateway_address']
    attr_field_type_vals = {u'gateway_address': {'restrictions': [], 'description': [u'gateway-address field is used only for router-type bgpaas-client. It holds the ipv4 gateway address for the ipv4 subnet from which the client has IP address. The value is used as nexthop when advertising routes to the client via bgp.'], 'simple_type': u'IpAddress', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'vendor': {'restrictions': None, 'description': [u'Vendor name for this BGP router, contrail, juniper or cisco etc.'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'admin_down': {'restrictions': None, 'description': [u'Administratively up or down.'], 'simple_type': u'xsd:boolean', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'boolean'}, u'ipv6_gateway_address': {'restrictions': [], 'description': [u'The ipv6-gateway-address field is used only for router-type bgpaas-client. It holds ipv6 gateway address for ipv6 subnet from which the client has IP address. The value is used as nexthop when advertising routes to the client via bgp.  Note that the ipv6-gateway-address can be a regular ipv6 address or a ipv4-mapped-ipv6 adddress.'], 'simple_type': u'IpAddress', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'local_autonomous_system': {'restrictions': None, 'description': [u'BgpRouter specific Autonomous System number if different from global AS number. Typically used when clusters of control nodes in same contrail system are in different locations. Currently only 16 bit AS number is supported.'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'port': {'restrictions': None, 'description': [u'TCP port number on which BGP protocol connections are accepted. default is based on standareds.'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'auth_data': {'restrictions': None, 'description': [u'Authentication related configuration like type, keys etc.'], 'simple_type': u'AuthenticationData', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'AuthenticationData'}, u'cluster_id': {'restrictions': None, 'description': [u'Cluster Id for this BGP router.'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'address': {'restrictions': [], 'description': [u'Ip address used to reach this BGP router by the system.'], 'simple_type': u'IpAddress', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'true', 'attr_type': u'string'}, u'source_port': {'restrictions': None, 'description': [u'For system internal use in BGPaaS service.'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'system-only', 'attr_type': u'integer'}, u'router_type': {'restrictions': [u'control-node', u'external-control-node', u'router', u'bgpaas-server', u'bgpaas-client'], 'description': [u'BGP router type.'], 'simple_type': u'BgpRouterType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'identifier': {'restrictions': [], 'description': [u'Router ID for this BGP router. Dotted ip notation. For contrail control-nodes System will automatically assign value of address field.'], 'simple_type': u'IpAddress', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'true', 'attr_type': u'string'}, u'hold_time': {'restrictions': [0, 65535], 'description': [u'BGP hold time in seconds [0-65535], Max time to detect liveliness to peer. Value 0 will result in default value of 90 seconds'], 'simple_type': u'BgpHoldTime', 'is_complex': 0, 'restriction_type': 'range', 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'autonomous_system': {'restrictions': None, 'description': [u'Autonomous System number for this BGP router. Currently only 16 bit AS number is supported. For contrail control nodes this has to be equal to global AS number.'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'true', 'attr_type': u'integer'}, u'address_families': {'restrictions': None, 'description': [u'BGP address families supported by BGP router'], 'simple_type': u'AddressFamilies', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'AddressFamilies'}}
    def __init__(self, admin_down=False, vendor=None, cluster_id=None, autonomous_system=None, identifier=None, address=None, port=None, source_port=None, hold_time=0, address_families=None, auth_data=None, local_autonomous_system=None, router_type=None, gateway_address=None, ipv6_gateway_address=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _admin_down = params_dict[u"admin_down"]
        except KeyError:
            _admin_down = admin_down
        self.admin_down = _admin_down
        try:
            _vendor = params_dict[u"vendor"]
        except KeyError:
            _vendor = vendor
        self.vendor = _vendor
        try:
            _cluster_id = params_dict[u"cluster_id"]
        except KeyError:
            _cluster_id = cluster_id
        self.cluster_id = _cluster_id
        try:
            _autonomous_system = params_dict[u"autonomous_system"]
        except KeyError:
            _autonomous_system = autonomous_system
        self.autonomous_system = _autonomous_system
        try:
            _identifier = params_dict[u"identifier"]
        except KeyError:
            _identifier = identifier
        self.identifier = _identifier
        try:
            _address = params_dict[u"address"]
        except KeyError:
            _address = address
        self.address = _address
        try:
            _port = params_dict[u"port"]
        except KeyError:
            _port = port
        self.port = _port
        try:
            _source_port = params_dict[u"source_port"]
        except KeyError:
            _source_port = source_port
        self.source_port = _source_port
        try:
            _hold_time = params_dict[u"hold_time"]
        except KeyError:
            _hold_time = hold_time
        self.hold_time = _hold_time
        try:
            _address_families = params_dict[u"address_families"]
        except KeyError:
            _address_families = address_families
        if isinstance(_address_families, dict):
            obj = AddressFamilies(params_dict=_address_families)
            self.address_families = obj
        else:
            self.address_families = _address_families
        try:
            _auth_data = params_dict[u"auth_data"]
        except KeyError:
            _auth_data = auth_data
        if isinstance(_auth_data, dict):
            obj = AuthenticationData(params_dict=_auth_data)
            self.auth_data = obj
        else:
            self.auth_data = _auth_data
        try:
            _local_autonomous_system = params_dict[u"local_autonomous_system"]
        except KeyError:
            _local_autonomous_system = local_autonomous_system
        self.local_autonomous_system = _local_autonomous_system
        try:
            _router_type = params_dict[u"router_type"]
        except KeyError:
            _router_type = router_type
        self.router_type = _router_type
        try:
            _gateway_address = params_dict[u"gateway_address"]
        except KeyError:
            _gateway_address = gateway_address
        self.gateway_address = _gateway_address
        try:
            _ipv6_gateway_address = params_dict[u"ipv6_gateway_address"]
        except KeyError:
            _ipv6_gateway_address = ipv6_gateway_address
        self.ipv6_gateway_address = _ipv6_gateway_address
    def factory(*args_, **kwargs_):
        if BgpRouterParams.subclass:
            return BgpRouterParams.subclass(*args_, **kwargs_)
        else:
            return BgpRouterParams(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_admin_down(self): return self.admin_down
    def set_admin_down(self, admin_down): self.admin_down = admin_down
    def get_vendor(self): return self.vendor
    def set_vendor(self, vendor): self.vendor = vendor
    def get_cluster_id(self): return self.cluster_id
    def set_cluster_id(self, cluster_id): self.cluster_id = cluster_id
    def get_autonomous_system(self): return self.autonomous_system
    def set_autonomous_system(self, autonomous_system): self.autonomous_system = autonomous_system
    def get_identifier(self): return self.identifier
    def set_identifier(self, identifier): self.identifier = identifier
    def validate_IpAddress(self, value):
        # Validate type IpAddress, a restriction on xsd:string.
        pass
    def get_address(self): return self.address
    def set_address(self, address): self.address = address
    def get_port(self): return self.port
    def set_port(self, port): self.port = port
    def get_source_port(self): return self.source_port
    def set_source_port(self, source_port): self.source_port = source_port
    def get_hold_time(self): return self.hold_time
    def set_hold_time(self, hold_time): self.hold_time = hold_time
    def validate_BgpHoldTime(self, value):
        # Validate type BgpHoldTime, a restriction on xsd:integer.
        error = False
        if isinstance(value, list):
            v_int = list(map(int, value))
            v1, v2 = min(v_int), max(v_int)
        else:
            v1, v2 = int(value), int(value)
        error |= (v2 > 65535)
        if error:
            raise ValueError("BgpHoldTime must be in the range {'minimum': 0}-{'maximum': 65535}")
    def get_address_families(self): return self.address_families
    def set_address_families(self, address_families): self.address_families = address_families
    def get_auth_data(self): return self.auth_data
    def set_auth_data(self, auth_data): self.auth_data = auth_data
    def get_local_autonomous_system(self): return self.local_autonomous_system
    def set_local_autonomous_system(self, local_autonomous_system): self.local_autonomous_system = local_autonomous_system
    def get_router_type(self): return self.router_type
    def set_router_type(self, router_type): self.router_type = router_type
    def validate_BgpRouterType(self, value):
        # Validate type BgpRouterType, a restriction on xsd:string.
        error = False
        if isinstance(value, list):
            error = set(value) - set([u'control-node', u'external-control-node', u'router', u'bgpaas-server', u'bgpaas-client'])
        else:
            error = value not in [u'control-node', u'external-control-node', u'router', u'bgpaas-server', u'bgpaas-client']
        if error:
            raise ValueError("BgpRouterType must be one of [u'control-node', u'external-control-node', u'router', u'bgpaas-server', u'bgpaas-client']")
    def get_gateway_address(self): return self.gateway_address
    def set_gateway_address(self, gateway_address): self.gateway_address = gateway_address
    def get_ipv6_gateway_address(self): return self.ipv6_gateway_address
    def set_ipv6_gateway_address(self, ipv6_gateway_address): self.ipv6_gateway_address = ipv6_gateway_address
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.admin_down == other.admin_down and
                    self.vendor == other.vendor and
                    self.cluster_id == other.cluster_id and
                    self.autonomous_system == other.autonomous_system and
                    self.identifier == other.identifier and
                    self.address == other.address and
                    self.port == other.port and
                    self.source_port == other.source_port and
                    self.hold_time == other.hold_time and
                    self.address_families == other.address_families and
                    self.auth_data == other.auth_data and
                    self.local_autonomous_system == other.local_autonomous_system and
                    self.router_type == other.router_type and
                    self.gateway_address == other.gateway_address and
                    self.ipv6_gateway_address == other.ipv6_gateway_address)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.admin_down if self.admin_down is not None else -7985492147856592190,
                     self.vendor if self.vendor is not None else -7985492147856592190,
                     self.cluster_id if self.cluster_id is not None else -7985492147856592190,
                     self.autonomous_system if self.autonomous_system is not None else -7985492147856592190,
                     self.identifier if self.identifier is not None else -7985492147856592190,
                     self.address if self.address is not None else -7985492147856592190,
                     self.port if self.port is not None else -7985492147856592190,
                     self.source_port if self.source_port is not None else -7985492147856592190,
                     self.hold_time if self.hold_time is not None else -7985492147856592190,
                     self.address_families if self.address_families is not None else -7985492147856592190,
                     self.auth_data if self.auth_data is not None else -7985492147856592190,
                     self.local_autonomous_system if self.local_autonomous_system is not None else -7985492147856592190,
                     self.router_type if self.router_type is not None else -7985492147856592190,
                     self.gateway_address if self.gateway_address is not None else -7985492147856592190,
                     self.ipv6_gateway_address if self.ipv6_gateway_address is not None else -7985492147856592190))

    def __repr__(self):
        return ("admin_down = " + str(self.admin_down) + ", " +
                "vendor = " + str(self.vendor) + ", " +
                "cluster_id = " + str(self.cluster_id) + ", " +
                "autonomous_system = " + str(self.autonomous_system) + ", " +
                "identifier = " + str(self.identifier) + ", " +
                "address = " + str(self.address) + ", " +
                "port = " + str(self.port) + ", " +
                "source_port = " + str(self.source_port) + ", " +
                "hold_time = " + str(self.hold_time) + ", " +
                "address_families = " + str(self.address_families) + ", " +
                "auth_data = " + str(self.auth_data) + ", " +
                "local_autonomous_system = " + str(self.local_autonomous_system) + ", " +
                "router_type = " + str(self.router_type) + ", " +
                "gateway_address = " + str(self.gateway_address) + ", " +
                "ipv6_gateway_address = " + str(self.ipv6_gateway_address))

    def copy(self):
        cp = BgpRouterParams()
        if self.admin_down is not None:
            cp.admin_down = self.admin_down
        if self.vendor is not None:
            cp.vendor = self.vendor
        if self.cluster_id is not None:
            cp.cluster_id = self.cluster_id
        if self.autonomous_system is not None:
            cp.autonomous_system = self.autonomous_system
        if self.identifier is not None:
            cp.identifier = self.identifier
        if self.address is not None:
            cp.address = self.address
        if self.port is not None:
            cp.port = self.port
        if self.source_port is not None:
            cp.source_port = self.source_port
        if self.hold_time is not None:
            cp.hold_time = self.hold_time
        if self.address_families is not None:
            cp.address_families = self.address_families.copy()
        if self.auth_data is not None:
            cp.auth_data = self.auth_data.copy()
        if self.local_autonomous_system is not None:
            cp.local_autonomous_system = self.local_autonomous_system
        if self.router_type is not None:
            cp.router_type = self.router_type
        if self.gateway_address is not None:
            cp.gateway_address = self.gateway_address
        if self.ipv6_gateway_address is not None:
            cp.ipv6_gateway_address = self.ipv6_gateway_address
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_admin_down (obj.populate_boolean ("admin_down"))
        obj.set_vendor (obj.populate_string ("vendor"))
        obj.set_cluster_id (obj.populate_integer ("cluster_id"))
        obj.set_autonomous_system (obj.populate_integer ("autonomous_system"))
        obj.set_identifier (obj.populate_string ("identifier"))
        obj.set_address (obj.populate_string ("address"))
        obj.set_port (obj.populate_integer ("port"))
        obj.set_source_port (obj.populate_integer ("source_port"))
        obj.set_hold_time (obj.populate_integer ("hold_time"))
        obj.set_address_families (AddressFamilies.populate ())
        obj.set_auth_data (AuthenticationData.populate ())
        obj.set_local_autonomous_system (obj.populate_integer ("local_autonomous_system"))
        obj.set_router_type (obj.populate_string ("router_type"))
        obj.set_gateway_address (obj.populate_string ("gateway_address"))
        obj.set_ipv6_gateway_address (obj.populate_string ("ipv6_gateway_address"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='BgpRouterParams', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BgpRouterParams')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BgpRouterParams'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='BgpRouterParams', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.admin_down is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sadmin-down>%s</%sadmin-down>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.admin_down)), input_name='admin-down'), namespace_, eol_))
        if self.vendor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svendor>%s</%svendor>%s' % (namespace_, self.gds_format_string(quote_xml(self.vendor).encode(ExternalEncoding), input_name='vendor'), namespace_, eol_))
        if self.cluster_id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scluster-id>%s</%scluster-id>%s' % (namespace_, self.gds_format_integer(self.cluster_id, input_name='cluster-id'), namespace_, eol_))
        if self.autonomous_system is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sautonomous-system>%s</%sautonomous-system>%s' % (namespace_, self.gds_format_integer(self.autonomous_system, input_name='autonomous-system'), namespace_, eol_))
        if self.identifier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sidentifier>%s</%sidentifier>%s' % (namespace_, self.gds_format_string(quote_xml(self.identifier).encode(ExternalEncoding), input_name='identifier'), namespace_, eol_))
        if self.address is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saddress>%s</%saddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.address).encode(ExternalEncoding), input_name='address'), namespace_, eol_))
        if self.port is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sport>%s</%sport>%s' % (namespace_, self.gds_format_integer(self.port, input_name='port'), namespace_, eol_))
        if self.source_port is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssource-port>%s</%ssource-port>%s' % (namespace_, self.gds_format_integer(self.source_port, input_name='source-port'), namespace_, eol_))
        if self.hold_time is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shold-time>%s</%shold-time>%s' % (namespace_, self.gds_format_integer(self.hold_time, input_name='hold-time'), namespace_, eol_))
        if self.address_families is not None:
            self.address_families.export_xml(outfile, level, namespace_, name_='address-families', pretty_print=pretty_print)
        if self.auth_data is not None:
            self.auth_data.export_xml(outfile, level, namespace_, name_='auth-data', pretty_print=pretty_print)
        if self.local_autonomous_system is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slocal-autonomous-system>%s</%slocal-autonomous-system>%s' % (namespace_, self.gds_format_integer(self.local_autonomous_system, input_name='local-autonomous-system'), namespace_, eol_))
        if self.router_type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srouter-type>%s</%srouter-type>%s' % (namespace_, self.gds_format_string(quote_xml(self.router_type).encode(ExternalEncoding), input_name='router-type'), namespace_, eol_))
        if self.gateway_address is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgateway-address>%s</%sgateway-address>%s' % (namespace_, self.gds_format_string(quote_xml(self.gateway_address).encode(ExternalEncoding), input_name='gateway-address'), namespace_, eol_))
        if self.ipv6_gateway_address is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sipv6-gateway-address>%s</%sipv6-gateway-address>%s' % (namespace_, self.gds_format_string(quote_xml(self.ipv6_gateway_address).encode(ExternalEncoding), input_name='ipv6-gateway-address'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.admin_down is not None or
            self.vendor is not None or
            self.cluster_id is not None or
            self.autonomous_system is not None or
            self.identifier is not None or
            self.address is not None or
            self.port is not None or
            self.source_port is not None or
            self.hold_time is not None or
            self.address_families is not None or
            self.auth_data is not None or
            self.local_autonomous_system is not None or
            self.router_type is not None or
            self.gateway_address is not None or
            self.ipv6_gateway_address is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BgpRouterParams'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.admin_down is not None:
            showIndent(outfile, level)
            outfile.write('admin_down=%s,\n' % self.admin_down)
        if self.vendor is not None:
            showIndent(outfile, level)
            outfile.write('vendor=%s,\n' % quote_python(self.vendor).encode(ExternalEncoding))
        if self.cluster_id is not None:
            showIndent(outfile, level)
            outfile.write('cluster_id=%d,\n' % self.cluster_id)
        if self.autonomous_system is not None:
            showIndent(outfile, level)
            outfile.write('autonomous_system=%d,\n' % self.autonomous_system)
        if self.identifier is not None:
            showIndent(outfile, level)
            outfile.write('identifier=%s,\n' % quote_python(self.identifier).encode(ExternalEncoding))
        if self.address is not None:
            showIndent(outfile, level)
            outfile.write('address=%s,\n' % quote_python(self.address).encode(ExternalEncoding))
        if self.port is not None:
            showIndent(outfile, level)
            outfile.write('port=%d,\n' % self.port)
        if self.source_port is not None:
            showIndent(outfile, level)
            outfile.write('source_port=%d,\n' % self.source_port)
        if self.hold_time is not None:
            showIndent(outfile, level)
            outfile.write('hold_time=%d,\n' % self.hold_time)
        if self.address_families is not None:
            showIndent(outfile, level)
            outfile.write('address_families=model_.AddressFamilies(\n')
            self.address_families.exportLiteral(outfile, level, name_='address_families')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.auth_data is not None:
            showIndent(outfile, level)
            outfile.write('auth_data=model_.AuthenticationData(\n')
            self.auth_data.exportLiteral(outfile, level, name_='auth_data')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.local_autonomous_system is not None:
            showIndent(outfile, level)
            outfile.write('local_autonomous_system=%d,\n' % self.local_autonomous_system)
        if self.router_type is not None:
            showIndent(outfile, level)
            outfile.write('router_type=%s,\n' % quote_python(self.router_type).encode(ExternalEncoding))
        if self.gateway_address is not None:
            showIndent(outfile, level)
            outfile.write('gateway_address=%s,\n' % quote_python(self.gateway_address).encode(ExternalEncoding))
        if self.ipv6_gateway_address is not None:
            showIndent(outfile, level)
            outfile.write('ipv6_gateway_address=%s,\n' % quote_python(self.ipv6_gateway_address).encode(ExternalEncoding))
    def exportDict(self, name_='BgpRouterParams'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'admin-down':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'admin_down')
            self.admin_down = ival_
        elif nodeName_ == 'vendor':
            vendor_ = child_.text
            vendor_ = self.gds_validate_string(vendor_, node, 'vendor')
            self.vendor = vendor_
        elif nodeName_ == 'cluster-id':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'cluster_id')
            self.cluster_id = ival_
        elif nodeName_ == 'autonomous-system':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'autonomous_system')
            self.autonomous_system = ival_
        elif nodeName_ == 'identifier':
            identifier_ = child_.text
            identifier_ = self.gds_validate_string(identifier_, node, 'identifier')
            self.identifier = identifier_
            self.validate_IpAddress(self.identifier)    # validate type IpAddress
        elif nodeName_ == 'address':
            address_ = child_.text
            address_ = self.gds_validate_string(address_, node, 'address')
            self.address = address_
            self.validate_IpAddress(self.address)    # validate type IpAddress
        elif nodeName_ == 'port':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'port')
            self.port = ival_
        elif nodeName_ == 'source-port':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'source_port')
            self.source_port = ival_
        elif nodeName_ == 'hold-time':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'hold_time')
            self.hold_time = ival_
            self.validate_BgpHoldTime(self.hold_time)    # validate type BgpHoldTime
        elif nodeName_ == 'address-families':
            obj_ = AddressFamilies.factory()
            obj_.build(child_)
            self.set_address_families(obj_)
        elif nodeName_ == 'auth-data':
            obj_ = AuthenticationData.factory()
            obj_.build(child_)
            self.set_auth_data(obj_)
        elif nodeName_ == 'local-autonomous-system':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'local_autonomous_system')
            self.local_autonomous_system = ival_
        elif nodeName_ == 'router-type':
            router_type_ = child_.text
            router_type_ = self.gds_validate_string(router_type_, node, 'router_type')
            self.router_type = router_type_
            self.validate_BgpRouterType(self.router_type)    # validate type BgpRouterType
        elif nodeName_ == 'gateway-address':
            gateway_address_ = child_.text
            gateway_address_ = self.gds_validate_string(gateway_address_, node, 'gateway_address')
            self.gateway_address = gateway_address_
            self.validate_IpAddress(self.gateway_address)    # validate type IpAddress
        elif nodeName_ == 'ipv6-gateway-address':
            ipv6_gateway_address_ = child_.text
            ipv6_gateway_address_ = self.gds_validate_string(ipv6_gateway_address_, node, 'ipv6_gateway_address')
            self.ipv6_gateway_address = ipv6_gateway_address_
            self.validate_IpAddress(self.ipv6_gateway_address)    # validate type IpAddress
# end class BgpRouterParams


class BgpPeeringAttributes(GeneratedsSuper):
    """
    Attributes:
    * session
        Type:           :class:`.BgpSession`

        Created By:           User (required)

        Description:
          List of BGP sessions parameters. There can be multiple BGP sessions between two

          BGP routers. Currently only 1 session is supported.

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'session']
    attr_field_type_vals = {u'session': {'restrictions': None, 'description': [u'List of BGP sessions parameters. There can be multiple BGP sessions between two BGP routers. Currently only 1 session is supported.'], 'simple_type': u'BgpSession', 'is_complex': 1, 'restriction_type': None, 'is_array': True, 'required': u'true', 'attr_type': u'BgpSession'}}
    def __init__(self, session=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _session = params_dict[u"session"]
        except KeyError:
            _session = session
        if not _session:
            self.session = []
        else:
            if isinstance(_session[0], dict):
                objs = [BgpSession(params_dict=elem) for elem in _session]
                self.session = objs
            else:
                self.session = _session
    def factory(*args_, **kwargs_):
        if BgpPeeringAttributes.subclass:
            return BgpPeeringAttributes.subclass(*args_, **kwargs_)
        else:
            return BgpPeeringAttributes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_session(self): return self.session
    def set_session(self, session): self.session = session
    def add_session(self, value): self.session.append(value)
    def insert_session(self, index, value): self.session[index] = value
    def delete_session(self, value): self.session.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.session == other.session)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.session or [])))

    def __repr__(self):
        return ("session = " + str(self.session))

    def copy(self):
        cp = BgpPeeringAttributes()
        if self.session is not None:
            cp.session = [x.copy() for x in self.session]
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_session ([BgpSession.populate ()])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='BgpPeeringAttributes', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BgpPeeringAttributes')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BgpPeeringAttributes'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='BgpPeeringAttributes', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for session_ in self.session:
            if isinstance(session_, dict):
                session_ = BgpSession(**session_)
            session_.export_xml(outfile, level, namespace_, name_='session', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.session
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BgpPeeringAttributes'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('session=[\n')
        level += 1
        for session_ in self.session:
            showIndent(outfile, level)
            outfile.write('model_.BgpSession(\n')
            session_.exportLiteral(outfile, level, name_='BgpSession')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='BgpPeeringAttributes'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'session':
            obj_ = BgpSession.factory()
            obj_.build(child_)
            self.session.append(obj_)
# end class BgpPeeringAttributes


class BgpSession(GeneratedsSuper):
    """
    Attributes:
    * uuid
        Type:           str

        Created By:           User (required)

        Description:
          When multiple sessions are present, each session must have an unique id.

    * attributes
        Type:           :class:`.BgpSessionAttributes`

        Created By:           User (required)

        Description:
          There can be upto 3 instances BGP session attributes, representing configuration

          for both ends and common. Currently only 1 instance representing common

          attributes is supported.

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'uuid', u'attributes']
    attr_field_type_vals = {u'attributes': {'restrictions': None, 'description': [u'There can be upto 3 instances BGP session attributes, representing configuration for both ends and common. Currently only 1 instance representing common attributes is supported.'], 'simple_type': u'BgpSessionAttributes', 'is_complex': 1, 'restriction_type': None, 'is_array': True, 'required': u'true', 'attr_type': u'BgpSessionAttributes'}, u'uuid': {'restrictions': None, 'description': [u'When multiple sessions are present, each session must have an unique id.'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'true', 'attr_type': u'string'}}
    def __init__(self, uuid=None, attributes=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _uuid = params_dict[u"uuid"]
        except KeyError:
            _uuid = uuid
        self.uuid = _uuid
        try:
            _attributes = params_dict[u"attributes"]
        except KeyError:
            _attributes = attributes
        if not _attributes:
            self.attributes = []
        else:
            if isinstance(_attributes[0], dict):
                objs = [BgpSessionAttributes(params_dict=elem) for elem in _attributes]
                self.attributes = objs
            else:
                self.attributes = _attributes
    def factory(*args_, **kwargs_):
        if BgpSession.subclass:
            return BgpSession.subclass(*args_, **kwargs_)
        else:
            return BgpSession(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uuid(self): return self.uuid
    def set_uuid(self, uuid): self.uuid = uuid
    def get_attributes(self): return self.attributes
    def set_attributes(self, attributes): self.attributes = attributes
    def add_attributes(self, value): self.attributes.append(value)
    def insert_attributes(self, index, value): self.attributes[index] = value
    def delete_attributes(self, value): self.attributes.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.uuid == other.uuid and
                    self.attributes == other.attributes)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.uuid if self.uuid is not None else -7985492147856592190,
                     tuple(self.attributes or [])))

    def __repr__(self):
        return ("uuid = " + str(self.uuid) + ", " +
                "attributes = " + str(self.attributes))

    def copy(self):
        cp = BgpSession()
        if self.uuid is not None:
            cp.uuid = self.uuid
        if self.attributes is not None:
            cp.attributes = [x.copy() for x in self.attributes]
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_uuid (obj.populate_string ("uuid"))
        obj.set_attributes ([BgpSessionAttributes.populate ()])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='BgpSession', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BgpSession')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BgpSession'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='BgpSession', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.uuid is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%suuid>%s</%suuid>%s' % (namespace_, self.gds_format_string(quote_xml(self.uuid).encode(ExternalEncoding), input_name='uuid'), namespace_, eol_))
        for attributes_ in self.attributes:
            if isinstance(attributes_, dict):
                attributes_ = BgpSessionAttributes(**attributes_)
            attributes_.export_xml(outfile, level, namespace_, name_='attributes', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.uuid is not None or
            self.attributes
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BgpSession'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.uuid is not None:
            showIndent(outfile, level)
            outfile.write('uuid=%s,\n' % quote_python(self.uuid).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('attributes=[\n')
        level += 1
        for attributes_ in self.attributes:
            showIndent(outfile, level)
            outfile.write('model_.BgpSessionAttributes(\n')
            attributes_.exportLiteral(outfile, level, name_='BgpSessionAttributes')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='BgpSession'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'uuid':
            uuid_ = child_.text
            uuid_ = self.gds_validate_string(uuid_, node, 'uuid')
            self.uuid = uuid_
        elif nodeName_ == 'attributes':
            obj_ = BgpSessionAttributes.factory()
            obj_.build(child_)
            self.attributes.append(obj_)
# end class BgpSession


class RouteOriginOverride(GeneratedsSuper):
    """
    Attributes:
    * origin_override
        Type:           bool

        Created By:           User (optional)

        Description:
          Set true to override Route origin with the given value

    * origin
        Type:           str, *one-of* [u'IGP', u'EGP', u'INCOMPLETE']

        Created By:           User (optional)

        Description:
          User define route origin value

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'origin_override', u'origin']
    attr_field_type_vals = {u'origin': {'restrictions': [u'IGP', u'EGP', u'INCOMPLETE'], 'description': [u'User define route origin value'], 'simple_type': u'RouteOriginAttributeType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'origin_override': {'restrictions': None, 'description': [u'Set true to override Route origin with the given value'], 'simple_type': u'xsd:boolean', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'boolean'}}
    def __init__(self, origin_override=False, origin='IGP', params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _origin_override = params_dict[u"origin_override"]
        except KeyError:
            _origin_override = origin_override
        self.origin_override = _origin_override
        try:
            _origin = params_dict[u"origin"]
        except KeyError:
            _origin = origin
        self.origin = _origin
    def factory(*args_, **kwargs_):
        if RouteOriginOverride.subclass:
            return RouteOriginOverride.subclass(*args_, **kwargs_)
        else:
            return RouteOriginOverride(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_origin_override(self): return self.origin_override
    def set_origin_override(self, origin_override): self.origin_override = origin_override
    def get_origin(self): return self.origin
    def set_origin(self, origin): self.origin = origin
    def validate_RouteOriginAttributeType(self, value):
        # Validate type RouteOriginAttributeType, a restriction on xsd:string.
        error = False
        if isinstance(value, list):
            error = set(value) - set([u'IGP', u'EGP', u'INCOMPLETE'])
        else:
            error = value not in [u'IGP', u'EGP', u'INCOMPLETE']
        if error:
            raise ValueError("RouteOriginAttributeType must be one of [u'IGP', u'EGP', u'INCOMPLETE']")
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.origin_override == other.origin_override and
                    self.origin == other.origin)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.origin_override if self.origin_override is not None else -7985492147856592190,
                     self.origin if self.origin is not None else -7985492147856592190))

    def __repr__(self):
        return ("origin_override = " + str(self.origin_override) + ", " +
                "origin = " + str(self.origin))

    def copy(self):
        cp = RouteOriginOverride()
        if self.origin_override is not None:
            cp.origin_override = self.origin_override
        if self.origin is not None:
            cp.origin = self.origin
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_origin_override (obj.populate_boolean ("origin_override"))
        obj.set_origin (obj.populate_string ("origin"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='RouteOriginOverride', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RouteOriginOverride')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RouteOriginOverride'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RouteOriginOverride', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.origin_override is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sorigin-override>%s</%sorigin-override>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.origin_override)), input_name='origin-override'), namespace_, eol_))
        if self.origin is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sorigin>%s</%sorigin>%s' % (namespace_, self.gds_format_string(quote_xml(self.origin).encode(ExternalEncoding), input_name='origin'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.origin_override is not None or
            self.origin is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RouteOriginOverride'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.origin_override is not None:
            showIndent(outfile, level)
            outfile.write('origin_override=%s,\n' % self.origin_override)
        if self.origin is not None:
            showIndent(outfile, level)
            outfile.write('origin=%s,\n' % quote_python(self.origin).encode(ExternalEncoding))
    def exportDict(self, name_='RouteOriginOverride'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'origin-override':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'origin_override')
            self.origin_override = ival_
        elif nodeName_ == 'origin':
            origin_ = child_.text
            origin_ = self.gds_validate_string(origin_, node, 'origin')
            self.origin = origin_
            self.validate_RouteOriginAttributeType(self.origin)    # validate type RouteOriginAttributeType
# end class RouteOriginOverride


class BgpSessionAttributes(GeneratedsSuper):
    """
    Attributes:
    * bgp_router
        Type:           str

        Created By:           User (optional)

        Description:
          When the parameters are uni-directional the bgp-router element specifies to

          which node the configuration applies. If missing the attributes apply to both

          ends of the session.

    * admin_down
        Type:           bool

        Created By:           User (optional)

        Description:
          Administratively mark this session down.

    * passive
        Type:           bool

        Created By:           User (optional)

        Description:
          This is passive session. It will not initiated connection. This is not relevant

          when session attributes represent common part. It is recommended that it should

          not be set to true in current release.

    * as_override
        Type:           bool

        Created By:           User (optional)

        Description:
          To Be Added

    * hold_time
        Type:           int, *within* [0, 65535]

        Created By:           User (optional)

        Description:
          A non-zero hold-time overrides the hold-time inherited from the bgp-router

          configuration. BGP hold time in seconds [0-65535], Max time to detect liveliness

          of peer.

    * loop_count
        Type:           int, *within* [0, 16]

        Created By:           User (optional)

        Description:
          For routing loop detection, loop-count is the number of times the local AS is

          allowed in the AS_PATH attribute.

    * local_autonomous_system
        Type:           int

        Created By:           User (optional)

        Description:
          Local autonomous system number used for this particular session. If configured,

          this overrides autonomous-system number and local-autonomous-system number

          configured under BgpRouterParams

    * address_families
        Type:           :class:`.AddressFamilies`

        Created By:           User (optional)

        Description:
          BGP address families supported on this session.

    * auth_data
        Type:           :class:`.AuthenticationData`

        Created By:           User (optional)

        Description:
          Authentication related configuration for this session like type, keys etc.

    * family_attributes
        Type:           :class:`.BgpFamilyAttributes`

        Created By:           User (optional)

        Description:
          Session attributes over ride per BGP address family. Attributes like address

          family, loop-count and prefix-limit.

    * private_as_action
        Type:           str, *one-of* [u'remove', u'remove-all', u'replace-all']

        Created By:           User (optional)

        Description:
          Remove or replace private ASes from AS Path attributes advertised to this

          session.

    * route_origin_override
        Type:           :class:`.RouteOriginOverride`

        Created By:           User (optional)

        Description:
          User defined route origin value to override

    """
    """When the parameters are uni-directional the bgp-router element
    specifies to which node the configuration applies. If missing
    the attributes apply to both ends of the session. A non-zero
    hold-time overrides the hold-time inherited from the bgp-router
    configuration. AS Override causes the neighbors AS to be
    replaced with the BGP speaker AS in the AS Path."""
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'bgp_router', u'admin_down', u'passive', u'as_override', u'hold_time', u'loop_count', u'local_autonomous_system', u'address_families', u'auth_data', u'family_attributes', u'private_as_action', u'route_origin_override']
    attr_field_type_vals = {u'auth_data': {'restrictions': None, 'description': [u'Authentication related configuration for this session like type, keys etc.'], 'simple_type': u'AuthenticationData', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'AuthenticationData'}, u'route_origin_override': {'restrictions': None, 'description': [u'User defined route origin value to override'], 'simple_type': u'RouteOriginOverride', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'RouteOriginOverride'}, u'admin_down': {'restrictions': None, 'description': [u'Administratively mark this session down.'], 'simple_type': u'xsd:boolean', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'boolean'}, u'private_as_action': {'restrictions': [u'remove', u'remove-all', u'replace-all'], 'description': [u'Remove or replace private ASes from AS Path attributes advertised to this session.'], 'simple_type': u'BgpPrivateAsAction', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'as_override': {'restrictions': None, 'description': [u'To Be Added'], 'simple_type': u'xsd:boolean', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'boolean'}, u'bgp_router': {'restrictions': None, 'description': [u'When the parameters are uni-directional the bgp-router element specifies to which node the configuration applies. If missing the attributes apply to both ends of the session.'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'local_autonomous_system': {'restrictions': None, 'description': [u'Local autonomous system number used for this particular session. If configured, this overrides autonomous-system number and local-autonomous-system number configured under BgpRouterParams'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'passive': {'restrictions': None, 'description': [u'This is passive session. It will not initiated connection. This is not relevant when session attributes represent common part. It is recommended that it should not be set to true in current release.'], 'simple_type': u'xsd:boolean', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'boolean'}, u'family_attributes': {'restrictions': None, 'description': [u'Session attributes over ride per BGP address family. Attributes like address family, loop-count and prefix-limit.'], 'simple_type': u'BgpFamilyAttributes', 'is_complex': 1, 'restriction_type': None, 'is_array': True, 'required': u'optional', 'attr_type': u'BgpFamilyAttributes'}, u'hold_time': {'restrictions': [0, 65535], 'description': [u'A non-zero hold-time overrides the hold-time inherited from the bgp-router configuration. BGP hold time in seconds [0-65535], Max time to detect liveliness of peer.'], 'simple_type': u'BgpHoldTime', 'is_complex': 0, 'restriction_type': 'range', 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'loop_count': {'restrictions': [0, 16], 'description': [u'For routing loop detection, loop-count is the number of times the local AS is allowed in the AS_PATH attribute.'], 'simple_type': u'BgpAsPathLoopCount', 'is_complex': 0, 'restriction_type': 'range', 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'address_families': {'restrictions': None, 'description': [u'BGP address families supported on this session.'], 'simple_type': u'AddressFamilies', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'AddressFamilies'}}
    def __init__(self, bgp_router=None, admin_down=False, passive=False, as_override=False, hold_time=0, loop_count=0, local_autonomous_system=0, address_families=None, auth_data=None, family_attributes=None, private_as_action=None, route_origin_override=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _bgp_router = params_dict[u"bgp_router"]
        except KeyError:
            _bgp_router = bgp_router
        self.bgp_router = _bgp_router
        try:
            _admin_down = params_dict[u"admin_down"]
        except KeyError:
            _admin_down = admin_down
        self.admin_down = _admin_down
        try:
            _passive = params_dict[u"passive"]
        except KeyError:
            _passive = passive
        self.passive = _passive
        try:
            _as_override = params_dict[u"as_override"]
        except KeyError:
            _as_override = as_override
        self.as_override = _as_override
        try:
            _hold_time = params_dict[u"hold_time"]
        except KeyError:
            _hold_time = hold_time
        self.hold_time = _hold_time
        try:
            _loop_count = params_dict[u"loop_count"]
        except KeyError:
            _loop_count = loop_count
        self.loop_count = _loop_count
        try:
            _local_autonomous_system = params_dict[u"local_autonomous_system"]
        except KeyError:
            _local_autonomous_system = local_autonomous_system
        self.local_autonomous_system = _local_autonomous_system
        try:
            _address_families = params_dict[u"address_families"]
        except KeyError:
            _address_families = address_families
        if isinstance(_address_families, dict):
            obj = AddressFamilies(params_dict=_address_families)
            self.address_families = obj
        else:
            self.address_families = _address_families
        try:
            _auth_data = params_dict[u"auth_data"]
        except KeyError:
            _auth_data = auth_data
        if isinstance(_auth_data, dict):
            obj = AuthenticationData(params_dict=_auth_data)
            self.auth_data = obj
        else:
            self.auth_data = _auth_data
        try:
            _family_attributes = params_dict[u"family_attributes"]
        except KeyError:
            _family_attributes = family_attributes
        if not _family_attributes:
            self.family_attributes = []
        else:
            if isinstance(_family_attributes[0], dict):
                objs = [BgpFamilyAttributes(params_dict=elem) for elem in _family_attributes]
                self.family_attributes = objs
            else:
                self.family_attributes = _family_attributes
        try:
            _private_as_action = params_dict[u"private_as_action"]
        except KeyError:
            _private_as_action = private_as_action
        self.private_as_action = _private_as_action
        try:
            _route_origin_override = params_dict[u"route_origin_override"]
        except KeyError:
            _route_origin_override = route_origin_override
        if isinstance(_route_origin_override, dict):
            obj = RouteOriginOverride(params_dict=_route_origin_override)
            self.route_origin_override = obj
        else:
            self.route_origin_override = _route_origin_override
    def factory(*args_, **kwargs_):
        if BgpSessionAttributes.subclass:
            return BgpSessionAttributes.subclass(*args_, **kwargs_)
        else:
            return BgpSessionAttributes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_bgp_router(self): return self.bgp_router
    def set_bgp_router(self, bgp_router): self.bgp_router = bgp_router
    def get_admin_down(self): return self.admin_down
    def set_admin_down(self, admin_down): self.admin_down = admin_down
    def get_passive(self): return self.passive
    def set_passive(self, passive): self.passive = passive
    def get_as_override(self): return self.as_override
    def set_as_override(self, as_override): self.as_override = as_override
    def get_hold_time(self): return self.hold_time
    def set_hold_time(self, hold_time): self.hold_time = hold_time
    def validate_BgpHoldTime(self, value):
        # Validate type BgpHoldTime, a restriction on xsd:integer.
        error = False
        if isinstance(value, list):
            v_int = list(map(int, value))
            v1, v2 = min(v_int), max(v_int)
        else:
            v1, v2 = int(value), int(value)
        error |= (v2 > 65535)
        if error:
            raise ValueError("BgpHoldTime must be in the range {'minimum': 0}-{'maximum': 65535}")
    def get_loop_count(self): return self.loop_count
    def set_loop_count(self, loop_count): self.loop_count = loop_count
    def validate_BgpAsPathLoopCount(self, value):
        # Validate type BgpAsPathLoopCount, a restriction on xsd:integer.
        error = False
        if isinstance(value, list):
            v_int = list(map(int, value))
            v1, v2 = min(v_int), max(v_int)
        else:
            v1, v2 = int(value), int(value)
        error |= (v2 > 16)
        if error:
            raise ValueError("BgpAsPathLoopCount must be in the range {'minimum': 0}-{'maximum': 16}")
    def get_local_autonomous_system(self): return self.local_autonomous_system
    def set_local_autonomous_system(self, local_autonomous_system): self.local_autonomous_system = local_autonomous_system
    def get_address_families(self): return self.address_families
    def set_address_families(self, address_families): self.address_families = address_families
    def get_auth_data(self): return self.auth_data
    def set_auth_data(self, auth_data): self.auth_data = auth_data
    def get_family_attributes(self): return self.family_attributes
    def set_family_attributes(self, family_attributes): self.family_attributes = family_attributes
    def add_family_attributes(self, value): self.family_attributes.append(value)
    def insert_family_attributes(self, index, value): self.family_attributes[index] = value
    def delete_family_attributes(self, value): self.family_attributes.remove(value)
    def get_private_as_action(self): return self.private_as_action
    def set_private_as_action(self, private_as_action): self.private_as_action = private_as_action
    def validate_BgpPrivateAsAction(self, value):
        # Validate type BgpPrivateAsAction, a restriction on xsd:string.
        error = False
        if isinstance(value, list):
            error = set(value) - set([u'remove', u'remove-all', u'replace-all'])
        else:
            error = value not in [u'remove', u'remove-all', u'replace-all']
        if error:
            raise ValueError("BgpPrivateAsAction must be one of [u'remove', u'remove-all', u'replace-all']")
    def get_route_origin_override(self): return self.route_origin_override
    def set_route_origin_override(self, route_origin_override): self.route_origin_override = route_origin_override
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.bgp_router == other.bgp_router and
                    self.admin_down == other.admin_down and
                    self.passive == other.passive and
                    self.as_override == other.as_override and
                    self.hold_time == other.hold_time and
                    self.loop_count == other.loop_count and
                    self.local_autonomous_system == other.local_autonomous_system and
                    self.address_families == other.address_families and
                    self.auth_data == other.auth_data and
                    self.family_attributes == other.family_attributes and
                    self.private_as_action == other.private_as_action and
                    self.route_origin_override == other.route_origin_override)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.bgp_router if self.bgp_router is not None else -7985492147856592190,
                     self.admin_down if self.admin_down is not None else -7985492147856592190,
                     self.passive if self.passive is not None else -7985492147856592190,
                     self.as_override if self.as_override is not None else -7985492147856592190,
                     self.hold_time if self.hold_time is not None else -7985492147856592190,
                     self.loop_count if self.loop_count is not None else -7985492147856592190,
                     self.local_autonomous_system if self.local_autonomous_system is not None else -7985492147856592190,
                     self.address_families if self.address_families is not None else -7985492147856592190,
                     self.auth_data if self.auth_data is not None else -7985492147856592190,
                     tuple(self.family_attributes or []),
                     self.private_as_action if self.private_as_action is not None else -7985492147856592190,
                     self.route_origin_override if self.route_origin_override is not None else -7985492147856592190))

    def __repr__(self):
        return ("bgp_router = " + str(self.bgp_router) + ", " +
                "admin_down = " + str(self.admin_down) + ", " +
                "passive = " + str(self.passive) + ", " +
                "as_override = " + str(self.as_override) + ", " +
                "hold_time = " + str(self.hold_time) + ", " +
                "loop_count = " + str(self.loop_count) + ", " +
                "local_autonomous_system = " + str(self.local_autonomous_system) + ", " +
                "address_families = " + str(self.address_families) + ", " +
                "auth_data = " + str(self.auth_data) + ", " +
                "family_attributes = " + str(self.family_attributes) + ", " +
                "private_as_action = " + str(self.private_as_action) + ", " +
                "route_origin_override = " + str(self.route_origin_override))

    def copy(self):
        cp = BgpSessionAttributes()
        if self.bgp_router is not None:
            cp.bgp_router = self.bgp_router
        if self.admin_down is not None:
            cp.admin_down = self.admin_down
        if self.passive is not None:
            cp.passive = self.passive
        if self.as_override is not None:
            cp.as_override = self.as_override
        if self.hold_time is not None:
            cp.hold_time = self.hold_time
        if self.loop_count is not None:
            cp.loop_count = self.loop_count
        if self.local_autonomous_system is not None:
            cp.local_autonomous_system = self.local_autonomous_system
        if self.address_families is not None:
            cp.address_families = self.address_families.copy()
        if self.auth_data is not None:
            cp.auth_data = self.auth_data.copy()
        if self.family_attributes is not None:
            cp.family_attributes = [x.copy() for x in self.family_attributes]
        if self.private_as_action is not None:
            cp.private_as_action = self.private_as_action
        if self.route_origin_override is not None:
            cp.route_origin_override = self.route_origin_override.copy()
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_bgp_router (obj.populate_string ("bgp_router"))
        obj.set_admin_down (obj.populate_boolean ("admin_down"))
        obj.set_passive (obj.populate_boolean ("passive"))
        obj.set_as_override (obj.populate_boolean ("as_override"))
        obj.set_hold_time (obj.populate_integer ("hold_time"))
        obj.set_loop_count (obj.populate_integer ("loop_count"))
        obj.set_local_autonomous_system (obj.populate_integer ("local_autonomous_system"))
        obj.set_address_families (AddressFamilies.populate ())
        obj.set_auth_data (AuthenticationData.populate ())
        obj.set_family_attributes ([BgpFamilyAttributes.populate ()])
        obj.set_private_as_action (obj.populate_string ("private_as_action"))
        obj.set_route_origin_override (RouteOriginOverride.populate ())
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='BgpSessionAttributes', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BgpSessionAttributes')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BgpSessionAttributes'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='BgpSessionAttributes', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.bgp_router is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbgp-router>%s</%sbgp-router>%s' % (namespace_, self.gds_format_string(quote_xml(self.bgp_router).encode(ExternalEncoding), input_name='bgp-router'), namespace_, eol_))
        if self.admin_down is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sadmin-down>%s</%sadmin-down>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.admin_down)), input_name='admin-down'), namespace_, eol_))
        if self.passive is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spassive>%s</%spassive>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.passive)), input_name='passive'), namespace_, eol_))
        if self.as_override is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sas-override>%s</%sas-override>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.as_override)), input_name='as-override'), namespace_, eol_))
        if self.hold_time is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shold-time>%s</%shold-time>%s' % (namespace_, self.gds_format_integer(self.hold_time, input_name='hold-time'), namespace_, eol_))
        if self.loop_count is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sloop-count>%s</%sloop-count>%s' % (namespace_, self.gds_format_integer(self.loop_count, input_name='loop-count'), namespace_, eol_))
        if self.local_autonomous_system is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slocal-autonomous-system>%s</%slocal-autonomous-system>%s' % (namespace_, self.gds_format_integer(self.local_autonomous_system, input_name='local-autonomous-system'), namespace_, eol_))
        if self.address_families is not None:
            self.address_families.export_xml(outfile, level, namespace_, name_='address-families', pretty_print=pretty_print)
        if self.auth_data is not None:
            self.auth_data.export_xml(outfile, level, namespace_, name_='auth-data', pretty_print=pretty_print)
        for family_attributes_ in self.family_attributes:
            if isinstance(family_attributes_, dict):
                family_attributes_ = BgpFamilyAttributes(**family_attributes_)
            family_attributes_.export_xml(outfile, level, namespace_, name_='family-attributes', pretty_print=pretty_print)
        if self.private_as_action is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprivate-as-action>%s</%sprivate-as-action>%s' % (namespace_, self.gds_format_string(quote_xml(self.private_as_action).encode(ExternalEncoding), input_name='private-as-action'), namespace_, eol_))
        if self.route_origin_override is not None:
            self.route_origin_override.export_xml(outfile, level, namespace_, name_='route-origin-override', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.bgp_router is not None or
            self.admin_down is not None or
            self.passive is not None or
            self.as_override is not None or
            self.hold_time is not None or
            self.loop_count is not None or
            self.local_autonomous_system is not None or
            self.address_families is not None or
            self.auth_data is not None or
            self.family_attributes or
            self.private_as_action is not None or
            self.route_origin_override is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BgpSessionAttributes'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.bgp_router is not None:
            showIndent(outfile, level)
            outfile.write('bgp_router=%s,\n' % quote_python(self.bgp_router).encode(ExternalEncoding))
        if self.admin_down is not None:
            showIndent(outfile, level)
            outfile.write('admin_down=%s,\n' % self.admin_down)
        if self.passive is not None:
            showIndent(outfile, level)
            outfile.write('passive=%s,\n' % self.passive)
        if self.as_override is not None:
            showIndent(outfile, level)
            outfile.write('as_override=%s,\n' % self.as_override)
        if self.hold_time is not None:
            showIndent(outfile, level)
            outfile.write('hold_time=%d,\n' % self.hold_time)
        if self.loop_count is not None:
            showIndent(outfile, level)
            outfile.write('loop_count=%d,\n' % self.loop_count)
        if self.local_autonomous_system is not None:
            showIndent(outfile, level)
            outfile.write('local_autonomous_system=%d,\n' % self.local_autonomous_system)
        if self.address_families is not None:
            showIndent(outfile, level)
            outfile.write('address_families=model_.AddressFamilies(\n')
            self.address_families.exportLiteral(outfile, level, name_='address_families')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.auth_data is not None:
            showIndent(outfile, level)
            outfile.write('auth_data=model_.AuthenticationData(\n')
            self.auth_data.exportLiteral(outfile, level, name_='auth_data')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('family_attributes=[\n')
        level += 1
        for family_attributes_ in self.family_attributes:
            showIndent(outfile, level)
            outfile.write('model_.BgpFamilyAttributes(\n')
            family_attributes_.exportLiteral(outfile, level, name_='BgpFamilyAttributes')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.private_as_action is not None:
            showIndent(outfile, level)
            outfile.write('private_as_action=%s,\n' % quote_python(self.private_as_action).encode(ExternalEncoding))
        if self.route_origin_override is not None:
            showIndent(outfile, level)
            outfile.write('route_origin_override=model_.RouteOriginOverride(\n')
            self.route_origin_override.exportLiteral(outfile, level, name_='route_origin_override')
            showIndent(outfile, level)
            outfile.write('),\n')
    def exportDict(self, name_='BgpSessionAttributes'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'bgp-router':
            bgp_router_ = child_.text
            bgp_router_ = self.gds_validate_string(bgp_router_, node, 'bgp_router')
            self.bgp_router = bgp_router_
        elif nodeName_ == 'admin-down':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'admin_down')
            self.admin_down = ival_
        elif nodeName_ == 'passive':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'passive')
            self.passive = ival_
        elif nodeName_ == 'as-override':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'as_override')
            self.as_override = ival_
        elif nodeName_ == 'hold-time':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'hold_time')
            self.hold_time = ival_
            self.validate_BgpHoldTime(self.hold_time)    # validate type BgpHoldTime
        elif nodeName_ == 'loop-count':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'loop_count')
            self.loop_count = ival_
            self.validate_BgpAsPathLoopCount(self.loop_count)    # validate type BgpAsPathLoopCount
        elif nodeName_ == 'local-autonomous-system':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'local_autonomous_system')
            self.local_autonomous_system = ival_
        elif nodeName_ == 'address-families':
            obj_ = AddressFamilies.factory()
            obj_.build(child_)
            self.set_address_families(obj_)
        elif nodeName_ == 'auth-data':
            obj_ = AuthenticationData.factory()
            obj_.build(child_)
            self.set_auth_data(obj_)
        elif nodeName_ == 'family-attributes':
            obj_ = BgpFamilyAttributes.factory()
            obj_.build(child_)
            self.family_attributes.append(obj_)
        elif nodeName_ == 'private-as-action':
            private_as_action_ = child_.text
            private_as_action_ = self.gds_validate_string(private_as_action_, node, 'private_as_action')
            self.private_as_action = private_as_action_
            self.validate_BgpPrivateAsAction(self.private_as_action)    # validate type BgpPrivateAsAction
        elif nodeName_ == 'route-origin-override':
            obj_ = RouteOriginOverride.factory()
            obj_.build(child_)
            self.set_route_origin_override(obj_)
# end class BgpSessionAttributes


class BgpFamilyAttributes(GeneratedsSuper):
    """
    Attributes:
    * address_family
        Type:           str, *one-of* [u'inet', u'inet-labeled', u'inet-vpn', u'e-vpn', u'erm-vpn', u'route-target', u'inet6', u'inet-mvpn', u'inet6-vpn']

        Created By:           User (required)

        Description:
          Address family for which these parameters are applied.

    * loop_count
        Type:           int, *within* [0, 16]

        Created By:           User (optional)

        Description:
          For routing loop detection, loop-count is the number of times the local bgp-

          routers AS is             allowed in the AS_PATH attribute.

    * prefix_limit
        Type:           :class:`.BgpPrefixLimit`

        Created By:           User (optional)

        Description:
          prefix-limit contains the maximum number of prefixes that are allowed to be

          received on the session for this address family.

    * default_tunnel_encap
        Type:           str, *one-of* [u'gre', u'mpls', u'udp', u'vxlan']

        Created By:           User (optional)

        Description:
          Default prioritized tunnel encapsulation list.

    """
    """This type is used to configure per address-family parameters for a
    BgpSession. * loop-count is the number of times the local bgp-
    router's AS is allowed in the AS_PATH attribute. * prefix-limit
    contains the maximum number of prefixes that are allowed to be
    received on the session."""
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'address_family', u'loop_count', u'prefix_limit', u'default_tunnel_encap']
    attr_field_type_vals = {u'prefix_limit': {'restrictions': None, 'description': [u'prefix-limit contains the maximum number of prefixes that are allowed to be received on the session for this address family.'], 'simple_type': u'BgpPrefixLimit', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'BgpPrefixLimit'}, u'default_tunnel_encap': {'restrictions': [u'gre', u'mpls', u'udp', u'vxlan'], 'description': [u'Default prioritized tunnel encapsulation list.'], 'simple_type': u'BgpTunnelEncapsulationType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': True, 'required': u'optional', 'attr_type': u'string'}, u'loop_count': {'restrictions': [0, 16], 'description': [u'For routing loop detection, loop-count is the number of times the local bgp-routers AS is             allowed in the AS_PATH attribute.'], 'simple_type': u'BgpAsPathLoopCount', 'is_complex': 0, 'restriction_type': 'range', 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'address_family': {'restrictions': [u'inet', u'inet-labeled', u'inet-vpn', u'e-vpn', u'erm-vpn', u'route-target', u'inet6', u'inet-mvpn', u'inet6-vpn'], 'description': [u'Address family for which these parameters are applied.'], 'simple_type': u'AddressFamily', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'true', 'attr_type': u'string'}}
    def __init__(self, address_family=None, loop_count=0, prefix_limit=None, default_tunnel_encap=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _address_family = params_dict[u"address_family"]
        except KeyError:
            _address_family = address_family
        self.address_family = _address_family
        try:
            _loop_count = params_dict[u"loop_count"]
        except KeyError:
            _loop_count = loop_count
        self.loop_count = _loop_count
        try:
            _prefix_limit = params_dict[u"prefix_limit"]
        except KeyError:
            _prefix_limit = prefix_limit
        if isinstance(_prefix_limit, dict):
            obj = BgpPrefixLimit(params_dict=_prefix_limit)
            self.prefix_limit = obj
        else:
            self.prefix_limit = _prefix_limit
        try:
            _default_tunnel_encap = params_dict[u"default_tunnel_encap"]
        except KeyError:
            _default_tunnel_encap = default_tunnel_encap
        if not _default_tunnel_encap:
            self.default_tunnel_encap = []
        else:
            self.default_tunnel_encap = _default_tunnel_encap
    def factory(*args_, **kwargs_):
        if BgpFamilyAttributes.subclass:
            return BgpFamilyAttributes.subclass(*args_, **kwargs_)
        else:
            return BgpFamilyAttributes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_address_family(self): return self.address_family
    def set_address_family(self, address_family): self.address_family = address_family
    def validate_AddressFamily(self, value):
        # Validate type AddressFamily, a restriction on xsd:string.
        error = False
        if isinstance(value, list):
            error = set(value) - set([u'inet', u'inet-labeled', u'inet-vpn', u'e-vpn', u'erm-vpn', u'route-target', u'inet6', u'inet-mvpn', u'inet6-vpn'])
        else:
            error = value not in [u'inet', u'inet-labeled', u'inet-vpn', u'e-vpn', u'erm-vpn', u'route-target', u'inet6', u'inet-mvpn', u'inet6-vpn']
        if error:
            raise ValueError("AddressFamily must be one of [u'inet', u'inet-labeled', u'inet-vpn', u'e-vpn', u'erm-vpn', u'route-target', u'inet6', u'inet-mvpn', u'inet6-vpn']")
    def get_loop_count(self): return self.loop_count
    def set_loop_count(self, loop_count): self.loop_count = loop_count
    def validate_BgpAsPathLoopCount(self, value):
        # Validate type BgpAsPathLoopCount, a restriction on xsd:integer.
        error = False
        if isinstance(value, list):
            v_int = list(map(int, value))
            v1, v2 = min(v_int), max(v_int)
        else:
            v1, v2 = int(value), int(value)
        error |= (v2 > 16)
        if error:
            raise ValueError("BgpAsPathLoopCount must be in the range {'minimum': 0}-{'maximum': 16}")
    def get_prefix_limit(self): return self.prefix_limit
    def set_prefix_limit(self, prefix_limit): self.prefix_limit = prefix_limit
    def get_default_tunnel_encap(self): return self.default_tunnel_encap
    def set_default_tunnel_encap(self, default_tunnel_encap): self.default_tunnel_encap = default_tunnel_encap
    def add_default_tunnel_encap(self, value): self.default_tunnel_encap.append(value)
    def insert_default_tunnel_encap(self, index, value): self.default_tunnel_encap[index] = value
    def delete_default_tunnel_encap(self, value): self.default_tunnel_encap.remove(value)
    def validate_BgpTunnelEncapsulationType(self, value):
        # Validate type BgpTunnelEncapsulationType, a restriction on xsd:string.
        error = False
        if isinstance(value, list):
            error = set(value) - set([u'gre', u'mpls', u'udp', u'vxlan'])
        else:
            error = value not in [u'gre', u'mpls', u'udp', u'vxlan']
        if error:
            raise ValueError("BgpTunnelEncapsulationType must be one of [u'gre', u'mpls', u'udp', u'vxlan']")
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.address_family == other.address_family and
                    self.loop_count == other.loop_count and
                    self.prefix_limit == other.prefix_limit and
                    self.default_tunnel_encap == other.default_tunnel_encap)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.address_family if self.address_family is not None else -7985492147856592190,
                     self.loop_count if self.loop_count is not None else -7985492147856592190,
                     self.prefix_limit if self.prefix_limit is not None else -7985492147856592190,
                     tuple(self.default_tunnel_encap or [])))

    def __repr__(self):
        return ("address_family = " + str(self.address_family) + ", " +
                "loop_count = " + str(self.loop_count) + ", " +
                "prefix_limit = " + str(self.prefix_limit) + ", " +
                "default_tunnel_encap = " + str(self.default_tunnel_encap))

    def copy(self):
        cp = BgpFamilyAttributes()
        if self.address_family is not None:
            cp.address_family = self.address_family
        if self.loop_count is not None:
            cp.loop_count = self.loop_count
        if self.prefix_limit is not None:
            cp.prefix_limit = self.prefix_limit.copy()
        if self.default_tunnel_encap is not None:
            cp.default_tunnel_encap = list(self.default_tunnel_encap)
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_address_family (obj.populate_string ("address_family"))
        obj.set_loop_count (obj.populate_integer ("loop_count"))
        obj.set_prefix_limit (BgpPrefixLimit.populate ())
        obj.set_default_tunnel_encap ([obj.populate_string ("default_tunnel_encap")])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='BgpFamilyAttributes', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BgpFamilyAttributes')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BgpFamilyAttributes'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='BgpFamilyAttributes', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.address_family is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saddress-family>%s</%saddress-family>%s' % (namespace_, self.gds_format_string(quote_xml(self.address_family).encode(ExternalEncoding), input_name='address-family'), namespace_, eol_))
        if self.loop_count is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sloop-count>%s</%sloop-count>%s' % (namespace_, self.gds_format_integer(self.loop_count, input_name='loop-count'), namespace_, eol_))
        if self.prefix_limit is not None:
            self.prefix_limit.export_xml(outfile, level, namespace_, name_='prefix-limit', pretty_print=pretty_print)
        for default_tunnel_encap_ in self.default_tunnel_encap:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdefault-tunnel-encap>%s</%sdefault-tunnel-encap>%s' % (namespace_, self.gds_format_string(quote_xml(default_tunnel_encap_).encode(ExternalEncoding), input_name='default-tunnel-encap'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.address_family is not None or
            self.loop_count is not None or
            self.prefix_limit is not None or
            self.default_tunnel_encap
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BgpFamilyAttributes'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.address_family is not None:
            showIndent(outfile, level)
            outfile.write('address_family=%s,\n' % quote_python(self.address_family).encode(ExternalEncoding))
        if self.loop_count is not None:
            showIndent(outfile, level)
            outfile.write('loop_count=%d,\n' % self.loop_count)
        if self.prefix_limit is not None:
            showIndent(outfile, level)
            outfile.write('prefix_limit=model_.BgpPrefixLimit(\n')
            self.prefix_limit.exportLiteral(outfile, level, name_='prefix_limit')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('default_tunnel_encap=[\n')
        level += 1
        for default_tunnel_encap_ in self.default_tunnel_encap:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(default_tunnel_encap_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='BgpFamilyAttributes'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'address-family':
            address_family_ = child_.text
            address_family_ = self.gds_validate_string(address_family_, node, 'address_family')
            self.address_family = address_family_
            self.validate_AddressFamily(self.address_family)    # validate type AddressFamily
        elif nodeName_ == 'loop-count':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'loop_count')
            self.loop_count = ival_
            self.validate_BgpAsPathLoopCount(self.loop_count)    # validate type BgpAsPathLoopCount
        elif nodeName_ == 'prefix-limit':
            obj_ = BgpPrefixLimit.factory()
            obj_.build(child_)
            self.set_prefix_limit(obj_)
        elif nodeName_ == 'default-tunnel-encap':
            default_tunnel_encap_ = child_.text
            default_tunnel_encap_ = self.gds_validate_string(default_tunnel_encap_, node, 'default_tunnel_encap')
            self.default_tunnel_encap.append(default_tunnel_encap_)
            self.validate_BgpTunnelEncapsulationType(self.default_tunnel_encap)    # validate type BgpTunnelEncapsulationType
# end class BgpFamilyAttributes


class BgpPrefixLimit(GeneratedsSuper):
    """
    Attributes:
    * maximum
        Type:           int

    * idle_timeout
        Type:           int, *within* [0, 86400]

        Created By:           User (optional)

        Description:
          Time in seconds after which the session is allowed to re-establish after

          teardown.

    """
    """This is used to configure the maximum number of received prefixes
    and control the behavior of the session when the maximum is
    reached."""
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'maximum', u'idle_timeout']
    attr_field_type_vals = {u'idle_timeout': {'restrictions': [0, 86400], 'description': [u'Time in seconds after which the session is allowed to re-establish after teardown.'], 'simple_type': u'BgpPrefixLimitIdleTimeout', 'is_complex': 0, 'restriction_type': 'range', 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'maximum': {'restrictions': None, 'description': [], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'integer'}}
    def __init__(self, maximum=None, idle_timeout=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _maximum = params_dict[u"maximum"]
        except KeyError:
            _maximum = maximum
        self.maximum = _maximum
        try:
            _idle_timeout = params_dict[u"idle_timeout"]
        except KeyError:
            _idle_timeout = idle_timeout
        self.idle_timeout = _idle_timeout
    def factory(*args_, **kwargs_):
        if BgpPrefixLimit.subclass:
            return BgpPrefixLimit.subclass(*args_, **kwargs_)
        else:
            return BgpPrefixLimit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_maximum(self): return self.maximum
    def set_maximum(self, maximum): self.maximum = maximum
    def get_idle_timeout(self): return self.idle_timeout
    def set_idle_timeout(self, idle_timeout): self.idle_timeout = idle_timeout
    def validate_BgpPrefixLimitIdleTimeout(self, value):
        # Validate type BgpPrefixLimitIdleTimeout, a restriction on xsd:integer.
        error = False
        if isinstance(value, list):
            v_int = list(map(int, value))
            v1, v2 = min(v_int), max(v_int)
        else:
            v1, v2 = int(value), int(value)
        error |= (v2 > 86400)
        if error:
            raise ValueError("BgpPrefixLimitIdleTimeout must be in the range {'minimum': 0}-{'maximum': 86400}")
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.maximum == other.maximum and
                    self.idle_timeout == other.idle_timeout)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.maximum if self.maximum is not None else -7985492147856592190,
                     self.idle_timeout if self.idle_timeout is not None else -7985492147856592190))

    def __repr__(self):
        return ("maximum = " + str(self.maximum) + ", " +
                "idle_timeout = " + str(self.idle_timeout))

    def copy(self):
        cp = BgpPrefixLimit()
        if self.maximum is not None:
            cp.maximum = self.maximum
        if self.idle_timeout is not None:
            cp.idle_timeout = self.idle_timeout
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_maximum (obj.populate_integer ("maximum"))
        obj.set_idle_timeout (obj.populate_integer ("idle_timeout"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='BgpPrefixLimit', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BgpPrefixLimit')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BgpPrefixLimit'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='BgpPrefixLimit', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.maximum is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smaximum>%s</%smaximum>%s' % (namespace_, self.gds_format_integer(self.maximum, input_name='maximum'), namespace_, eol_))
        if self.idle_timeout is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sidle-timeout>%s</%sidle-timeout>%s' % (namespace_, self.gds_format_integer(self.idle_timeout, input_name='idle-timeout'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.maximum is not None or
            self.idle_timeout is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BgpPrefixLimit'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.maximum is not None:
            showIndent(outfile, level)
            outfile.write('maximum=%d,\n' % self.maximum)
        if self.idle_timeout is not None:
            showIndent(outfile, level)
            outfile.write('idle_timeout=%d,\n' % self.idle_timeout)
    def exportDict(self, name_='BgpPrefixLimit'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'maximum':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'maximum')
            self.maximum = ival_
        elif nodeName_ == 'idle-timeout':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'idle_timeout')
            self.idle_timeout = ival_
            self.validate_BgpPrefixLimitIdleTimeout(self.idle_timeout)    # validate type BgpPrefixLimitIdleTimeout
# end class BgpPrefixLimit


class AddressFamilies(GeneratedsSuper):
    """
    Attributes:
    * family
        Type:           str, *one-of* [u'inet', u'inet-labeled', u'inet-vpn', u'e-vpn', u'erm-vpn', u'route-target', u'inet6', u'inet-mvpn', u'inet6-vpn']

        Description:
          BGP address families supported by contrail.

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'family']
    attr_field_type_vals = {u'family': {'restrictions': [u'inet', u'inet-labeled', u'inet-vpn', u'e-vpn', u'erm-vpn', u'route-target', u'inet6', u'inet-mvpn', u'inet6-vpn'], 'description': [u'BGP address families supported by contrail.'], 'simple_type': u'AddressFamily', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': True, 'required': None, 'attr_type': u'string'}}
    def __init__(self, family=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _family = params_dict[u"family"]
        except KeyError:
            _family = family
        if not _family:
            self.family = []
        else:
            self.family = _family
    def factory(*args_, **kwargs_):
        if AddressFamilies.subclass:
            return AddressFamilies.subclass(*args_, **kwargs_)
        else:
            return AddressFamilies(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_family(self): return self.family
    def set_family(self, family): self.family = family
    def add_family(self, value): self.family.append(value)
    def insert_family(self, index, value): self.family[index] = value
    def delete_family(self, value): self.family.remove(value)
    def validate_AddressFamily(self, value):
        # Validate type AddressFamily, a restriction on xsd:string.
        error = False
        if isinstance(value, list):
            error = set(value) - set([u'inet', u'inet-labeled', u'inet-vpn', u'e-vpn', u'erm-vpn', u'route-target', u'inet6', u'inet-mvpn', u'inet6-vpn'])
        else:
            error = value not in [u'inet', u'inet-labeled', u'inet-vpn', u'e-vpn', u'erm-vpn', u'route-target', u'inet6', u'inet-mvpn', u'inet6-vpn']
        if error:
            raise ValueError("AddressFamily must be one of [u'inet', u'inet-labeled', u'inet-vpn', u'e-vpn', u'erm-vpn', u'route-target', u'inet6', u'inet-mvpn', u'inet6-vpn']")
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.family == other.family)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.family or [])))

    def __repr__(self):
        return ("family = " + str(self.family))

    def copy(self):
        cp = AddressFamilies()
        if self.family is not None:
            cp.family = list(self.family)
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_family ([obj.populate_string ("family")])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='AddressFamilies', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AddressFamilies')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AddressFamilies'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AddressFamilies', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for family_ in self.family:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfamily>%s</%sfamily>%s' % (namespace_, self.gds_format_string(quote_xml(family_).encode(ExternalEncoding), input_name='family'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.family
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AddressFamilies'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('family=[\n')
        level += 1
        for family_ in self.family:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(family_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='AddressFamilies'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'family':
            family_ = child_.text
            family_ = self.gds_validate_string(family_, node, 'family')
            self.family.append(family_)
            self.validate_AddressFamily(self.family)    # validate type AddressFamily
# end class AddressFamilies


class AuthenticationKeyItem(GeneratedsSuper):
    """
    Attributes:
    * key_id
        Type:           int, *within* [0, 63]

    * key
        Type:           str

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'key_id', u'key']
    attr_field_type_vals = {u'key_id': {'restrictions': [0, 63], 'description': [], 'simple_type': u'AuthenticationKeyId', 'is_complex': 0, 'restriction_type': 'range', 'is_array': False, 'required': None, 'attr_type': u'integer'}, u'key': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}}
    def __init__(self, key_id=None, key=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _key_id = params_dict[u"key_id"]
        except KeyError:
            _key_id = key_id
        self.key_id = _key_id
        try:
            _key = params_dict[u"key"]
        except KeyError:
            _key = key
        self.key = _key
    def factory(*args_, **kwargs_):
        if AuthenticationKeyItem.subclass:
            return AuthenticationKeyItem.subclass(*args_, **kwargs_)
        else:
            return AuthenticationKeyItem(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_key_id(self): return self.key_id
    def set_key_id(self, key_id): self.key_id = key_id
    def validate_AuthenticationKeyId(self, value):
        # Validate type AuthenticationKeyId, a restriction on xsd:integer.
        error = False
        if isinstance(value, list):
            v_int = list(map(int, value))
            v1, v2 = min(v_int), max(v_int)
        else:
            v1, v2 = int(value), int(value)
        error |= (v2 > 63)
        if error:
            raise ValueError("AuthenticationKeyId must be in the range {'minimum': 0}-{'maximum': 63}")
    def get_key(self): return self.key
    def set_key(self, key): self.key = key
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.key_id == other.key_id and
                    self.key == other.key)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.key_id if self.key_id is not None else -7985492147856592190,
                     self.key if self.key is not None else -7985492147856592190))

    def __repr__(self):
        return ("key_id = " + str(self.key_id) + ", " +
                "key = " + str(self.key))

    def copy(self):
        cp = AuthenticationKeyItem()
        if self.key_id is not None:
            cp.key_id = self.key_id
        if self.key is not None:
            cp.key = self.key
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_key_id (obj.populate_integer ("key_id"))
        obj.set_key (obj.populate_string ("key"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='AuthenticationKeyItem', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AuthenticationKeyItem')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AuthenticationKeyItem'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AuthenticationKeyItem', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.key_id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%skey-id>%s</%skey-id>%s' % (namespace_, self.gds_format_integer(self.key_id, input_name='key-id'), namespace_, eol_))
        if self.key is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%skey>%s</%skey>%s' % (namespace_, self.gds_format_string(quote_xml(self.key).encode(ExternalEncoding), input_name='key'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.key_id is not None or
            self.key is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AuthenticationKeyItem'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.key_id is not None:
            showIndent(outfile, level)
            outfile.write('key_id=%d,\n' % self.key_id)
        if self.key is not None:
            showIndent(outfile, level)
            outfile.write('key=%s,\n' % quote_python(self.key).encode(ExternalEncoding))
    def exportDict(self, name_='AuthenticationKeyItem'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'key-id':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'key_id')
            self.key_id = ival_
            self.validate_AuthenticationKeyId(self.key_id)    # validate type AuthenticationKeyId
        elif nodeName_ == 'key':
            key_ = child_.text
            key_ = self.gds_validate_string(key_, node, 'key')
            self.key = key_
# end class AuthenticationKeyItem


class AuthenticationData(GeneratedsSuper):
    """
    Attributes:
    * key_type
        Type:           str, *one-of* [u'md5']

        Created By:           User (required)

        Description:
          Authentication type for this session. Currently only MD5 is supported.

    * key_items
        Type:           :class:`.AuthenticationKeyItem`

        Created By:           User (required)

        Description:
          Upto two keys can be specified. Currently only one key is supported.

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'key_type', u'key_items']
    attr_field_type_vals = {u'key_type': {'restrictions': [u'md5'], 'description': [u'Authentication type for this session. Currently only MD5 is supported.'], 'simple_type': u'AuthenticationKeyType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'true', 'attr_type': u'string'}, u'key_items': {'restrictions': None, 'description': [u'Upto two keys can be specified. Currently only one key is supported.'], 'simple_type': u'AuthenticationKeyItem', 'is_complex': 1, 'restriction_type': None, 'is_array': True, 'required': u'true', 'attr_type': u'AuthenticationKeyItem'}}
    def __init__(self, key_type=None, key_items=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _key_type = params_dict[u"key_type"]
        except KeyError:
            _key_type = key_type
        self.key_type = _key_type
        try:
            _key_items = params_dict[u"key_items"]
        except KeyError:
            _key_items = key_items
        if not _key_items:
            self.key_items = []
        else:
            if isinstance(_key_items[0], dict):
                objs = [AuthenticationKeyItem(params_dict=elem) for elem in _key_items]
                self.key_items = objs
            else:
                self.key_items = _key_items
    def factory(*args_, **kwargs_):
        if AuthenticationData.subclass:
            return AuthenticationData.subclass(*args_, **kwargs_)
        else:
            return AuthenticationData(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_key_type(self): return self.key_type
    def set_key_type(self, key_type): self.key_type = key_type
    def validate_AuthenticationKeyType(self, value):
        # Validate type AuthenticationKeyType, a restriction on xsd:string.
        error = False
        if isinstance(value, list):
            error = set(value) - set([u'md5'])
        else:
            error = value not in [u'md5']
        if error:
            raise ValueError("AuthenticationKeyType must be one of [u'md5']")
    def get_key_items(self): return self.key_items
    def set_key_items(self, key_items): self.key_items = key_items
    def add_key_items(self, value): self.key_items.append(value)
    def insert_key_items(self, index, value): self.key_items[index] = value
    def delete_key_items(self, value): self.key_items.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.key_type == other.key_type and
                    self.key_items == other.key_items)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.key_type if self.key_type is not None else -7985492147856592190,
                     tuple(self.key_items or [])))

    def __repr__(self):
        return ("key_type = " + str(self.key_type) + ", " +
                "key_items = " + str(self.key_items))

    def copy(self):
        cp = AuthenticationData()
        if self.key_type is not None:
            cp.key_type = self.key_type
        if self.key_items is not None:
            cp.key_items = [x.copy() for x in self.key_items]
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_key_type (obj.populate_string ("key_type"))
        obj.set_key_items ([AuthenticationKeyItem.populate ()])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='AuthenticationData', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AuthenticationData')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AuthenticationData'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AuthenticationData', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.key_type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%skey-type>%s</%skey-type>%s' % (namespace_, self.gds_format_string(quote_xml(self.key_type).encode(ExternalEncoding), input_name='key-type'), namespace_, eol_))
        for key_items_ in self.key_items:
            if isinstance(key_items_, dict):
                key_items_ = AuthenticationKeyItem(**key_items_)
            key_items_.export_xml(outfile, level, namespace_, name_='key-items', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.key_type is not None or
            self.key_items
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AuthenticationData'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.key_type is not None:
            showIndent(outfile, level)
            outfile.write('key_type=%s,\n' % quote_python(self.key_type).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('key_items=[\n')
        level += 1
        for key_items_ in self.key_items:
            showIndent(outfile, level)
            outfile.write('model_.AuthenticationKeyItem(\n')
            key_items_.exportLiteral(outfile, level, name_='AuthenticationKeyItem')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='AuthenticationData'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'key-type':
            key_type_ = child_.text
            key_type_ = self.gds_validate_string(key_type_, node, 'key_type')
            self.key_type = key_type_
            self.validate_AuthenticationKeyType(self.key_type)    # validate type AuthenticationKeyType
        elif nodeName_ == 'key-items':
            obj_ = AuthenticationKeyItem.factory()
            obj_.build(child_)
            self.key_items.append(obj_)
# end class AuthenticationData


class ServiceChainInfo(GeneratedsSuper):
    """
    Attributes:
    * routing_instance
        Type:           str

    * prefix
        Type:           str

    * service_chain_address
        Type:           str, *one-of* xsd:string

    * service_instance
        Type:           str

    * source_routing_instance
        Type:           str

    * service_chain_id
        Type:           str

    * sc_head
        Type:           bool

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'routing_instance', u'prefix', u'service_chain_address', u'service_instance', u'source_routing_instance', u'service_chain_id', u'sc_head']
    attr_field_type_vals = {u'service_instance': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'prefix': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': True, 'required': None, 'attr_type': u'string'}, u'sc_head': {'restrictions': None, 'description': [], 'simple_type': u'xsd:boolean', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'boolean'}, u'service_chain_id': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'routing_instance': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'source_routing_instance': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'service_chain_address': {'restrictions': [], 'description': [], 'simple_type': u'IpAddress', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': None, 'attr_type': u'string'}}
    def __init__(self, routing_instance=None, prefix=None, service_chain_address=None, service_instance=None, source_routing_instance=None, service_chain_id=None, sc_head=False, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _routing_instance = params_dict[u"routing_instance"]
        except KeyError:
            _routing_instance = routing_instance
        self.routing_instance = _routing_instance
        try:
            _prefix = params_dict[u"prefix"]
        except KeyError:
            _prefix = prefix
        if not _prefix:
            self.prefix = []
        else:
            self.prefix = _prefix
        try:
            _service_chain_address = params_dict[u"service_chain_address"]
        except KeyError:
            _service_chain_address = service_chain_address
        self.service_chain_address = _service_chain_address
        try:
            _service_instance = params_dict[u"service_instance"]
        except KeyError:
            _service_instance = service_instance
        self.service_instance = _service_instance
        try:
            _source_routing_instance = params_dict[u"source_routing_instance"]
        except KeyError:
            _source_routing_instance = source_routing_instance
        self.source_routing_instance = _source_routing_instance
        try:
            _service_chain_id = params_dict[u"service_chain_id"]
        except KeyError:
            _service_chain_id = service_chain_id
        self.service_chain_id = _service_chain_id
        try:
            _sc_head = params_dict[u"sc_head"]
        except KeyError:
            _sc_head = sc_head
        self.sc_head = _sc_head
    def factory(*args_, **kwargs_):
        if ServiceChainInfo.subclass:
            return ServiceChainInfo.subclass(*args_, **kwargs_)
        else:
            return ServiceChainInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_routing_instance(self): return self.routing_instance
    def set_routing_instance(self, routing_instance): self.routing_instance = routing_instance
    def get_prefix(self): return self.prefix
    def set_prefix(self, prefix): self.prefix = prefix
    def add_prefix(self, value): self.prefix.append(value)
    def insert_prefix(self, index, value): self.prefix[index] = value
    def delete_prefix(self, value): self.prefix.remove(value)
    def get_service_chain_address(self): return self.service_chain_address
    def set_service_chain_address(self, service_chain_address): self.service_chain_address = service_chain_address
    def validate_IpAddress(self, value):
        # Validate type IpAddress, a restriction on xsd:string.
        pass
    def get_service_instance(self): return self.service_instance
    def set_service_instance(self, service_instance): self.service_instance = service_instance
    def get_source_routing_instance(self): return self.source_routing_instance
    def set_source_routing_instance(self, source_routing_instance): self.source_routing_instance = source_routing_instance
    def get_service_chain_id(self): return self.service_chain_id
    def set_service_chain_id(self, service_chain_id): self.service_chain_id = service_chain_id
    def get_sc_head(self): return self.sc_head
    def set_sc_head(self, sc_head): self.sc_head = sc_head
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.routing_instance == other.routing_instance and
                    self.prefix == other.prefix and
                    self.service_chain_address == other.service_chain_address and
                    self.service_instance == other.service_instance and
                    self.source_routing_instance == other.source_routing_instance and
                    self.service_chain_id == other.service_chain_id and
                    self.sc_head == other.sc_head)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.routing_instance if self.routing_instance is not None else -7985492147856592190,
                     tuple(self.prefix or []),
                     self.service_chain_address if self.service_chain_address is not None else -7985492147856592190,
                     self.service_instance if self.service_instance is not None else -7985492147856592190,
                     self.source_routing_instance if self.source_routing_instance is not None else -7985492147856592190,
                     self.service_chain_id if self.service_chain_id is not None else -7985492147856592190,
                     self.sc_head if self.sc_head is not None else -7985492147856592190))

    def __repr__(self):
        return ("routing_instance = " + str(self.routing_instance) + ", " +
                "prefix = " + str(self.prefix) + ", " +
                "service_chain_address = " + str(self.service_chain_address) + ", " +
                "service_instance = " + str(self.service_instance) + ", " +
                "source_routing_instance = " + str(self.source_routing_instance) + ", " +
                "service_chain_id = " + str(self.service_chain_id) + ", " +
                "sc_head = " + str(self.sc_head))

    def copy(self):
        cp = ServiceChainInfo()
        if self.routing_instance is not None:
            cp.routing_instance = self.routing_instance
        if self.prefix is not None:
            cp.prefix = list(self.prefix)
        if self.service_chain_address is not None:
            cp.service_chain_address = self.service_chain_address
        if self.service_instance is not None:
            cp.service_instance = self.service_instance
        if self.source_routing_instance is not None:
            cp.source_routing_instance = self.source_routing_instance
        if self.service_chain_id is not None:
            cp.service_chain_id = self.service_chain_id
        if self.sc_head is not None:
            cp.sc_head = self.sc_head
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_routing_instance (obj.populate_string ("routing_instance"))
        obj.set_prefix ([obj.populate_string ("prefix")])
        obj.set_service_chain_address (obj.populate_string ("service_chain_address"))
        obj.set_service_instance (obj.populate_string ("service_instance"))
        obj.set_source_routing_instance (obj.populate_string ("source_routing_instance"))
        obj.set_service_chain_id (obj.populate_string ("service_chain_id"))
        obj.set_sc_head (obj.populate_boolean ("sc_head"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='ServiceChainInfo', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ServiceChainInfo')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ServiceChainInfo'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ServiceChainInfo', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.routing_instance is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srouting-instance>%s</%srouting-instance>%s' % (namespace_, self.gds_format_string(quote_xml(self.routing_instance).encode(ExternalEncoding), input_name='routing-instance'), namespace_, eol_))
        for prefix_ in self.prefix:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprefix>%s</%sprefix>%s' % (namespace_, self.gds_format_string(quote_xml(prefix_).encode(ExternalEncoding), input_name='prefix'), namespace_, eol_))
        if self.service_chain_address is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sservice-chain-address>%s</%sservice-chain-address>%s' % (namespace_, self.gds_format_string(quote_xml(self.service_chain_address).encode(ExternalEncoding), input_name='service-chain-address'), namespace_, eol_))
        if self.service_instance is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sservice-instance>%s</%sservice-instance>%s' % (namespace_, self.gds_format_string(quote_xml(self.service_instance).encode(ExternalEncoding), input_name='service-instance'), namespace_, eol_))
        if self.source_routing_instance is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssource-routing-instance>%s</%ssource-routing-instance>%s' % (namespace_, self.gds_format_string(quote_xml(self.source_routing_instance).encode(ExternalEncoding), input_name='source-routing-instance'), namespace_, eol_))
        if self.service_chain_id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sservice-chain-id>%s</%sservice-chain-id>%s' % (namespace_, self.gds_format_string(quote_xml(self.service_chain_id).encode(ExternalEncoding), input_name='service-chain-id'), namespace_, eol_))
        if self.sc_head is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssc-head>%s</%ssc-head>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.sc_head)), input_name='sc-head'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.routing_instance is not None or
            self.prefix or
            self.service_chain_address is not None or
            self.service_instance is not None or
            self.source_routing_instance is not None or
            self.service_chain_id is not None or
            self.sc_head is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ServiceChainInfo'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.routing_instance is not None:
            showIndent(outfile, level)
            outfile.write('routing_instance=%s,\n' % quote_python(self.routing_instance).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('prefix=[\n')
        level += 1
        for prefix_ in self.prefix:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(prefix_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.service_chain_address is not None:
            showIndent(outfile, level)
            outfile.write('service_chain_address=%s,\n' % quote_python(self.service_chain_address).encode(ExternalEncoding))
        if self.service_instance is not None:
            showIndent(outfile, level)
            outfile.write('service_instance=%s,\n' % quote_python(self.service_instance).encode(ExternalEncoding))
        if self.source_routing_instance is not None:
            showIndent(outfile, level)
            outfile.write('source_routing_instance=%s,\n' % quote_python(self.source_routing_instance).encode(ExternalEncoding))
        if self.service_chain_id is not None:
            showIndent(outfile, level)
            outfile.write('service_chain_id=%s,\n' % quote_python(self.service_chain_id).encode(ExternalEncoding))
        if self.sc_head is not None:
            showIndent(outfile, level)
            outfile.write('sc_head=%s,\n' % self.sc_head)
    def exportDict(self, name_='ServiceChainInfo'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'routing-instance':
            routing_instance_ = child_.text
            routing_instance_ = self.gds_validate_string(routing_instance_, node, 'routing_instance')
            self.routing_instance = routing_instance_
        elif nodeName_ == 'prefix':
            prefix_ = child_.text
            prefix_ = self.gds_validate_string(prefix_, node, 'prefix')
            self.prefix.append(prefix_)
        elif nodeName_ == 'service-chain-address':
            service_chain_address_ = child_.text
            service_chain_address_ = self.gds_validate_string(service_chain_address_, node, 'service_chain_address')
            self.service_chain_address = service_chain_address_
            self.validate_IpAddress(self.service_chain_address)    # validate type IpAddress
        elif nodeName_ == 'service-instance':
            service_instance_ = child_.text
            service_instance_ = self.gds_validate_string(service_instance_, node, 'service_instance')
            self.service_instance = service_instance_
        elif nodeName_ == 'source-routing-instance':
            source_routing_instance_ = child_.text
            source_routing_instance_ = self.gds_validate_string(source_routing_instance_, node, 'source_routing_instance')
            self.source_routing_instance = source_routing_instance_
        elif nodeName_ == 'service-chain-id':
            service_chain_id_ = child_.text
            service_chain_id_ = self.gds_validate_string(service_chain_id_, node, 'service_chain_id')
            self.service_chain_id = service_chain_id_
        elif nodeName_ == 'sc-head':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'sc_head')
            self.sc_head = ival_
# end class ServiceChainInfo


class StaticRouteType(GeneratedsSuper):
    """
    Attributes:
    * prefix
        Type:           str

    * next_hop
        Type:           str

    * route_target
        Type:           str

    * community
        Type:           str

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'prefix', u'next_hop', u'route_target', u'community']
    attr_field_type_vals = {u'route_target': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': True, 'required': None, 'attr_type': u'string'}, u'prefix': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'next_hop': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'community': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': True, 'required': None, 'attr_type': u'string'}}
    def __init__(self, prefix=None, next_hop=None, route_target=None, community=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _prefix = params_dict[u"prefix"]
        except KeyError:
            _prefix = prefix
        self.prefix = _prefix
        try:
            _next_hop = params_dict[u"next_hop"]
        except KeyError:
            _next_hop = next_hop
        self.next_hop = _next_hop
        try:
            _route_target = params_dict[u"route_target"]
        except KeyError:
            _route_target = route_target
        if not _route_target:
            self.route_target = []
        else:
            self.route_target = _route_target
        try:
            _community = params_dict[u"community"]
        except KeyError:
            _community = community
        if not _community:
            self.community = []
        else:
            self.community = _community
    def factory(*args_, **kwargs_):
        if StaticRouteType.subclass:
            return StaticRouteType.subclass(*args_, **kwargs_)
        else:
            return StaticRouteType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_prefix(self): return self.prefix
    def set_prefix(self, prefix): self.prefix = prefix
    def get_next_hop(self): return self.next_hop
    def set_next_hop(self, next_hop): self.next_hop = next_hop
    def get_route_target(self): return self.route_target
    def set_route_target(self, route_target): self.route_target = route_target
    def add_route_target(self, value): self.route_target.append(value)
    def insert_route_target(self, index, value): self.route_target[index] = value
    def delete_route_target(self, value): self.route_target.remove(value)
    def get_community(self): return self.community
    def set_community(self, community): self.community = community
    def add_community(self, value): self.community.append(value)
    def insert_community(self, index, value): self.community[index] = value
    def delete_community(self, value): self.community.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.prefix == other.prefix and
                    self.next_hop == other.next_hop and
                    self.route_target == other.route_target and
                    self.community == other.community)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.prefix if self.prefix is not None else -7985492147856592190,
                     self.next_hop if self.next_hop is not None else -7985492147856592190,
                     tuple(self.route_target or []),
                     tuple(self.community or [])))

    def __repr__(self):
        return ("prefix = " + str(self.prefix) + ", " +
                "next_hop = " + str(self.next_hop) + ", " +
                "route_target = " + str(self.route_target) + ", " +
                "community = " + str(self.community))

    def copy(self):
        cp = StaticRouteType()
        if self.prefix is not None:
            cp.prefix = self.prefix
        if self.next_hop is not None:
            cp.next_hop = self.next_hop
        if self.route_target is not None:
            cp.route_target = list(self.route_target)
        if self.community is not None:
            cp.community = list(self.community)
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_prefix (obj.populate_string ("prefix"))
        obj.set_next_hop (obj.populate_string ("next_hop"))
        obj.set_route_target ([obj.populate_string ("route_target")])
        obj.set_community ([obj.populate_string ("community")])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='StaticRouteType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StaticRouteType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StaticRouteType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='StaticRouteType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.prefix is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprefix>%s</%sprefix>%s' % (namespace_, self.gds_format_string(quote_xml(self.prefix).encode(ExternalEncoding), input_name='prefix'), namespace_, eol_))
        if self.next_hop is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snext-hop>%s</%snext-hop>%s' % (namespace_, self.gds_format_string(quote_xml(self.next_hop).encode(ExternalEncoding), input_name='next-hop'), namespace_, eol_))
        for route_target_ in self.route_target:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sroute-target>%s</%sroute-target>%s' % (namespace_, self.gds_format_string(quote_xml(route_target_).encode(ExternalEncoding), input_name='route-target'), namespace_, eol_))
        for community_ in self.community:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scommunity>%s</%scommunity>%s' % (namespace_, self.gds_format_string(quote_xml(community_).encode(ExternalEncoding), input_name='community'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.prefix is not None or
            self.next_hop is not None or
            self.route_target or
            self.community
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StaticRouteType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.prefix is not None:
            showIndent(outfile, level)
            outfile.write('prefix=%s,\n' % quote_python(self.prefix).encode(ExternalEncoding))
        if self.next_hop is not None:
            showIndent(outfile, level)
            outfile.write('next_hop=%s,\n' % quote_python(self.next_hop).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('route_target=[\n')
        level += 1
        for route_target_ in self.route_target:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(route_target_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('community=[\n')
        level += 1
        for community_ in self.community:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(community_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='StaticRouteType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'prefix':
            prefix_ = child_.text
            prefix_ = self.gds_validate_string(prefix_, node, 'prefix')
            self.prefix = prefix_
        elif nodeName_ == 'next-hop':
            next_hop_ = child_.text
            next_hop_ = self.gds_validate_string(next_hop_, node, 'next_hop')
            self.next_hop = next_hop_
        elif nodeName_ == 'route-target':
            route_target_ = child_.text
            route_target_ = self.gds_validate_string(route_target_, node, 'route_target')
            self.route_target.append(route_target_)
        elif nodeName_ == 'community':
            community_ = child_.text
            community_ = self.gds_validate_string(community_, node, 'community')
            self.community.append(community_)
# end class StaticRouteType


class StaticRouteEntriesType(GeneratedsSuper):
    """
    Attributes:
    * route
        Type:           :class:`.StaticRouteType`

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'route']
    attr_field_type_vals = {u'route': {'restrictions': None, 'description': [], 'simple_type': u'StaticRouteType', 'is_complex': 1, 'restriction_type': None, 'is_array': True, 'required': None, 'attr_type': u'StaticRouteType'}}
    def __init__(self, route=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _route = params_dict[u"route"]
        except KeyError:
            _route = route
        if not _route:
            self.route = []
        else:
            if isinstance(_route[0], dict):
                objs = [StaticRouteType(params_dict=elem) for elem in _route]
                self.route = objs
            else:
                self.route = _route
    def factory(*args_, **kwargs_):
        if StaticRouteEntriesType.subclass:
            return StaticRouteEntriesType.subclass(*args_, **kwargs_)
        else:
            return StaticRouteEntriesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_route(self): return self.route
    def set_route(self, route): self.route = route
    def add_route(self, value): self.route.append(value)
    def insert_route(self, index, value): self.route[index] = value
    def delete_route(self, value): self.route.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.route == other.route)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.route or [])))

    def __repr__(self):
        return ("route = " + str(self.route))

    def copy(self):
        cp = StaticRouteEntriesType()
        if self.route is not None:
            cp.route = [x.copy() for x in self.route]
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_route ([StaticRouteType.populate ()])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='StaticRouteEntriesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StaticRouteEntriesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StaticRouteEntriesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='StaticRouteEntriesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for route_ in self.route:
            if isinstance(route_, dict):
                route_ = StaticRouteType(**route_)
            route_.export_xml(outfile, level, namespace_, name_='route', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.route
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StaticRouteEntriesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('route=[\n')
        level += 1
        for route_ in self.route:
            showIndent(outfile, level)
            outfile.write('model_.StaticRouteType(\n')
            route_.exportLiteral(outfile, level, name_='StaticRouteType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='StaticRouteEntriesType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'route':
            obj_ = StaticRouteType.factory()
            obj_.build(child_)
            self.route.append(obj_)
# end class StaticRouteEntriesType


class ProtocolBgpType(GeneratedsSuper):
    """
    Attributes:
    * autonomous_system
        Type:           int

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'autonomous_system']
    attr_field_type_vals = {u'autonomous_system': {'restrictions': None, 'description': [], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'integer'}}
    def __init__(self, autonomous_system=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _autonomous_system = params_dict[u"autonomous_system"]
        except KeyError:
            _autonomous_system = autonomous_system
        self.autonomous_system = _autonomous_system
    def factory(*args_, **kwargs_):
        if ProtocolBgpType.subclass:
            return ProtocolBgpType.subclass(*args_, **kwargs_)
        else:
            return ProtocolBgpType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_autonomous_system(self): return self.autonomous_system
    def set_autonomous_system(self, autonomous_system): self.autonomous_system = autonomous_system
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.autonomous_system == other.autonomous_system)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.autonomous_system if self.autonomous_system is not None else -7985492147856592190))

    def __repr__(self):
        return ("autonomous_system = " + str(self.autonomous_system))

    def copy(self):
        cp = ProtocolBgpType()
        if self.autonomous_system is not None:
            cp.autonomous_system = self.autonomous_system
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_autonomous_system (obj.populate_integer ("autonomous_system"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='ProtocolBgpType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProtocolBgpType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ProtocolBgpType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ProtocolBgpType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.autonomous_system is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sautonomous-system>%s</%sautonomous-system>%s' % (namespace_, self.gds_format_integer(self.autonomous_system, input_name='autonomous-system'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.autonomous_system is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ProtocolBgpType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.autonomous_system is not None:
            showIndent(outfile, level)
            outfile.write('autonomous_system=%d,\n' % self.autonomous_system)
    def exportDict(self, name_='ProtocolBgpType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'autonomous-system':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'autonomous_system')
            self.autonomous_system = ival_
# end class ProtocolBgpType


class ProtocolOspfType(GeneratedsSuper):
    """
    Attributes:
    * area
        Type:           int

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'area']
    attr_field_type_vals = {u'area': {'restrictions': None, 'description': [], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'integer'}}
    def __init__(self, area=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _area = params_dict[u"area"]
        except KeyError:
            _area = area
        self.area = _area
    def factory(*args_, **kwargs_):
        if ProtocolOspfType.subclass:
            return ProtocolOspfType.subclass(*args_, **kwargs_)
        else:
            return ProtocolOspfType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_area(self): return self.area
    def set_area(self, area): self.area = area
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.area == other.area)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.area if self.area is not None else -7985492147856592190))

    def __repr__(self):
        return ("area = " + str(self.area))

    def copy(self):
        cp = ProtocolOspfType()
        if self.area is not None:
            cp.area = self.area
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_area (obj.populate_integer ("area"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='ProtocolOspfType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProtocolOspfType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ProtocolOspfType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ProtocolOspfType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.area is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sarea>%s</%sarea>%s' % (namespace_, self.gds_format_integer(self.area, input_name='area'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.area is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ProtocolOspfType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.area is not None:
            showIndent(outfile, level)
            outfile.write('area=%d,\n' % self.area)
    def exportDict(self, name_='ProtocolOspfType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'area':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'area')
            self.area = ival_
# end class ProtocolOspfType


class ProtocolStaticType(GeneratedsSuper):
    """
    Attributes:
    * route
        Type:           :class:`.IpPrefixType`

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'route']
    attr_field_type_vals = {u'route': {'restrictions': None, 'description': [], 'simple_type': u'IpPrefixType', 'is_complex': 0, 'restriction_type': None, 'is_array': True, 'required': None, 'attr_type': u'string'}}
    def __init__(self, route=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _route = params_dict[u"route"]
        except KeyError:
            _route = route
        if not _route:
            self.route = []
        else:
            self.route = _route
    def factory(*args_, **kwargs_):
        if ProtocolStaticType.subclass:
            return ProtocolStaticType.subclass(*args_, **kwargs_)
        else:
            return ProtocolStaticType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_route(self): return self.route
    def set_route(self, route): self.route = route
    def add_route(self, value): self.route.append(value)
    def insert_route(self, index, value): self.route[index] = value
    def delete_route(self, value): self.route.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.route == other.route)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.route or [])))

    def __repr__(self):
        return ("route = " + str(self.route))

    def copy(self):
        cp = ProtocolStaticType()
        if self.route is not None:
            cp.route = list(self.route)
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_route ([obj.populate_string ("route")])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='ProtocolStaticType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProtocolStaticType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ProtocolStaticType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ProtocolStaticType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for route_ in self.route:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sroute>%s</%sroute>%s' % (namespace_, self.gds_format_string(quote_xml(route_).encode(ExternalEncoding), input_name='route'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.route
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ProtocolStaticType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('route=[\n')
        level += 1
        for route_ in self.route:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(route_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='ProtocolStaticType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'route':
            route_ = child_.text
            route_ = self.gds_validate_string(route_, node, 'route')
            self.route.append(route_)
# end class ProtocolStaticType


class ConnectionType(GeneratedsSuper):
    """
    Attributes:
    * destination_instance
        Type:           str

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'destination_instance']
    attr_field_type_vals = {u'destination_instance': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}}
    def __init__(self, destination_instance=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _destination_instance = params_dict[u"destination_instance"]
        except KeyError:
            _destination_instance = destination_instance
        self.destination_instance = _destination_instance
    def factory(*args_, **kwargs_):
        if ConnectionType.subclass:
            return ConnectionType.subclass(*args_, **kwargs_)
        else:
            return ConnectionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_destination_instance(self): return self.destination_instance
    def set_destination_instance(self, destination_instance): self.destination_instance = destination_instance
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.destination_instance == other.destination_instance)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.destination_instance if self.destination_instance is not None else -7985492147856592190))

    def __repr__(self):
        return ("destination_instance = " + str(self.destination_instance))

    def copy(self):
        cp = ConnectionType()
        if self.destination_instance is not None:
            cp.destination_instance = self.destination_instance
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_destination_instance (obj.populate_string ("destination_instance"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='ConnectionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConnectionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ConnectionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ConnectionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.destination_instance is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdestination-instance>%s</%sdestination-instance>%s' % (namespace_, self.gds_format_string(quote_xml(self.destination_instance).encode(ExternalEncoding), input_name='destination-instance'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.destination_instance is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ConnectionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.destination_instance is not None:
            showIndent(outfile, level)
            outfile.write('destination_instance=%s,\n' % quote_python(self.destination_instance).encode(ExternalEncoding))
    def exportDict(self, name_='ConnectionType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'destination-instance':
            destination_instance_ = child_.text
            destination_instance_ = self.gds_validate_string(destination_instance_, node, 'destination_instance')
            self.destination_instance = destination_instance_
# end class ConnectionType


class InstanceTargetType(GeneratedsSuper):
    """
    Attributes:
    * import_export
        Type:           str, *one-of* [u'import', u'export']

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'import_export']
    attr_field_type_vals = {u'import_export': {'restrictions': [u'import', u'export'], 'description': [], 'simple_type': u'ImportExportType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': None, 'attr_type': u'string'}}
    def __init__(self, import_export=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _import_export = params_dict[u"import_export"]
        except KeyError:
            _import_export = import_export
        self.import_export = _import_export
    def factory(*args_, **kwargs_):
        if InstanceTargetType.subclass:
            return InstanceTargetType.subclass(*args_, **kwargs_)
        else:
            return InstanceTargetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_import_export(self): return self.import_export
    def set_import_export(self, import_export): self.import_export = import_export
    def validate_ImportExportType(self, value):
        # Validate type ImportExportType, a restriction on xsd:string.
        error = False
        if isinstance(value, list):
            error = set(value) - set([u'import', u'export'])
        else:
            error = value not in [u'import', u'export']
        if error:
            raise ValueError("ImportExportType must be one of [u'import', u'export']")
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.import_export == other.import_export)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.import_export if self.import_export is not None else -7985492147856592190))

    def __repr__(self):
        return ("import_export = " + str(self.import_export))

    def copy(self):
        cp = InstanceTargetType()
        if self.import_export is not None:
            cp.import_export = self.import_export
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_import_export (obj.populate_string ("import_export"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='InstanceTargetType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InstanceTargetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InstanceTargetType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='InstanceTargetType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.import_export is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%simport-export>%s</%simport-export>%s' % (namespace_, self.gds_format_string(quote_xml(self.import_export).encode(ExternalEncoding), input_name='import-export'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.import_export is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='InstanceTargetType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.import_export is not None:
            showIndent(outfile, level)
            outfile.write('import_export=%s,\n' % quote_python(self.import_export).encode(ExternalEncoding))
    def exportDict(self, name_='InstanceTargetType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'import-export':
            import_export_ = child_.text
            import_export_ = self.gds_validate_string(import_export_, node, 'import_export')
            self.import_export = import_export_
            self.validate_ImportExportType(self.import_export)    # validate type ImportExportType
# end class InstanceTargetType


class DefaultProtocolType(GeneratedsSuper):
    """
    Attributes:
    * bgp
        Type:           :class:`.ProtocolBgpType`

    * ospf
        Type:           :class:`.ProtocolOspfType`

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'bgp', u'ospf']
    attr_field_type_vals = {u'bgp': {'restrictions': None, 'description': [], 'simple_type': u'ProtocolBgpType', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'ProtocolBgpType'}, u'ospf': {'restrictions': None, 'description': [], 'simple_type': u'ProtocolOspfType', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'ProtocolOspfType'}}
    def __init__(self, bgp=None, ospf=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _bgp = params_dict[u"bgp"]
        except KeyError:
            _bgp = bgp
        if isinstance(_bgp, dict):
            obj = ProtocolBgpType(params_dict=_bgp)
            self.bgp = obj
        else:
            self.bgp = _bgp
        try:
            _ospf = params_dict[u"ospf"]
        except KeyError:
            _ospf = ospf
        if isinstance(_ospf, dict):
            obj = ProtocolOspfType(params_dict=_ospf)
            self.ospf = obj
        else:
            self.ospf = _ospf
    def factory(*args_, **kwargs_):
        if DefaultProtocolType.subclass:
            return DefaultProtocolType.subclass(*args_, **kwargs_)
        else:
            return DefaultProtocolType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_bgp(self): return self.bgp
    def set_bgp(self, bgp): self.bgp = bgp
    def get_ospf(self): return self.ospf
    def set_ospf(self, ospf): self.ospf = ospf
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.bgp == other.bgp and
                    self.ospf == other.ospf)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.bgp if self.bgp is not None else -7985492147856592190,
                     self.ospf if self.ospf is not None else -7985492147856592190))

    def __repr__(self):
        return ("bgp = " + str(self.bgp) + ", " +
                "ospf = " + str(self.ospf))

    def copy(self):
        cp = DefaultProtocolType()
        if self.bgp is not None:
            cp.bgp = self.bgp.copy()
        if self.ospf is not None:
            cp.ospf = self.ospf.copy()
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_bgp (ProtocolBgpType.populate ())
        obj.set_ospf (ProtocolOspfType.populate ())
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='DefaultProtocolType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DefaultProtocolType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DefaultProtocolType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DefaultProtocolType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.bgp is not None:
            self.bgp.export_xml(outfile, level, namespace_, name_='bgp', pretty_print=pretty_print)
        if self.ospf is not None:
            self.ospf.export_xml(outfile, level, namespace_, name_='ospf', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.bgp is not None or
            self.ospf is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DefaultProtocolType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.bgp is not None:
            showIndent(outfile, level)
            outfile.write('bgp=model_.ProtocolBgpType(\n')
            self.bgp.exportLiteral(outfile, level, name_='bgp')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ospf is not None:
            showIndent(outfile, level)
            outfile.write('ospf=model_.ProtocolOspfType(\n')
            self.ospf.exportLiteral(outfile, level, name_='ospf')
            showIndent(outfile, level)
            outfile.write('),\n')
    def exportDict(self, name_='DefaultProtocolType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'bgp':
            obj_ = ProtocolBgpType.factory()
            obj_.build(child_)
            self.set_bgp(obj_)
        elif nodeName_ == 'ospf':
            obj_ = ProtocolOspfType.factory()
            obj_.build(child_)
            self.set_ospf(obj_)
# end class DefaultProtocolType


class BindingType(GeneratedsSuper):
    """
    Attributes:
    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = []
    attr_field_type_vals = {}
    def __init__(self, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        pass
    def factory(*args_, **kwargs_):
        if BindingType.subclass:
            return BindingType.subclass(*args_, **kwargs_)
        else:
            return BindingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def __eq__(self, other): return True
    def __ne__(self, other): return False
    def __hash__(self): return 0
    def __repr__(self): return 
    def copy(self): return BindingType()
    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='BindingType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BindingType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BindingType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='BindingType', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BindingType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def exportDict(self, name_='BindingType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class BindingType


class AttachmentAddressType(GeneratedsSuper):
    """
    Attributes:
    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = []
    attr_field_type_vals = {}
    def __init__(self, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        pass
    def factory(*args_, **kwargs_):
        if AttachmentAddressType.subclass:
            return AttachmentAddressType.subclass(*args_, **kwargs_)
        else:
            return AttachmentAddressType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def __eq__(self, other): return True
    def __ne__(self, other): return False
    def __hash__(self): return 0
    def __repr__(self): return 
    def copy(self): return AttachmentAddressType()
    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='AttachmentAddressType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AttachmentAddressType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AttachmentAddressType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AttachmentAddressType', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AttachmentAddressType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def exportDict(self, name_='AttachmentAddressType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AttachmentAddressType


class AttachmentInfoType(GeneratedsSuper):
    """
    Attributes:
    * static
        Type:           :class:`.ProtocolStaticType`

    * bgp
        Type:           :class:`.ProtocolBgpType`

    * ospf
        Type:           :class:`.ProtocolOspfType`

    * state
        Type:           str, *one-of* xsd:string

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'static', u'bgp', u'ospf', u'state']
    attr_field_type_vals = {u'bgp': {'restrictions': None, 'description': [], 'simple_type': u'ProtocolBgpType', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'ProtocolBgpType'}, u'ospf': {'restrictions': None, 'description': [], 'simple_type': u'ProtocolOspfType', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'ProtocolOspfType'}, u'state': {'restrictions': [], 'description': [], 'simple_type': u'ProtocolStateType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': None, 'attr_type': u'string'}, u'static': {'restrictions': None, 'description': [], 'simple_type': u'ProtocolStaticType', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'ProtocolStaticType'}}
    def __init__(self, static=None, bgp=None, ospf=None, state=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _static = params_dict[u"static"]
        except KeyError:
            _static = static
        if isinstance(_static, dict):
            obj = ProtocolStaticType(params_dict=_static)
            self.static = obj
        else:
            self.static = _static
        try:
            _bgp = params_dict[u"bgp"]
        except KeyError:
            _bgp = bgp
        if isinstance(_bgp, dict):
            obj = ProtocolBgpType(params_dict=_bgp)
            self.bgp = obj
        else:
            self.bgp = _bgp
        try:
            _ospf = params_dict[u"ospf"]
        except KeyError:
            _ospf = ospf
        if isinstance(_ospf, dict):
            obj = ProtocolOspfType(params_dict=_ospf)
            self.ospf = obj
        else:
            self.ospf = _ospf
        try:
            _state = params_dict[u"state"]
        except KeyError:
            _state = state
        self.state = _state
    def factory(*args_, **kwargs_):
        if AttachmentInfoType.subclass:
            return AttachmentInfoType.subclass(*args_, **kwargs_)
        else:
            return AttachmentInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_static(self): return self.static
    def set_static(self, static): self.static = static
    def get_bgp(self): return self.bgp
    def set_bgp(self, bgp): self.bgp = bgp
    def get_ospf(self): return self.ospf
    def set_ospf(self, ospf): self.ospf = ospf
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def validate_ProtocolStateType(self, value):
        # Validate type ProtocolStateType, a restriction on xsd:string.
        pass
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.static == other.static and
                    self.bgp == other.bgp and
                    self.ospf == other.ospf and
                    self.state == other.state)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.static if self.static is not None else -7985492147856592190,
                     self.bgp if self.bgp is not None else -7985492147856592190,
                     self.ospf if self.ospf is not None else -7985492147856592190,
                     self.state if self.state is not None else -7985492147856592190))

    def __repr__(self):
        return ("static = " + str(self.static) + ", " +
                "bgp = " + str(self.bgp) + ", " +
                "ospf = " + str(self.ospf) + ", " +
                "state = " + str(self.state))

    def copy(self):
        cp = AttachmentInfoType()
        if self.static is not None:
            cp.static = self.static.copy()
        if self.bgp is not None:
            cp.bgp = self.bgp.copy()
        if self.ospf is not None:
            cp.ospf = self.ospf.copy()
        if self.state is not None:
            cp.state = self.state
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_static (ProtocolStaticType.populate ())
        obj.set_bgp (ProtocolBgpType.populate ())
        obj.set_ospf (ProtocolOspfType.populate ())
        obj.set_state (obj.populate_string ("state"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='AttachmentInfoType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AttachmentInfoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AttachmentInfoType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AttachmentInfoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.static is not None:
            self.static.export_xml(outfile, level, namespace_, name_='static', pretty_print=pretty_print)
        if self.bgp is not None:
            self.bgp.export_xml(outfile, level, namespace_, name_='bgp', pretty_print=pretty_print)
        if self.ospf is not None:
            self.ospf.export_xml(outfile, level, namespace_, name_='ospf', pretty_print=pretty_print)
        if self.state is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstate>%s</%sstate>%s' % (namespace_, self.gds_format_string(quote_xml(self.state).encode(ExternalEncoding), input_name='state'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.static is not None or
            self.bgp is not None or
            self.ospf is not None or
            self.state is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AttachmentInfoType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.static is not None:
            showIndent(outfile, level)
            outfile.write('static=model_.ProtocolStaticType(\n')
            self.static.exportLiteral(outfile, level, name_='static')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.bgp is not None:
            showIndent(outfile, level)
            outfile.write('bgp=model_.ProtocolBgpType(\n')
            self.bgp.exportLiteral(outfile, level, name_='bgp')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ospf is not None:
            showIndent(outfile, level)
            outfile.write('ospf=model_.ProtocolOspfType(\n')
            self.ospf.exportLiteral(outfile, level, name_='ospf')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.state is not None:
            showIndent(outfile, level)
            outfile.write('state=%s,\n' % quote_python(self.state).encode(ExternalEncoding))
    def exportDict(self, name_='AttachmentInfoType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'static':
            obj_ = ProtocolStaticType.factory()
            obj_.build(child_)
            self.set_static(obj_)
        elif nodeName_ == 'bgp':
            obj_ = ProtocolBgpType.factory()
            obj_.build(child_)
            self.set_bgp(obj_)
        elif nodeName_ == 'ospf':
            obj_ = ProtocolOspfType.factory()
            obj_.build(child_)
            self.set_ospf(obj_)
        elif nodeName_ == 'state':
            state_ = child_.text
            state_ = self.gds_validate_string(state_, node, 'state')
            self.state = state_
            self.validate_ProtocolStateType(self.state)    # validate type ProtocolStateType
# end class AttachmentInfoType


class PolicyStatementType(GeneratedsSuper):
    """
    Attributes:
    * term
        Type:           :class:`.PolicyTermType`

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'term']
    attr_field_type_vals = {u'term': {'restrictions': None, 'description': [], 'simple_type': u'PolicyTermType', 'is_complex': 1, 'restriction_type': None, 'is_array': True, 'required': None, 'attr_type': u'PolicyTermType'}}
    def __init__(self, term=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _term = params_dict[u"term"]
        except KeyError:
            _term = term
        if not _term:
            self.term = []
        else:
            if isinstance(_term[0], dict):
                objs = [PolicyTermType(params_dict=elem) for elem in _term]
                self.term = objs
            else:
                self.term = _term
    def factory(*args_, **kwargs_):
        if PolicyStatementType.subclass:
            return PolicyStatementType.subclass(*args_, **kwargs_)
        else:
            return PolicyStatementType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_term(self): return self.term
    def set_term(self, term): self.term = term
    def add_term(self, value): self.term.append(value)
    def insert_term(self, index, value): self.term[index] = value
    def delete_term(self, value): self.term.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.term == other.term)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.term or [])))

    def __repr__(self):
        return ("term = " + str(self.term))

    def copy(self):
        cp = PolicyStatementType()
        if self.term is not None:
            cp.term = [x.copy() for x in self.term]
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_term ([PolicyTermType.populate ()])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='PolicyStatementType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PolicyStatementType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PolicyStatementType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PolicyStatementType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for term_ in self.term:
            if isinstance(term_, dict):
                term_ = PolicyTermType(**term_)
            term_.export_xml(outfile, level, namespace_, name_='term', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.term
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PolicyStatementType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('term=[\n')
        level += 1
        for term_ in self.term:
            showIndent(outfile, level)
            outfile.write('model_.PolicyTermType(\n')
            term_.exportLiteral(outfile, level, name_='PolicyTermType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='PolicyStatementType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'term':
            obj_ = PolicyTermType.factory()
            obj_.build(child_)
            self.term.append(obj_)
# end class PolicyStatementType


class AsListType(GeneratedsSuper):
    """
    Attributes:
    * asn_list
        Type:           int

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'asn_list']
    attr_field_type_vals = {u'asn_list': {'restrictions': None, 'description': [], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': True, 'required': None, 'attr_type': u'integer'}}
    def __init__(self, asn_list=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _asn_list = params_dict[u"asn_list"]
        except KeyError:
            _asn_list = asn_list
        if not _asn_list:
            self.asn_list = []
        else:
            self.asn_list = _asn_list
    def factory(*args_, **kwargs_):
        if AsListType.subclass:
            return AsListType.subclass(*args_, **kwargs_)
        else:
            return AsListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_asn_list(self): return self.asn_list
    def set_asn_list(self, asn_list): self.asn_list = asn_list
    def add_asn_list(self, value): self.asn_list.append(value)
    def insert_asn_list(self, index, value): self.asn_list[index] = value
    def delete_asn_list(self, value): self.asn_list.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.asn_list == other.asn_list)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.asn_list or [])))

    def __repr__(self):
        return ("asn_list = " + str(self.asn_list))

    def copy(self):
        cp = AsListType()
        if self.asn_list is not None:
            cp.asn_list = list(self.asn_list)
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_asn_list ([obj.populate_integer ("asn_list")])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='AsListType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AsListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AsListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AsListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for asn_list_ in self.asn_list:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sasn-list>%s</%sasn-list>%s' % (namespace_, self.gds_format_integer(asn_list_, input_name='asn-list'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.asn_list
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AsListType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('asn_list=[\n')
        level += 1
        for asn_list_ in self.asn_list:
            showIndent(outfile, level)
            outfile.write('%d,\n' % asn_list)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='AsListType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'asn-list':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'asn_list')
            self.asn_list.append(ival_)
# end class AsListType


class ActionAsPathType(GeneratedsSuper):
    """
    Attributes:
    * expand
        Type:           :class:`.AsListType`

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'expand']
    attr_field_type_vals = {u'expand': {'restrictions': None, 'description': [], 'simple_type': u'AsListType', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'AsListType'}}
    def __init__(self, expand=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _expand = params_dict[u"expand"]
        except KeyError:
            _expand = expand
        if isinstance(_expand, dict):
            obj = AsListType(params_dict=_expand)
            self.expand = obj
        else:
            self.expand = _expand
    def factory(*args_, **kwargs_):
        if ActionAsPathType.subclass:
            return ActionAsPathType.subclass(*args_, **kwargs_)
        else:
            return ActionAsPathType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_expand(self): return self.expand
    def set_expand(self, expand): self.expand = expand
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.expand == other.expand)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.expand if self.expand is not None else -7985492147856592190))

    def __repr__(self):
        return ("expand = " + str(self.expand))

    def copy(self):
        cp = ActionAsPathType()
        if self.expand is not None:
            cp.expand = self.expand.copy()
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_expand (AsListType.populate ())
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='ActionAsPathType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActionAsPathType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ActionAsPathType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ActionAsPathType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.expand is not None:
            self.expand.export_xml(outfile, level, namespace_, name_='expand', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.expand is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ActionAsPathType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.expand is not None:
            showIndent(outfile, level)
            outfile.write('expand=model_.AsListType(\n')
            self.expand.exportLiteral(outfile, level, name_='expand')
            showIndent(outfile, level)
            outfile.write('),\n')
    def exportDict(self, name_='ActionAsPathType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'expand':
            obj_ = AsListType.factory()
            obj_.build(child_)
            self.set_expand(obj_)
# end class ActionAsPathType


class CommunityListType(GeneratedsSuper):
    """
    Attributes:
    * community
        Type:           str, *one-of* xsd:string

        Description:
          List of Community attributes, it indicates the attributes with which the routes

          are tagged while publishing.

          The attributes will be represented as bgp community in the path attribute.

          Each attribute is indicated as string.

              1. String with two integers separated by ":". E.g. "64512:123"

              2. Well-known community as string.

                 Possible values are "no-export" "accept-own" "no-advertise" "no-export-

          subconfed" "no-reoriginate"

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'community']
    attr_field_type_vals = {u'community': {'restrictions': [], 'description': [], 'simple_type': u'CommunityAttribute', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': True, 'required': None, 'attr_type': u'string'}}
    def __init__(self, community=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _community = params_dict[u"community"]
        except KeyError:
            _community = community
        if not _community:
            self.community = []
        else:
            self.community = _community
    def factory(*args_, **kwargs_):
        if CommunityListType.subclass:
            return CommunityListType.subclass(*args_, **kwargs_)
        else:
            return CommunityListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_community(self): return self.community
    def set_community(self, community): self.community = community
    def add_community(self, value): self.community.append(value)
    def insert_community(self, index, value): self.community[index] = value
    def delete_community(self, value): self.community.remove(value)
    def validate_CommunityAttribute(self, value):
        # Validate type CommunityAttribute, a restriction on xsd:string.
        pass
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.community == other.community)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.community or [])))

    def __repr__(self):
        return ("community = " + str(self.community))

    def copy(self):
        cp = CommunityListType()
        if self.community is not None:
            cp.community = list(self.community)
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_community ([obj.populate_string ("community")])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='CommunityListType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommunityListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommunityListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CommunityListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for community_ in self.community:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scommunity>%s</%scommunity>%s' % (namespace_, self.gds_format_string(quote_xml(community_).encode(ExternalEncoding), input_name='community'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.community
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CommunityListType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('community=[\n')
        level += 1
        for community_ in self.community:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(community_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='CommunityListType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'community':
            community_ = child_.text
            community_ = self.gds_validate_string(community_, node, 'community')
            self.community.append(community_)
            self.validate_CommunityAttribute(self.community)    # validate type CommunityAttribute
# end class CommunityListType


class ExtCommunityListType(GeneratedsSuper):
    """
    Attributes:
    * community
        Type:           str

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'community']
    attr_field_type_vals = {u'community': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': True, 'required': None, 'attr_type': u'string'}}
    def __init__(self, community=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _community = params_dict[u"community"]
        except KeyError:
            _community = community
        if not _community:
            self.community = []
        else:
            self.community = _community
    def factory(*args_, **kwargs_):
        if ExtCommunityListType.subclass:
            return ExtCommunityListType.subclass(*args_, **kwargs_)
        else:
            return ExtCommunityListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_community(self): return self.community
    def set_community(self, community): self.community = community
    def add_community(self, value): self.community.append(value)
    def insert_community(self, index, value): self.community[index] = value
    def delete_community(self, value): self.community.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.community == other.community)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.community or [])))

    def __repr__(self):
        return ("community = " + str(self.community))

    def copy(self):
        cp = ExtCommunityListType()
        if self.community is not None:
            cp.community = list(self.community)
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_community ([obj.populate_string ("community")])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='ExtCommunityListType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExtCommunityListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExtCommunityListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ExtCommunityListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for community_ in self.community:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scommunity>%s</%scommunity>%s' % (namespace_, self.gds_format_string(quote_xml(community_).encode(ExternalEncoding), input_name='community'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.community
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ExtCommunityListType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('community=[\n')
        level += 1
        for community_ in self.community:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(community_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='ExtCommunityListType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'community':
            community_ = child_.text
            community_ = self.gds_validate_string(community_, node, 'community')
            self.community.append(community_)
# end class ExtCommunityListType


class ActionCommunityType(GeneratedsSuper):
    """
    Attributes:
    * add
        Type:           :class:`.CommunityListType`

    * remove
        Type:           :class:`.CommunityListType`

    * set
        Type:           :class:`.CommunityListType`

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'add', u'remove', u'set']
    attr_field_type_vals = {u'add': {'restrictions': None, 'description': [], 'simple_type': u'CommunityListType', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'CommunityListType'}, u'set': {'restrictions': None, 'description': [], 'simple_type': u'CommunityListType', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'CommunityListType'}, u'remove': {'restrictions': None, 'description': [], 'simple_type': u'CommunityListType', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'CommunityListType'}}
    def __init__(self, add=None, remove=None, set=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _add = params_dict[u"add"]
        except KeyError:
            _add = add
        if isinstance(_add, dict):
            obj = CommunityListType(params_dict=_add)
            self.add = obj
        else:
            self.add = _add
        try:
            _remove = params_dict[u"remove"]
        except KeyError:
            _remove = remove
        if isinstance(_remove, dict):
            obj = CommunityListType(params_dict=_remove)
            self.remove = obj
        else:
            self.remove = _remove
        try:
            _set = params_dict[u"set"]
        except KeyError:
            _set = set
        if isinstance(_set, dict):
            obj = CommunityListType(params_dict=_set)
            self.set = obj
        else:
            self.set = _set
    def factory(*args_, **kwargs_):
        if ActionCommunityType.subclass:
            return ActionCommunityType.subclass(*args_, **kwargs_)
        else:
            return ActionCommunityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_add(self): return self.add
    def set_add(self, add): self.add = add
    def get_remove(self): return self.remove
    def set_remove(self, remove): self.remove = remove
    def get_set(self): return self.set
    def set_set(self, set): self.set = set
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.add == other.add and
                    self.remove == other.remove and
                    self.set == other.set)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.add if self.add is not None else -7985492147856592190,
                     self.remove if self.remove is not None else -7985492147856592190,
                     self.set if self.set is not None else -7985492147856592190))

    def __repr__(self):
        return ("add = " + str(self.add) + ", " +
                "remove = " + str(self.remove) + ", " +
                "set = " + str(self.set))

    def copy(self):
        cp = ActionCommunityType()
        if self.add is not None:
            cp.add = self.add.copy()
        if self.remove is not None:
            cp.remove = self.remove.copy()
        if self.set is not None:
            cp.set = self.set.copy()
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_add (CommunityListType.populate ())
        obj.set_remove (CommunityListType.populate ())
        obj.set_set (CommunityListType.populate ())
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='ActionCommunityType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActionCommunityType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ActionCommunityType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ActionCommunityType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.add is not None:
            self.add.export_xml(outfile, level, namespace_, name_='add', pretty_print=pretty_print)
        if self.remove is not None:
            self.remove.export_xml(outfile, level, namespace_, name_='remove', pretty_print=pretty_print)
        if self.set is not None:
            self.set.export_xml(outfile, level, namespace_, name_='set', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.add is not None or
            self.remove is not None or
            self.set is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ActionCommunityType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.add is not None:
            showIndent(outfile, level)
            outfile.write('add=model_.CommunityListType(\n')
            self.add.exportLiteral(outfile, level, name_='add')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.remove is not None:
            showIndent(outfile, level)
            outfile.write('remove=model_.CommunityListType(\n')
            self.remove.exportLiteral(outfile, level, name_='remove')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.set is not None:
            showIndent(outfile, level)
            outfile.write('set=model_.CommunityListType(\n')
            self.set.exportLiteral(outfile, level, name_='set')
            showIndent(outfile, level)
            outfile.write('),\n')
    def exportDict(self, name_='ActionCommunityType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'add':
            obj_ = CommunityListType.factory()
            obj_.build(child_)
            self.set_add(obj_)
        elif nodeName_ == 'remove':
            obj_ = CommunityListType.factory()
            obj_.build(child_)
            self.set_remove(obj_)
        elif nodeName_ == 'set':
            obj_ = CommunityListType.factory()
            obj_.build(child_)
            self.set_set(obj_)
# end class ActionCommunityType


class ActionExtCommunityType(GeneratedsSuper):
    """
    Attributes:
    * add
        Type:           :class:`.ExtCommunityListType`

    * remove
        Type:           :class:`.ExtCommunityListType`

    * set
        Type:           :class:`.ExtCommunityListType`

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'add', u'remove', u'set']
    attr_field_type_vals = {u'add': {'restrictions': None, 'description': [], 'simple_type': u'ExtCommunityListType', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'ExtCommunityListType'}, u'set': {'restrictions': None, 'description': [], 'simple_type': u'ExtCommunityListType', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'ExtCommunityListType'}, u'remove': {'restrictions': None, 'description': [], 'simple_type': u'ExtCommunityListType', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'ExtCommunityListType'}}
    def __init__(self, add=None, remove=None, set=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _add = params_dict[u"add"]
        except KeyError:
            _add = add
        if isinstance(_add, dict):
            obj = ExtCommunityListType(params_dict=_add)
            self.add = obj
        else:
            self.add = _add
        try:
            _remove = params_dict[u"remove"]
        except KeyError:
            _remove = remove
        if isinstance(_remove, dict):
            obj = ExtCommunityListType(params_dict=_remove)
            self.remove = obj
        else:
            self.remove = _remove
        try:
            _set = params_dict[u"set"]
        except KeyError:
            _set = set
        if isinstance(_set, dict):
            obj = ExtCommunityListType(params_dict=_set)
            self.set = obj
        else:
            self.set = _set
    def factory(*args_, **kwargs_):
        if ActionExtCommunityType.subclass:
            return ActionExtCommunityType.subclass(*args_, **kwargs_)
        else:
            return ActionExtCommunityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_add(self): return self.add
    def set_add(self, add): self.add = add
    def get_remove(self): return self.remove
    def set_remove(self, remove): self.remove = remove
    def get_set(self): return self.set
    def set_set(self, set): self.set = set
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.add == other.add and
                    self.remove == other.remove and
                    self.set == other.set)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.add if self.add is not None else -7985492147856592190,
                     self.remove if self.remove is not None else -7985492147856592190,
                     self.set if self.set is not None else -7985492147856592190))

    def __repr__(self):
        return ("add = " + str(self.add) + ", " +
                "remove = " + str(self.remove) + ", " +
                "set = " + str(self.set))

    def copy(self):
        cp = ActionExtCommunityType()
        if self.add is not None:
            cp.add = self.add.copy()
        if self.remove is not None:
            cp.remove = self.remove.copy()
        if self.set is not None:
            cp.set = self.set.copy()
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_add (ExtCommunityListType.populate ())
        obj.set_remove (ExtCommunityListType.populate ())
        obj.set_set (ExtCommunityListType.populate ())
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='ActionExtCommunityType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActionExtCommunityType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ActionExtCommunityType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ActionExtCommunityType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.add is not None:
            self.add.export_xml(outfile, level, namespace_, name_='add', pretty_print=pretty_print)
        if self.remove is not None:
            self.remove.export_xml(outfile, level, namespace_, name_='remove', pretty_print=pretty_print)
        if self.set is not None:
            self.set.export_xml(outfile, level, namespace_, name_='set', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.add is not None or
            self.remove is not None or
            self.set is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ActionExtCommunityType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.add is not None:
            showIndent(outfile, level)
            outfile.write('add=model_.ExtCommunityListType(\n')
            self.add.exportLiteral(outfile, level, name_='add')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.remove is not None:
            showIndent(outfile, level)
            outfile.write('remove=model_.ExtCommunityListType(\n')
            self.remove.exportLiteral(outfile, level, name_='remove')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.set is not None:
            showIndent(outfile, level)
            outfile.write('set=model_.ExtCommunityListType(\n')
            self.set.exportLiteral(outfile, level, name_='set')
            showIndent(outfile, level)
            outfile.write('),\n')
    def exportDict(self, name_='ActionExtCommunityType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'add':
            obj_ = ExtCommunityListType.factory()
            obj_.build(child_)
            self.set_add(obj_)
        elif nodeName_ == 'remove':
            obj_ = ExtCommunityListType.factory()
            obj_.build(child_)
            self.set_remove(obj_)
        elif nodeName_ == 'set':
            obj_ = ExtCommunityListType.factory()
            obj_.build(child_)
            self.set_set(obj_)
# end class ActionExtCommunityType


class ActionUpdateType(GeneratedsSuper):
    """
    Attributes:
    * as_path
        Type:           :class:`.ActionAsPathType`

    * community
        Type:           :class:`.ActionCommunityType`

    * extcommunity
        Type:           :class:`.ActionExtCommunityType`

    * local_pref
        Type:           int

    * med
        Type:           int

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'as_path', u'community', u'extcommunity', u'local_pref', u'med']
    attr_field_type_vals = {u'extcommunity': {'restrictions': None, 'description': [], 'simple_type': u'ActionExtCommunityType', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'ActionExtCommunityType'}, u'local_pref': {'restrictions': None, 'description': [], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'integer'}, u'as_path': {'restrictions': None, 'description': [], 'simple_type': u'ActionAsPathType', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'ActionAsPathType'}, u'community': {'restrictions': None, 'description': [], 'simple_type': u'ActionCommunityType', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'ActionCommunityType'}, u'med': {'restrictions': None, 'description': [], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'integer'}}
    def __init__(self, as_path=None, community=None, extcommunity=None, local_pref=None, med=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _as_path = params_dict[u"as_path"]
        except KeyError:
            _as_path = as_path
        if isinstance(_as_path, dict):
            obj = ActionAsPathType(params_dict=_as_path)
            self.as_path = obj
        else:
            self.as_path = _as_path
        try:
            _community = params_dict[u"community"]
        except KeyError:
            _community = community
        if isinstance(_community, dict):
            obj = ActionCommunityType(params_dict=_community)
            self.community = obj
        else:
            self.community = _community
        try:
            _extcommunity = params_dict[u"extcommunity"]
        except KeyError:
            _extcommunity = extcommunity
        if isinstance(_extcommunity, dict):
            obj = ActionExtCommunityType(params_dict=_extcommunity)
            self.extcommunity = obj
        else:
            self.extcommunity = _extcommunity
        try:
            _local_pref = params_dict[u"local_pref"]
        except KeyError:
            _local_pref = local_pref
        self.local_pref = _local_pref
        try:
            _med = params_dict[u"med"]
        except KeyError:
            _med = med
        self.med = _med
    def factory(*args_, **kwargs_):
        if ActionUpdateType.subclass:
            return ActionUpdateType.subclass(*args_, **kwargs_)
        else:
            return ActionUpdateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_as_path(self): return self.as_path
    def set_as_path(self, as_path): self.as_path = as_path
    def get_community(self): return self.community
    def set_community(self, community): self.community = community
    def get_extcommunity(self): return self.extcommunity
    def set_extcommunity(self, extcommunity): self.extcommunity = extcommunity
    def get_local_pref(self): return self.local_pref
    def set_local_pref(self, local_pref): self.local_pref = local_pref
    def get_med(self): return self.med
    def set_med(self, med): self.med = med
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.as_path == other.as_path and
                    self.community == other.community and
                    self.extcommunity == other.extcommunity and
                    self.local_pref == other.local_pref and
                    self.med == other.med)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.as_path if self.as_path is not None else -7985492147856592190,
                     self.community if self.community is not None else -7985492147856592190,
                     self.extcommunity if self.extcommunity is not None else -7985492147856592190,
                     self.local_pref if self.local_pref is not None else -7985492147856592190,
                     self.med if self.med is not None else -7985492147856592190))

    def __repr__(self):
        return ("as_path = " + str(self.as_path) + ", " +
                "community = " + str(self.community) + ", " +
                "extcommunity = " + str(self.extcommunity) + ", " +
                "local_pref = " + str(self.local_pref) + ", " +
                "med = " + str(self.med))

    def copy(self):
        cp = ActionUpdateType()
        if self.as_path is not None:
            cp.as_path = self.as_path.copy()
        if self.community is not None:
            cp.community = self.community.copy()
        if self.extcommunity is not None:
            cp.extcommunity = self.extcommunity.copy()
        if self.local_pref is not None:
            cp.local_pref = self.local_pref
        if self.med is not None:
            cp.med = self.med
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_as_path (ActionAsPathType.populate ())
        obj.set_community (ActionCommunityType.populate ())
        obj.set_extcommunity (ActionExtCommunityType.populate ())
        obj.set_local_pref (obj.populate_integer ("local_pref"))
        obj.set_med (obj.populate_integer ("med"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='ActionUpdateType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActionUpdateType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ActionUpdateType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ActionUpdateType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.as_path is not None:
            self.as_path.export_xml(outfile, level, namespace_, name_='as-path', pretty_print=pretty_print)
        if self.community is not None:
            self.community.export_xml(outfile, level, namespace_, name_='community', pretty_print=pretty_print)
        if self.extcommunity is not None:
            self.extcommunity.export_xml(outfile, level, namespace_, name_='extcommunity', pretty_print=pretty_print)
        if self.local_pref is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slocal-pref>%s</%slocal-pref>%s' % (namespace_, self.gds_format_integer(self.local_pref, input_name='local-pref'), namespace_, eol_))
        if self.med is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smed>%s</%smed>%s' % (namespace_, self.gds_format_integer(self.med, input_name='med'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.as_path is not None or
            self.community is not None or
            self.extcommunity is not None or
            self.local_pref is not None or
            self.med is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ActionUpdateType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.as_path is not None:
            showIndent(outfile, level)
            outfile.write('as_path=model_.ActionAsPathType(\n')
            self.as_path.exportLiteral(outfile, level, name_='as_path')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.community is not None:
            showIndent(outfile, level)
            outfile.write('community=model_.ActionCommunityType(\n')
            self.community.exportLiteral(outfile, level, name_='community')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.extcommunity is not None:
            showIndent(outfile, level)
            outfile.write('extcommunity=model_.ActionExtCommunityType(\n')
            self.extcommunity.exportLiteral(outfile, level, name_='extcommunity')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.local_pref is not None:
            showIndent(outfile, level)
            outfile.write('local_pref=%d,\n' % self.local_pref)
        if self.med is not None:
            showIndent(outfile, level)
            outfile.write('med=%d,\n' % self.med)
    def exportDict(self, name_='ActionUpdateType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'as-path':
            obj_ = ActionAsPathType.factory()
            obj_.build(child_)
            self.set_as_path(obj_)
        elif nodeName_ == 'community':
            obj_ = ActionCommunityType.factory()
            obj_.build(child_)
            self.set_community(obj_)
        elif nodeName_ == 'extcommunity':
            obj_ = ActionExtCommunityType.factory()
            obj_.build(child_)
            self.set_extcommunity(obj_)
        elif nodeName_ == 'local-pref':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'local_pref')
            self.local_pref = ival_
        elif nodeName_ == 'med':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'med')
            self.med = ival_
# end class ActionUpdateType


class TermActionListType(GeneratedsSuper):
    """
    Attributes:
    * update
        Type:           :class:`.ActionUpdateType`

    * action
        Type:           str, *one-of* [u'reject', u'accept', u'next']

    * external
        Type:           str, *one-of* [u'ospf-type-1', u'ospf-type-2']

        Created By:           User (optional)

    * as_path_expand
        Type:           str

        Created By:           User (optional)

        Description:
          Valid only for network-device TermType. string should be in format of AS

          number(s) seperated by spaces

    * as_path_prepend
        Type:           str

        Created By:           User (optional)

        Description:
          Valid only for network-device TermType. string should be in format of AS

          number(s) seperated by spaces

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'update', u'action', u'external', u'as_path_expand', u'as_path_prepend']
    attr_field_type_vals = {u'action': {'restrictions': [u'reject', u'accept', u'next'], 'description': [], 'simple_type': u'ActionType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': None, 'attr_type': u'string'}, u'as_path_expand': {'restrictions': None, 'description': [u'Valid only for network-device TermType. string should be in format of AS number(s) seperated by spaces'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'as_path_prepend': {'restrictions': None, 'description': [u'Valid only for network-device TermType. string should be in format of AS number(s) seperated by spaces'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'update': {'restrictions': None, 'description': [], 'simple_type': u'ActionUpdateType', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'ActionUpdateType'}, u'external': {'restrictions': [u'ospf-type-1', u'ospf-type-2'], 'description': [], 'simple_type': u'ExternalRouteType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'optional', 'attr_type': u'string'}}
    def __init__(self, update=None, action=None, external=None, as_path_expand=None, as_path_prepend=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _update = params_dict[u"update"]
        except KeyError:
            _update = update
        if isinstance(_update, dict):
            obj = ActionUpdateType(params_dict=_update)
            self.update = obj
        else:
            self.update = _update
        try:
            _action = params_dict[u"action"]
        except KeyError:
            _action = action
        self.action = _action
        try:
            _external = params_dict[u"external"]
        except KeyError:
            _external = external
        self.external = _external
        try:
            _as_path_expand = params_dict[u"as_path_expand"]
        except KeyError:
            _as_path_expand = as_path_expand
        self.as_path_expand = _as_path_expand
        try:
            _as_path_prepend = params_dict[u"as_path_prepend"]
        except KeyError:
            _as_path_prepend = as_path_prepend
        self.as_path_prepend = _as_path_prepend
    def factory(*args_, **kwargs_):
        if TermActionListType.subclass:
            return TermActionListType.subclass(*args_, **kwargs_)
        else:
            return TermActionListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_update(self): return self.update
    def set_update(self, update): self.update = update
    def get_action(self): return self.action
    def set_action(self, action): self.action = action
    def validate_ActionType(self, value):
        # Validate type ActionType, a restriction on xsd:string.
        error = False
        if isinstance(value, list):
            error = set(value) - set([u'reject', u'accept', u'next'])
        else:
            error = value not in [u'reject', u'accept', u'next']
        if error:
            raise ValueError("ActionType must be one of [u'reject', u'accept', u'next']")
    def get_external(self): return self.external
    def set_external(self, external): self.external = external
    def validate_ExternalRouteType(self, value):
        # Validate type ExternalRouteType, a restriction on xsd:string.
        error = False
        if isinstance(value, list):
            error = set(value) - set([u'ospf-type-1', u'ospf-type-2'])
        else:
            error = value not in [u'ospf-type-1', u'ospf-type-2']
        if error:
            raise ValueError("ExternalRouteType must be one of [u'ospf-type-1', u'ospf-type-2']")
    def get_as_path_expand(self): return self.as_path_expand
    def set_as_path_expand(self, as_path_expand): self.as_path_expand = as_path_expand
    def get_as_path_prepend(self): return self.as_path_prepend
    def set_as_path_prepend(self, as_path_prepend): self.as_path_prepend = as_path_prepend
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.update == other.update and
                    self.action == other.action and
                    self.external == other.external and
                    self.as_path_expand == other.as_path_expand and
                    self.as_path_prepend == other.as_path_prepend)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.update if self.update is not None else -7985492147856592190,
                     self.action if self.action is not None else -7985492147856592190,
                     self.external if self.external is not None else -7985492147856592190,
                     self.as_path_expand if self.as_path_expand is not None else -7985492147856592190,
                     self.as_path_prepend if self.as_path_prepend is not None else -7985492147856592190))

    def __repr__(self):
        return ("update = " + str(self.update) + ", " +
                "action = " + str(self.action) + ", " +
                "external = " + str(self.external) + ", " +
                "as_path_expand = " + str(self.as_path_expand) + ", " +
                "as_path_prepend = " + str(self.as_path_prepend))

    def copy(self):
        cp = TermActionListType()
        if self.update is not None:
            cp.update = self.update.copy()
        if self.action is not None:
            cp.action = self.action
        if self.external is not None:
            cp.external = self.external
        if self.as_path_expand is not None:
            cp.as_path_expand = self.as_path_expand
        if self.as_path_prepend is not None:
            cp.as_path_prepend = self.as_path_prepend
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_update (ActionUpdateType.populate ())
        obj.set_action (obj.populate_string ("action"))
        obj.set_external (obj.populate_string ("external"))
        obj.set_as_path_expand (obj.populate_string ("as_path_expand"))
        obj.set_as_path_prepend (obj.populate_string ("as_path_prepend"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='TermActionListType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TermActionListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TermActionListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TermActionListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.update is not None:
            self.update.export_xml(outfile, level, namespace_, name_='update', pretty_print=pretty_print)
        if self.action is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saction>%s</%saction>%s' % (namespace_, self.gds_format_string(quote_xml(self.action).encode(ExternalEncoding), input_name='action'), namespace_, eol_))
        if self.external is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexternal>%s</%sexternal>%s' % (namespace_, self.gds_format_string(quote_xml(self.external).encode(ExternalEncoding), input_name='external'), namespace_, eol_))
        if self.as_path_expand is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sas-path-expand>%s</%sas-path-expand>%s' % (namespace_, self.gds_format_string(quote_xml(self.as_path_expand).encode(ExternalEncoding), input_name='as-path-expand'), namespace_, eol_))
        if self.as_path_prepend is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sas-path-prepend>%s</%sas-path-prepend>%s' % (namespace_, self.gds_format_string(quote_xml(self.as_path_prepend).encode(ExternalEncoding), input_name='as-path-prepend'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.update is not None or
            self.action is not None or
            self.external is not None or
            self.as_path_expand is not None or
            self.as_path_prepend is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TermActionListType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.update is not None:
            showIndent(outfile, level)
            outfile.write('update=model_.ActionUpdateType(\n')
            self.update.exportLiteral(outfile, level, name_='update')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.action is not None:
            showIndent(outfile, level)
            outfile.write('action=%s,\n' % quote_python(self.action).encode(ExternalEncoding))
        if self.external is not None:
            showIndent(outfile, level)
            outfile.write('external=%s,\n' % quote_python(self.external).encode(ExternalEncoding))
        if self.as_path_expand is not None:
            showIndent(outfile, level)
            outfile.write('as_path_expand=%s,\n' % quote_python(self.as_path_expand).encode(ExternalEncoding))
        if self.as_path_prepend is not None:
            showIndent(outfile, level)
            outfile.write('as_path_prepend=%s,\n' % quote_python(self.as_path_prepend).encode(ExternalEncoding))
    def exportDict(self, name_='TermActionListType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'update':
            obj_ = ActionUpdateType.factory()
            obj_.build(child_)
            self.set_update(obj_)
        elif nodeName_ == 'action':
            action_ = child_.text
            action_ = self.gds_validate_string(action_, node, 'action')
            self.action = action_
            self.validate_ActionType(self.action)    # validate type ActionType
        elif nodeName_ == 'external':
            external_ = child_.text
            external_ = self.gds_validate_string(external_, node, 'external')
            self.external = external_
            self.validate_ExternalRouteType(self.external)    # validate type ExternalRouteType
        elif nodeName_ == 'as-path-expand':
            as_path_expand_ = child_.text
            as_path_expand_ = self.gds_validate_string(as_path_expand_, node, 'as_path_expand')
            self.as_path_expand = as_path_expand_
        elif nodeName_ == 'as-path-prepend':
            as_path_prepend_ = child_.text
            as_path_prepend_ = self.gds_validate_string(as_path_prepend_, node, 'as_path_prepend')
            self.as_path_prepend = as_path_prepend_
# end class TermActionListType


class PrefixMatchType(GeneratedsSuper):
    """
    Attributes:
    * prefix
        Type:           str

    * prefix_type
        Type:           str, *one-of* [u'exact', u'longer', u'orlonger']

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'prefix', u'prefix_type']
    attr_field_type_vals = {u'prefix_type': {'restrictions': [u'exact', u'longer', u'orlonger'], 'description': [], 'simple_type': u'PrefixType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': None, 'attr_type': u'string'}, u'prefix': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}}
    def __init__(self, prefix=None, prefix_type=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _prefix = params_dict[u"prefix"]
        except KeyError:
            _prefix = prefix
        self.prefix = _prefix
        try:
            _prefix_type = params_dict[u"prefix_type"]
        except KeyError:
            _prefix_type = prefix_type
        self.prefix_type = _prefix_type
    def factory(*args_, **kwargs_):
        if PrefixMatchType.subclass:
            return PrefixMatchType.subclass(*args_, **kwargs_)
        else:
            return PrefixMatchType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_prefix(self): return self.prefix
    def set_prefix(self, prefix): self.prefix = prefix
    def get_prefix_type(self): return self.prefix_type
    def set_prefix_type(self, prefix_type): self.prefix_type = prefix_type
    def validate_PrefixType(self, value):
        # Validate type PrefixType, a restriction on xsd:string.
        error = False
        if isinstance(value, list):
            error = set(value) - set([u'exact', u'longer', u'orlonger'])
        else:
            error = value not in [u'exact', u'longer', u'orlonger']
        if error:
            raise ValueError("PrefixType must be one of [u'exact', u'longer', u'orlonger']")
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.prefix == other.prefix and
                    self.prefix_type == other.prefix_type)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.prefix if self.prefix is not None else -7985492147856592190,
                     self.prefix_type if self.prefix_type is not None else -7985492147856592190))

    def __repr__(self):
        return ("prefix = " + str(self.prefix) + ", " +
                "prefix_type = " + str(self.prefix_type))

    def copy(self):
        cp = PrefixMatchType()
        if self.prefix is not None:
            cp.prefix = self.prefix
        if self.prefix_type is not None:
            cp.prefix_type = self.prefix_type
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_prefix (obj.populate_string ("prefix"))
        obj.set_prefix_type (obj.populate_string ("prefix_type"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='PrefixMatchType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PrefixMatchType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PrefixMatchType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PrefixMatchType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.prefix is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprefix>%s</%sprefix>%s' % (namespace_, self.gds_format_string(quote_xml(self.prefix).encode(ExternalEncoding), input_name='prefix'), namespace_, eol_))
        if self.prefix_type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprefix-type>%s</%sprefix-type>%s' % (namespace_, self.gds_format_string(quote_xml(self.prefix_type).encode(ExternalEncoding), input_name='prefix-type'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.prefix is not None or
            self.prefix_type is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PrefixMatchType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.prefix is not None:
            showIndent(outfile, level)
            outfile.write('prefix=%s,\n' % quote_python(self.prefix).encode(ExternalEncoding))
        if self.prefix_type is not None:
            showIndent(outfile, level)
            outfile.write('prefix_type=%s,\n' % quote_python(self.prefix_type).encode(ExternalEncoding))
    def exportDict(self, name_='PrefixMatchType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'prefix':
            prefix_ = child_.text
            prefix_ = self.gds_validate_string(prefix_, node, 'prefix')
            self.prefix = prefix_
        elif nodeName_ == 'prefix-type':
            prefix_type_ = child_.text
            prefix_type_ = self.gds_validate_string(prefix_type_, node, 'prefix_type')
            self.prefix_type = prefix_type_
            self.validate_PrefixType(self.prefix_type)    # validate type PrefixType
# end class PrefixMatchType


class TermMatchConditionType(GeneratedsSuper):
    """
    Attributes:
    * protocol
        Type:           str, *one-of* [u'xmpp', u'service-chain', u'interface', u'interface-static', u'service-interface', u'bgpaas', u'bgp', u'static', u'aggregate', u'direct', u'pim', u'evpn', u'ospf', u'ospf3']

    * prefix
        Type:           :class:`.PrefixMatchType`

    * community
        Type:           str

    * community_list
        Type:           str

    * community_match_all
        Type:           bool

    * extcommunity_list
        Type:           str

    * extcommunity_match_all
        Type:           bool

    * family
        Type:           str, *one-of* [u'inet', u'inet-vpn', u'evpn']

        Created By:           User (optional)

    * as_path
        Type:           int

        Created By:           User (optional)

    * external
        Type:           str, *one-of* [u'ospf-type-1', u'ospf-type-2']

        Created By:           User (optional)

    * local_pref
        Type:           int

        Created By:           User (optional)

    * nlri_route_type
        Type:           int

        Created By:           User (optional)

        Description:
          list of integer values in range of 1 to 10 inclusive.

    * prefix_list
        Type:           :class:`.PrefixListMatchType`

        Created By:           User (optional)

        Description:
          list of prefixes from interface route table uuids with prefix types.

    * route_filter
        Type:           :class:`.RouteFilterType`

        Created By:           User (optional)

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'protocol', u'prefix', u'community', u'community_list', u'community_match_all', u'extcommunity_list', u'extcommunity_match_all', u'family', u'as_path', u'external', u'local_pref', u'nlri_route_type', u'prefix_list', u'route_filter']
    attr_field_type_vals = {u'nlri_route_type': {'restrictions': None, 'description': [u'list of integer values in range of 1 to 10 inclusive.'], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': True, 'required': u'optional', 'attr_type': u'integer'}, u'protocol': {'restrictions': [u'xmpp', u'service-chain', u'interface', u'interface-static', u'service-interface', u'bgpaas', u'bgp', u'static', u'aggregate', u'direct', u'pim', u'evpn', u'ospf', u'ospf3'], 'description': [], 'simple_type': u'PathSourceType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': True, 'required': None, 'attr_type': u'string'}, u'family': {'restrictions': [u'inet', u'inet-vpn', u'evpn'], 'description': [], 'simple_type': u'FamilyType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'route_filter': {'restrictions': None, 'description': [], 'simple_type': u'RouteFilterType', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'RouteFilterType'}, u'as_path': {'restrictions': None, 'description': [], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': True, 'required': u'optional', 'attr_type': u'integer'}, u'community': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'community_list': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': True, 'required': None, 'attr_type': u'string'}, u'prefix': {'restrictions': None, 'description': [], 'simple_type': u'PrefixMatchType', 'is_complex': 1, 'restriction_type': None, 'is_array': True, 'required': None, 'attr_type': u'PrefixMatchType'}, u'external': {'restrictions': [u'ospf-type-1', u'ospf-type-2'], 'description': [], 'simple_type': u'ExternalRouteType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'extcommunity_match_all': {'restrictions': None, 'description': [], 'simple_type': u'xsd:boolean', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'boolean'}, u'local_pref': {'restrictions': None, 'description': [], 'simple_type': u'xsd:integer', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'integer'}, u'community_match_all': {'restrictions': None, 'description': [], 'simple_type': u'xsd:boolean', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'boolean'}, u'prefix_list': {'restrictions': None, 'description': [u'list of prefixes from interface route table uuids with prefix types.'], 'simple_type': u'PrefixListMatchType', 'is_complex': 1, 'restriction_type': None, 'is_array': True, 'required': u'optional', 'attr_type': u'PrefixListMatchType'}, u'extcommunity_list': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': True, 'required': None, 'attr_type': u'string'}}
    def __init__(self, protocol=None, prefix=None, community=None, community_list=None, community_match_all=None, extcommunity_list=None, extcommunity_match_all=None, family=None, as_path=None, external=None, local_pref=None, nlri_route_type=None, prefix_list=None, route_filter=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _protocol = params_dict[u"protocol"]
        except KeyError:
            _protocol = protocol
        if not _protocol:
            self.protocol = []
        else:
            self.protocol = _protocol
        try:
            _prefix = params_dict[u"prefix"]
        except KeyError:
            _prefix = prefix
        if not _prefix:
            self.prefix = []
        else:
            if isinstance(_prefix[0], dict):
                objs = [PrefixMatchType(params_dict=elem) for elem in _prefix]
                self.prefix = objs
            else:
                self.prefix = _prefix
        try:
            _community = params_dict[u"community"]
        except KeyError:
            _community = community
        self.community = _community
        try:
            _community_list = params_dict[u"community_list"]
        except KeyError:
            _community_list = community_list
        if not _community_list:
            self.community_list = []
        else:
            self.community_list = _community_list
        try:
            _community_match_all = params_dict[u"community_match_all"]
        except KeyError:
            _community_match_all = community_match_all
        self.community_match_all = _community_match_all
        try:
            _extcommunity_list = params_dict[u"extcommunity_list"]
        except KeyError:
            _extcommunity_list = extcommunity_list
        if not _extcommunity_list:
            self.extcommunity_list = []
        else:
            self.extcommunity_list = _extcommunity_list
        try:
            _extcommunity_match_all = params_dict[u"extcommunity_match_all"]
        except KeyError:
            _extcommunity_match_all = extcommunity_match_all
        self.extcommunity_match_all = _extcommunity_match_all
        try:
            _family = params_dict[u"family"]
        except KeyError:
            _family = family
        self.family = _family
        try:
            _as_path = params_dict[u"as_path"]
        except KeyError:
            _as_path = as_path
        if not _as_path:
            self.as_path = []
        else:
            self.as_path = _as_path
        try:
            _external = params_dict[u"external"]
        except KeyError:
            _external = external
        self.external = _external
        try:
            _local_pref = params_dict[u"local_pref"]
        except KeyError:
            _local_pref = local_pref
        self.local_pref = _local_pref
        try:
            _nlri_route_type = params_dict[u"nlri_route_type"]
        except KeyError:
            _nlri_route_type = nlri_route_type
        if not _nlri_route_type:
            self.nlri_route_type = []
        else:
            self.nlri_route_type = _nlri_route_type
        try:
            _prefix_list = params_dict[u"prefix_list"]
        except KeyError:
            _prefix_list = prefix_list
        if not _prefix_list:
            self.prefix_list = []
        else:
            if isinstance(_prefix_list[0], dict):
                objs = [PrefixListMatchType(params_dict=elem) for elem in _prefix_list]
                self.prefix_list = objs
            else:
                self.prefix_list = _prefix_list
        try:
            _route_filter = params_dict[u"route_filter"]
        except KeyError:
            _route_filter = route_filter
        if isinstance(_route_filter, dict):
            obj = RouteFilterType(params_dict=_route_filter)
            self.route_filter = obj
        else:
            self.route_filter = _route_filter
    def factory(*args_, **kwargs_):
        if TermMatchConditionType.subclass:
            return TermMatchConditionType.subclass(*args_, **kwargs_)
        else:
            return TermMatchConditionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_protocol(self): return self.protocol
    def set_protocol(self, protocol): self.protocol = protocol
    def add_protocol(self, value): self.protocol.append(value)
    def insert_protocol(self, index, value): self.protocol[index] = value
    def delete_protocol(self, value): self.protocol.remove(value)
    def validate_PathSourceType(self, value):
        # Validate type PathSourceType, a restriction on xsd:string.
        error = False
        if isinstance(value, list):
            error = set(value) - set([u'xmpp', u'service-chain', u'interface', u'interface-static', u'service-interface', u'bgpaas', u'bgp', u'static', u'aggregate', u'direct', u'pim', u'evpn', u'ospf', u'ospf3'])
        else:
            error = value not in [u'xmpp', u'service-chain', u'interface', u'interface-static', u'service-interface', u'bgpaas', u'bgp', u'static', u'aggregate', u'direct', u'pim', u'evpn', u'ospf', u'ospf3']
        if error:
            raise ValueError("PathSourceType must be one of [u'xmpp', u'service-chain', u'interface', u'interface-static', u'service-interface', u'bgpaas', u'bgp', u'static', u'aggregate', u'direct', u'pim', u'evpn', u'ospf', u'ospf3']")
    def get_prefix(self): return self.prefix
    def set_prefix(self, prefix): self.prefix = prefix
    def add_prefix(self, value): self.prefix.append(value)
    def insert_prefix(self, index, value): self.prefix[index] = value
    def delete_prefix(self, value): self.prefix.remove(value)
    def get_community(self): return self.community
    def set_community(self, community): self.community = community
    def get_community_list(self): return self.community_list
    def set_community_list(self, community_list): self.community_list = community_list
    def add_community_list(self, value): self.community_list.append(value)
    def insert_community_list(self, index, value): self.community_list[index] = value
    def delete_community_list(self, value): self.community_list.remove(value)
    def get_community_match_all(self): return self.community_match_all
    def set_community_match_all(self, community_match_all): self.community_match_all = community_match_all
    def get_extcommunity_list(self): return self.extcommunity_list
    def set_extcommunity_list(self, extcommunity_list): self.extcommunity_list = extcommunity_list
    def add_extcommunity_list(self, value): self.extcommunity_list.append(value)
    def insert_extcommunity_list(self, index, value): self.extcommunity_list[index] = value
    def delete_extcommunity_list(self, value): self.extcommunity_list.remove(value)
    def get_extcommunity_match_all(self): return self.extcommunity_match_all
    def set_extcommunity_match_all(self, extcommunity_match_all): self.extcommunity_match_all = extcommunity_match_all
    def get_family(self): return self.family
    def set_family(self, family): self.family = family
    def validate_FamilyType(self, value):
        # Validate type FamilyType, a restriction on xsd:string.
        error = False
        if isinstance(value, list):
            error = set(value) - set([u'inet', u'inet-vpn', u'evpn'])
        else:
            error = value not in [u'inet', u'inet-vpn', u'evpn']
        if error:
            raise ValueError("FamilyType must be one of [u'inet', u'inet-vpn', u'evpn']")
    def get_as_path(self): return self.as_path
    def set_as_path(self, as_path): self.as_path = as_path
    def add_as_path(self, value): self.as_path.append(value)
    def insert_as_path(self, index, value): self.as_path[index] = value
    def delete_as_path(self, value): self.as_path.remove(value)
    def get_external(self): return self.external
    def set_external(self, external): self.external = external
    def validate_ExternalRouteType(self, value):
        # Validate type ExternalRouteType, a restriction on xsd:string.
        error = False
        if isinstance(value, list):
            error = set(value) - set([u'ospf-type-1', u'ospf-type-2'])
        else:
            error = value not in [u'ospf-type-1', u'ospf-type-2']
        if error:
            raise ValueError("ExternalRouteType must be one of [u'ospf-type-1', u'ospf-type-2']")
    def get_local_pref(self): return self.local_pref
    def set_local_pref(self, local_pref): self.local_pref = local_pref
    def get_nlri_route_type(self): return self.nlri_route_type
    def set_nlri_route_type(self, nlri_route_type): self.nlri_route_type = nlri_route_type
    def add_nlri_route_type(self, value): self.nlri_route_type.append(value)
    def insert_nlri_route_type(self, index, value): self.nlri_route_type[index] = value
    def delete_nlri_route_type(self, value): self.nlri_route_type.remove(value)
    def get_prefix_list(self): return self.prefix_list
    def set_prefix_list(self, prefix_list): self.prefix_list = prefix_list
    def add_prefix_list(self, value): self.prefix_list.append(value)
    def insert_prefix_list(self, index, value): self.prefix_list[index] = value
    def delete_prefix_list(self, value): self.prefix_list.remove(value)
    def get_route_filter(self): return self.route_filter
    def set_route_filter(self, route_filter): self.route_filter = route_filter
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.protocol == other.protocol and
                    self.prefix == other.prefix and
                    self.community == other.community and
                    self.community_list == other.community_list and
                    self.community_match_all == other.community_match_all and
                    self.extcommunity_list == other.extcommunity_list and
                    self.extcommunity_match_all == other.extcommunity_match_all and
                    self.family == other.family and
                    self.as_path == other.as_path and
                    self.external == other.external and
                    self.local_pref == other.local_pref and
                    self.nlri_route_type == other.nlri_route_type and
                    self.prefix_list == other.prefix_list and
                    self.route_filter == other.route_filter)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.protocol or []),
                     tuple(self.prefix or []),
                     self.community if self.community is not None else -7985492147856592190,
                     tuple(self.community_list or []),
                     self.community_match_all if self.community_match_all is not None else -7985492147856592190,
                     tuple(self.extcommunity_list or []),
                     self.extcommunity_match_all if self.extcommunity_match_all is not None else -7985492147856592190,
                     self.family if self.family is not None else -7985492147856592190,
                     tuple(self.as_path or []),
                     self.external if self.external is not None else -7985492147856592190,
                     self.local_pref if self.local_pref is not None else -7985492147856592190,
                     tuple(self.nlri_route_type or []),
                     tuple(self.prefix_list or []),
                     self.route_filter if self.route_filter is not None else -7985492147856592190))

    def __repr__(self):
        return ("protocol = " + str(self.protocol) + ", " +
                "prefix = " + str(self.prefix) + ", " +
                "community = " + str(self.community) + ", " +
                "community_list = " + str(self.community_list) + ", " +
                "community_match_all = " + str(self.community_match_all) + ", " +
                "extcommunity_list = " + str(self.extcommunity_list) + ", " +
                "extcommunity_match_all = " + str(self.extcommunity_match_all) + ", " +
                "family = " + str(self.family) + ", " +
                "as_path = " + str(self.as_path) + ", " +
                "external = " + str(self.external) + ", " +
                "local_pref = " + str(self.local_pref) + ", " +
                "nlri_route_type = " + str(self.nlri_route_type) + ", " +
                "prefix_list = " + str(self.prefix_list) + ", " +
                "route_filter = " + str(self.route_filter))

    def copy(self):
        cp = TermMatchConditionType()
        if self.protocol is not None:
            cp.protocol = list(self.protocol)
        if self.prefix is not None:
            cp.prefix = [x.copy() for x in self.prefix]
        if self.community is not None:
            cp.community = self.community
        if self.community_list is not None:
            cp.community_list = list(self.community_list)
        if self.community_match_all is not None:
            cp.community_match_all = self.community_match_all
        if self.extcommunity_list is not None:
            cp.extcommunity_list = list(self.extcommunity_list)
        if self.extcommunity_match_all is not None:
            cp.extcommunity_match_all = self.extcommunity_match_all
        if self.family is not None:
            cp.family = self.family
        if self.as_path is not None:
            cp.as_path = list(self.as_path)
        if self.external is not None:
            cp.external = self.external
        if self.local_pref is not None:
            cp.local_pref = self.local_pref
        if self.nlri_route_type is not None:
            cp.nlri_route_type = list(self.nlri_route_type)
        if self.prefix_list is not None:
            cp.prefix_list = [x.copy() for x in self.prefix_list]
        if self.route_filter is not None:
            cp.route_filter = self.route_filter.copy()
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_protocol ([obj.populate_string ("protocol")])
        obj.set_prefix ([PrefixMatchType.populate ()])
        obj.set_community (obj.populate_string ("community"))
        obj.set_community_list ([obj.populate_string ("community_list")])
        obj.set_community_match_all (obj.populate_boolean ("community_match_all"))
        obj.set_extcommunity_list ([obj.populate_string ("extcommunity_list")])
        obj.set_extcommunity_match_all (obj.populate_boolean ("extcommunity_match_all"))
        obj.set_family (obj.populate_string ("family"))
        obj.set_as_path ([obj.populate_integer ("as_path")])
        obj.set_external (obj.populate_string ("external"))
        obj.set_local_pref (obj.populate_integer ("local_pref"))
        obj.set_nlri_route_type ([obj.populate_integer ("nlri_route_type")])
        obj.set_prefix_list ([PrefixListMatchType.populate ()])
        obj.set_route_filter (RouteFilterType.populate ())
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='TermMatchConditionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TermMatchConditionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TermMatchConditionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TermMatchConditionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for protocol_ in self.protocol:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprotocol>%s</%sprotocol>%s' % (namespace_, self.gds_format_string(quote_xml(protocol_).encode(ExternalEncoding), input_name='protocol'), namespace_, eol_))
        for prefix_ in self.prefix:
            if isinstance(prefix_, dict):
                prefix_ = PrefixMatchType(**prefix_)
            prefix_.export_xml(outfile, level, namespace_, name_='prefix', pretty_print=pretty_print)
        if self.community is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scommunity>%s</%scommunity>%s' % (namespace_, self.gds_format_string(quote_xml(self.community).encode(ExternalEncoding), input_name='community'), namespace_, eol_))
        for community_list_ in self.community_list:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scommunity-list>%s</%scommunity-list>%s' % (namespace_, self.gds_format_string(quote_xml(community_list_).encode(ExternalEncoding), input_name='community-list'), namespace_, eol_))
        if self.community_match_all is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scommunity-match-all>%s</%scommunity-match-all>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.community_match_all)), input_name='community-match-all'), namespace_, eol_))
        for extcommunity_list_ in self.extcommunity_list:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sextcommunity-list>%s</%sextcommunity-list>%s' % (namespace_, self.gds_format_string(quote_xml(extcommunity_list_).encode(ExternalEncoding), input_name='extcommunity-list'), namespace_, eol_))
        if self.extcommunity_match_all is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sextcommunity-match-all>%s</%sextcommunity-match-all>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.extcommunity_match_all)), input_name='extcommunity-match-all'), namespace_, eol_))
        if self.family is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfamily>%s</%sfamily>%s' % (namespace_, self.gds_format_string(quote_xml(self.family).encode(ExternalEncoding), input_name='family'), namespace_, eol_))
        for as_path_ in self.as_path:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sas-path>%s</%sas-path>%s' % (namespace_, self.gds_format_integer(as_path_, input_name='as-path'), namespace_, eol_))
        if self.external is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexternal>%s</%sexternal>%s' % (namespace_, self.gds_format_string(quote_xml(self.external).encode(ExternalEncoding), input_name='external'), namespace_, eol_))
        if self.local_pref is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slocal-pref>%s</%slocal-pref>%s' % (namespace_, self.gds_format_integer(self.local_pref, input_name='local-pref'), namespace_, eol_))
        for nlri_route_type_ in self.nlri_route_type:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snlri-route-type>%s</%snlri-route-type>%s' % (namespace_, self.gds_format_integer(nlri_route_type_, input_name='nlri-route-type'), namespace_, eol_))
        for prefix_list_ in self.prefix_list:
            if isinstance(prefix_list_, dict):
                prefix_list_ = PrefixListMatchType(**prefix_list_)
            prefix_list_.export_xml(outfile, level, namespace_, name_='prefix-list', pretty_print=pretty_print)
        if self.route_filter is not None:
            self.route_filter.export_xml(outfile, level, namespace_, name_='route-filter', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.protocol or
            self.prefix or
            self.community is not None or
            self.community_list or
            self.community_match_all is not None or
            self.extcommunity_list or
            self.extcommunity_match_all is not None or
            self.family is not None or
            self.as_path or
            self.external is not None or
            self.local_pref is not None or
            self.nlri_route_type or
            self.prefix_list or
            self.route_filter is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TermMatchConditionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('protocol=[\n')
        level += 1
        for protocol_ in self.protocol:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(protocol_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('prefix=[\n')
        level += 1
        for prefix_ in self.prefix:
            showIndent(outfile, level)
            outfile.write('model_.PrefixMatchType(\n')
            prefix_.exportLiteral(outfile, level, name_='PrefixMatchType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.community is not None:
            showIndent(outfile, level)
            outfile.write('community=%s,\n' % quote_python(self.community).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('community_list=[\n')
        level += 1
        for community_list_ in self.community_list:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(community_list_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.community_match_all is not None:
            showIndent(outfile, level)
            outfile.write('community_match_all=%s,\n' % self.community_match_all)
        showIndent(outfile, level)
        outfile.write('extcommunity_list=[\n')
        level += 1
        for extcommunity_list_ in self.extcommunity_list:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(extcommunity_list_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.extcommunity_match_all is not None:
            showIndent(outfile, level)
            outfile.write('extcommunity_match_all=%s,\n' % self.extcommunity_match_all)
        if self.family is not None:
            showIndent(outfile, level)
            outfile.write('family=%s,\n' % quote_python(self.family).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('as_path=[\n')
        level += 1
        for as_path_ in self.as_path:
            showIndent(outfile, level)
            outfile.write('%d,\n' % as_path)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.external is not None:
            showIndent(outfile, level)
            outfile.write('external=%s,\n' % quote_python(self.external).encode(ExternalEncoding))
        if self.local_pref is not None:
            showIndent(outfile, level)
            outfile.write('local_pref=%d,\n' % self.local_pref)
        showIndent(outfile, level)
        outfile.write('nlri_route_type=[\n')
        level += 1
        for nlri_route_type_ in self.nlri_route_type:
            showIndent(outfile, level)
            outfile.write('%d,\n' % nlri_route_type)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('prefix_list=[\n')
        level += 1
        for prefix_list_ in self.prefix_list:
            showIndent(outfile, level)
            outfile.write('model_.PrefixListMatchType(\n')
            prefix_list_.exportLiteral(outfile, level, name_='PrefixListMatchType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.route_filter is not None:
            showIndent(outfile, level)
            outfile.write('route_filter=model_.RouteFilterType(\n')
            self.route_filter.exportLiteral(outfile, level, name_='route_filter')
            showIndent(outfile, level)
            outfile.write('),\n')
    def exportDict(self, name_='TermMatchConditionType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'protocol':
            protocol_ = child_.text
            protocol_ = self.gds_validate_string(protocol_, node, 'protocol')
            self.protocol.append(protocol_)
            self.validate_PathSourceType(self.protocol)    # validate type PathSourceType
        elif nodeName_ == 'prefix':
            obj_ = PrefixMatchType.factory()
            obj_.build(child_)
            self.prefix.append(obj_)
        elif nodeName_ == 'community':
            community_ = child_.text
            community_ = self.gds_validate_string(community_, node, 'community')
            self.community = community_
        elif nodeName_ == 'community-list':
            community_list_ = child_.text
            community_list_ = self.gds_validate_string(community_list_, node, 'community_list')
            self.community_list.append(community_list_)
        elif nodeName_ == 'community-match-all':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'community_match_all')
            self.community_match_all = ival_
        elif nodeName_ == 'extcommunity-list':
            extcommunity_list_ = child_.text
            extcommunity_list_ = self.gds_validate_string(extcommunity_list_, node, 'extcommunity_list')
            self.extcommunity_list.append(extcommunity_list_)
        elif nodeName_ == 'extcommunity-match-all':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'extcommunity_match_all')
            self.extcommunity_match_all = ival_
        elif nodeName_ == 'family':
            family_ = child_.text
            family_ = self.gds_validate_string(family_, node, 'family')
            self.family = family_
            self.validate_FamilyType(self.family)    # validate type FamilyType
        elif nodeName_ == 'as-path':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'as_path')
            self.as_path.append(ival_)
        elif nodeName_ == 'external':
            external_ = child_.text
            external_ = self.gds_validate_string(external_, node, 'external')
            self.external = external_
            self.validate_ExternalRouteType(self.external)    # validate type ExternalRouteType
        elif nodeName_ == 'local-pref':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'local_pref')
            self.local_pref = ival_
        elif nodeName_ == 'nlri-route-type':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'nlri_route_type')
            self.nlri_route_type.append(ival_)
        elif nodeName_ == 'prefix-list':
            obj_ = PrefixListMatchType.factory()
            obj_.build(child_)
            self.prefix_list.append(obj_)
        elif nodeName_ == 'route-filter':
            obj_ = RouteFilterType.factory()
            obj_.build(child_)
            self.set_route_filter(obj_)
# end class TermMatchConditionType


class PolicyTermType(GeneratedsSuper):
    """
    Attributes:
    * term_match_condition
        Type:           :class:`.TermMatchConditionType`

    * term_action_list
        Type:           :class:`.TermActionListType`

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'term_match_condition', u'term_action_list']
    attr_field_type_vals = {u'term_action_list': {'restrictions': None, 'description': [], 'simple_type': u'TermActionListType', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'TermActionListType'}, u'term_match_condition': {'restrictions': None, 'description': [], 'simple_type': u'TermMatchConditionType', 'is_complex': 1, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'TermMatchConditionType'}}
    def __init__(self, term_match_condition=None, term_action_list=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _term_match_condition = params_dict[u"term_match_condition"]
        except KeyError:
            _term_match_condition = term_match_condition
        if isinstance(_term_match_condition, dict):
            obj = TermMatchConditionType(params_dict=_term_match_condition)
            self.term_match_condition = obj
        else:
            self.term_match_condition = _term_match_condition
        try:
            _term_action_list = params_dict[u"term_action_list"]
        except KeyError:
            _term_action_list = term_action_list
        if isinstance(_term_action_list, dict):
            obj = TermActionListType(params_dict=_term_action_list)
            self.term_action_list = obj
        else:
            self.term_action_list = _term_action_list
    def factory(*args_, **kwargs_):
        if PolicyTermType.subclass:
            return PolicyTermType.subclass(*args_, **kwargs_)
        else:
            return PolicyTermType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_term_match_condition(self): return self.term_match_condition
    def set_term_match_condition(self, term_match_condition): self.term_match_condition = term_match_condition
    def get_term_action_list(self): return self.term_action_list
    def set_term_action_list(self, term_action_list): self.term_action_list = term_action_list
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.term_match_condition == other.term_match_condition and
                    self.term_action_list == other.term_action_list)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.term_match_condition if self.term_match_condition is not None else -7985492147856592190,
                     self.term_action_list if self.term_action_list is not None else -7985492147856592190))

    def __repr__(self):
        return ("term_match_condition = " + str(self.term_match_condition) + ", " +
                "term_action_list = " + str(self.term_action_list))

    def copy(self):
        cp = PolicyTermType()
        if self.term_match_condition is not None:
            cp.term_match_condition = self.term_match_condition.copy()
        if self.term_action_list is not None:
            cp.term_action_list = self.term_action_list.copy()
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_term_match_condition (TermMatchConditionType.populate ())
        obj.set_term_action_list (TermActionListType.populate ())
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='PolicyTermType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PolicyTermType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PolicyTermType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PolicyTermType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.term_match_condition is not None:
            self.term_match_condition.export_xml(outfile, level, namespace_, name_='term-match-condition', pretty_print=pretty_print)
        if self.term_action_list is not None:
            self.term_action_list.export_xml(outfile, level, namespace_, name_='term-action-list', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.term_match_condition is not None or
            self.term_action_list is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PolicyTermType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.term_match_condition is not None:
            showIndent(outfile, level)
            outfile.write('term_match_condition=model_.TermMatchConditionType(\n')
            self.term_match_condition.exportLiteral(outfile, level, name_='term_match_condition')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.term_action_list is not None:
            showIndent(outfile, level)
            outfile.write('term_action_list=model_.TermActionListType(\n')
            self.term_action_list.exportLiteral(outfile, level, name_='term_action_list')
            showIndent(outfile, level)
            outfile.write('),\n')
    def exportDict(self, name_='PolicyTermType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'term-match-condition':
            obj_ = TermMatchConditionType.factory()
            obj_.build(child_)
            self.set_term_match_condition(obj_)
        elif nodeName_ == 'term-action-list':
            obj_ = TermActionListType.factory()
            obj_.build(child_)
            self.set_term_action_list(obj_)
# end class PolicyTermType


class PrefixListMatchType(GeneratedsSuper):
    """
    Attributes:
    * interface_route_table_uuid
        Type:           str

        Created By:           User (required)

        Description:
          list of interface route table uuids used to build list of prefixes.

    * prefix_type
        Type:           str, *one-of* [u'exact', u'longer', u'orlonger']

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'interface_route_table_uuid', u'prefix_type']
    attr_field_type_vals = {u'prefix_type': {'restrictions': [u'exact', u'longer', u'orlonger'], 'description': [], 'simple_type': u'PrefixType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': None, 'attr_type': u'string'}, u'interface_route_table_uuid': {'restrictions': None, 'description': [u'list of interface route table uuids used to build list of prefixes.'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': True, 'required': u'true', 'attr_type': u'string'}}
    def __init__(self, interface_route_table_uuid=None, prefix_type=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _interface_route_table_uuid = params_dict[u"interface_route_table_uuid"]
        except KeyError:
            _interface_route_table_uuid = interface_route_table_uuid
        if not _interface_route_table_uuid:
            self.interface_route_table_uuid = []
        else:
            self.interface_route_table_uuid = _interface_route_table_uuid
        try:
            _prefix_type = params_dict[u"prefix_type"]
        except KeyError:
            _prefix_type = prefix_type
        self.prefix_type = _prefix_type
    def factory(*args_, **kwargs_):
        if PrefixListMatchType.subclass:
            return PrefixListMatchType.subclass(*args_, **kwargs_)
        else:
            return PrefixListMatchType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_interface_route_table_uuid(self): return self.interface_route_table_uuid
    def set_interface_route_table_uuid(self, interface_route_table_uuid): self.interface_route_table_uuid = interface_route_table_uuid
    def add_interface_route_table_uuid(self, value): self.interface_route_table_uuid.append(value)
    def insert_interface_route_table_uuid(self, index, value): self.interface_route_table_uuid[index] = value
    def delete_interface_route_table_uuid(self, value): self.interface_route_table_uuid.remove(value)
    def get_prefix_type(self): return self.prefix_type
    def set_prefix_type(self, prefix_type): self.prefix_type = prefix_type
    def validate_PrefixType(self, value):
        # Validate type PrefixType, a restriction on xsd:string.
        error = False
        if isinstance(value, list):
            error = set(value) - set([u'exact', u'longer', u'orlonger'])
        else:
            error = value not in [u'exact', u'longer', u'orlonger']
        if error:
            raise ValueError("PrefixType must be one of [u'exact', u'longer', u'orlonger']")
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.interface_route_table_uuid == other.interface_route_table_uuid and
                    self.prefix_type == other.prefix_type)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.interface_route_table_uuid or []),
                     self.prefix_type if self.prefix_type is not None else -7985492147856592190))

    def __repr__(self):
        return ("interface_route_table_uuid = " + str(self.interface_route_table_uuid) + ", " +
                "prefix_type = " + str(self.prefix_type))

    def copy(self):
        cp = PrefixListMatchType()
        if self.interface_route_table_uuid is not None:
            cp.interface_route_table_uuid = list(self.interface_route_table_uuid)
        if self.prefix_type is not None:
            cp.prefix_type = self.prefix_type
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_interface_route_table_uuid ([obj.populate_string ("interface_route_table_uuid")])
        obj.set_prefix_type (obj.populate_string ("prefix_type"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='PrefixListMatchType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PrefixListMatchType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PrefixListMatchType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PrefixListMatchType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for interface_route_table_uuid_ in self.interface_route_table_uuid:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinterface-route-table-uuid>%s</%sinterface-route-table-uuid>%s' % (namespace_, self.gds_format_string(quote_xml(interface_route_table_uuid_).encode(ExternalEncoding), input_name='interface-route-table-uuid'), namespace_, eol_))
        if self.prefix_type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprefix-type>%s</%sprefix-type>%s' % (namespace_, self.gds_format_string(quote_xml(self.prefix_type).encode(ExternalEncoding), input_name='prefix-type'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.interface_route_table_uuid or
            self.prefix_type is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PrefixListMatchType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('interface_route_table_uuid=[\n')
        level += 1
        for interface_route_table_uuid_ in self.interface_route_table_uuid:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(interface_route_table_uuid_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.prefix_type is not None:
            showIndent(outfile, level)
            outfile.write('prefix_type=%s,\n' % quote_python(self.prefix_type).encode(ExternalEncoding))
    def exportDict(self, name_='PrefixListMatchType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'interface-route-table-uuid':
            interface_route_table_uuid_ = child_.text
            interface_route_table_uuid_ = self.gds_validate_string(interface_route_table_uuid_, node, 'interface_route_table_uuid')
            self.interface_route_table_uuid.append(interface_route_table_uuid_)
        elif nodeName_ == 'prefix-type':
            prefix_type_ = child_.text
            prefix_type_ = self.gds_validate_string(prefix_type_, node, 'prefix_type')
            self.prefix_type = prefix_type_
            self.validate_PrefixType(self.prefix_type)    # validate type PrefixType
# end class PrefixListMatchType


class RouteFilterType(GeneratedsSuper):
    """
    Attributes:
    * route_filter_properties
        Type:           :class:`.RouteFilterProperties`

        Description:
          List of route filter properties.

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'route_filter_properties']
    attr_field_type_vals = {u'route_filter_properties': {'restrictions': None, 'description': [u'List of route filter properties.'], 'simple_type': u'RouteFilterProperties', 'is_complex': 1, 'restriction_type': None, 'is_array': True, 'required': None, 'attr_type': u'RouteFilterProperties'}}
    def __init__(self, route_filter_properties=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _route_filter_properties = params_dict[u"route_filter_properties"]
        except KeyError:
            _route_filter_properties = route_filter_properties
        if not _route_filter_properties:
            self.route_filter_properties = []
        else:
            if isinstance(_route_filter_properties[0], dict):
                objs = [RouteFilterProperties(params_dict=elem) for elem in _route_filter_properties]
                self.route_filter_properties = objs
            else:
                self.route_filter_properties = _route_filter_properties
    def factory(*args_, **kwargs_):
        if RouteFilterType.subclass:
            return RouteFilterType.subclass(*args_, **kwargs_)
        else:
            return RouteFilterType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_route_filter_properties(self): return self.route_filter_properties
    def set_route_filter_properties(self, route_filter_properties): self.route_filter_properties = route_filter_properties
    def add_route_filter_properties(self, value): self.route_filter_properties.append(value)
    def insert_route_filter_properties(self, index, value): self.route_filter_properties[index] = value
    def delete_route_filter_properties(self, value): self.route_filter_properties.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.route_filter_properties == other.route_filter_properties)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.route_filter_properties or [])))

    def __repr__(self):
        return ("route_filter_properties = " + str(self.route_filter_properties))

    def copy(self):
        cp = RouteFilterType()
        if self.route_filter_properties is not None:
            cp.route_filter_properties = [x.copy() for x in self.route_filter_properties]
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_route_filter_properties ([RouteFilterProperties.populate ()])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='RouteFilterType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RouteFilterType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RouteFilterType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RouteFilterType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for route_filter_properties_ in self.route_filter_properties:
            if isinstance(route_filter_properties_, dict):
                route_filter_properties_ = RouteFilterProperties(**route_filter_properties_)
            route_filter_properties_.export_xml(outfile, level, namespace_, name_='route-filter-properties', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.route_filter_properties
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RouteFilterType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('route_filter_properties=[\n')
        level += 1
        for route_filter_properties_ in self.route_filter_properties:
            showIndent(outfile, level)
            outfile.write('model_.RouteFilterProperties(\n')
            route_filter_properties_.exportLiteral(outfile, level, name_='RouteFilterProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='RouteFilterType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'route-filter-properties':
            obj_ = RouteFilterProperties.factory()
            obj_.build(child_)
            self.route_filter_properties.append(obj_)
# end class RouteFilterType


class RouteFilterProperties(GeneratedsSuper):
    """
    Attributes:
    * route
        Type:           str

        Created By:           User (required)

        Description:
          route filter IP address or host name.

    * route_type
        Type:           str, *one-of* [u'exact', u'longer', u'orlonger', u'prefix-length-range', u'through', u'upto']

    * route_type_value
        Type:           str

        Created By:           User (optional)

        Description:
          Valid only for through, upto or prefix-length-range RouteFType. Format: for

          prefix-length-range it stores '/min-length-/max-length'. through should be

          string, upto stores '/number'

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'route', u'route_type', u'route_type_value']
    attr_field_type_vals = {u'route_type': {'restrictions': [u'exact', u'longer', u'orlonger', u'prefix-length-range', u'through', u'upto'], 'description': [], 'simple_type': u'RouteFType', 'is_complex': 0, 'restriction_type': 'enum', 'is_array': False, 'required': None, 'attr_type': u'string'}, u'route_type_value': {'restrictions': None, 'description': [u"Valid only for through, upto or prefix-length-range RouteFType. Format: for prefix-length-range it stores '/min-length-/max-length'. through should be string, upto stores '/number'"], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'optional', 'attr_type': u'string'}, u'route': {'restrictions': None, 'description': [u'route filter IP address or host name.'], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': u'true', 'attr_type': u'string'}}
    def __init__(self, route=None, route_type=None, route_type_value=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _route = params_dict[u"route"]
        except KeyError:
            _route = route
        self.route = _route
        try:
            _route_type = params_dict[u"route_type"]
        except KeyError:
            _route_type = route_type
        self.route_type = _route_type
        try:
            _route_type_value = params_dict[u"route_type_value"]
        except KeyError:
            _route_type_value = route_type_value
        self.route_type_value = _route_type_value
    def factory(*args_, **kwargs_):
        if RouteFilterProperties.subclass:
            return RouteFilterProperties.subclass(*args_, **kwargs_)
        else:
            return RouteFilterProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_route(self): return self.route
    def set_route(self, route): self.route = route
    def get_route_type(self): return self.route_type
    def set_route_type(self, route_type): self.route_type = route_type
    def validate_RouteFType(self, value):
        # Validate type RouteFType, a restriction on xsd:string.
        error = False
        if isinstance(value, list):
            error = set(value) - set([u'exact', u'longer', u'orlonger', u'prefix-length-range', u'through', u'upto'])
        else:
            error = value not in [u'exact', u'longer', u'orlonger', u'prefix-length-range', u'through', u'upto']
        if error:
            raise ValueError("RouteFType must be one of [u'exact', u'longer', u'orlonger', u'prefix-length-range', u'through', u'upto']")
    def get_route_type_value(self): return self.route_type_value
    def set_route_type_value(self, route_type_value): self.route_type_value = route_type_value
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.route == other.route and
                    self.route_type == other.route_type and
                    self.route_type_value == other.route_type_value)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.route if self.route is not None else -7985492147856592190,
                     self.route_type if self.route_type is not None else -7985492147856592190,
                     self.route_type_value if self.route_type_value is not None else -7985492147856592190))

    def __repr__(self):
        return ("route = " + str(self.route) + ", " +
                "route_type = " + str(self.route_type) + ", " +
                "route_type_value = " + str(self.route_type_value))

    def copy(self):
        cp = RouteFilterProperties()
        if self.route is not None:
            cp.route = self.route
        if self.route_type is not None:
            cp.route_type = self.route_type
        if self.route_type_value is not None:
            cp.route_type_value = self.route_type_value
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_route (obj.populate_string ("route"))
        obj.set_route_type (obj.populate_string ("route_type"))
        obj.set_route_type_value (obj.populate_string ("route_type_value"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='RouteFilterProperties', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RouteFilterProperties')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RouteFilterProperties'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RouteFilterProperties', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.route is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sroute>%s</%sroute>%s' % (namespace_, self.gds_format_string(quote_xml(self.route).encode(ExternalEncoding), input_name='route'), namespace_, eol_))
        if self.route_type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sroute-type>%s</%sroute-type>%s' % (namespace_, self.gds_format_string(quote_xml(self.route_type).encode(ExternalEncoding), input_name='route-type'), namespace_, eol_))
        if self.route_type_value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sroute-type-value>%s</%sroute-type-value>%s' % (namespace_, self.gds_format_string(quote_xml(self.route_type_value).encode(ExternalEncoding), input_name='route-type-value'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.route is not None or
            self.route_type is not None or
            self.route_type_value is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RouteFilterProperties'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.route is not None:
            showIndent(outfile, level)
            outfile.write('route=%s,\n' % quote_python(self.route).encode(ExternalEncoding))
        if self.route_type is not None:
            showIndent(outfile, level)
            outfile.write('route_type=%s,\n' % quote_python(self.route_type).encode(ExternalEncoding))
        if self.route_type_value is not None:
            showIndent(outfile, level)
            outfile.write('route_type_value=%s,\n' % quote_python(self.route_type_value).encode(ExternalEncoding))
    def exportDict(self, name_='RouteFilterProperties'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'route':
            route_ = child_.text
            route_ = self.gds_validate_string(route_, node, 'route')
            self.route = route_
        elif nodeName_ == 'route-type':
            route_type_ = child_.text
            route_type_ = self.gds_validate_string(route_type_, node, 'route_type')
            self.route_type = route_type_
            self.validate_RouteFType(self.route_type)    # validate type RouteFType
        elif nodeName_ == 'route-type-value':
            route_type_value_ = child_.text
            route_type_value_ = self.gds_validate_string(route_type_value_, node, 'route_type_value')
            self.route_type_value = route_type_value_
# end class RouteFilterProperties


class FieldNamesList(GeneratedsSuper):
    """
    Attributes:
    * field_names
        Type:           str

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'field_names']
    attr_field_type_vals = {u'field_names': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': True, 'required': None, 'attr_type': u'string'}}
    def __init__(self, field_names=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _field_names = params_dict[u"field_names"]
        except KeyError:
            _field_names = field_names
        if not _field_names:
            self.field_names = []
        else:
            self.field_names = _field_names
    def factory(*args_, **kwargs_):
        if FieldNamesList.subclass:
            return FieldNamesList.subclass(*args_, **kwargs_)
        else:
            return FieldNamesList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_field_names(self): return self.field_names
    def set_field_names(self, field_names): self.field_names = field_names
    def add_field_names(self, value): self.field_names.append(value)
    def insert_field_names(self, index, value): self.field_names[index] = value
    def delete_field_names(self, value): self.field_names.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.field_names == other.field_names)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.field_names or [])))

    def __repr__(self):
        return ("field_names = " + str(self.field_names))

    def copy(self):
        cp = FieldNamesList()
        if self.field_names is not None:
            cp.field_names = list(self.field_names)
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_field_names ([obj.populate_string ("field_names")])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='FieldNamesList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FieldNamesList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FieldNamesList'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FieldNamesList', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for field_names_ in self.field_names:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfield-names>%s</%sfield-names>%s' % (namespace_, self.gds_format_string(quote_xml(field_names_).encode(ExternalEncoding), input_name='field-names'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.field_names
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FieldNamesList'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('field_names=[\n')
        level += 1
        for field_names_ in self.field_names:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(field_names_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='FieldNamesList'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'field-names':
            field_names_ = child_.text
            field_names_ = self.gds_validate_string(field_names_, node, 'field_names')
            self.field_names.append(field_names_)
# end class FieldNamesList


class StructuredSyslogLinkType(GeneratedsSuper):
    """
    Attributes:
    * overlay
        Type:           str

    * underlay
        Type:           str

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'overlay', u'underlay']
    attr_field_type_vals = {u'underlay': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}, u'overlay': {'restrictions': None, 'description': [], 'simple_type': u'xsd:string', 'is_complex': 0, 'restriction_type': None, 'is_array': False, 'required': None, 'attr_type': u'string'}}
    def __init__(self, overlay=None, underlay=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _overlay = params_dict[u"overlay"]
        except KeyError:
            _overlay = overlay
        self.overlay = _overlay
        try:
            _underlay = params_dict[u"underlay"]
        except KeyError:
            _underlay = underlay
        self.underlay = _underlay
    def factory(*args_, **kwargs_):
        if StructuredSyslogLinkType.subclass:
            return StructuredSyslogLinkType.subclass(*args_, **kwargs_)
        else:
            return StructuredSyslogLinkType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_overlay(self): return self.overlay
    def set_overlay(self, overlay): self.overlay = overlay
    def get_underlay(self): return self.underlay
    def set_underlay(self, underlay): self.underlay = underlay
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.overlay == other.overlay and
                    self.underlay == other.underlay)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((self.overlay if self.overlay is not None else -7985492147856592190,
                     self.underlay if self.underlay is not None else -7985492147856592190))

    def __repr__(self):
        return ("overlay = " + str(self.overlay) + ", " +
                "underlay = " + str(self.underlay))

    def copy(self):
        cp = StructuredSyslogLinkType()
        if self.overlay is not None:
            cp.overlay = self.overlay
        if self.underlay is not None:
            cp.underlay = self.underlay
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_overlay (obj.populate_string ("overlay"))
        obj.set_underlay (obj.populate_string ("underlay"))
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='StructuredSyslogLinkType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StructuredSyslogLinkType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StructuredSyslogLinkType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='StructuredSyslogLinkType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.overlay is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soverlay>%s</%soverlay>%s' % (namespace_, self.gds_format_string(quote_xml(self.overlay).encode(ExternalEncoding), input_name='overlay'), namespace_, eol_))
        if self.underlay is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sunderlay>%s</%sunderlay>%s' % (namespace_, self.gds_format_string(quote_xml(self.underlay).encode(ExternalEncoding), input_name='underlay'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.overlay is not None or
            self.underlay is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StructuredSyslogLinkType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.overlay is not None:
            showIndent(outfile, level)
            outfile.write('overlay=%s,\n' % quote_python(self.overlay).encode(ExternalEncoding))
        if self.underlay is not None:
            showIndent(outfile, level)
            outfile.write('underlay=%s,\n' % quote_python(self.underlay).encode(ExternalEncoding))
    def exportDict(self, name_='StructuredSyslogLinkType'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'overlay':
            overlay_ = child_.text
            overlay_ = self.gds_validate_string(overlay_, node, 'overlay')
            self.overlay = overlay_
        elif nodeName_ == 'underlay':
            underlay_ = child_.text
            underlay_ = self.gds_validate_string(underlay_, node, 'underlay')
            self.underlay = underlay_
# end class StructuredSyslogLinkType


class StructuredSyslogLinkmap(GeneratedsSuper):
    """
    Attributes:
    * links
        Type:           :class:`.StructuredSyslogLinkType`

    """
    subclass = None
    superclass = None
    class_description = []
    attr_fields = [u'links']
    attr_field_type_vals = {u'links': {'restrictions': None, 'description': [], 'simple_type': u'StructuredSyslogLinkType', 'is_complex': 1, 'restriction_type': None, 'is_array': True, 'required': None, 'attr_type': u'StructuredSyslogLinkType'}}
    def __init__(self, links=None, params_dict=None, **kwargs):
        # Prefer params_dict based value over arg for from_dict path
        params_dict = params_dict or {}
        try:
            _links = params_dict[u"links"]
        except KeyError:
            _links = links
        if not _links:
            self.links = []
        else:
            if isinstance(_links[0], dict):
                objs = [StructuredSyslogLinkType(params_dict=elem) for elem in _links]
                self.links = objs
            else:
                self.links = _links
    def factory(*args_, **kwargs_):
        if StructuredSyslogLinkmap.subclass:
            return StructuredSyslogLinkmap.subclass(*args_, **kwargs_)
        else:
            return StructuredSyslogLinkmap(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_links(self): return self.links
    def set_links(self, links): self.links = links
    def add_links(self, value): self.links.append(value)
    def insert_links(self, index, value): self.links[index] = value
    def delete_links(self, value): self.links.remove(value)
    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.links == other.links)
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, self.__class__):
            return not self.__eq__(other)
        return NotImplemented

    def __hash__(self):
        return hash((tuple(self.links or [])))

    def __repr__(self):
        return ("links = " + str(self.links))

    def copy(self):
        cp = StructuredSyslogLinkmap()
        if self.links is not None:
            cp.links = [x.copy() for x in self.links]
        return cp

    @classmethod
    def populate (cls, *a, **kwa):
        obj = cls (*a, **kwa)
        obj.set_links ([StructuredSyslogLinkType.populate ()])
        return obj
    def export_xml(self, outfile, level=1, namespace_='', name_='StructuredSyslogLinkmap', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StructuredSyslogLinkmap')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StructuredSyslogLinkmap'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='StructuredSyslogLinkmap', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for links_ in self.links:
            if isinstance(links_, dict):
                links_ = StructuredSyslogLinkType(**links_)
            links_.export_xml(outfile, level, namespace_, name_='links', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.links
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StructuredSyslogLinkmap'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('links=[\n')
        level += 1
        for links_ in self.links:
            showIndent(outfile, level)
            outfile.write('model_.StructuredSyslogLinkType(\n')
            links_.exportLiteral(outfile, level, name_='StructuredSyslogLinkType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def exportDict(self, name_='StructuredSyslogLinkmap'):
        # do obj->json->dict to handle nested complextype in object
        obj_json = json.dumps(self, default=lambda o: dict((k, v) for k, v in o.__dict__.items()))
        obj_dict = json.loads(obj_json)
        if name_:
            return {name_: obj_dict}
        return obj_dict
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'links':
            obj_ = StructuredSyslogLinkType.factory()
            obj_.build(child_)
            self.links.append(obj_)
# end class StructuredSyslogLinkmap



__all__ = [
    "AclEntriesType",
    "AclRuleType",
    "ActionAsPathType",
    "ActionCommunityType",
    "ActionExtCommunityType",
    "ActionListType",
    "ActionUpdateType",
    "AddressFamilies",
    "AddressType",
    "AlarmAndList",
    "AlarmExpression",
    "AlarmOperand2",
    "AlarmOrList",
    "AllocationPoolType",
    "AllowedAddressPair",
    "AllowedAddressPairs",
    "ApiAccessListType",
    "ApiAccessType",
    "AsListType",
    "AsnRangeType",
    "AttachmentAddressType",
    "AttachmentInfoType",
    "AuthenticationData",
    "AuthenticationKeyItem",
    "AutonomousSystemsType",
    "BGPaaSControlNodeZoneAttributes",
    "BGPaaServiceParametersType",
    "BaremetalPortGroupInfo",
    "BaremetalPortInfo",
    "BaremetalProperties",
    "BaremetalServerInfo",
    "BfdParameters",
    "BgpFamilyAttributes",
    "BgpParameters",
    "BgpPeeringAttributes",
    "BgpPrefixLimit",
    "BgpRouterParams",
    "BgpSession",
    "BgpSessionAttributes",
    "BindingType",
    "BridgeDomainMembershipType",
    "CliDiffInfoType",
    "CliDiffListType",
    "CloudInstanceInfo",
    "CommunityAttributes",
    "CommunityListType",
    "ConnectionType",
    "ControlTrafficDscpType",
    "DefaultProtocolType",
    "DeviceCredential",
    "DeviceCredentialList",
    "DeviceFamilyListType",
    "DevicePlatformListType",
    "DhcpOptionType",
    "DhcpOptionsListType",
    "DiscoveryPubSubEndPointType",
    "DiscoveryServiceAssignmentType",
    "DnsSoaRecordType",
    "DnsmasqLeaseParameters",
    "DomainLimitsType",
    "DpdkInfo",
    "DriverInfo",
    "ESXIHostInfo",
    "ESXIProperties",
    "EcmpHashingIncludeFields",
    "EnabledInterfaceParams",
    "EncapsulationPrioritiesType",
    "EncryptionTunnelEndpoint",
    "EncryptionTunnelEndpointList",
    "ExecutableInfoListType",
    "ExecutableInfoType",
    "ExtCommunityListType",
    "FabricNetworkTag",
    "FatFlowProtocols",
    "FieldNamesList",
    "FirewallRuleEndpointType",
    "FirewallRuleMatchTagsType",
    "FirewallRuleMatchTagsTypeIdList",
    "FirewallSequence",
    "FirewallServiceGroupType",
    "FirewallServiceType",
    "FloatingIpPoolSubnetType",
    "FlowAgingTimeout",
    "FlowAgingTimeoutList",
    "GracefulRestartParametersType",
    "IdPermsType",
    "InstanceTargetType",
    "InterfaceMapType",
    "InterfaceMirrorType",
    "IpAddressesType",
    "IpamDnsAddressType",
    "IpamSubnetType",
    "IpamSubnets",
    "IpamType",
    "JunosServicePorts",
    "KeyValuePair",
    "KeyValuePairs",
    "LinklocalServiceEntryType",
    "LinklocalServicesTypes",
    "LoadbalancerHealthmonitorType",
    "LoadbalancerListenerType",
    "LoadbalancerMemberType",
    "LoadbalancerPoolType",
    "LoadbalancerType",
    "LocalLinkConnection",
    "LogicalRouterPRListParams",
    "LogicalRouterPRListType",
    "LogicalRouterVirtualNetworkType",
    "MACLimitControlType",
    "MACMoveLimitControlType",
    "MacAddressesType",
    "MatchConditionType",
    "MirrorActionType",
    "MulticastSourceGroup",
    "MulticastSourceGroups",
    "NamespaceValue",
    "NodeProfileRoleType",
    "NodeProfileRolesType",
    "OspfParameters",
    "PermType",
    "PermType2",
    "PimParameters",
    "PlaybookInfoListType",
    "PlaybookInfoType",
    "PluginProperties",
    "PluginProperty",
    "PolicyBasedForwardingRuleType",
    "PolicyEntriesType",
    "PolicyRuleType",
    "PolicyStatementType",
    "PolicyTermType",
    "PortGroupProperties",
    "PortInfoType",
    "PortMap",
    "PortMappings",
    "PortTranslationPool",
    "PortTranslationPools",
    "PortType",
    "PrefixListMatchType",
    "PrefixMatchType",
    "ProtocolBgpType",
    "ProtocolOspfType",
    "ProtocolStaticType",
    "ProtocolType",
    "ProviderDetails",
    "QosIdForwardingClassPair",
    "QosIdForwardingClassPairs",
    "QuotaType",
    "RbacPermType",
    "RbacRuleEntriesType",
    "RbacRuleType",
    "RouteFilterProperties",
    "RouteFilterType",
    "RouteListType",
    "RouteOriginOverride",
    "RouteTableType",
    "RouteTargetList",
    "RouteType",
    "RoutedProperties",
    "RoutingBridgingRolesType",
    "RoutingPolicyParameters",
    "RoutingPolicyServiceInstanceType",
    "RoutingPolicyType",
    "SNMPCredentials",
    "SecurityLoggingObjectRuleEntryType",
    "SecurityLoggingObjectRuleListType",
    "SequenceType",
    "SerialNumListType",
    "ServiceApplianceInterfaceType",
    "ServiceChainInfo",
    "ServiceHealthCheckType",
    "ServiceInstanceInterfaceType",
    "ServiceInstanceType",
    "ServiceInterfaceTag",
    "ServiceScaleOutType",
    "ServiceTemplateInterfaceType",
    "ServiceTemplateType",
    "ServiceVirtualNetworkType",
    "SflowParameters",
    "ShareType",
    "SloRateType",
    "SriovInfo",
    "StaticMirrorNhType",
    "StaticRouteEntriesType",
    "StaticRouteParameters",
    "StaticRouteType",
    "StatsCollectionFrequency",
    "StormControlParameters",
    "StructuredSyslogLinkType",
    "StructuredSyslogLinkmap",
    "SubnetListType",
    "SubnetType",
    "TelemetryResourceInfo",
    "TelemetryStateInfo",
    "TermActionListType",
    "TermMatchConditionType",
    "TimerType",
    "UserCredentials",
    "UserDefinedLogStat",
    "UserDefinedLogStatList",
    "UuidType",
    "UveKeysType",
    "VendorHardwaresType",
    "VirtualDnsRecordType",
    "VirtualDnsType",
    "VirtualIpType",
    "VirtualMachineInterfacePropertiesType",
    "VirtualNetworkPolicyType",
    "VirtualNetworkRoutedPropertiesType",
    "VirtualNetworkType",
    "VirtualRouterNetworkIpamType",
    "VnSubnetsType",
    "VpgInterfaceParametersType",
    "VrfAssignRuleType",
    "VrfAssignTableType"
    ]
