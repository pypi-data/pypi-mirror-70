"""
PathGeneratorLatentLinear.py

Concrete subclass of AbstractPathGenerator that generates nonlinear paths
between points in their original feature space. These nonlinear paths are
created by using a latent space embedding created by an autoencoder structure.
The autoencoder structure involves two functions:
+ An encoder, which maps original features to latent features
+ A decoder, which maps latent features to an estimate of original features.
The nonlinear path is generated by mapping source and destination to the
latent space (using the encoder), doing linear interpolation there, and
mapping back to the original feature space (using the decoder). This is in
the context of path integrated gradients as described in "Axiomatic
Attribution for Deep Networks" by M Sundarajan et al
(https://arxiv.org/abs/1703.01365).

Defines:
+ class LatentLinearPathGenerator(AbstractPathGenerator)

"""

import numpy as np  # matrix operations
from eig.paths.PathGeneratorAbstract import AbstractPathGenerator
from eig.paths.path_utils import interpolate_linear


class LatentLinearPathGenerator(AbstractPathGenerator):
    """
    Concrete realization of AbstractPathGenerator that creates a path
    that is linear in autoencoder latent space.

    Attributes
    ----------
    encoder: Callable[[np.ndarray(shape=(n, *feature_shape))],
                      np.ndarray(shape=(n, *latent_shape))]
        Function that maps features in original space to latent space. The
        values `feature_shape` and `latent_shape` are fixed, while `n` is any
        positive integer.
    decoder: Callable[[np.ndarray(shape=(m, *latent_shape))],
                      np.ndarray(shape=(m, *feature_shape))]
        Function that maps features from latent space back to the original
        space. Typically trained such that x ~ decoder(encoder(x)). The values
        `feature_shape` and `latent_shape` are fixed, while `n` is any
        positive integer.
    pct_interpolate_ends: float
        Percentage of npoints for calls to get_path(s) that will be devoted
        to linearly interpolating difference between src/dst and autoencoded
        version.

    Methods
    -------
    get_path(src, dst, npoints):
        Obtains path between src and dst.

    Notes
    -----
    Currently no checking done for dimensions of encoder/decoder input.
    However, note that src/dst should be of an appropriate dimension for them.
    """
    def __init__(self, encoder, decoder, pct_interpolate_ends=0.0):
        """
        Parameters
        ----------
        encoder: Callable[[np.ndarray(shape=(n, *feature_shape))],
                          np.ndarray(shape=(n, *latent_shape))]
            Function that maps features in original space to latent space. The
            values `feature_shape` and `latent_shape` are fixed, while `n` is
            any positive integer.
        decoder: Callable[[np.ndarray(shape=(m, *latent_shape))],
                          np.ndarray(shape=(m, *feature_shape))]
            Function that maps features from latent space back to the original
            space. Typically trained such that x ~ decoder(encoder(x)). The
            values `feature_shape` and `latent_shape` are fixed, while `n` is
            any positive integer.
        pct_interpolate_ends: Optional[float]
            Fraction of npoints that will be used to interpolate between
            src/dst and their autoencoded counterparts (half to each). Default
            value of 40% set by empirical evaluation of L1 distances for
            individual steps comparing interior path vs the first and last
            steps.
        """
        # keep track of encoder and decoder
        self.encoder = encoder
        self.decoder = decoder
        # keep track of interpolation percentage
        if not (0 <= pct_interpolate_ends <= 1):
            raise ValueError("pct_interpolate_ends must be between 0 and 1")
        self.pct_interpolate_ends = pct_interpolate_ends
        return

    def get_path(self, src, dst, npoints):
        """ Obtain nonlinear path between src and dst using encoder/decoder

        Uses encoder/decoder to make a nonlinear path in original feature
        space corresponding to linear path in latent space corresponding to
        encoder/decoder.

        Parameters
        ----------
        src: np.ndarray
            The source of the resultant path
        dst: np.ndarray
            The destination of the resultant path
        npoints: int
            The number of points in the resultant path. This must be at least 4
            because it requires both the original and autoencoded endpoints.

        Returns
        -------
        np.ndarray(shape=(npoints, *src.shape))
            The resulting path from src to dst, linear in latent features.
        """
        # use get_paths
        return self.get_paths(src[np.newaxis], dst[np.newaxis], npoints)[0]

    def get_paths_decode(self, src_array, dst_array, decoder_data, npoints):
        """ Obtain nonlinear paths between points using encoder/decoder

        Uses encoder/decoder to make a nonlinear path in original feature
        space corresponding to linear path in latent space corresponding to
        encoder/decoder.

        Parameters
        ----------
        src_array, dst_array: np.ndarray(shape=(npaths, *feature_shape))
            The sources and destinations of resulting paths
        npoints: int
            The number of points in the resultant path. This must be at least 4
            because it requires both the original and autoencoded endpoints.

        Returns
        -------
        np.ndarray(shape=(npoints, *src.shape))
            The resulting paths from sources to destinations, linear in latent
            features
        """
        # If encoder has other inputs, it will be fed as list,
        # extract src and destination from it.
        if isinstance(src_array, list) and isinstance(dst_array, list):
            src = src_array[0]
            dst = dst_array[0]
            if src_array[1] is not None:
                src_encoder = [src, src_array[1]]
            else:
                src_encoder = [src]
            if dst_array[1] is not None:
                dst_encoder = [dst, dst_array[1]]
            else:
                dst_encoder = [dst]
        else:
            src_encoder = src_array
            dst_encoder = dst_array
            src = src_array
            dst = dst_array
        # check provided input
        if npoints < 4:
            raise ValueError("npoints must be greater than or equal to 4")
        if src.shape != dst.shape:
            print(src, dst)
            raise ValueError("src and dst must have same shapes")

        # calculate how to divide interpolation in linear/latent space
        # linear interpolation for ends of path between src/dst and
        # corresponding autoencoded points
        # npoints = nsrc + ninterior + nend, where nsrc=nend
        # define nborder = nsrc + nend,
        # then nborder ~ npoints * pct_interpolate_end
        nborder_flt = npoints * self.pct_interpolate_ends  # floating point
        # make sure within appropriate range (2 <= nborder <= npoints - 2)
        nborder = min(max(int(np.floor(nborder_flt)), 2), npoints - 2)
        # integer division by 2 for nsrc and nend (fine to lose 1 remainder)
        nsrc = nborder // 2
        nend = nsrc
        # get ninterior
        ninterior = npoints - nsrc - nend

        # encode endpoints
        src_latent = self.encoder(src_encoder)
        dst_latent = self.encoder(dst_encoder)

        # obtain interior path: linear in latent space
        interior_path_latent = interpolate_linear(
            src_latent, dst_latent, ninterior,
            endpoint=True, interpolate_axis=1
        )
        
        # map interior points of path back to original space
        interior_path_latent_flatten = interior_path_latent.reshape(
            [interior_path_latent.shape[0] * interior_path_latent.shape[1]]
            + list(interior_path_latent.shape[2:])
        ) 

        if decoder_data is not None:
            decoder_list = [interior_path_latent_flatten, decoder_data]
        else:
            decoder_list = [interior_path_latent_flatten]
        interior_path_original_flatten = self.decoder(decoder_list)

        # make our final path...
        paths = np.zeros(
            shape=[len(src), npoints] + list(src.shape[1:])
        )
        
        # put in the interior path
        paths[:, nsrc:-nend] = interior_path_original_flatten.reshape(
            list(interior_path_latent.shape[:2]) + list(src.shape[1:])
        )
        # linearly interpolate in the source path
        paths[:, :nsrc] = interpolate_linear(
            src, paths[:, nsrc], nsrc,
            endpoint=False, interpolate_axis=1
        )
        # linearly interpolate in the destination/end path
        paths[:, -nend:] = interpolate_linear(
            paths[:, -nend - 1], dst, nend + 1,
            endpoint=True, interpolate_axis=1
        )[:, 1:]  # skip the first point
        
        # return the resulting path
        return paths
