# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.


import weakref
import ctypes
from sys import getrefcount


#
_incref = ctypes.pythonapi.Py_IncRef
_incref.argtypes = [ctypes.py_object]
_incref.restype = None


#
_decref = ctypes.pythonapi.Py_DecRef
_decref.argtypes = [ctypes.py_object]
_decref.restype = None




from enum import IntEnum


from warnings import warn


import weakref



from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_genapi')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_genapi')
    _genapi = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_genapi', [dirname(__file__)])
        except ImportError:
            import _genapi
            return _genapi
        try:
            _mod = imp.load_module('_genapi', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _genapi = swig_import_helper()
    del swig_import_helper
else:
    import _genapi
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

try:
    import weakref
    weakref_proxy = weakref.proxy
except __builtin__.Exception:
    weakref_proxy = lambda x: x


class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _genapi.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self):
        return _genapi.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _genapi.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _genapi.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _genapi.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _genapi.SwigPyIterator_equal(self, x)

    def copy(self):
        return _genapi.SwigPyIterator_copy(self)

    def next(self):
        return _genapi.SwigPyIterator_next(self)

    def __next__(self):
        return _genapi.SwigPyIterator___next__(self)

    def previous(self):
        return _genapi.SwigPyIterator_previous(self)

    def advance(self, n):
        return _genapi.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _genapi.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _genapi.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _genapi.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _genapi.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _genapi.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _genapi.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _genapi.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class ios_base(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ios_base, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ios_base, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    erase_event = _genapi.ios_base_erase_event
    imbue_event = _genapi.ios_base_imbue_event
    copyfmt_event = _genapi.ios_base_copyfmt_event

    def register_callback(self, __fn, __index):
        return _genapi.ios_base_register_callback(self, __fn, __index)

    def flags(self, *args):
        return _genapi.ios_base_flags(self, *args)

    def setf(self, *args):
        return _genapi.ios_base_setf(self, *args)

    def unsetf(self, __mask):
        return _genapi.ios_base_unsetf(self, __mask)

    def precision(self, *args):
        return _genapi.ios_base_precision(self, *args)

    def width(self, *args):
        return _genapi.ios_base_width(self, *args)
    if _newclass:
        sync_with_stdio = staticmethod(_genapi.ios_base_sync_with_stdio)
    else:
        sync_with_stdio = _genapi.ios_base_sync_with_stdio

    def imbue(self, __loc):
        return _genapi.ios_base_imbue(self, __loc)

    def getloc(self):
        return _genapi.ios_base_getloc(self)
    if _newclass:
        xalloc = staticmethod(_genapi.ios_base_xalloc)
    else:
        xalloc = _genapi.ios_base_xalloc

    def iword(self, __ix):
        return _genapi.ios_base_iword(self, __ix)

    def pword(self, __ix):
        return _genapi.ios_base_pword(self, __ix)
    __swig_destroy__ = _genapi.delete_ios_base
    __del__ = lambda self: None
ios_base_swigregister = _genapi.ios_base_swigregister
ios_base_swigregister(ios_base)
cvar = _genapi.cvar
ios_base.boolalpha = _genapi.cvar.ios_base_boolalpha
ios_base.dec = _genapi.cvar.ios_base_dec
ios_base.fixed = _genapi.cvar.ios_base_fixed
ios_base.hex = _genapi.cvar.ios_base_hex
ios_base.internal = _genapi.cvar.ios_base_internal
ios_base.left = _genapi.cvar.ios_base_left
ios_base.oct = _genapi.cvar.ios_base_oct
ios_base.right = _genapi.cvar.ios_base_right
ios_base.scientific = _genapi.cvar.ios_base_scientific
ios_base.showbase = _genapi.cvar.ios_base_showbase
ios_base.showpoint = _genapi.cvar.ios_base_showpoint
ios_base.showpos = _genapi.cvar.ios_base_showpos
ios_base.skipws = _genapi.cvar.ios_base_skipws
ios_base.unitbuf = _genapi.cvar.ios_base_unitbuf
ios_base.uppercase = _genapi.cvar.ios_base_uppercase
ios_base.adjustfield = _genapi.cvar.ios_base_adjustfield
ios_base.basefield = _genapi.cvar.ios_base_basefield
ios_base.floatfield = _genapi.cvar.ios_base_floatfield
ios_base.badbit = _genapi.cvar.ios_base_badbit
ios_base.eofbit = _genapi.cvar.ios_base_eofbit
ios_base.failbit = _genapi.cvar.ios_base_failbit
ios_base.goodbit = _genapi.cvar.ios_base_goodbit
ios_base.app = _genapi.cvar.ios_base_app
ios_base.ate = _genapi.cvar.ios_base_ate
ios_base.binary = _genapi.cvar.ios_base_binary
ios_base.ios_base_in = _genapi.cvar.ios_base_ios_base_in
ios_base.out = _genapi.cvar.ios_base_out
ios_base.trunc = _genapi.cvar.ios_base_trunc
ios_base.beg = _genapi.cvar.ios_base_beg
ios_base.cur = _genapi.cvar.ios_base_cur
ios_base.end = _genapi.cvar.ios_base_end

def ios_base_sync_with_stdio(__sync=True):
    return _genapi.ios_base_sync_with_stdio(__sync)
ios_base_sync_with_stdio = _genapi.ios_base_sync_with_stdio

def ios_base_xalloc():
    return _genapi.ios_base_xalloc()
ios_base_xalloc = _genapi.ios_base_xalloc

class ios(ios_base):
    __swig_setmethods__ = {}
    for _s in [ios_base]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ios, name, value)
    __swig_getmethods__ = {}
    for _s in [ios_base]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ios, name)
    __repr__ = _swig_repr

    def rdstate(self):
        return _genapi.ios_rdstate(self)

    def clear(self, *args):
        return _genapi.ios_clear(self, *args)

    def setstate(self, __state):
        return _genapi.ios_setstate(self, __state)

    def good(self):
        return _genapi.ios_good(self)

    def eof(self):
        return _genapi.ios_eof(self)

    def fail(self):
        return _genapi.ios_fail(self)

    def bad(self):
        return _genapi.ios_bad(self)

    def exceptions(self, *args):
        return _genapi.ios_exceptions(self, *args)

    def __init__(self, __sb):
        this = _genapi.new_ios(__sb)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _genapi.delete_ios
    __del__ = lambda self: None

    def tie(self, *args):
        return _genapi.ios_tie(self, *args)

    def rdbuf(self, *args):
        return _genapi.ios_rdbuf(self, *args)

    def copyfmt(self, __rhs):
        return _genapi.ios_copyfmt(self, __rhs)

    def fill(self, *args):
        return _genapi.ios_fill(self, *args)

    def imbue(self, __loc):
        return _genapi.ios_imbue(self, __loc)

    def narrow(self, __c, __dfault):
        return _genapi.ios_narrow(self, __c, __dfault)

    def widen(self, __c):
        return _genapi.ios_widen(self, __c)
ios_swigregister = _genapi.ios_swigregister
ios_swigregister(ios)


GenericException = _genapi.GenericException


InvalidArgumentException = _genapi.InvalidArgumentException


OutOfRangeException = _genapi.OutOfRangeException


PropertyException = _genapi.PropertyException


RuntimeException = _genapi.RuntimeException


LogicalErrorException = _genapi.LogicalErrorException


AccessException = _genapi.AccessException


TimeoutException = _genapi.TimeoutException


DynamicCastException = _genapi.DynamicCastException


class ESign(IntEnum):
    """
    signed or unsigned integers
    """
    Signed          = 0     #: Integer is signed
    Unsigned        = 1     #: Integer is unsigned
    _UndefinedSign  = 2     #: Object is not yet initialized


class EAccessMode(IntEnum):
    """
    access mode of a node
    """
    NI              = 0     #: Not implemented
    NA              = 1     #: Not available
    WO              = 2     #: Write Only
    RO              = 3     #: Read Only
    RW                    = 4       #: Read and Write
    _UndefinedAccesMode   = 5 #: Object is not yet initialized
    _CycleDetectAccesMode = 6   #: used internally for AccessMode cycle detection


class EVisibility(IntEnum):
    """
    recommended visibility of a node
    """
    Beginner = 0,              #: Always visible
    Expert = 1,                #: Visible for experts or Gurus
    Guru = 2,                  #: Visible for Gurus
    Invisible = 3,             #: Not Visible
    _UndefinedVisibility  = 99 #: Object is not yet initialized


class ECachingMode(IntEnum):
    """
    caching mode of a register
    """
    NoCache = 0              #: Do not use cache
    WriteThrough = 1         #: Write to cache and register
    WriteAround = 2          #: Write to register, write to cache on read
    _UndefinedCachingMode = 3#: Not yet initialized


class ERepresentation(IntEnum):
    """
    recommended representation of a node value
    """
    Linear = 0                     #: Slider with linear behavior
    Logarithmic = 1                #: Slider with logarithmic behaviour
    Boolean = 2                    #: Check box
    PureNumber = 3                 #: Decimal number in an edit control
    HexNumber = 4                  #: Hex number in an edit control
    IPV4Address = 5                #: IP-Address
    MACAddress = 6                 #: MAC-Address
    _UndefinedRepresentation = 7   #: undefined


class EEndianess(IntEnum):
    """
    Endianess of a value in a register
    """
    BigEndian = 0        #: Register is big endian
    LittleEndian = 1     #: Register is little endian
    _UndefinedEndian = 2 #: Object is not yet initialized


class ENameSpace(IntEnum):
    """
    Defines if a node name is standard or custom
    """
    Custom = 0              #: name resides in custom namespace
    Standard = 1           #: name resides in one of the standard namespaces
    _UndefinedNameSpace = 2#: Object is not yet initialized


class EStandardNameSpace(IntEnum):
    """
    Defines from which standard namespace a node name comes from
    """
    Custom = 0          #: name resides in custom namespace
    GEV = 1             #: name resides in GigE Vision namespace
    IIDC = 2            #: name resides in 1394 IIDC namespace
    CL = 3              #: name resides in camera link namespace
    USB = 4             #: name resides in USB namespace
    _UndefinedStandardNameSpace = 5  #: Object is not yet initialized


class EYesNo(IntEnum):
    """
    Defines the chices of a Yes/No alternaitve
    """
    No = 0,                 #: no
    Yes = 1,                #: yes
    _UndefinedYesNo = 2     #: Object is not yet initialized


class ESlope(IntEnum):
    """
    typedef for fomula type
    """
    Increasing = 0      #: strictly monotonous increasing
    Decreasing = 1      #: strictly monotonous decreasing
    Varying = 2         #: slope changes, e.g. at run-time
    Automatic = 3      #: slope is determined automatically by probing the function
    _UndefinedESlope  = 4#: Object is not yet initialized


class EXMLValidation(IntEnum):
    """
    typedef describing the different validity checks which can be performed on an XML file
    """
    xvLoad      = 0x00000001    #: Creates a dummy node map
    xvCycles    = 0x00000002    #: checks for write and dependency cycles (implies xvLoad)
    xvSFNC      = 0x00000004    #: checks for conformance with the standard feature naming convention (SFNC)
    xvDefault   = 0x00000000    #: checks performed if nothing else is said
    xvAll       = 0xffffffff    #: all possible checks
    _UndefinedEXMLValidation = 0x8000000 #: Object is not yet initialized


class EDisplayNotation(IntEnum):
    """
    typedef for float notation
    """
    fnAutomatic = 0                #: the notation if either scientific or fixed depending on what is shorter
    fnFixed = 1                    #: the notation is fixed, e.g. 123.4
    fnScientific = 2               #: the notation is scientific, e.g. 1.234e2
    _UndefinedEDisplayNotation = 3 #: Object is not yet initialized


class EInterfaceType(IntEnum):
    """
    typedef for interface type
    """
    intfIValue = 0       #: IValue interface
    intfIBase = 1        #: IBase interface
    intfIInteger = 2     #: IInteger interface
    intfIBoolean = 3     #: IBoolean interface
    intfICommand = 4     #: ICommand interface
    intfIFloat = 5       #: IFloat interface
    intfIString = 6      #: IString interface
    intfIRegister = 7    #: IRegister interface
    intfICategory = 8    #: ICategory interface
    intfIEnumeration = 9 #: IEnumeration interface
    intfIEnumEntry = 10   #: IEnumEntry interface
    intfIPort       = 11  #: IPort interface


class ELinkType(IntEnum):
    """
    typedef for link type For details see GenICam wiki : GenApi/SoftwareArchitecture/NodeDependencies
    """
    ctParentNodes = 0                       #: All nodes for which this node is at least an invalidating child
    ctReadingChildren = 1           #: All nodes which can be read from
    ctWritingChildren = 2           #: All nodes which can write a value further down the node stack
    ctInvalidatingChildren = 3 #: All directly connected nodes which invalidate this node
    ctDependingNodes = 4    #: All directly or indirectly connected nodes which are invalidated by this nodes (i.e. which are dependent on this node)
    ctTerminalNodes = 5         #: All indirectly connected terminal nodes


class EIncMode(IntEnum):
    """
    typedef for increment mode
    """
    noIncrement = 0    #: The feature has no increment
    fixedIncrement = 1 #: The feature has a fix increment
    listIncrement = 2  #: The feature has a list of valid value


class EInputDirection(IntEnum):
    """
    typedef for link type
    """
    idFrom = 0 #: Indicates a swiss knife that it is used as worker for a converter computing FROM
    idTo = 1   #: Indicates a swiss knife that it is used as worker for a converter computing TO
    idNone = 2 #: SwissKnife is not used within a converter


class ECallbackType(IntEnum):
    """
    the type of callback
    """
    cbPostInsideLock = 1   #: callback is fired on leaving the tree inside the lock-guarded area
    cbPostOutsideLock = 2  #: callback is fired on leaving the tree inside the lock-guarded area

class ESignClass(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ESignClass, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ESignClass, name)
    __repr__ = _swig_repr
    if _newclass:
        from_string = staticmethod(_genapi.ESignClass_from_string)
    else:
        from_string = _genapi.ESignClass_from_string
    if _newclass:
        to_string = staticmethod(_genapi.ESignClass_to_string)
    else:
        to_string = _genapi.ESignClass_to_string

    def __init__(self):
        this = _genapi.new_ESignClass()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _genapi.delete_ESignClass
    __del__ = lambda self: None
ESignClass_swigregister = _genapi.ESignClass_swigregister
ESignClass_swigregister(ESignClass)

def ESignClass_from_string(ValueStr, pValue):
    return _genapi.ESignClass_from_string(ValueStr, pValue)
ESignClass_from_string = _genapi.ESignClass_from_string

def ESignClass_to_string(*args):
    return _genapi.ESignClass_to_string(*args)
ESignClass_to_string = _genapi.ESignClass_to_string

class EEndianessClass(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, EEndianessClass, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, EEndianessClass, name)
    __repr__ = _swig_repr
    if _newclass:
        from_string = staticmethod(_genapi.EEndianessClass_from_string)
    else:
        from_string = _genapi.EEndianessClass_from_string
    if _newclass:
        to_string = staticmethod(_genapi.EEndianessClass_to_string)
    else:
        to_string = _genapi.EEndianessClass_to_string

    def __init__(self):
        this = _genapi.new_EEndianessClass()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _genapi.delete_EEndianessClass
    __del__ = lambda self: None
EEndianessClass_swigregister = _genapi.EEndianessClass_swigregister
EEndianessClass_swigregister(EEndianessClass)

def EEndianessClass_from_string(ValueStr, pValue):
    return _genapi.EEndianessClass_from_string(ValueStr, pValue)
EEndianessClass_from_string = _genapi.EEndianessClass_from_string

def EEndianessClass_to_string(*args):
    return _genapi.EEndianessClass_to_string(*args)
EEndianessClass_to_string = _genapi.EEndianessClass_to_string

class ERepresentationClass(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ERepresentationClass, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ERepresentationClass, name)
    __repr__ = _swig_repr
    if _newclass:
        from_string = staticmethod(_genapi.ERepresentationClass_from_string)
    else:
        from_string = _genapi.ERepresentationClass_from_string
    if _newclass:
        to_string = staticmethod(_genapi.ERepresentationClass_to_string)
    else:
        to_string = _genapi.ERepresentationClass_to_string

    def __init__(self):
        this = _genapi.new_ERepresentationClass()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _genapi.delete_ERepresentationClass
    __del__ = lambda self: None
ERepresentationClass_swigregister = _genapi.ERepresentationClass_swigregister
ERepresentationClass_swigregister(ERepresentationClass)

def ERepresentationClass_from_string(ValueStr, pValue):
    return _genapi.ERepresentationClass_from_string(ValueStr, pValue)
ERepresentationClass_from_string = _genapi.ERepresentationClass_from_string

def ERepresentationClass_to_string(*args):
    return _genapi.ERepresentationClass_to_string(*args)
ERepresentationClass_to_string = _genapi.ERepresentationClass_to_string

class EVisibilityClass(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, EVisibilityClass, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, EVisibilityClass, name)
    __repr__ = _swig_repr
    if _newclass:
        from_string = staticmethod(_genapi.EVisibilityClass_from_string)
    else:
        from_string = _genapi.EVisibilityClass_from_string
    if _newclass:
        to_string = staticmethod(_genapi.EVisibilityClass_to_string)
    else:
        to_string = _genapi.EVisibilityClass_to_string

    def __init__(self):
        this = _genapi.new_EVisibilityClass()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _genapi.delete_EVisibilityClass
    __del__ = lambda self: None
EVisibilityClass_swigregister = _genapi.EVisibilityClass_swigregister
EVisibilityClass_swigregister(EVisibilityClass)

def EVisibilityClass_from_string(ValueStr, pValue):
    return _genapi.EVisibilityClass_from_string(ValueStr, pValue)
EVisibilityClass_from_string = _genapi.EVisibilityClass_from_string

def EVisibilityClass_to_string(*args):
    return _genapi.EVisibilityClass_to_string(*args)
EVisibilityClass_to_string = _genapi.EVisibilityClass_to_string

class EAccessModeClass(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, EAccessModeClass, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, EAccessModeClass, name)
    __repr__ = _swig_repr
    if _newclass:
        from_string = staticmethod(_genapi.EAccessModeClass_from_string)
    else:
        from_string = _genapi.EAccessModeClass_from_string
    if _newclass:
        to_string = staticmethod(_genapi.EAccessModeClass_to_string)
    else:
        to_string = _genapi.EAccessModeClass_to_string

    def __init__(self):
        this = _genapi.new_EAccessModeClass()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _genapi.delete_EAccessModeClass
    __del__ = lambda self: None
EAccessModeClass_swigregister = _genapi.EAccessModeClass_swigregister
EAccessModeClass_swigregister(EAccessModeClass)

def EAccessModeClass_from_string(ValueStr, pValue):
    return _genapi.EAccessModeClass_from_string(ValueStr, pValue)
EAccessModeClass_from_string = _genapi.EAccessModeClass_from_string

def EAccessModeClass_to_string(*args):
    return _genapi.EAccessModeClass_to_string(*args)
EAccessModeClass_to_string = _genapi.EAccessModeClass_to_string

class ECachingModeClass(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ECachingModeClass, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ECachingModeClass, name)
    __repr__ = _swig_repr
    if _newclass:
        from_string = staticmethod(_genapi.ECachingModeClass_from_string)
    else:
        from_string = _genapi.ECachingModeClass_from_string
    if _newclass:
        to_string = staticmethod(_genapi.ECachingModeClass_to_string)
    else:
        to_string = _genapi.ECachingModeClass_to_string

    def __init__(self):
        this = _genapi.new_ECachingModeClass()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _genapi.delete_ECachingModeClass
    __del__ = lambda self: None
ECachingModeClass_swigregister = _genapi.ECachingModeClass_swigregister
ECachingModeClass_swigregister(ECachingModeClass)

def ECachingModeClass_from_string(ValueStr, pValue):
    return _genapi.ECachingModeClass_from_string(ValueStr, pValue)
ECachingModeClass_from_string = _genapi.ECachingModeClass_from_string

def ECachingModeClass_to_string(*args):
    return _genapi.ECachingModeClass_to_string(*args)
ECachingModeClass_to_string = _genapi.ECachingModeClass_to_string

class ENameSpaceClass(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ENameSpaceClass, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ENameSpaceClass, name)
    __repr__ = _swig_repr
    if _newclass:
        from_string = staticmethod(_genapi.ENameSpaceClass_from_string)
    else:
        from_string = _genapi.ENameSpaceClass_from_string
    if _newclass:
        to_string = staticmethod(_genapi.ENameSpaceClass_to_string)
    else:
        to_string = _genapi.ENameSpaceClass_to_string

    def __init__(self):
        this = _genapi.new_ENameSpaceClass()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _genapi.delete_ENameSpaceClass
    __del__ = lambda self: None
ENameSpaceClass_swigregister = _genapi.ENameSpaceClass_swigregister
ENameSpaceClass_swigregister(ENameSpaceClass)

def ENameSpaceClass_from_string(ValueStr, pValue):
    return _genapi.ENameSpaceClass_from_string(ValueStr, pValue)
ENameSpaceClass_from_string = _genapi.ENameSpaceClass_from_string

def ENameSpaceClass_to_string(*args):
    return _genapi.ENameSpaceClass_to_string(*args)
ENameSpaceClass_to_string = _genapi.ENameSpaceClass_to_string

class EYesNoClass(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, EYesNoClass, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, EYesNoClass, name)
    __repr__ = _swig_repr
    if _newclass:
        from_string = staticmethod(_genapi.EYesNoClass_from_string)
    else:
        from_string = _genapi.EYesNoClass_from_string
    if _newclass:
        to_string = staticmethod(_genapi.EYesNoClass_to_string)
    else:
        to_string = _genapi.EYesNoClass_to_string

    def __init__(self):
        this = _genapi.new_EYesNoClass()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _genapi.delete_EYesNoClass
    __del__ = lambda self: None
EYesNoClass_swigregister = _genapi.EYesNoClass_swigregister
EYesNoClass_swigregister(EYesNoClass)

def EYesNoClass_from_string(ValueStr, pValue):
    return _genapi.EYesNoClass_from_string(ValueStr, pValue)
EYesNoClass_from_string = _genapi.EYesNoClass_from_string

def EYesNoClass_to_string(*args):
    return _genapi.EYesNoClass_to_string(*args)
EYesNoClass_to_string = _genapi.EYesNoClass_to_string

class EStandardNameSpaceClass(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, EStandardNameSpaceClass, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, EStandardNameSpaceClass, name)
    __repr__ = _swig_repr
    if _newclass:
        from_string = staticmethod(_genapi.EStandardNameSpaceClass_from_string)
    else:
        from_string = _genapi.EStandardNameSpaceClass_from_string
    if _newclass:
        to_string = staticmethod(_genapi.EStandardNameSpaceClass_to_string)
    else:
        to_string = _genapi.EStandardNameSpaceClass_to_string

    def __init__(self):
        this = _genapi.new_EStandardNameSpaceClass()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _genapi.delete_EStandardNameSpaceClass
    __del__ = lambda self: None
EStandardNameSpaceClass_swigregister = _genapi.EStandardNameSpaceClass_swigregister
EStandardNameSpaceClass_swigregister(EStandardNameSpaceClass)

def EStandardNameSpaceClass_from_string(ValueStr, pValue):
    return _genapi.EStandardNameSpaceClass_from_string(ValueStr, pValue)
EStandardNameSpaceClass_from_string = _genapi.EStandardNameSpaceClass_from_string

def EStandardNameSpaceClass_to_string(*args):
    return _genapi.EStandardNameSpaceClass_to_string(*args)
EStandardNameSpaceClass_to_string = _genapi.EStandardNameSpaceClass_to_string

class ESlopeClass(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ESlopeClass, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ESlopeClass, name)
    __repr__ = _swig_repr
    if _newclass:
        from_string = staticmethod(_genapi.ESlopeClass_from_string)
    else:
        from_string = _genapi.ESlopeClass_from_string
    if _newclass:
        to_string = staticmethod(_genapi.ESlopeClass_to_string)
    else:
        to_string = _genapi.ESlopeClass_to_string

    def __init__(self):
        this = _genapi.new_ESlopeClass()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _genapi.delete_ESlopeClass
    __del__ = lambda self: None
ESlopeClass_swigregister = _genapi.ESlopeClass_swigregister
ESlopeClass_swigregister(ESlopeClass)

def ESlopeClass_from_string(ValueStr, pValue):
    return _genapi.ESlopeClass_from_string(ValueStr, pValue)
ESlopeClass_from_string = _genapi.ESlopeClass_from_string

def ESlopeClass_to_string(*args):
    return _genapi.ESlopeClass_to_string(*args)
ESlopeClass_to_string = _genapi.ESlopeClass_to_string

class EDisplayNotationClass(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, EDisplayNotationClass, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, EDisplayNotationClass, name)
    __repr__ = _swig_repr
    if _newclass:
        from_string = staticmethod(_genapi.EDisplayNotationClass_from_string)
    else:
        from_string = _genapi.EDisplayNotationClass_from_string
    if _newclass:
        to_string = staticmethod(_genapi.EDisplayNotationClass_to_string)
    else:
        to_string = _genapi.EDisplayNotationClass_to_string

    def __init__(self):
        this = _genapi.new_EDisplayNotationClass()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _genapi.delete_EDisplayNotationClass
    __del__ = lambda self: None
EDisplayNotationClass_swigregister = _genapi.EDisplayNotationClass_swigregister
EDisplayNotationClass_swigregister(EDisplayNotationClass)

def EDisplayNotationClass_from_string(ValueStr, pValue):
    return _genapi.EDisplayNotationClass_from_string(ValueStr, pValue)
EDisplayNotationClass_from_string = _genapi.EDisplayNotationClass_from_string

def EDisplayNotationClass_to_string(*args):
    return _genapi.EDisplayNotationClass_to_string(*args)
EDisplayNotationClass_to_string = _genapi.EDisplayNotationClass_to_string

class EInputDirectionClass(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, EInputDirectionClass, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, EInputDirectionClass, name)
    __repr__ = _swig_repr
    if _newclass:
        from_string = staticmethod(_genapi.EInputDirectionClass_from_string)
    else:
        from_string = _genapi.EInputDirectionClass_from_string
    if _newclass:
        to_string = staticmethod(_genapi.EInputDirectionClass_to_string)
    else:
        to_string = _genapi.EInputDirectionClass_to_string

    def __init__(self):
        this = _genapi.new_EInputDirectionClass()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _genapi.delete_EInputDirectionClass
    __del__ = lambda self: None
EInputDirectionClass_swigregister = _genapi.EInputDirectionClass_swigregister
EInputDirectionClass_swigregister(EInputDirectionClass)

def EInputDirectionClass_from_string(ValueStr, pValue):
    return _genapi.EInputDirectionClass_from_string(ValueStr, pValue)
EInputDirectionClass_from_string = _genapi.EInputDirectionClass_from_string

def EInputDirectionClass_to_string(*args):
    return _genapi.EInputDirectionClass_to_string(*args)
EInputDirectionClass_to_string = _genapi.EInputDirectionClass_to_string

class Version(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Version, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Version, name)
    __repr__ = _swig_repr
    __swig_setmethods__["Major"] = _genapi.Version_Major_set
    __swig_getmethods__["Major"] = _genapi.Version_Major_get
    if _newclass:
        Major = _swig_property(_genapi.Version_Major_get, _genapi.Version_Major_set)
    __swig_setmethods__["Minor"] = _genapi.Version_Minor_set
    __swig_getmethods__["Minor"] = _genapi.Version_Minor_get
    if _newclass:
        Minor = _swig_property(_genapi.Version_Minor_get, _genapi.Version_Minor_set)
    __swig_setmethods__["SubMinor"] = _genapi.Version_SubMinor_set
    __swig_getmethods__["SubMinor"] = _genapi.Version_SubMinor_get
    if _newclass:
        SubMinor = _swig_property(_genapi.Version_SubMinor_get, _genapi.Version_SubMinor_set)

    def __init__(self):
        this = _genapi.new_Version()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _genapi.delete_Version
    __del__ = lambda self: None
Version_swigregister = _genapi.Version_swigregister
Version_swigregister(Version)

class IBase(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IBase, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IBase, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_access_mode(self):
        return _genapi.IBase_get_access_mode(self)
IBase_swigregister = _genapi.IBase_swigregister
IBase_swigregister(IBase)

class INode(IBase):
    __swig_setmethods__ = {}
    for _s in [IBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, INode, name, value)
    __swig_getmethods__ = {}
    for _s in [IBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, INode, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def _primal_get_name(self, FullQualified=False):
        return _genapi.INode__primal_get_name(self, FullQualified)

    def _get_name_space(self):
        return _genapi.INode__get_name_space(self)

    def _get_visibility(self):
        return _genapi.INode__get_visibility(self)

    def invalidate_node(self):
        return _genapi.INode_invalidate_node(self)

    def is_cachable(self):
        return _genapi.INode_is_cachable(self)

    def is_access_mode_cacheable(self):
        return _genapi.INode_is_access_mode_cacheable(self)

    def _get_caching_mode(self):
        return _genapi.INode__get_caching_mode(self)

    def _get_polling_time(self):
        return _genapi.INode__get_polling_time(self)

    def _get_tooltip(self):
        return _genapi.INode__get_tooltip(self)

    def _get_description(self):
        return _genapi.INode__get_description(self)

    def _get_display_name(self):
        return _genapi.INode__get_display_name(self)

    def _get_device_name(self):
        return _genapi.INode__get_device_name(self)

    def _get_children(self, *args):
        return _genapi.INode__get_children(self, *args)

    def _get_parents(self):
        return _genapi.INode__get_parents(self)

    def register_callback(self, INPUT):
        return _genapi.INode_register_callback(self, INPUT)

    def deregister_callback(self, hCallback):
        return _genapi.INode_deregister_callback(self, hCallback)

    def _get_node_map(self):
        return _genapi.INode__get_node_map(self)

    def _get_event_id(self):
        return _genapi.INode__get_event_id(self)

    def is_streamable(self):
        return _genapi.INode_is_streamable(self)

    def _get_property_names(self):
        return _genapi.INode__get_property_names(self)

    def get_property(self, PropertyName):
        return _genapi.INode_get_property(self, PropertyName)

    def impose_access_mode(self, ImposedAccessMode):
        return _genapi.INode_impose_access_mode(self, ImposedAccessMode)

    def impose_visibility(self, ImposedVisibility):
        return _genapi.INode_impose_visibility(self, ImposedVisibility)

    def _get_alias(self):
        return _genapi.INode__get_alias(self)

    def _get_cast_alias(self):
        return _genapi.INode__get_cast_alias(self)

    def _get_docu_url(self):
        return _genapi.INode__get_docu_url(self)

    def is_deprecated(self):
        return _genapi.INode_is_deprecated(self)

    def _get_principal_interface_type(self):
        return _genapi.INode__get_principal_interface_type(self)

    def is_feature(self):
        return _genapi.INode_is_feature(self)

    def is_selector(self):
        return _genapi.INode_is_selector(self)

    def _get_selected_features(self):
        return _genapi.INode__get_selected_features(self)

    def _get_selecting_features(self):
        return _genapi.INode__get_selecting_features(self)

    name_space = property(_get_name_space)


    visibility = property(_get_visibility)


    caching_mode = property(_get_caching_mode)


    polling_time = property(_get_polling_time)


    tooltip = property(_get_tooltip)


    description = property(_get_description)


    display_name = property(_get_display_name)


    device_name = property(_get_device_name)


    children = property(_get_children)


    parents = property(_get_parents)


    node_map = property(_get_node_map)


    event_id = property(_get_event_id)


    property_names = property(_get_property_names)


    alias = property(_get_alias)


    cast_alias = property(_get_cast_alias)


    docu_url = property(_get_docu_url)


    principal_interface_type = property(_get_principal_interface_type)


    def _get_name(self):
        return self._primal_get_name()

    def _get_name_full_qualified(self):
        return self._primal_get_name(True)



    name = property(_get_name)


    name_full_qualified = property(_get_name_full_qualified)


    selected_features = property(_get_selected_features)


    selecting_features = property(_get_selecting_features)

INode_swigregister = _genapi.INode_swigregister
INode_swigregister(INode)


def is_readable(*args):
    return _genapi.is_readable(*args)
is_readable = _genapi.is_readable

def is_writable(*args):
    return _genapi.is_writable(*args)
is_writable = _genapi.is_writable

def is_implemented(*args):
    return _genapi.is_implemented(*args)
is_implemented = _genapi.is_implemented

def is_available(*args):
    return _genapi.is_available(*args)
is_available = _genapi.is_available

def combine(Peter, Paul):
    return _genapi.combine(Peter, Paul)
combine = _genapi.combine

def is_visible(Visibility, MaxVisiblity):
    return _genapi.is_visible(Visibility, MaxVisiblity)
is_visible = _genapi.is_visible

def CombineVisibility(Peter, Paul):
    return _genapi.CombineVisibility(Peter, Paul)
CombineVisibility = _genapi.CombineVisibility

def is_cacheable(CachingMode):
    return _genapi.is_cacheable(CachingMode)
is_cacheable = _genapi.is_cacheable

def CombineCachingMode(Peter, Paul):
    return _genapi.CombineCachingMode(Peter, Paul)
CombineCachingMode = _genapi.CombineCachingMode
class INodeMap(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, INodeMap, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, INodeMap, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def _get_nodes(self):
        return _genapi.INodeMap__get_nodes(self)

    def get_node(self, Name):
        return _genapi.INodeMap_get_node(self, Name)

    def invalidate_nodes(self):
        return _genapi.INodeMap_invalidate_nodes(self)

    def connect(self, *args):
        return _genapi.INodeMap_connect(self, *args)

    def _get_device_name(self):
        return _genapi.INodeMap__get_device_name(self)

    def poll(self, ElapsedTime):
        return _genapi.INodeMap_poll(self, ElapsedTime)

    def _get_lock(self):
        return _genapi.INodeMap__get_lock(self)

    def _get_num_nodes(self):
        return _genapi.INodeMap__get_num_nodes(self)

    def _get_device_info(self):
        return _genapi.INodeMap__get_device_info(self)

    device_name = property(_get_device_name)


    device_info = property(_get_device_info)


    nodes = property(_get_nodes)


    lock = property(_get_lock)


    num_nodes = property(_get_num_nodes)


    def __getattr__(self, attribute):
        if attribute in self.__dict__ or attribute in ("thisown", "this"):
            return object.__getattr__(self, attribute)
        else:
            return self.get_node(attribute)

    def __setattr__(self, attribute, val):
        if attribute in self.__dict__ or attribute in ("thisown", "this"):
            object.__setattr__(self, attribute, val)
        else:
            self.get_node(attribute).set_value(val)

    def __dir__(self):
        l = []
        l += [x for x in dir(type(self))]
        l += [x for x in self.__dict__.keys()]
        try:
            l += [x.node.name for x in filter(lambda n: n.node.is_feature(), self.nodes)]
        except:
            pass
        try:
            l += [x.node for x in filter(lambda n: "ChunkData" in (f.node.name for f in n.node.parents), self.nodes)]
        except:
            pass
        return sorted(set(l))

INodeMap_swigregister = _genapi.INodeMap_swigregister
INodeMap_swigregister(INodeMap)


def deregister(pCallbackInfo):
    return _genapi.deregister(pCallbackInfo)
deregister = _genapi.deregister
class PyNodeCallback(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PyNodeCallback, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PyNodeCallback, name)
    __repr__ = _swig_repr

    def __init__(self, pNode, PyFunc, CallbackType):
        this = _genapi.new_PyNodeCallback(pNode, PyFunc, CallbackType)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _genapi.delete_PyNodeCallback
    __del__ = lambda self: None

    def _get_node(self):
        return _genapi.PyNodeCallback__get_node(self)

    node = property(_get_node)

PyNodeCallback_swigregister = _genapi.PyNodeCallback_swigregister
PyNodeCallback_swigregister(PyNodeCallback)


def register(node, callback_fun, callback_type=ECallbackType.cbPostInsideLock):
    assert callback_type in ( ECallbackType.cbPostOutsideLock, ECallbackType.cbPostInsideLock)
    cb = PyNodeCallback(node, callback_fun, callback_type)
    cb.thisown = 0
    return node.register_callback(cb)


class IValue(IBase):
    __swig_setmethods__ = {}
    for _s in [IBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IValue, name, value)
    __swig_getmethods__ = {}
    for _s in [IBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IValue, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def _get_node(self):
        return _genapi.IValue__get_node(self)

    def to_string(self, Verify=False, IgnoreCache=False):
        return _genapi.IValue_to_string(self, Verify, IgnoreCache)

    def from_string(self, ValueStr, Verify=True):
        return _genapi.IValue_from_string(self, ValueStr, Verify)

    def is_value_cache_valid(self):
        return _genapi.IValue_is_value_cache_valid(self)

    node = property(_get_node)

IValue_swigregister = _genapi.IValue_swigregister
IValue_swigregister(IValue)

class node_vector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, node_vector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, node_vector, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _genapi.node_vector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _genapi.node_vector___nonzero__(self)

    def __bool__(self):
        return _genapi.node_vector___bool__(self)

    def __len__(self):
        return _genapi.node_vector___len__(self)

    def __getslice__(self, i, j):
        return _genapi.node_vector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _genapi.node_vector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _genapi.node_vector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _genapi.node_vector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _genapi.node_vector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _genapi.node_vector___setitem__(self, *args)

    def pop(self):
        return _genapi.node_vector_pop(self)

    def append(self, x):
        return _genapi.node_vector_append(self, x)

    def empty(self):
        return _genapi.node_vector_empty(self)

    def size(self):
        return _genapi.node_vector_size(self)

    def swap(self, v):
        return _genapi.node_vector_swap(self, v)

    def begin(self):
        return _genapi.node_vector_begin(self)

    def end(self):
        return _genapi.node_vector_end(self)

    def rbegin(self):
        return _genapi.node_vector_rbegin(self)

    def rend(self):
        return _genapi.node_vector_rend(self)

    def clear(self):
        return _genapi.node_vector_clear(self)

    def get_allocator(self):
        return _genapi.node_vector_get_allocator(self)

    def pop_back(self):
        return _genapi.node_vector_pop_back(self)

    def erase(self, *args):
        return _genapi.node_vector_erase(self, *args)

    def __init__(self, *args):
        this = _genapi.new_node_vector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _genapi.node_vector_push_back(self, x)

    def front(self):
        return _genapi.node_vector_front(self)

    def back(self):
        return _genapi.node_vector_back(self)

    def assign(self, n, x):
        return _genapi.node_vector_assign(self, n, x)

    def resize(self, *args):
        return _genapi.node_vector_resize(self, *args)

    def insert(self, *args):
        return _genapi.node_vector_insert(self, *args)

    def reserve(self, n):
        return _genapi.node_vector_reserve(self, n)

    def capacity(self):
        return _genapi.node_vector_capacity(self)
    __swig_destroy__ = _genapi.delete_node_vector
    __del__ = lambda self: None
node_vector_swigregister = _genapi.node_vector_swigregister
node_vector_swigregister(node_vector)

class value_vector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, value_vector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, value_vector, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _genapi.value_vector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _genapi.value_vector___nonzero__(self)

    def __bool__(self):
        return _genapi.value_vector___bool__(self)

    def __len__(self):
        return _genapi.value_vector___len__(self)

    def __getslice__(self, i, j):
        return _genapi.value_vector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _genapi.value_vector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _genapi.value_vector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _genapi.value_vector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _genapi.value_vector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _genapi.value_vector___setitem__(self, *args)

    def pop(self):
        return _genapi.value_vector_pop(self)

    def append(self, x):
        return _genapi.value_vector_append(self, x)

    def empty(self):
        return _genapi.value_vector_empty(self)

    def size(self):
        return _genapi.value_vector_size(self)

    def swap(self, v):
        return _genapi.value_vector_swap(self, v)

    def begin(self):
        return _genapi.value_vector_begin(self)

    def end(self):
        return _genapi.value_vector_end(self)

    def rbegin(self):
        return _genapi.value_vector_rbegin(self)

    def rend(self):
        return _genapi.value_vector_rend(self)

    def clear(self):
        return _genapi.value_vector_clear(self)

    def get_allocator(self):
        return _genapi.value_vector_get_allocator(self)

    def pop_back(self):
        return _genapi.value_vector_pop_back(self)

    def erase(self, *args):
        return _genapi.value_vector_erase(self, *args)

    def __init__(self, *args):
        this = _genapi.new_value_vector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _genapi.value_vector_push_back(self, x)

    def front(self):
        return _genapi.value_vector_front(self)

    def back(self):
        return _genapi.value_vector_back(self)

    def assign(self, n, x):
        return _genapi.value_vector_assign(self, n, x)

    def resize(self, *args):
        return _genapi.value_vector_resize(self, *args)

    def insert(self, *args):
        return _genapi.value_vector_insert(self, *args)

    def reserve(self, n):
        return _genapi.value_vector_reserve(self, n)

    def capacity(self):
        return _genapi.value_vector_capacity(self)
    __swig_destroy__ = _genapi.delete_value_vector
    __del__ = lambda self: None
value_vector_swigregister = _genapi.value_vector_swigregister
value_vector_swigregister(value_vector)

class string_vector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, string_vector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, string_vector, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _genapi.string_vector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _genapi.string_vector___nonzero__(self)

    def __bool__(self):
        return _genapi.string_vector___bool__(self)

    def __len__(self):
        return _genapi.string_vector___len__(self)

    def __getslice__(self, i, j):
        return _genapi.string_vector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _genapi.string_vector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _genapi.string_vector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _genapi.string_vector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _genapi.string_vector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _genapi.string_vector___setitem__(self, *args)

    def pop(self):
        return _genapi.string_vector_pop(self)

    def append(self, x):
        return _genapi.string_vector_append(self, x)

    def empty(self):
        return _genapi.string_vector_empty(self)

    def size(self):
        return _genapi.string_vector_size(self)

    def swap(self, v):
        return _genapi.string_vector_swap(self, v)

    def begin(self):
        return _genapi.string_vector_begin(self)

    def end(self):
        return _genapi.string_vector_end(self)

    def rbegin(self):
        return _genapi.string_vector_rbegin(self)

    def rend(self):
        return _genapi.string_vector_rend(self)

    def clear(self):
        return _genapi.string_vector_clear(self)

    def get_allocator(self):
        return _genapi.string_vector_get_allocator(self)

    def pop_back(self):
        return _genapi.string_vector_pop_back(self)

    def erase(self, *args):
        return _genapi.string_vector_erase(self, *args)

    def __init__(self, *args):
        this = _genapi.new_string_vector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _genapi.string_vector_push_back(self, x)

    def front(self):
        return _genapi.string_vector_front(self)

    def back(self):
        return _genapi.string_vector_back(self)

    def assign(self, n, x):
        return _genapi.string_vector_assign(self, n, x)

    def resize(self, *args):
        return _genapi.string_vector_resize(self, *args)

    def insert(self, *args):
        return _genapi.string_vector_insert(self, *args)

    def reserve(self, n):
        return _genapi.string_vector_reserve(self, n)

    def capacity(self):
        return _genapi.string_vector_capacity(self)
    __swig_destroy__ = _genapi.delete_string_vector
    __del__ = lambda self: None
string_vector_swigregister = _genapi.string_vector_swigregister
string_vector_swigregister(string_vector)

class IPort(IBase):
    __swig_setmethods__ = {}
    for _s in [IBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IPort, name, value)
    __swig_getmethods__ = {}
    for _s in [IBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IPort, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def read(self, Address, pBuffer):
        return _genapi.IPort_read(self, Address, pBuffer)

    def write(self, Address, pBuffer):
        return _genapi.IPort_write(self, Address, pBuffer)

    def _get_node(self):
        return _genapi.IPort__get_node(self)

    def _get_chunk_id(self):
        return _genapi.IPort__get_chunk_id(self)

    def cache_chunk_data(self):
        return _genapi.IPort_cache_chunk_data(self)

    def _get_swap_endianess(self):
        return _genapi.IPort__get_swap_endianess(self)

    node = property(_get_node)


    chunk_id = property(_get_chunk_id)


    swap_endianess = property(_get_swap_endianess)

IPort_swigregister = _genapi.IPort_swigregister
IPort_swigregister(IPort)

CHUNK_BASE_ADDRESS_REGISTER_LEN = _genapi.CHUNK_BASE_ADDRESS_REGISTER_LEN
CHUNK_LENGTH_REGISTER_LEN = _genapi.CHUNK_LENGTH_REGISTER_LEN
class IChunkPort(IPort):
    __swig_setmethods__ = {}
    for _s in [IPort]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IChunkPort, name, value)
    __swig_getmethods__ = {}
    for _s in [IPort]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IChunkPort, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def _get_chunk_id(self):
        return _genapi.IChunkPort__get_chunk_id(self)

    def cache_chunk_data(self):
        return _genapi.IChunkPort_cache_chunk_data(self)

    chunk_id = property(_get_chunk_id)

IChunkPort_swigregister = _genapi.IChunkPort_swigregister
IChunkPort_swigregister(IChunkPort)

class IPortConstruct(IPort):
    __swig_setmethods__ = {}
    for _s in [IPort]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IPortConstruct, name, value)
    __swig_getmethods__ = {}
    for _s in [IPort]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IPortConstruct, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def _get_swap_endianess(self):
        return _genapi.IPortConstruct__get_swap_endianess(self)
IPortConstruct_swigregister = _genapi.IPortConstruct_swigregister
IPortConstruct_swigregister(IPortConstruct)

class IPortWriteList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IPortWriteList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IPortWriteList, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def write(self, pBuffer, Address, Length):
        return _genapi.IPortWriteList_write(self, pBuffer, Address, Length)

    def replay(self, pPort):
        return _genapi.IPortWriteList_replay(self, pPort)

    def set_cookie(self, Value):
        return _genapi.IPortWriteList_set_cookie(self, Value)

    def _get_cookie(self):
        return _genapi.IPortWriteList__get_cookie(self)

    cookie = property(_get_cookie)

IPortWriteList_swigregister = _genapi.IPortWriteList_swigregister
IPortWriteList_swigregister(IPortWriteList)

class IPortReplay(IPort):
    __swig_setmethods__ = {}
    for _s in [IPort]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IPortReplay, name, value)
    __swig_getmethods__ = {}
    for _s in [IPort]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IPortReplay, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def replay(self, pPortRecorder, Invalidate=True):
        return _genapi.IPortReplay_replay(self, pPortRecorder, Invalidate)
IPortReplay_swigregister = _genapi.IPortReplay_swigregister
IPortReplay_swigregister(IPortReplay)

class IPortRecorder(IPortReplay):
    __swig_setmethods__ = {}
    for _s in [IPortReplay]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IPortRecorder, name, value)
    __swig_getmethods__ = {}
    for _s in [IPortReplay]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IPortRecorder, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def start_recording(self, pPortRecorder):
        return _genapi.IPortRecorder_start_recording(self, pPortRecorder)

    def stop_recording(self):
        return _genapi.IPortRecorder_stop_recording(self)
IPortRecorder_swigregister = _genapi.IPortRecorder_swigregister
IPortRecorder_swigregister(IPortRecorder)

class AbstractPort(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AbstractPort, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AbstractPort, name)
    __repr__ = _swig_repr

    def __init__(self):
        if self.__class__ == AbstractPort:
            _self = None
        else:
            _self = self
        this = _genapi.new_AbstractPort(_self, )
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _genapi.delete_AbstractPort
    __del__ = lambda self: None

    def get_access_mode(self):
        return _genapi.AbstractPort_get_access_mode(self)

    def read(self, Address, pBuffer):
        return _genapi.AbstractPort_read(self, Address, pBuffer)

    def write(self, Address, pBuffer):
        return _genapi.AbstractPort_write(self, Address, pBuffer)

    def invalidate_node(self):
        return _genapi.AbstractPort_invalidate_node(self)
    def __disown__(self):
        self.this.disown()
        _genapi.disown_AbstractPort(self)
        return weakref_proxy(self)
AbstractPort_swigregister = _genapi.AbstractPort_swigregister
AbstractPort_swigregister(AbstractPort)

class IDeviceInfo(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IDeviceInfo, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IDeviceInfo, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def _get_model_name(self):
        return _genapi.IDeviceInfo__get_model_name(self)

    def _get_vendor_name(self):
        return _genapi.IDeviceInfo__get_vendor_name(self)

    def _get_tooltip(self):
        return _genapi.IDeviceInfo__get_tooltip(self)

    def _get_standard_name_space(self):
        return _genapi.IDeviceInfo__get_standard_name_space(self)

    def _get_genapi_version(self):
        return _genapi.IDeviceInfo__get_genapi_version(self)

    def get_schema_version(self):
        return _genapi.IDeviceInfo_get_schema_version(self)

    def get_device_version(self):
        return _genapi.IDeviceInfo_get_device_version(self)

    def _get_product_guid(self):
        return _genapi.IDeviceInfo__get_product_guid(self)

    def _get_version_guid(self):
        return _genapi.IDeviceInfo__get_version_guid(self)

    genapi_version = property(_get_genapi_version)


    model_name = property(_get_model_name)


    vendor_name = property(_get_vendor_name)


    tooltip = property(_get_tooltip)


    standard_name_space = property(_get_standard_name_space)


    product_guid = property(_get_product_guid)


    version_guid = property(_get_version_guid)

IDeviceInfo_swigregister = _genapi.IDeviceInfo_swigregister
IDeviceInfo_swigregister(IDeviceInfo)

class NodeMap(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, NodeMap, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, NodeMap, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _genapi.new_NodeMap(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _genapi.delete_NodeMap
    __del__ = lambda self: None

    def load_xml_from_file(self, FileName):
        return _genapi.NodeMap_load_xml_from_file(self, FileName)

    def load_xml_from_string(self, XMLData):
        return _genapi.NodeMap_load_xml_from_string(self, XMLData)

    def load_xml_from_zip_file(self, ZipFileName):
        return _genapi.NodeMap_load_xml_from_zip_file(self, ZipFileName)

    def _get_device_name(self):
        return _genapi.NodeMap__get_device_name(self)

    def poll(self, ElapsedTime):
        return _genapi.NodeMap_poll(self, ElapsedTime)

    def _destroy(self):
        return _genapi.NodeMap__destroy(self)
    if _newclass:
        clear_xml_cache = staticmethod(_genapi.NodeMap_clear_xml_cache)
    else:
        clear_xml_cache = _genapi.NodeMap_clear_xml_cache

    def _get_nodes(self):
        return _genapi.NodeMap__get_nodes(self)

    def _get_node(self, key):
        return _genapi.NodeMap__get_node(self, key)

    def get_node(self, key):
        return _genapi.NodeMap_get_node(self, key)

    def _invalidate_nodes(self):
        return _genapi.NodeMap__invalidate_nodes(self)

    def _connect(self, *args):
        return _genapi.NodeMap__connect(self, *args)
    __swig_setmethods__["pointer"] = _genapi.NodeMap_pointer_set
    __swig_getmethods__["pointer"] = _genapi.NodeMap_pointer_get
    if _newclass:
        pointer = _swig_property(_genapi.NodeMap_pointer_get, _genapi.NodeMap_pointer_set)

    def _get_device_info(self):
        return _genapi.NodeMap__get_device_info(self)

    device_info = property(_get_device_info)


    nodes = property(_get_nodes)


    def has_node(self, names, condition='matches'):
        if type(names) is list or type(names) is tuple:
    # Multiple queries:
            if condition == 'matches':
                for name in names:
                    if not hasattr(self, name):
                        return False
                return True
            elif condition == 'contains':
                for name in names:
                    if hasattr(self, name):
                        return True
                return False
            else:
                raise ValueError('Specified condition {0} is not supported.'.format(condition))
        elif type(names) is str:
    # Single query:
            return hasattr(self, names)
        else:
            raise TypeError('Queried information is not in any of list, str, or tuple.')

    def __getattr__(self, attribute):
        if attribute in self.__dict__ or attribute in ("thisown", "this") or \
                attribute == '_concrete_port':
            return object.__getattr__(self, attribute)
        else:
            try:
                return self.get_node(attribute)
            except LogicalErrorException as e:
    # Raise AttributeError to naturally work with
    # the hasattr function:
                raise AttributeError from e

    def __setattr__(self, attribute, val):
        if attribute in self.__dict__ or attribute in ("thisown", "this") or \
                attribute == '_concrete_port':
            object.__setattr__(self, attribute, val)
        else:
            warn('Rewrite the code with {0}.value = {1} instead.'.format(attribute, val), DeprecationWarning, stacklevel=2)
            self.get_node(attribute).set_value(val)

    def __dir__(self):
        l = []
        l += [x for x in dir(type(self))]
        l += [x for x in self.__dict__.keys()]
        try:
            l += [x.node.name for x in filter(lambda n: n.node.is_feature(), self.nodes)]
        except:
            pass
        return sorted(set(l))

    def connect(self, *args):
    # Hold the ConcretePort object on _concrete_port attribute as
    # long as the node map exists.
        self._concrete_port = args[0]
        return self._connect(*args)

    def disconnect(self):
        self._concrete_port = None

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.__del__()

    def __del__(self):
        self.disconnect()

NodeMap_swigregister = _genapi.NodeMap_swigregister
NodeMap_swigregister(NodeMap)

def NodeMap_clear_xml_cache():
    return _genapi.NodeMap_clear_xml_cache()
NodeMap_clear_xml_cache = _genapi.NodeMap_clear_xml_cache

class IFloat(IValue):
    __swig_setmethods__ = {}
    for _s in [IValue]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFloat, name, value)
    __swig_getmethods__ = {}
    for _s in [IValue]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFloat, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def _primal_set_value(self, Value, Verify=True):
        return _genapi.IFloat__primal_set_value(self, Value, Verify)

    def _primal_get_value(self, Verify=False, IgnoreCache=False):
        return _genapi.IFloat__primal_get_value(self, Verify, IgnoreCache)

    def __call__(self):
        return _genapi.IFloat___call__(self)

    def _get_min(self):
        return _genapi.IFloat__get_min(self)

    def _get_max(self):
        return _genapi.IFloat__get_max(self)

    def has_inc(self):
        return _genapi.IFloat_has_inc(self)

    def _get_inc_mode(self):
        return _genapi.IFloat__get_inc_mode(self)

    def _get_inc(self):
        return _genapi.IFloat__get_inc(self)

    def _get_list_of_valid_values(self, bounded=True):
        return _genapi.IFloat__get_list_of_valid_values(self, bounded)

    def _get_representation(self):
        return _genapi.IFloat__get_representation(self)

    def _get_unit(self):
        return _genapi.IFloat__get_unit(self)

    def _get_display_notation(self):
        return _genapi.IFloat__get_display_notation(self)

    def _get_display_precision(self):
        return _genapi.IFloat__get_display_precision(self)

    def impose_min(self, Value):
        return _genapi.IFloat_impose_min(self, Value)

    def impose_max(self, Value):
        return _genapi.IFloat_impose_max(self, Value)

    def _get_int_alias(self):
        return _genapi.IFloat__get_int_alias(self)

    def _get_enum_alias(self):
        return _genapi.IFloat__get_enum_alias(self)

    min = property(_get_min)


    max = property(_get_max)


    inc_mode = property(_get_inc_mode)


    inc = property(_get_inc)


    list_of_valid_values = property(_get_list_of_valid_values)


    representation = property(_get_representation)


    unit = property(_get_unit)


    display_notation = property(_get_display_notation)


    display_precision = property(_get_display_precision)


    int_alias = property(_get_int_alias)


    enum_alias = property(_get_enum_alias)


    def _set_value(self, value):
        self._primal_set_value(value)

    def set_value(self, value, verify = True):
        self._primal_set_value(value, verify)

    def _get_value(self):
        return self._primal_get_value()

    def get_value(self, verify=False, ignore_cache=False):
        if not verify and not ignore_cache:
            """
            Following Python's principle, we don't want to have multiple ways
            to do the same thing. If a client doesn't neet to verify and
            doesn't want to ignore cache, just use its property, 'value', but
            not the the getter method, 'get_value'.
            """
            raise AssertionError('Either of arguments must be True if you want to call this method. If you can ommit vrification and do not want to ignore cache, just type ".value".')
        else:
            return self._primal_get_value(Verify=verify, IgnoreCache=ignore_cache)



    value = property(_get_value, _set_value)

IFloat_swigregister = _genapi.IFloat_swigregister
IFloat_swigregister(IFloat)

class IInteger(IValue):
    __swig_setmethods__ = {}
    for _s in [IValue]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IInteger, name, value)
    __swig_getmethods__ = {}
    for _s in [IValue]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IInteger, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def _primal_set_value(self, Value, Verify=True):
        return _genapi.IInteger__primal_set_value(self, Value, Verify)

    def _primal_get_value(self, Verify=False, IgnoreCache=False):
        return _genapi.IInteger__primal_get_value(self, Verify, IgnoreCache)

    def __call__(self):
        return _genapi.IInteger___call__(self)

    def _get_min(self):
        return _genapi.IInteger__get_min(self)

    def _get_max(self):
        return _genapi.IInteger__get_max(self)

    def _get_inc_mode(self):
        return _genapi.IInteger__get_inc_mode(self)

    def _get_inc(self):
        return _genapi.IInteger__get_inc(self)

    def _get_list_of_valid_values(self, bounded=True):
        return _genapi.IInteger__get_list_of_valid_values(self, bounded)

    def _get_representation(self):
        return _genapi.IInteger__get_representation(self)

    def _get_unit(self):
        return _genapi.IInteger__get_unit(self)

    def impose_min(self, Value):
        return _genapi.IInteger_impose_min(self, Value)

    def impose_max(self, Value):
        return _genapi.IInteger_impose_max(self, Value)

    def _get_float_alias(self):
        return _genapi.IInteger__get_float_alias(self)

    def set(self, pBuffer, Verify=True):
        return _genapi.IInteger_set(self, pBuffer, Verify)

    def get(self, pBuffer, Verify=False, IgnoreCache=False):
        return _genapi.IInteger_get(self, pBuffer, Verify, IgnoreCache)

    def _get_length(self):
        return _genapi.IInteger__get_length(self)

    def _get_address(self):
        return _genapi.IInteger__get_address(self)

    min = property(_get_min)


    max = property(_get_max)


    inc_mode = property(_get_inc_mode)


    inc = property(_get_inc)


    list_of_valid_values = property(_get_list_of_valid_values)


    representation = property(_get_representation)


    unit = property(_get_unit)


    address = property(_get_address)


    length = property(_get_length)


    float_alias = property(_get_float_alias)


    def _set_value(self, value):
        self._primal_set_value(value)

    def set_value(self, value, verify = True):
        self._primal_set_value(value, verify)

    def _get_value(self):
        return self._primal_get_value()

    def get_value(self, verify=False, ignore_cache=False):
        if not verify and not ignore_cache:
            """
            Following Python's principle, we don't want to have multiple ways
            to do the same thing. If a client doesn't neet to verify and
            doesn't want to ignore cache, just use its property, 'value', but
            not the the getter method, 'get_value'.
            """
            raise AssertionError('Either of arguments must be True if you want to call this method. If you can ommit vrification and do not want to ignore cache, just type ".value".')
        else:
            return self._primal_get_value(Verify=verify, IgnoreCache=ignore_cache)



    value = property(_get_value, _set_value)

IInteger_swigregister = _genapi.IInteger_swigregister
IInteger_swigregister(IInteger)

class IRegister(IValue):
    __swig_setmethods__ = {}
    for _s in [IValue]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IRegister, name, value)
    __swig_getmethods__ = {}
    for _s in [IValue]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IRegister, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def set(self, pBuffer, Verify=True):
        return _genapi.IRegister_set(self, pBuffer, Verify)

    def get(self, pBuffer, Verify=False, IgnoreCache=False):
        return _genapi.IRegister_get(self, pBuffer, Verify, IgnoreCache)

    def _get_length(self):
        return _genapi.IRegister__get_length(self)

    def _get_address(self):
        return _genapi.IRegister__get_address(self)

    length = property(_get_length)


    address = property(_get_address)


    def GetAll(self):
        return self.Get(self.GetLength())

IRegister_swigregister = _genapi.IRegister_swigregister
IRegister_swigregister(IRegister)

class IEnumEntry(IValue):
    __swig_setmethods__ = {}
    for _s in [IValue]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IEnumEntry, name, value)
    __swig_getmethods__ = {}
    for _s in [IValue]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IEnumEntry, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def _primal_get_value(self):
        return _genapi.IEnumEntry__primal_get_value(self)

    def _get_symbolic(self):
        return _genapi.IEnumEntry__get_symbolic(self)

    def _get_numeric_value(self):
        return _genapi.IEnumEntry__get_numeric_value(self)

    def is_self_clearing(self):
        return _genapi.IEnumEntry_is_self_clearing(self)

    symbolic = property(_get_symbolic)


    numeric_value = property(_get_numeric_value)


    def __call__( self ):
        return self.get_value()


    def _set_value(self, value):
        self._primal_set_value(value)

    def set_value(self, value, verify = True):
        self._primal_set_value(value, verify)

    def _get_value(self):
        return self._primal_get_value()

    def get_value(self, verify=False, ignore_cache=False):
        if not verify and not ignore_cache:
            """
            Following Python's principle, we don't want to have multiple ways
            to do the same thing. If a client doesn't neet to verify and
            doesn't want to ignore cache, just use its property, 'value', but
            not the the getter method, 'get_value'.
            """
            raise AssertionError('Either of arguments must be True if you want to call this method. If you can ommit vrification and do not want to ignore cache, just type ".value".')
        else:
            return self._primal_get_value(Verify=verify, IgnoreCache=ignore_cache)



    value = property(_get_value, _set_value)

IEnumEntry_swigregister = _genapi.IEnumEntry_swigregister
IEnumEntry_swigregister(IEnumEntry)

class IEnumeration(IValue):
    __swig_setmethods__ = {}
    for _s in [IValue]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IEnumeration, name, value)
    __swig_getmethods__ = {}
    for _s in [IValue]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IEnumeration, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def _get_symbolics(self):
        return _genapi.IEnumeration__get_symbolics(self)

    def _get_entries(self):
        return _genapi.IEnumeration__get_entries(self)

    def set_int_value(self, Value, Verify=True):
        return _genapi.IEnumeration_set_int_value(self, Value, Verify)

    def get_int_value(self, Verify=False, IgnoreCache=False):
        return _genapi.IEnumeration_get_int_value(self, Verify, IgnoreCache)

    def get_entry_by_name(self, Symbolic):
        return _genapi.IEnumeration_get_entry_by_name(self, Symbolic)

    def get_entry(self, IntValue):
        return _genapi.IEnumeration_get_entry(self, IntValue)

    def get_current_entry(self, Verify=False, IgnoreCache=False):
        return _genapi.IEnumeration_get_current_entry(self, Verify, IgnoreCache)

    def __call__(self):
        return _genapi.IEnumeration___call__(self)

    def _primal_get_value(self):
        return _genapi.IEnumeration__primal_get_value(self)

    def _primal_set_value(self, entry, verify=False):
        return _genapi.IEnumeration__primal_set_value(self, entry, verify)

    symbolics = property(_get_symbolics)


    entries = property(_get_entries)


    def _set_value(self, value):
        self._primal_set_value(value)

    def set_value(self, value, verify = True):
        self._primal_set_value(value, verify)

    def _get_value(self):
        return self._primal_get_value()

    def get_value(self, verify=False, ignore_cache=False):
        if not verify and not ignore_cache:
            """
            Following Python's principle, we don't want to have multiple ways
            to do the same thing. If a client doesn't neet to verify and
            doesn't want to ignore cache, just use its property, 'value', but
            not the the getter method, 'get_value'.
            """
            raise AssertionError('Either of arguments must be True if you want to call this method. If you can ommit vrification and do not want to ignore cache, just type ".value".')
        else:
            return self._primal_get_value(Verify=verify, IgnoreCache=ignore_cache)



    value = property(_get_value, _set_value)

IEnumeration_swigregister = _genapi.IEnumeration_swigregister
IEnumeration_swigregister(IEnumeration)

class IBoolean(IValue):
    __swig_setmethods__ = {}
    for _s in [IValue]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IBoolean, name, value)
    __swig_getmethods__ = {}
    for _s in [IValue]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IBoolean, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def _primal_set_value(self, Value, Verify=True):
        return _genapi.IBoolean__primal_set_value(self, Value, Verify)

    def _primal_get_value(self, Verify=False, IgnoreCache=False):
        return _genapi.IBoolean__primal_get_value(self, Verify, IgnoreCache)

    def __call__(self):
        return _genapi.IBoolean___call__(self)

    def _set_value(self, value):
        self._primal_set_value(value)

    def set_value(self, value, verify = True):
        self._primal_set_value(value, verify)

    def _get_value(self):
        return self._primal_get_value()

    def get_value(self, verify=False, ignore_cache=False):
        if not verify and not ignore_cache:
            """
            Following Python's principle, we don't want to have multiple ways
            to do the same thing. If a client doesn't neet to verify and
            doesn't want to ignore cache, just use its property, 'value', but
            not the the getter method, 'get_value'.
            """
            raise AssertionError('Either of arguments must be True if you want to call this method. If you can ommit vrification and do not want to ignore cache, just type ".value".')
        else:
            return self._primal_get_value(Verify=verify, IgnoreCache=ignore_cache)



    value = property(_get_value, _set_value)

IBoolean_swigregister = _genapi.IBoolean_swigregister
IBoolean_swigregister(IBoolean)

class ICommand(IValue):
    __swig_setmethods__ = {}
    for _s in [IValue]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ICommand, name, value)
    __swig_getmethods__ = {}
    for _s in [IValue]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ICommand, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def execute(self, Verify=True):
        return _genapi.ICommand_execute(self, Verify)

    def __call__(self):
        return _genapi.ICommand___call__(self)

    def is_done(self, Verify=False):
        return _genapi.ICommand_is_done(self, Verify)
ICommand_swigregister = _genapi.ICommand_swigregister
ICommand_swigregister(ICommand)

class IString(IValue):
    __swig_setmethods__ = {}
    for _s in [IValue]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IString, name, value)
    __swig_getmethods__ = {}
    for _s in [IValue]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IString, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def _primal_set_value(self, Value, Verify=True):
        return _genapi.IString__primal_set_value(self, Value, Verify)

    def _primal_get_value(self, Verify=False, IgnoreCache=False):
        return _genapi.IString__primal_get_value(self, Verify, IgnoreCache)

    def __call__(self):
        return _genapi.IString___call__(self)

    def _get_max_length(self):
        return _genapi.IString__get_max_length(self)

    def _get_length(self):
        return _genapi.IString__get_length(self)

    max_length = property(_get_max_length)


    length = property(_get_length)


    def _set_value(self, value):
        self._primal_set_value(value)

    def set_value(self, value, verify = True):
        self._primal_set_value(value, verify)

    def _get_value(self):
        return self._primal_get_value()

    def get_value(self, verify=False, ignore_cache=False):
        if not verify and not ignore_cache:
            """
            Following Python's principle, we don't want to have multiple ways
            to do the same thing. If a client doesn't neet to verify and
            doesn't want to ignore cache, just use its property, 'value', but
            not the the getter method, 'get_value'.
            """
            raise AssertionError('Either of arguments must be True if you want to call this method. If you can ommit vrification and do not want to ignore cache, just type ".value".')
        else:
            return self._primal_get_value(Verify=verify, IgnoreCache=ignore_cache)



    value = property(_get_value, _set_value)

IString_swigregister = _genapi.IString_swigregister
IString_swigregister(IString)

class ICategory(IValue):
    __swig_setmethods__ = {}
    for _s in [IValue]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ICategory, name, value)
    __swig_getmethods__ = {}
    for _s in [IValue]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ICategory, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def _get_features(self):
        return _genapi.ICategory__get_features(self)

    features = property(_get_features)

ICategory_swigregister = _genapi.ICategory_swigregister
ICategory_swigregister(ICategory)

class IReference(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IReference, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IReference, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def set_reference(self, pBase):
        return _genapi.IReference_set_reference(self, pBase)
IReference_swigregister = _genapi.IReference_swigregister
IReference_swigregister(IReference)

class IEnumReference(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IEnumReference, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IEnumReference, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def set_enum_reference(self, Index, Name):
        return _genapi.IEnumReference_set_enum_reference(self, Index, Name)

    def set_num_enums(self, NumEnums):
        return _genapi.IEnumReference_set_num_enums(self, NumEnums)
IEnumReference_swigregister = _genapi.IEnumReference_swigregister
IEnumReference_swigregister(IEnumReference)

class ISelector(IBase):
    __swig_setmethods__ = {}
    for _s in [IBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ISelector, name, value)
    __swig_getmethods__ = {}
    for _s in [IBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ISelector, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def is_selector(self):
        return _genapi.ISelector_is_selector(self)

    def _get_selected_features(self):
        return _genapi.ISelector__get_selected_features(self)

    def _get_selecting_features(self):
        return _genapi.ISelector__get_selecting_features(self)

    selected_features = property(_get_selected_features)


    selecting_features = property(_get_selecting_features)

ISelector_swigregister = _genapi.ISelector_swigregister
ISelector_swigregister(ISelector)

class ISelectorDigit(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ISelectorDigit, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ISelectorDigit, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def set_first(self):
        return _genapi.ISelectorDigit_set_first(self)

    def set_next(self, Tick=True):
        return _genapi.ISelectorDigit_set_next(self, Tick)

    def restore(self):
        return _genapi.ISelectorDigit_restore(self)

    def to_string(self):
        return _genapi.ISelectorDigit_to_string(self)

    def get_selector_list(self, Incremental=False):
        return _genapi.ISelectorDigit_get_selector_list(self, Incremental)
ISelectorDigit_swigregister = _genapi.ISelectorDigit_swigregister
ISelectorDigit_swigregister(ISelectorDigit)

class SelectorSet(ISelectorDigit):
    __swig_setmethods__ = {}
    for _s in [ISelectorDigit]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SelectorSet, name, value)
    __swig_getmethods__ = {}
    for _s in [ISelectorDigit]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SelectorSet, name)
    __repr__ = _swig_repr

    def __init__(self, pBase):
        this = _genapi.new_SelectorSet(pBase)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _genapi.delete_SelectorSet
    __del__ = lambda self: None

    def is_empty(self):
        return _genapi.SelectorSet_is_empty(self)

    def set_first(self):
        return _genapi.SelectorSet_set_first(self)

    def set_next(self, Tick=True):
        return _genapi.SelectorSet_set_next(self, Tick)

    def restore(self):
        return _genapi.SelectorSet_restore(self)

    def to_string(self):
        return _genapi.SelectorSet_to_string(self)

    def get_selector_list(self, Incremental=False):
        return _genapi.SelectorSet_get_selector_list(self, Incremental)
SelectorSet_swigregister = _genapi.SelectorSet_swigregister
SelectorSet_swigregister(SelectorSet)

class _ChunkPort(IPortConstruct):
    __swig_setmethods__ = {}
    for _s in [IPortConstruct]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _ChunkPort, name, value)
    __swig_getmethods__ = {}
    for _s in [IPortConstruct]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, _ChunkPort, name)
    __repr__ = _swig_repr

    def __init__(self, pPort=None):
        this = _genapi.new__ChunkPort(pPort)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _genapi.delete__ChunkPort
    __del__ = lambda self: None

    def _get_access_mode(self):
        return _genapi._ChunkPort__get_access_mode(self)

    def _get_principal_interface_type(self):
        return _genapi._ChunkPort__get_principal_interface_type(self)

    def read(self, pBuffer, Address, Length):
        return _genapi._ChunkPort_read(self, pBuffer, Address, Length)

    def write(self, pBuffer, Address, Length):
        return _genapi._ChunkPort_write(self, pBuffer, Address, Length)

    def set_port_impl(self, pPort):
        return _genapi._ChunkPort_set_port_impl(self, pPort)

    def _get_swap_endianess(self):
        return _genapi._ChunkPort__get_swap_endianess(self)

    def invalidate_node(self):
        return _genapi._ChunkPort_invalidate_node(self)

    def attach_port(self, pPort):
        return _genapi._ChunkPort_attach_port(self, pPort)

    def detach_port(self):
        return _genapi._ChunkPort_detach_port(self)

    def attach_chunk(self, pBaseAddress, ChunkOffset, Length, Cache):
        return _genapi._ChunkPort_attach_chunk(self, pBaseAddress, ChunkOffset, Length, Cache)

    def detach_chunk(self):
        return _genapi._ChunkPort_detach_chunk(self)

    def _get_chunk_id_length(self):
        return _genapi._ChunkPort__get_chunk_id_length(self)

    def check_chunk_id(self, *args):
        return _genapi._ChunkPort_check_chunk_id(self, *args)

    def update_buffer(self, pBaseAddress):
        return _genapi._ChunkPort_update_buffer(self, pBaseAddress)

    def clear_cache(self):
        return _genapi._ChunkPort_clear_cache(self)

    principal_interface_type = property(_get_principal_interface_type)


    access_mode = property(_get_access_mode)


    swap_endianess = property(_get_swap_endianess)


    chunk_id_length = property(_get_chunk_id_length)

_ChunkPort_swigregister = _genapi._ChunkPort_swigregister
_ChunkPort_swigregister(_ChunkPort)


class ChunkAdapter:
    def __init__(self, node_map=None, max_chunk_cache_size=-1):
#
        self._node_map = node_map
        self._max_chunk_cache_size = max_chunk_cache_size
        self._adapter = None
        self._buffer = None
#
        self._finalizer = weakref.finalize(self, self._destruct)

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self._destruct()

    def attach_node_map(self, node_map):
        self._node_map = node_map
        self._adapter.attach_node_map(self._node_map.pointer)

    def _destruct(self):
        self._adapter.detach_buffer()
        self._adapter.detach_node_map()

    def detach_node_map(self):
        self._adapter.detach_node_map()
        self._node_map = None

    def check_buffer_layout(self, buffer):
        return self._adapter.check_buffer_layout(buffer)

    def attach_buffer(self, buffer, statistics=None):
        self._buffer = buffer
        self._adapter.attach_buffer(self._buffer, statistics)

    def detach_buffer(self):
        self._adapter.detach_buffer()
        self._buffer = None

    def update_buffer(self, buffer):
        self._buffer = buffer
        self._adapter.update_buffer(self._buffer)

    def clear_caches(self):
        self._adapter.clear_caches()


class ChunkAdapterGeneric(ChunkAdapter):
    def __init__(self, node_map=None, max_chunk_cache_size=-1):
        super().__init__(node_map, max_chunk_cache_size)
        if self._node_map:
            self._adapter = _ChunkAdapterGeneric(
                pNodeMap=self._node_map.pointer,
                MaxChunkCacheSize=self._max_chunk_cache_size
            )
        else:
            self._adapter = _ChunkAdapterGeneric()

    def attach_buffer(self, buffer, single_chunk_data=None, statistics=None):
        self._buffer = buffer
        self._adapter.attach_buffer(self._buffer, single_chunk_data, statistics)


class ChunkAdapterGEV(ChunkAdapter):
    def __init__(self, node_map=None, max_chunk_cache_size=-1):
        super().__init__(node_map, max_chunk_cache_size)
        if self._node_map:
            self._adapter = _ChunkAdapterGEV(
                pNodeMap=self._node_map.pointer,
                MaxChunkCacheSize=self._max_chunk_cache_size
            )
        else:
            self._adapter = _ChunkAdapterGEV()


class ChunkAdapterU3V(ChunkAdapter):
    def __init__(self, node_map=None, max_chunk_cache_size=-1):
        super().__init__(node_map, max_chunk_cache_size)
        if self._node_map:
            self._adapter = _ChunkAdapterU3V(
                pNodeMap=self._node_map.pointer,
                MaxChunkCacheSize=self._max_chunk_cache_size
            )
        else:
            self._adapter = _ChunkAdapterU3V()

class AttachStatistics(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AttachStatistics, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AttachStatistics, name)
    __repr__ = _swig_repr
    __swig_getmethods__["num_chunk_ports"] = _genapi.AttachStatistics_num_chunk_ports_get
    if _newclass:
        num_chunk_ports = _swig_property(_genapi.AttachStatistics_num_chunk_ports_get)
    __swig_getmethods__["num_chunks"] = _genapi.AttachStatistics_num_chunks_get
    if _newclass:
        num_chunks = _swig_property(_genapi.AttachStatistics_num_chunks_get)
    __swig_getmethods__["num_attached_chunks"] = _genapi.AttachStatistics_num_attached_chunks_get
    if _newclass:
        num_attached_chunks = _swig_property(_genapi.AttachStatistics_num_attached_chunks_get)

    def __init__(self):
        this = _genapi.new_AttachStatistics()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _genapi.delete_AttachStatistics
    __del__ = lambda self: None
AttachStatistics_swigregister = _genapi.AttachStatistics_swigregister
AttachStatistics_swigregister(AttachStatistics)

class _ChunkAdapter(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _ChunkAdapter, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _ChunkAdapter, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _genapi.delete__ChunkAdapter
    __del__ = lambda self: None

    def attach_node_map(self, pNodeMap):
        return _genapi._ChunkAdapter_attach_node_map(self, pNodeMap)

    def detach_node_map(self):
        return _genapi._ChunkAdapter_detach_node_map(self)

    def check_buffer_layout(self, pBuffer):
        return _genapi._ChunkAdapter_check_buffer_layout(self, pBuffer)

    def attach_buffer(self, pBuffer, pAttachStatistics=None):
        return _genapi._ChunkAdapter_attach_buffer(self, pBuffer, pAttachStatistics)

    def detach_buffer(self):
        return _genapi._ChunkAdapter_detach_buffer(self)

    def update_buffer(self, pBaseAddress):
        return _genapi._ChunkAdapter_update_buffer(self, pBaseAddress)

    def clear_caches(self):
        return _genapi._ChunkAdapter_clear_caches(self)
_ChunkAdapter_swigregister = _genapi._ChunkAdapter_swigregister
_ChunkAdapter_swigregister(_ChunkAdapter)

class _ChunkAdapterGEV(_ChunkAdapter):
    __swig_setmethods__ = {}
    for _s in [_ChunkAdapter]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _ChunkAdapterGEV, name, value)
    __swig_getmethods__ = {}
    for _s in [_ChunkAdapter]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, _ChunkAdapterGEV, name)
    __repr__ = _swig_repr

    def __init__(self, pNodeMap=None, MaxChunkCacheSize=-1):
        this = _genapi.new__ChunkAdapterGEV(pNodeMap, MaxChunkCacheSize)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _genapi.delete__ChunkAdapterGEV
    __del__ = lambda self: None

    def check_buffer_layout(self, pBuffer):
        return _genapi._ChunkAdapterGEV_check_buffer_layout(self, pBuffer)

    def attach_buffer(self, pBuffer, pAttachStatistics=None):
        return _genapi._ChunkAdapterGEV_attach_buffer(self, pBuffer, pAttachStatistics)
_ChunkAdapterGEV_swigregister = _genapi._ChunkAdapterGEV_swigregister
_ChunkAdapterGEV_swigregister(_ChunkAdapterGEV)

class _ChunkAdapterU3V(_ChunkAdapter):
    __swig_setmethods__ = {}
    for _s in [_ChunkAdapter]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _ChunkAdapterU3V, name, value)
    __swig_getmethods__ = {}
    for _s in [_ChunkAdapter]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, _ChunkAdapterU3V, name)
    __repr__ = _swig_repr

    def __init__(self, pNodeMap=None, MaxChunkCacheSize=-1):
        this = _genapi.new__ChunkAdapterU3V(pNodeMap, MaxChunkCacheSize)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _genapi.delete__ChunkAdapterU3V
    __del__ = lambda self: None

    def check_buffer_layout(self, pBuffer):
        return _genapi._ChunkAdapterU3V_check_buffer_layout(self, pBuffer)

    def attach_buffer(self, pBuffer, pAttachStatistics=None):
        return _genapi._ChunkAdapterU3V_attach_buffer(self, pBuffer, pAttachStatistics)
_ChunkAdapterU3V_swigregister = _genapi._ChunkAdapterU3V_swigregister
_ChunkAdapterU3V_swigregister(_ChunkAdapterU3V)

class SingleChunkData(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SingleChunkData, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SingleChunkData, name)
    __repr__ = _swig_repr
    __swig_setmethods__["chunk_id"] = _genapi.SingleChunkData_chunk_id_set
    __swig_getmethods__["chunk_id"] = _genapi.SingleChunkData_chunk_id_get
    if _newclass:
        chunk_id = _swig_property(_genapi.SingleChunkData_chunk_id_get, _genapi.SingleChunkData_chunk_id_set)
    __swig_setmethods__["chunk_offset"] = _genapi.SingleChunkData_chunk_offset_set
    __swig_getmethods__["chunk_offset"] = _genapi.SingleChunkData_chunk_offset_get
    if _newclass:
        chunk_offset = _swig_property(_genapi.SingleChunkData_chunk_offset_get, _genapi.SingleChunkData_chunk_offset_set)
    __swig_setmethods__["chunk_length"] = _genapi.SingleChunkData_chunk_length_set
    __swig_getmethods__["chunk_length"] = _genapi.SingleChunkData_chunk_length_get
    if _newclass:
        chunk_length = _swig_property(_genapi.SingleChunkData_chunk_length_get, _genapi.SingleChunkData_chunk_length_set)

    def __init__(self):
        this = _genapi.new_SingleChunkData()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _genapi.delete_SingleChunkData
    __del__ = lambda self: None
SingleChunkData_swigregister = _genapi.SingleChunkData_swigregister
SingleChunkData_swigregister(SingleChunkData)

class SingleChunkDataStr_t(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SingleChunkDataStr_t, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SingleChunkDataStr_t, name)
    __repr__ = _swig_repr
    __swig_setmethods__["ChunkID"] = _genapi.SingleChunkDataStr_t_ChunkID_set
    __swig_getmethods__["ChunkID"] = _genapi.SingleChunkDataStr_t_ChunkID_get
    if _newclass:
        ChunkID = _swig_property(_genapi.SingleChunkDataStr_t_ChunkID_get, _genapi.SingleChunkDataStr_t_ChunkID_set)
    __swig_setmethods__["ChunkOffset"] = _genapi.SingleChunkDataStr_t_ChunkOffset_set
    __swig_getmethods__["ChunkOffset"] = _genapi.SingleChunkDataStr_t_ChunkOffset_get
    if _newclass:
        ChunkOffset = _swig_property(_genapi.SingleChunkDataStr_t_ChunkOffset_get, _genapi.SingleChunkDataStr_t_ChunkOffset_set)
    __swig_setmethods__["ChunkLength"] = _genapi.SingleChunkDataStr_t_ChunkLength_set
    __swig_getmethods__["ChunkLength"] = _genapi.SingleChunkDataStr_t_ChunkLength_get
    if _newclass:
        ChunkLength = _swig_property(_genapi.SingleChunkDataStr_t_ChunkLength_get, _genapi.SingleChunkDataStr_t_ChunkLength_set)

    def __init__(self):
        this = _genapi.new_SingleChunkDataStr_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _genapi.delete_SingleChunkDataStr_t
    __del__ = lambda self: None
SingleChunkDataStr_t_swigregister = _genapi.SingleChunkDataStr_t_swigregister
SingleChunkDataStr_t_swigregister(SingleChunkDataStr_t)

class _ChunkAdapterGeneric(_ChunkAdapter):
    __swig_setmethods__ = {}
    for _s in [_ChunkAdapter]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _ChunkAdapterGeneric, name, value)
    __swig_getmethods__ = {}
    for _s in [_ChunkAdapter]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, _ChunkAdapterGeneric, name)
    __repr__ = _swig_repr

    def __init__(self, pNodeMap=None, MaxChunkCacheSize=-1):
        this = _genapi.new__ChunkAdapterGeneric(pNodeMap, MaxChunkCacheSize)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _genapi.delete__ChunkAdapterGeneric
    __del__ = lambda self: None

    def check_buffer_layout(self, pBuffer):
        return _genapi._ChunkAdapterGeneric_check_buffer_layout(self, pBuffer)

    def attach_buffer(self, *args):
        return _genapi._ChunkAdapterGeneric_attach_buffer(self, *args)
_ChunkAdapterGeneric_swigregister = _genapi._ChunkAdapterGeneric_swigregister
_ChunkAdapterGeneric_swigregister(_ChunkAdapterGeneric)

class EventPort(IPortConstruct):
    __swig_setmethods__ = {}
    for _s in [IPortConstruct]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, EventPort, name, value)
    __swig_getmethods__ = {}
    for _s in [IPortConstruct]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, EventPort, name)
    __repr__ = _swig_repr

    def __init__(self, pNode=None):
        this = _genapi.new_EventPort(pNode)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _genapi.delete_EventPort
    __del__ = lambda self: None

    def _get_access_mode(self):
        return _genapi.EventPort__get_access_mode(self)

    def _get_principal_interface_type(self):
        return _genapi.EventPort__get_principal_interface_type(self)

    def read(self, pBuffer, Address, Length):
        return _genapi.EventPort_read(self, pBuffer, Address, Length)

    def write(self, pBuffer, Address, Length):
        return _genapi.EventPort_write(self, pBuffer, Address, Length)

    def set_port_impl(self, pPort):
        return _genapi.EventPort_set_port_impl(self, pPort)

    def _get_swap_endianess(self):
        return _genapi.EventPort__get_swap_endianess(self)

    def invalidate_node(self):
        return _genapi.EventPort_invalidate_node(self)

    def attach_node(self, pNode):
        return _genapi.EventPort_attach_node(self, pNode)

    def detach_node(self):
        return _genapi.EventPort_detach_node(self)

    def _get_event_id_length(self):
        return _genapi.EventPort__get_event_id_length(self)

    def check_event_id(self, *args):
        return _genapi.EventPort_check_event_id(self, *args)

    def attach_event(self, pBaseAddress, Length):
        return _genapi.EventPort_attach_event(self, pBaseAddress, Length)

    def detach_event(self):
        return _genapi.EventPort_detach_event(self)

    principal_interface_type = property(_get_principal_interface_type)


    access_mode = property(_get_access_mode)


    swap_endianess = property(_get_swap_endianess)


    event_id_length = property(_get_event_id_length)

EventPort_swigregister = _genapi.EventPort_swigregister
EventPort_swigregister(EventPort)

class EventAdapter(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, EventAdapter, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, EventAdapter, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _genapi.delete_EventAdapter
    __del__ = lambda self: None

    def attach_node_map(self, pNodeMap):
        return _genapi.EventAdapter_attach_node_map(self, pNodeMap)

    def detach_node_map(self):
        return _genapi.EventAdapter_detach_node_map(self)

    def deliver_message(self, msg):
        return _genapi.EventAdapter_deliver_message(self, msg)
EventAdapter_swigregister = _genapi.EventAdapter_swigregister
EventAdapter_swigregister(EventAdapter)

class EventAdapterGEV(EventAdapter):
    __swig_setmethods__ = {}
    for _s in [EventAdapter]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, EventAdapterGEV, name, value)
    __swig_getmethods__ = {}
    for _s in [EventAdapter]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, EventAdapterGEV, name)
    __repr__ = _swig_repr

    def __init__(self, pNodeMap=None):
        this = _genapi.new_EventAdapterGEV(pNodeMap)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _genapi.delete_EventAdapterGEV
    __del__ = lambda self: None

    def deliver_message(self, msg):
        return _genapi.EventAdapterGEV_deliver_message(self, msg)
EventAdapterGEV_swigregister = _genapi.EventAdapterGEV_swigregister
EventAdapterGEV_swigregister(EventAdapterGEV)

class EventAdapterU3V(EventAdapter):
    __swig_setmethods__ = {}
    for _s in [EventAdapter]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, EventAdapterU3V, name, value)
    __swig_getmethods__ = {}
    for _s in [EventAdapter]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, EventAdapterU3V, name)
    __repr__ = _swig_repr

    def __init__(self, pNodeMap=None):
        this = _genapi.new_EventAdapterU3V(pNodeMap)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _genapi.delete_EventAdapterU3V
    __del__ = lambda self: None

    def deliver_message(self, msg):
        return _genapi.EventAdapterU3V_deliver_message(self, msg)
EventAdapterU3V_swigregister = _genapi.EventAdapterU3V_swigregister
EventAdapterU3V_swigregister(EventAdapterU3V)

class EventAdapterCL(EventAdapter):
    __swig_setmethods__ = {}
    for _s in [EventAdapter]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, EventAdapterCL, name, value)
    __swig_getmethods__ = {}
    for _s in [EventAdapter]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, EventAdapterCL, name)
    __repr__ = _swig_repr

    def __init__(self, pNodeMap=None):
        this = _genapi.new_EventAdapterCL(pNodeMap)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _genapi.delete_EventAdapterCL
    __del__ = lambda self: None

    def deliver_message(self, msg):
        return _genapi.EventAdapterCL_deliver_message(self, msg)
EventAdapterCL_swigregister = _genapi.EventAdapterCL_swigregister
EventAdapterCL_swigregister(EventAdapterCL)

class EventAdapterGeneric(EventAdapter):
    __swig_setmethods__ = {}
    for _s in [EventAdapter]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, EventAdapterGeneric, name, value)
    __swig_getmethods__ = {}
    for _s in [EventAdapter]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, EventAdapterGeneric, name)
    __repr__ = _swig_repr

    def __init__(self, pNodeMap=None):
        this = _genapi.new_EventAdapterGeneric(pNodeMap)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _genapi.delete_EventAdapterGeneric
    __del__ = lambda self: None

    def deliver_message(self, *args):
        return _genapi.EventAdapterGeneric_deliver_message(self, *args)
EventAdapterGeneric_swigregister = _genapi.EventAdapterGeneric_swigregister
EventAdapterGeneric_swigregister(EventAdapterGeneric)

class FileProtocolAdapter(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FileProtocolAdapter, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FileProtocolAdapter, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _genapi.new_FileProtocolAdapter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def attach(self, pInterface):
        return _genapi.FileProtocolAdapter_attach(self, pInterface)

    def open_file(self, pFileName, mode):
        return _genapi.FileProtocolAdapter_open_file(self, pFileName, mode)

    def close_file(self, pFileName):
        return _genapi.FileProtocolAdapter_close_file(self, pFileName)

    def write(self, pBuffer, offs, pFileName):
        return _genapi.FileProtocolAdapter_write(self, pBuffer, offs, pFileName)

    def read(self, pBuffer, offs, pFileName):
        return _genapi.FileProtocolAdapter_read(self, pBuffer, offs, pFileName)

    def get_buf_size(self, pFileName, mode):
        return _genapi.FileProtocolAdapter_get_buf_size(self, pFileName, mode)

    def delete_file(self, pFileName):
        return _genapi.FileProtocolAdapter_delete_file(self, pFileName)

    class FileAccess(object):
        def __init__(self, read_bufsize = 4096):
            if read_bufsize == 0:
                raise IOError("invalid read_bufsize")

            self.isopen   = False
            self.filename = ""
            self.mode     = ""
            self.fpa      = FileProtocolAdapter()
            self.fpa_bufsize  = 0
            self.fpos     = 0
            self.read_bufsize = read_bufsize

        def open(self, nodemap, filename, openmode):
            self.fpa.attach(nodemap)
            self.filename = filename
            self.fpa.openFile(filename,openmode)
            self.fpa_bufsize = self.fpa.getBufSize(filename, openmode)
            self.fpos = 0
            self.isopen = True

        def close(self):
            self.isopen = False
            self.fpa.closeFile(self.filename)

        def _read(self, size):
            assert(self.isopen)
            buf = ""
            for ofs in xrange(0, size, self.fpa_bufsize):
                read_len, data  = self.fpa.read(self.fpa_bufsize, self.fpos + ofs, self.filename)
                if read_len <= 0:
                    break
                else:
                    buf += data[:min(size-ofs,read_len)]

            self.fpos += len(buf)
            return buf

        def read(self, size = -1):
            assert(self.isopen)
            if size < 0:
                buf = ""
                while True:
                    data  = self._read(self.read_bufsize)
                    buf += data
                    if len(data) < self.read_bufsize:
                        return buf

            else:
                data  = self._read(size)
                return data


        def write(self,data):
            assert(self.isopen)
            ret = self.fpa.write(data, self.fpos, self.filename)
            self.fpos += len(data)
            return ret

    __swig_destroy__ = _genapi.delete_FileProtocolAdapter
    __del__ = lambda self: None
FileProtocolAdapter_swigregister = _genapi.FileProtocolAdapter_swigregister
FileProtocolAdapter_swigregister(FileProtocolAdapter)

# This file is compatible with both classic and new-style classes.


