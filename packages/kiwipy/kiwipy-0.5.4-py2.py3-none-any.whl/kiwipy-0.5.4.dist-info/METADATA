Metadata-Version: 2.1
Name: kiwipy
Version: 0.5.4
Summary: A python remote communications library
Home-page: https://github.com/muhrin/kiwipy.git
Author: Martin Uhrin
Author-email: martin.uhrin@gmail.com
License: GPLv3 and MIT, see LICENSE file
Keywords: communication messaging rpc broadcast
Platform: UNKNOWN
Classifier: Development Status :: 4 - Beta
Classifier: License :: OSI Approved :: MIT License
Classifier: License :: OSI Approved :: GNU General Public License v3 (GPLv3)
Classifier: Programming Language :: Python :: 2
Classifier: Programming Language :: Python :: 2.7
Classifier: Programming Language :: Python :: 3.4
Classifier: Programming Language :: Python :: 3.5
Classifier: Programming Language :: Python :: 3.6
Classifier: Programming Language :: Python :: 3.7
Requires-Python: >=2.7,!=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*
Requires-Dist: six
Requires-Dist: shortuuid
Requires-Dist: backports.tempfile ; python_version < "3.2"
Requires-Dist: enum34 ; python_version < "3.4"
Requires-Dist: typing ; python_version < "3.5"
Requires-Dist: futures ; python_version == "2.7"
Provides-Extra: dev
Requires-Dist: pip ; extra == 'dev'
Requires-Dist: pre-commit ; extra == 'dev'
Requires-Dist: pytest (>=4) ; extra == 'dev'
Requires-Dist: pytest-cov ; extra == 'dev'
Requires-Dist: ipython (<6) ; extra == 'dev'
Requires-Dist: twine ; extra == 'dev'
Requires-Dist: yapf ; extra == 'dev'
Requires-Dist: prospector (<1.1.7) ; extra == 'dev'
Requires-Dist: pylint (<2) ; (python_version < "3") and extra == 'dev'
Requires-Dist: pylint ; (python_version >= "3") and extra == 'dev'
Provides-Extra: docs
Requires-Dist: Sphinx (==1.8.4) ; extra == 'docs'
Requires-Dist: Pygments (==2.3.1) ; extra == 'docs'
Requires-Dist: docutils (==0.14) ; extra == 'docs'
Provides-Extra: rmq
Requires-Dist: pika (>=1.0.0) ; extra == 'rmq'
Requires-Dist: topika (<0.3.0,>=0.2.0) ; extra == 'rmq'
Requires-Dist: pyyaml (~=5.1) ; extra == 'rmq'
Requires-Dist: tornado (<6) ; (python_version < "3") and extra == 'rmq'
Requires-Dist: tornado (<5) ; (python_version >= "3") and extra == 'rmq'

kiwipy
======

.. image:: https://travis-ci.org/aiidateam/kiwipy.svg
    :target: https://travis-ci.org/aiidateam/kiwipy
    :alt: Travis CI

.. image:: https://img.shields.io/pypi/v/kiwipy.svg
    :target: https://pypi.python.org/pypi/kiwipy/
    :alt: Latest Version

.. image:: https://img.shields.io/pypi/wheel/kiwipy.svg
    :target: https://pypi.python.org/pypi/kiwipy/

.. image:: https://img.shields.io/pypi/pyversions/kiwipy.svg
    :target: https://pypi.python.org/pypi/kiwipy/

.. image:: https://img.shields.io/pypi/l/kiwipy.svg
    :target: https://pypi.python.org/pypi/kiwipy/


kiwipy is a library that makes remote messaging using RabbitMQ (and any other protocol for which a backend is written) EASY.
I don't know about you but I find RabbitMQ HARD.
It's all too easy to make a configuration mistake which is then difficult to debug.
With kiwipy, there's none of this, just messaging, made simple, with all the nice properties and guarantees of AMQP.

Here's what you get:

* RPC
* Broadcast (with filters)
* Task queue messages

Let's dive in, with some examples taken from the `rmq tutorial <https://www.rabbitmq.com/getstarted.html>`_.

RPC
---

The client:

.. code-block:: python

    from kiwipy import rmq

    communicator = rmq.RmqThreadCommunicator.connect(connection_params={'url': 'amqp://localhost'})

    # Send an RPC message
    print(" [x] Requesting fib(30)")
    response = communicator.rpc_send('fib', 30).result()
    print((" [.] Got %r" % response))

`(rmq_rpc_client.py source) <https://raw.githubusercontent.com/aiidateam/kiwipy/develop/examples/rmq_rpc_client.py>`_


The server:

.. code-block:: python

    import threading

    from kiwipy import rmq


    def fib(comm, num):
        if num == 0:
            return 0
        if num == 1:
            return 1

        return fib(comm, num - 1) + fib(comm, num - 2)


    communicator = rmq.RmqThreadCommunicator.connect(connection_params={'url': 'amqp://localhost'})

    # Register an RPC subscriber with the name square
    communicator.add_rpc_subscriber(fib, 'fib')
    # Now wait indefinitely for fibonacci calls
    threading.Event().wait()

`(rmq_rpc_server.py source) <https://raw.githubusercontent.com/aiidateam/kiwipy/develop/examples/rmq_rpc_server.py>`_


Worker
------

Create a new task:

.. code-block:: python

    import sys

    from kiwipy import rmq

    message = ' '.join(sys.argv[1:]) or "Hello World!"

    with rmq.RmqThreadCommunicator.connect(connection_params={'url': 'amqp://localhost'}) as communicator:
        communicator.task_send(message)

`(rmq_new_task.py source) <https://raw.githubusercontent.com/aiidateam/kiwipy/develop/examples/rmq_new_task.py>`_


And the worker:

.. code-block:: python

    import time
    import threading

    from kiwipy import rmq

    print(' [*] Waiting for messages. To exit press CTRL+C')


    def callback(_comm, task):
        print((" [x] Received %r" % task))
        time.sleep(task.count(b'.'))
        print(" [x] Done")


    try:
        with rmq.RmqThreadCommunicator.connect(connection_params={'url': 'amqp://localhost'}) as communicator:
            communicator.add_task_subscriber(callback)
            threading.Event().wait()
    except KeyboardInterrupt:
        pass

`(rmq_worker.py source) <https://raw.githubusercontent.com/aiidateam/kiwipy/develop/examples/rmq_worker.py>`_


Versioning
==========

This software follows `Semantic Versioning`_



.. _Semantic Versioning: http://semver.org/



