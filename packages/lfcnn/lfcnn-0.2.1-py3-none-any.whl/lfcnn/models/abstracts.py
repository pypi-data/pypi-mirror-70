# Copyright (C) 2020  The LFCNN Authors
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.


"""Abstract base class definitions.
"""
import tensorflow.keras as keras
from tensorflow.keras.utils import multi_gpu_model
from tensorflow.keras.losses import Loss as Loss
from tensorflow.keras.metrics import Metric
from tensorflow.keras.optimizers import Optimizer
from tensorflow.keras.callbacks import Callback

from typing import Union, Dict, List, Optional, Tuple, Callable

from lfcnn.generators.utils import shape_wrapper


class BaseModel(object):

    def __init__(self,
                 optimizer: Optimizer,
                 loss: Union[Loss, Dict[str, Loss]],
                 metrics: Union[Metric, Dict[str, Metric], Dict[str, List[Metric]]],
                 callbacks: Callback):

        self._optimizer = optimizer
        self._loss = loss
        self._metrics = metrics
        self._callbacks = callbacks

        self._keras_model = None
        self._model_crop = None

        self._generator = None
        self._reshape_func = None
        self.set_generator_and_reshape()
        if self.generator is None or self.reshape_func is None:
            raise ValueError("Generator or reshape not set. Set them in the "
                             "model's set_generator_and_reshape method.")

        return

    def __create_model__(self,
                         inputs: List[keras.Input],
                         augmented_shape: Optional[Tuple[int, int, int, int, int]],
                         gpus: Union[int, List[int]],
                         cpu_merge: bool):
        """Create the Keras model as defined by the derived class,
        sets the keras_module attribute and compiles it with the specified
        optimizer, loss and metrics.

        See Also:
            :func:`create_model`
        """
        if gpus == 1:
            self._keras_model = self.create_model(inputs, augmented_shape)
        else:
            base_model = self.create_model(inputs, augmented_shape)
            self._keras_model = multi_gpu_model(base_model, cpu_merge=cpu_merge)

        self.keras_model.compile(optimizer=self._optimizer,
                                 loss=self._loss,
                                 metrics=self._metrics)
        return

    def set_generator_and_reshape(self):
        raise NotImplementedError("This needs to be implemented by the derived class.")

    def create_model(self, inputs: List[keras.Input], augmented_shape: Optional[Tuple[int, int, int, int, int]]) -> keras.Model:
        """Create the Keras model.
        Needs to be implemented by the derived class to define the network topology.

        Args:
            inputs: List of Keras Inputs. Single or multi inputs supported.

            augmented_shape: The augmented shape as generated by the generator.
                             Can be used to obtain the original light field's
                             shape, for example the number of subapertures
                             or the number of spectral channels.
        """
        raise NotImplementedError("This needs to be implemented by the derived class.")

    @property
    def optimizer(self) -> Optimizer:
        return self._optimizer

    @property
    def loss(self) -> Loss:
        return self._loss

    @property
    def metrics(self) -> Metric:
        return self._metrics

    @property
    def callbacks(self) -> Callback:
        return self._callbacks

    @property
    def generator(self):
        return self._generator

    @property
    def reshape_func(self) -> Callable:
        return self._reshape_func

    @property
    def model_crop(self) -> tuple:
        return self._model_crop

    @property
    def keras_model(self) -> keras.Model:
        return self._keras_model

    def train(self,
              data,
              valid_data,
              data_key,
              label_keys,
              augmented_shape,
              generated_shape,
              batch_size,
              valid_data_key=None,
              valid_label_keys=None,
              valid_batch_size=None,
              data_percentage=1.0,
              valid_percentage=1.0,
              range_data=None,
              range_labels=None,
              range_valid_data=None,
              range_valid_labels=None,
              augment=True,
              shuffle=True,
              use_mask=False,
              fix_seed=False,
              gpus: Union[int, List[int]] = 1,
              cpu_merge: bool = False,
              gen_kwargs: Optional[dict] = None,
              **kwargs) -> keras.callbacks.History:
        """Train and validate the model.

        Args:
            data: Data dictionary or path to training data .h5 file.

            valid_data: Data dictionary or path to validation data .h5 file.

            data_key:  Key of light field data in training data  file.

            label_keys:  Keys of label in training data  file.

            valid_data_key: Key of light field data in validation data  file.

            valid_label_keys: Keys of labels in validation data file.

            augmented_shape: Shape after augmentation.

            generated_shape: Generated shape or list of generated shapes in
                             case of multi input models.

            batch_size: Batch size.

            data_percentage: Percentage of training data to use.
                             Can be used to test a training on a smaller set.
            valid_percentage: Percentage of validation data to use.
                              Can be used to test a training on a smaller set.

            valid_batch_size: Batch size used for validation.

            range_data: Dynamic range of input light field data.
                        Used to normalize the input data to a range [0, 1].
                        If no normalization is necessary, specify None.

            range_labels: Dynamic range of input label data.
                          May be used to normalize the input data to a range [0, 1].
                          If no normalization is necessary, specify None.
                          If a list of labels is used, specify ranges as list,
                          e.g. [255, None, None]

            range_valid_data: Dynamic range of input light field validation data.
                              Used to normalize the input data to a range [0, 1].
                              If no normalization is necessary, specify None.

            range_valid_labels: Dynamic range of input label validation data.
                                May be used to normalize the input data to a range [0, 1].
                                If no normalization is necessary, specify None.
                                If a list of labels is used, specify ranges as list,
                                e.g. [255, None, None]

            augment: Whether to perform online augmentation.
                     Cropping to augmented_shape is always performed.

            shuffle: Whether to shuffle data between epochs.

            use_mask: Whether to use a color coding mask.

            fix_seed: Whether to use a constant seed for random augments during
                      training. The seed for validation is always fixed.

            gpus: Integer or list of integers specifying the number of GPUs
                  or GPU IDs to use for training. Defaults to 1. If more than
                  one GPU is used, the model will be distributed across
                  multiple GPUs, i.e. the batch will be split up across
                  the GPUs.

            cpu_merge: Used when gpus > 1. Whether to force merging model
                       weights under the scope of the CPU or not.
                       Defaults to False (recommended for NV-Link)

            gen_kwargs: Passed to generator instantiation.

            **kwargs: Passed to Keras fit.

        Returns:
            hist
            A History object.
            The attribute hist.history contains the logged values.
        """
        # For single input models, wrap shape in list
        generated_shape = shape_wrapper(generated_shape)

        # First, create model (also calculates model crop needed by generator)
        if self.keras_model is None:
            # generated_shape of generator is input_shape of model
            inputs = [keras.Input(shape) for shape in generated_shape]
            self.__create_model__(inputs,
                                  augmented_shape=augmented_shape,
                                  gpus=gpus,
                                  cpu_merge=cpu_merge)

        # Use reshape as defined by model
        reshape_func = self.reshape_func

        # Init Generators
        gen_kwargs = gen_kwargs or {}
        train_gen_kwargs = dict(data=data,
                                data_key=data_key,
                                label_keys=label_keys,
                                augmented_shape=augmented_shape,
                                generated_shape=generated_shape,
                                reshape_func=reshape_func,
                                model_crop=self.model_crop,
                                batch_size=batch_size,
                                range_data=range_data,
                                range_labels=range_labels,
                                data_percentage=data_percentage,
                                augment=augment,
                                shuffle=shuffle,
                                use_mask=use_mask,
                                fix_seed=fix_seed,
                                **gen_kwargs)

        # By default, use same data/label keys as for training data
        if valid_data_key is None:
            valid_data_key = data_key

        if valid_label_keys is None:
            valid_label_keys = label_keys

        if valid_batch_size is None:
            valid_batch_size = batch_size

        if range_valid_data is None and range_data is not None:
            import warnings
            warnings.warn(
                "You specified a data range for the training data but not for "
                "the validation data. Hence, the validation data will not be "
                "normalized. You can ignore this, if this is intended.")

        # For validation, fix seed and do not shuffle nor use augmentation
        valid_gen_kwargs = dict(data=valid_data,
                                data_key=valid_data_key,
                                label_keys=valid_label_keys,
                                augmented_shape=augmented_shape,
                                generated_shape=generated_shape,
                                reshape_func=reshape_func,
                                model_crop=self.model_crop,
                                batch_size=valid_batch_size,
                                range_data=range_valid_data,
                                range_labels=range_valid_labels,
                                data_percentage=valid_percentage,
                                augment=False,
                                shuffle=False,
                                use_mask=use_mask,
                                fix_seed=True,
                                **gen_kwargs)

        generator = self.generator(**train_gen_kwargs)
        if valid_data is not None:
            valid_generator = self.generator(**valid_gen_kwargs)
        else:
            valid_generator = None

        # Fit model using the data generator and the validation generator
        # Note that shuffling is performed in the generator.
        hist = self.keras_model.fit(generator,
                                    validation_data=valid_generator,
                                    callbacks=self._callbacks,
                                    shuffle=False,
                                    **kwargs)
        return hist

    def test(self,
             data,
             data_key,
             label_keys,
             augmented_shape,
             generated_shape,
             batch_size,
             data_percentage=1.0,
             range_data=None,
             range_labels=None,
             use_mask=False,
             gpus: Union[int, List[int]] = 1,
             cpu_merge: bool = False,
             gen_kwargs: Optional[dict] = None,
             **kwargs) -> dict:
        """Evaluate the model using a test dataset.

        Args:
            data: Data dictionary or path to test data .h5 file.

            data_key:  Key of light field data in test data  file.

            label_keys:  Keys of label in test data  file.

            augmented_shape: Shape after augmentation.

            generated_shape: Generated shape or list of generated shapes in
                             case of multi input models.

            batch_size: Batch size.

            data_percentage: Percentage of testing data to use.

            range_data: Dynamic range of input light field data.
                        Used to normalize the input data to a range [0, 1].
                        If no normalization is necessary, specify None.

            range_labels: Dynamic range of input label data.
                          May be used to normalize the input data to a range [0, 1].
                          If no normalization is necessary, specify None.
                          If a list of labels is used, specify ranges as list,
                          e.g. [255, None, None]

            use_mask: Whether to use a color coding mask.

            gpus: Integer or list of integers specifying the number of GPUs
                  or GPU IDs to use for training. Defaults to 1. If more than
                  one GPU is used, the model will be distributed across
                  multiple GPUs, i.e. the batch will be split up across
                  the GPUs.

            cpu_merge: Used when gpus > 1. Whether to force merging model
                       weights under the scope of the CPU or not.
                       Defaults to False (recommended for NV-Link)

            gen_kwargs: Passed to generator instantiation.

            **kwargs: Passed to Keras evaluate.

        Returns:
            Dictionary containing loss and metric test scores.
        """
        # For single input models, wrap shape in list
        generated_shape = shape_wrapper(generated_shape)

        if self.keras_model is None:
            # generated_shape of generator is input_shape of model
            inputs = [keras.Input(shape) for shape in generated_shape]
            self.__create_model__(inputs,
                                  augmented_shape=augmented_shape,
                                  gpus=gpus,
                                  cpu_merge=cpu_merge)

        reshape_func = self.reshape_func

        # Init Generator
        gen_kwargs = gen_kwargs or {}
        test_gen_kwargs = dict(data=data,
                               data_key=data_key,
                               label_keys=label_keys,
                               augmented_shape=augmented_shape,
                               generated_shape=generated_shape,
                               reshape_func=reshape_func,
                               model_crop=self.model_crop,
                               batch_size=batch_size,
                               range_data=range_data,
                               range_labels=range_labels,
                               data_percentage=data_percentage,
                               augment=False,
                               shuffle=False,
                               use_mask=use_mask,
                               fix_seed=True,
                               **gen_kwargs)

        test_gen = self.generator(**test_gen_kwargs)

        # Evaluate on test dataset.
        test_vals = self.keras_model.evaluate(test_gen, **kwargs)

        # Create dict with metric=test_value pairs
        test_res = {key: val for key, val in zip(self.keras_model.metrics_names, test_vals)}

        return test_res

    def predict(self):
        ...

    def save(self, filepath, overwrite=True, include_optimizer=True):

        if self.keras_model is None:
            raise ValueError("Model has not been loaded created yet. "
                             "Load or train the model first.")

        return self.keras_model.save(filepath, overwrite=overwrite, include_optimizer=include_optimizer)

    def load(self, filepath, compile=True):

        if not self.keras_model is None:
            raise ValueError("Model already loaded.")

        self._keras_model = keras.models.load_model(filepath, compile=False)
        if compile:
            self.keras_model.compile(optimizer=self._optimizer,
                                     loss=self._loss,
                                     metrics=self._metrics)
        return

    def save_weights(self, filepath, overwrite=True):

        if self.keras_model is None:
            raise ValueError("Model has not been loaded created yet. "
                             "Load or train the model first.")

        return self.keras_model.save_weights(filepath, overwrite)

    def load_weights(self, filepath, output_shape=None, augmented_shape=None, **kwargs):

        if self.keras_model is None:
            # output_shape of generator is input_shape of model
            input = keras.Input(output_shape)
            self.__create_model__(input, augmented_shape=augmented_shape)

        return self.keras_model.load_weights(filepath, **kwargs)
