[MODULE]
id=PPFORMS
name=Forms for remote approvals.
desc=Execute approvals and other actions from a one time we page.
company=Poplar Development
version=1.0.6
website=https://poplars.dev

[MESSAGE]
MSGID=PPFORMS.WFAPPROVALFORM
TEXTDESC=Notify the user of an approval form.
SUBJECT=Workflow Approval Required
BODY=A workflow in Sage300 requires your approval. \r\n\r\nPlease visit {FORMURL} to approve or reject the request.

[SCRIPT]
FILENAME=PPFORMS.remote_approvals
>>> SCRIPT >>>
###############################################################################
#  expip - Python Package Manager for Orchid Extender
#
#  expip is the Python package manager for Orchid Extender.  It enables you to
#  take advantage of the Python ecosystem.  Use it to install any package from
#  pypi.org or expi.dev.
#
#  author: Chris Binckly (2665093 Ontario Inc.)
#  email: cbinckly@gmail.com
#  Copyright 2665093 Ontario Inc. 2019
#
#  This software has a non-exclusive license and cannot be sublicensed, reused,
#  transferred or modified without written consent from 2665093 Ontario Inc.
#
###############################################################################
import os
import re
import sys
import bz2
import json
import base64
import string
import random
import hashlib
import datetime
import requests
import tempfile
import platform
import traceback
import subprocess
import configparser
from pathlib import Path
from contextlib import contextmanager

from accpac import *

from form_client import NamespaceClient

DEBUG = False
NAME = "expip - Python Package Manager for Extender"
VERSION = "2.2.3"

BILLING_EMAIL = "cbinckly@gmail.com"
SUPPORT_EMAIL = "cbinckly@gmail.com"
SUPPORT_URL = "https://2665093.ca"

PYSIG = "https://expi.dev/python/{version}/{file}"
UPDSIG = "https://expi.dev/access"
SHAS = { "3.4.2": {
            "python.exe": "8113c872d18c3f19aafc8c0e3bb4c3d94990f5cc2562b2c8654a6972e012f776",
            "python34.dll": "ea8d834c3f7f69270e47fbcccf9a159385b39b4aa7c6aae4a28fa9ff835455a7",
            },
       }

SCHEME_RE = re.compile(r'^(\w+)(\+(\w+)|)://')
PKG_FROM_SCHEME_RE = re.compile(r'/([a-zA-z0-9\-_])(.git|)[@#].+$')

MODULE = "EXPIP"
TABLE = "EXPIPCON"

PIPMIN = 19
PIPMAX = 20

## Entry point

def main(args):
    RemoteApprovalsUI()

### Utility Functions

def _debug(msg, excinfo=None):
    if DEBUG:
        msg = "DEBUG {}\n{}\n---------\n{}".format(rotoID, NAME, msg)
        if excinfo:
            msg = "\n".join([msg, traceback.format_exc(), ])
        showMessageBox(msg)

def _alert(msg):
    showMessageBox("{}\n\n{}".format(NAME, msg))

def success(*args):
    if sum(args) > 0:
        return False
    return True

### Interface Definition

class RemoteApprovalsUI(UI):
    """UI for Remote approvals management.    """

    # Custom control constants
    BUTTON_WIDTH = 1265
    BUTTON_SPACE = 150

    # Grid layout
    COL_MONTH = 0
    COL_USAGE = 1

    def __init__(self):
        """Initialize a new UI instance.  Speaks."""
        UI.__init__(self)
        

        shown = False
        try:
            self.namespace_client = NamespaceClient()
            self.namespaces = self.namespace_client.list()
            self.namespace = self.namespaces[0]
            self.title = "Remote Approval Management - {}".format(
            self.namespace['subdomain'])
            self.createScreen()
            self.show()
            shown = True
            self._refresh_grid()
        except Exception as e:
            if not shown:
                self.show()
            _alert("Error starting up: {}".format(
                e))
            _debug(e, excinfo=sys.exc_info()[2])
            self.closeUI()
        else:
            self.onClose = self.onCloseClick

    # Requests

    def createScreen(self):
        """Configure and render the fields and buttons.
        | Namespace subdomain.ff.io             |
        |                                       |
        | Soft Limit: NNNNNNNN                  |
        | Hard Limit: NNNNNNNN                  |
        |                                       |
        | Remaining this Month: NNNNNN          |
        |                                       |
        || Period   |                  Usage   ||
        || 2019-12  |                  15456   ||
        || 2020-01  |                  16765   ||
        |                                       |
        |  Logo: [https://path/logo.png       ] |
        | Style: [https://path/style.png      ] |
        |                                       |
        |                    +Save      +Close  |

        """



        f = self.addUIField("namespaceLabel")
        f.controlType = "EDIT"
        f.size = 250
        f.width = 5000
        f.labelWidth = 60
        f.caption = "Namespace"
        f.hasFinder = False
        f.setValue("{}.fleetingforms.io".format(self.namespace['subdomain']))
        f.enabled = False
        self.namespace_field = f

        f = self.addUIField("softLimitLabel")
        f.controlType = "EDIT"
        f.size = 250
        f.width = 5000
        f.labelWidth = 60
        f.caption = "Soft Limit"
        f.hasFinder = False
        f.setValue(str(self.namespace['soft_limit']))
        f.enabled = False
        self.soft_limit_field = f
        
        f = self.addUIField("hardLimitLabel")
        f.controlType = "EDIT"
        f.size = 250
        f.width = 5000
        f.labelWidth = 60
        f.caption = "Hard Limit"
        f.hasFinder = False
        f.setValue(str(self.namespace['hard_limit']))
        f.enabled = False
        self.hard_limit_field = f


        f = self.addUIField("remainingLabel")
        f.controlType = "EDIT"
        f.size = 250
        f.width = 5000
        f.labelWidth = 60
        f.caption = "Remaining (Month)"
        f.hasFinder = False
        curmonth = datetime.datetime.now().strftime("%Y-%m")
        f.enabled = False
        f.setValue(str(self.namespace['soft_limit'] - 
                   self.namespace['usage'].get(curmonth, 0)))
        self.remaining_field = f

        f = self.addUIField("supportEmailField")
        f.controlType = "EDIT"
        f.size = 250
        f.width = 5000
        f.labelWidth = 60
        f.caption = "Support Email"
        f.setValue(self.namespace.get('support_email', ''))
        f.hasFinder = False
        self.support_email_field = f
        
        f = self.addUIField("logoUrlField")
        f.controlType = "EDIT"
        f.size = 250
        f.width = 5000
        f.labelWidth = 60
        f.caption = "Logo URL"
        f.setValue(self.namespace.get('logo', ''))
        f.hasFinder = False
        self.logo_field = f

        f = self.addUIField("styleUrlField")
        f.controlType = "EDIT"
        f.size = 250
        f.width = 5000
        f.labelWidth = 60
        f.caption = "Style URL"
        f.setValue(self.namespace.get('style', ''))
        f.hasFinder = False
        self.style_field = f

        grid = self.addGrid("usageGrid")

        grid.setOnBeginEdit(self.gridOnBeginEdit)
        grid.onRowChanged = self.gridOnRowChanged

        grid.height = -100
        grid.width = -150
        # grid.top = self.remaining_label.top + 150
        grid.addTextColumn("Month", "LEFT", 100, True)
        grid.addTextColumn("Approvals", "Right", 300, True)
        self.usage_grid = grid
        self.usage_grid.removeAllRows()

        btn = self.addButton("btnSave", "&Save")
        btn.top = - self.BUTTON_SPACE - btn.height
        btn.width = self.BUTTON_WIDTH
        btn.left = self.usage_grid.left
        btn.onClick = self.onSaveClick
        self.btnSave = btn
        
        btn = self.addButton("btnClose", "&Close")
        btn.top = - self.BUTTON_SPACE - btn.height
        btn.width = self.BUTTON_WIDTH
        btn.left = -self.BUTTON_SPACE - self.BUTTON_WIDTH
        btn.onClick = self.onCloseClick
        self.btnClose = btn

        self.usage_grid.height = -self.BUTTON_SPACE - btn.height - 75

    def gridOnBeginEdit(self, e):
        _alert("Items in this grid cannot be edited.")
        return Abort

    def gridOnRowChanged(self, new_row):
        return Continue

    def _refresh_grid(self):
        for month, usage in self.namespace['usage'].items():
            row = self.usage_grid.createRow()
            row.columns[self.COL_MONTH] = month
            row.columns[self.COL_USAGE] = str(usage)
            self.usage_grid.addRow(row)

    # Event Handling
    def onSaveClick(self):
        if not hasattr(self, 'namespace') or not self.namespace:
            return Continue
            
        logo = self.logo_field.getValue()
        style = self.style_field.getValue()
        support_email = self.support_email_field.getValue()
        
        data = {
            'id': self.namespace['id'],
            'subdomain': self.namespace['subdomain'],
            'support_email': support_email,
            'logo': logo,
            'style': style,
        }
        
        try:
            self.namespace_client.update(self.namespace['id'], 
                                         data=data)
            _alert("Remote approvals settings updated.")
        except Exception as e:
            _alert("Remote approval settings update failed: {}".format(e))
        
        return Continue
            

    def onCloseClick(self):
        """Close the UI if the Close button or window X are clicked."""
        self.closeUI()
<<< SCRIPT <<<
[SCRIPT]
FILENAME=PPFORMS.poller
>>> SCRIPT >>>
"""
The poller component of the PPFORMS module connects to fleetingforms.io using
a Sage instance's unique token and downloads any forms that have been
completed or are in error.

On every execution, the poller takes the following steps::

    for each form in the polling results:
        if the form is completed and workflow related:
            progress the workflow based on the user action
        if the form is in error:
            log the error

    delete all processed forms
    log a summary of the actions taken

The poller can be executed from the Scripts panel or run using
:ref:`Process Scheduler <running-the-poller-with-process-scheduler>`.

The poller logs to
``Sage300/SharedData/Company/<ComanyName>/ppforms.poll.log``
"""
import logging
from logging.handlers import RotatingFileHandler
from pathlib import Path

try:
    from accpac import *
    from form_client import FormClient
except ImportError:
    pass


# Forms in these statuses need to be handled.
FORM_COMPLETED_STATUSES = { 'completed', 'error', }

# Execution contexts: run through the scripts panel (VI) or scheduler (PS)
VI = 0
PS = 1

# Error counter for PS
pserr = 0

# The logger must be setup in the main method, config here fails.
logger = None

def execution_context():
    """Enable running from PS or Scrips panel.

    If run through PS this will return PS, otherwise VI.
    """
    if program.startswith("AS1"):
        return PS
    return VI

def _alert(message):
    """Show an alert to the user.

    When running in VI, the alert is shown in a message box.
    """
    if execution_context() == VI:
        showMessageBox("Remote Approvals\n\n{}".format(message))
    logger.info(message)

def _error(message):
    """Register an error in the process.

    When running in VI, the error is shown in a message box.
    """
    if execution_context() == VI:
        showMessageBox("Remote Approvals - Error\n\n{}".format(message))
    logger.exception(message)

def main(*args, **kwargs):
    """Entry point for execution - perform a poll."""

    # Configure a logger to write to the log file.
    global logger
    log_path = Path(getOrgPath(), "ppforms.poll.log")
    logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s %(name)-12s %(levelname)-8s %(message)s',
            datefmt='%Y-%m-%dT%H:%M:%S',
            handlers=[RotatingFileHandler(
                filename=str(log_path),
                backupCount=5,
                maxBytes=10*1024*1024), ],
        )
    logger = logging.getLogger('PPFORMS.poll')
    logger.debug("main: org {}, user {}, program {}".format(
            org, user, program))

    # Create a new poller for this organization and poll.
    try:
        poller = FleetingFormPoller(org)
        successes, errors = poller.poll()
        summary = """
        Polling complete.

        {} approvals applied successfully
        {} errors encountered.

        See the details in the PS Log.
        """.format(len(successes), len(errors))
        _alert(summary)
    except PollerError as e:
        _error("Error in poller: {}".format(e))
    except Exception as e:
        _error("General failure in poller: {}".format(e))

    if execution_context() == PS:
        # When running through PS, log a completion message.
        log_message = "{}|{}|{}".format(
                "ERR" if errors else "OK",
                len(errors),
                log_path)
        log(log_message)

    if execution_context() == VI:
        # When running through the scripts panel, close the empty UI.
        UI().closeUI()

# Poller class and errors
class PollerError(Exception):
    """Base Exception class for all errors raised by the poller."""
    pass

class PollerStartupError(PollerError):
    """Poller failed to start."""
    pass

class PollerAPIError(PollerError):
    """Poller had an API communication failure."""
    pass

class PollerValidationError(PollerError):
    """Poller failed to validate a completed form."""
    pass

class PollerDeleteError(PollerAPIError):
    """Poller failed to delete a form over the API."""
    pass

class PollerWorkflowSaveError(PollerError):
    """Poller failed to save a workflow."""
    pass

class PollerFormInError(PollerError):
    """Poller encountered a form in an error state."""
    pass

class FormHandler(object):
    """Abstract parent for all form handlers.

    To handle a new type of form, define a new handler and register
    it in the FleetingFormPoller.FORM_HANDLERS dict.

    Form handlers are automatically dispatched based on the form.app.type
    value.
    """
    type = None

    def __init__(self, form):
        if not self.type:
            raise NotImplementedError("Handlers must have a type.")
        self.form = form

    def validate(self):
        raise NotImplementedError(
                "Validate must be implemented in a subclass.")

    def apply(self):
        raise NotImplementedError(
                "Apply must be implemented in a subclass.")

class WorkflowApprovalFormHandler(FormHandler):
    """Handle a workflow approval form.

    This handler validates that a workflow approval form has
    all the required fields and progresses to the next step based
    on the user action.

    :param form: the form to handle.
    :type form: dict
    """

    type = 'workflow_approval'

    def __init__(self, form):
        super(WorkflowApprovalFormHandler, self).__init__(form)
        self.wiid = None
        self.stepname = None
        self._validated = False

    def validate(self):
        """Validate a completed workflow approval self.form.

        Sets:
          - self.stepname: next workflow step
          - self.wiid: workflow instance id
          - self.app: app parameters for this form

        :returns: validated form
        :rtype: dict
        :raises: PollerValidationError
        """

        self.app = self.form.get('app', {})
        self.wiid = self.app.get('wiid')

        # forms must have a valid workflow instance id
        if not self.wiid:
            raise PollerValidationError(
                    "self.form {} has no workflow ID set.".self.format(
                        self.form.get('code', 'unset')))

        # and a mapping of form actions to steps.
        self.steps = self.app.get('steps', {})
        if not self.steps:
            raise PollerValidationError(
                    "self.form {} has no steps set.".self.format(
                        self.form.get('code', 'unset')))

        # an action must have been performed and recorded (i.e. Approve)
        self.result_action = self.form.get('result', {}).pop('action', None)
        if not self.result_action:
            raise PollerValidationError(
                    "No action for self.form {}".self.format(
                        self.form.get('code', 'unset')))

        # there must be a step to progress to for that action.
        self.stepname = self.steps.get(self.result_action)
        if not self.stepname:
            raise PollerValidationError(
                    "self.form {} has no stepname for {}.".self.format(
                            self.form.get('code', 'unset'),
                            self.result_action))

        # all is well.
        self._validated = True
        return self.form

    def apply(self):
        """Apply a workflow validation form.

        Applies a workflow validation form by setting the result
        values in the workflow instance values and progressing the
        workflow to the next step.

        :returns: None
        :raises: PollerError
        """
        if not self._validated:
            raise PollerValidationError(".validate() must be called on the "
                                        "form before .apply().")
        # Validate sets self.app, self.wiid, self.stepname
        wi = WorkflowInstance()
        _r = wi.loadInstance(self.wiid)

        # Copy all keys from the result into the workflow values.
        result = self.form.get('result', {})
        for (key, value) in result.items():
            wi.setValue(key, value)

        # If the RUNUSER result key is set, use it to change the
        # user executing the action.
        runuser = result.get("RUNUSER", user)
        wi.viworkih.put("RUNUSER", runuser)
        wi.viworkih.update()

        # Progress the workflow to the next step.
        logger.info('[{}] - progressing {} to {} as {}.'.format(
                self.form['code'], self.wiid, self.stepname, runuser))
        r = wi.progressTo(self.stepname)
        if wi.save() != 0:
            raise PollerWorkflowSaveError(
                    "Failed to progress {} to {} for form {}".format(
                             self.wiid, self.stepname,
                             self.form.get('code', 'unset')))


class FleetingFormPoller():
    """The fleeting form poller retrieves completed forms and applies them.

    :param org_: the sage company to poll for.
    :type org_: str
    :param clean: delete forms after applying their actions?
    :type clean: bool
    """

    FORM_HANDLERS = [
                WorkflowApprovalFormHandler,
            ]

    def __init__(self, org_, clean=True):
        self.errors = []
        self.successes = []
        self.org = org_
        self.clean = clean
        self.__form_list = []
        self._handlers = {}

        for handler_class in self.FORM_HANDLERS:
            self._handlers[handler_class.type] = handler_class

        try:
            self.client = FormClient()
        except Exception as e:
            raise PollerStartupError("Failed to start client: {}".format(e))

        logger.info("poller started for org {} with clean {}".format(
                org_, clean))

    def _flush_error_stack_to_log(self):
        """Flush the error stack to the log to debug errors in Sage."""
        errors = ErrorStack()
        logger.debug("flushing {} messages from error stack.".format(errors.count()))
        for i in range(0, errors.count()):
            func = logger.debug
            priority = errors.getPriority(i)
            if priority == PRI_MESSAGE:
                func = logger.info
            elif priority == PRI_WARNING:
                func = logger.warn
            elif priority == PRI_MESSAGE:
                func = logger.error
            func(errors.getText(i))
        errors.clear()

    @property
    def form_list(self):
        """A list of all forms in this namespace from cache or API."""
        if not self.__form_list:
            try:
                self.__form_list = self.client.list()
            except Exception as e:
                raise PollerAPIError("Failed to list forms: {}".format(e))
        return self.__form_list

    def form_list_filtered_by(self, form_filter={}, app_filter={}):
        """Yields forms from form_list matching form and app attrs.

        :param form_filter: the form attributes to filter for.
        :type form_filter: dict
        :param app_filer: the app attributes to filter for.
        :type app_filter: dict
        :yields: dict()
        """
        for form in self.form_list:
            if form_filter.items() <= form.items():
                if app_filter.items() <= form.get('app', {}).items():
                    yield(form)

    def poll(self):
        """Poll fleetingforms and process completed actions.

        :returns: a list of forms successfully processed and a list of forms
                  that encountered errors.
        :rtype: (list, list)
        """
        app_filter = {'org': self.org}

        # Filter our complete forms for this org.
        for form in self.form_list_filtered_by({'status': 'completed'},
                                               app_filter):
            try:
                # Get a handler for this form type.
                handler_class = self._handlers[form['app']['type']]

                # Create a new instance, validate and apply the action
                handler = handler_class(form)
                handler.validate()
                handler.apply()

                # Track stats and log/notify
                self.successes.append((form, True, ))
                _alert("[{}] - successfully applied.".format(form['code']))
            except Exception as e:
                # Log the error and track the form in errors.
                self.errors.append((form, e, ))
                _error("[{}] - error while applying: {}".format(
                        form['code'], e))
                # Flush Sage errors to the log for debugging
                self._flush_error_stack_to_log()

        # Find all forms in error for this org and log.
        # Deletion of the form deferred until cleanup.
        for form in self.form_list_filtered_by({'status': 'error'},
                                               app_filter):
            if app_filter.items() <= form['app'].items():
                raise PollerFormInError(
                        "Form {} is in an error state.".format(
                            form.get('code', 'unset')))

        # After processing completed forms and those in error,
        # clean up all processed forms from the service.
        if self.clean:
            self.cleanup()

        return (self.successes, self.errors)

    def cleanup(self):
        """Delete all successfully processed forms from the service.

        :returns: None
        """
        processed = self.successes + self.errors
        logger.debug('cleaning up {} forms.'.format(len(processed)))
        for (form, status) in processed:
            try:
                self.client.delete(form['id'])
                logger.info("[{}] - deleted form {}.".format(
                        form['code'], form['id']))
            except Exception as e:
                self.errors.append((form,
                        PollerDeleteError(
                        "Failed to delete the entry {}: {}".format(
                                form.get('code', 'unset'), e)),
                        ))

        # Clear the cache of forms for this org.
        self.__form_list.clear()
<<< SCRIPT <<<
[SCRIPT]
FILENAME=PPFORMS.Workflow.SendCreditLimitApprovalFormEmail
>>> SCRIPT >>>
"""
This workflow action sends a credit limit approval form link in
an email to one or more users.

The form has a title, content, a credit limit float field,
a long form comments box, and Approve/Reject buttons::

    Title

    Content

    Credit Limit: _________________________
    Comments: _____________________________

    Approve | Reject

The action takes the following parameters:

- Parameter1: Email Notification Template - sent to users to notify that
  that a form is available.
- Parameter2: To list of Sage Users or Extender User Groups
- Parameter3: Form Title and Content Template - template to render for form
  title (message subject) and content (message body)
- Parameter4: Approve,Reject - steps to proceed to when approved or rejected,
  comma separated.
"""
from collections import OrderedDict

try:
    from accpac import *
    from form_client import (create_workflow_approval_form,
                             resolve_users,
                             render_title_and_content_for, )
except ImportError:
    pass

form_controls =  [
                    {
                      'name': 'RUNUSER',
                      'type': 'text',
                      'label': 'Sage User',
                      'required': True,
                    },
                    {
                      'name': 'APPRCRLIMT',
                      'type': 'float',
                      'label': 'Credit Limit',
                      'required': True,
                    },
                    {
                      'name': 'APPROVALCOMMENT',
                      'type': 'textarea',
                      'label': 'Comments',
                      'required': True,
                    }
                ]

def workflow(e):
    """Execute the workflow step.

    This function is invoked by the workflow engine.  It is called
    with ``accpac.WorkflowArgs`` and must return ``0`` on success and
    ``1`` on failed.

    :param e: the workflow arguments for this action.
    :type e: ``accpac.WorkflowArgs``
    :returns: 0/1
    :rtype: int
    """

    # Parse the actions from P4 into a { label: nextstep, } data structure
    actions = OrderedDict()
    try:
        steps = e.resolve(e.p4).split(',')
        for step in steps:
            label, next_step = step.split('=')
            actions[label] = next_step
    except (IndexError, ValueError) as s:
        showMessageBox("The actions (P4) must be a comma-separated list "
                       "of label=nextstep pairs, "
                       "eg. 'Approve=Approved+RTP,Reject=Rejected'" )
        return 1

    # Create the form, setting the initial value for the credit limit.
    try:
        title, content = render_title_and_content_for(e.resolve(e.p3), e)
        credit_limit = e.resolve("{TOVALUE}").replace(",", "")
        form = create_workflow_approval_form(
                            e.wi.viworkih.get("WIID"),
                            form_controls,
                            title,
                            content,
                            actions,
                            APPRCRLIMT=credit_limit)
    except Exception as e:
        showMessageBox("Failed to create approval form: {}".format(e))
        return 1

    # Get the url for the form.
    url = form.get('url')
    if not url:
        error("Unable to get approval form URL.")
        return 1

    # And set it in the workflow for troubleshooting and posterity
    e.wi.setValue("FORMURL", url)

    # Resolve all users, groups, and emails from P2
    users = resolve_users(e.resolve(e.p2))

    # For each user identified, send an email with a custom link that sets
    # RUNUSER.
    for (username, email_address) in users:
        email = Email()
        email.setTo(email_address)
        if not email.load(e.resolve(e.p1)):
            error("Unable to load message template '" + e.p1 + "'")
            return 1

        # Build a custom URL for the user that defaults the runuser field.
        user_url = "{}?RUNUSER={}&".format(url, username)

        # And interpolate it into the template
        email.replace("FORMURL", user_url)

        # Do all the remaining interpolation for Workflow, View, and Globals
        # to build the subject and body.
        email.replace("", e.wi.getView())
        email.setSubject(e.resolve(email.subject))
        if email.textBody != None:
            email.setText(e.resolve(email.textBody))
        if email.htmlBody != None:
            email.setHtml(e.resolve(email.htmlBody))

        # Send the email.
        email.send()

    # Success.
    return 0
<<< SCRIPT <<<
[SCRIPT]
FILENAME=PPFORMS.Workflow.SendApprovalFormEmail
>>> SCRIPT >>>
"""
This workflow actions sends a general approval form link in
an email to one or more users.

The form has a title, content, a long form comments box,
and Approve/Reject buttons::

    Title

    Content

    Comments: _____________________________

    Approve | Reject

The action takes the following parameters:

- Parameter1: Email Notification Template - sent to users to notify that
  that a form is available.
- Parameter2: To list of Sage Users or Extender User Groups
- Parameter3: Form Title and Content Template - template to render for form
  title (message subject) and content (message body)
- Parameter4: Approve,Reject - steps to proceed to when approved or rejected,
  comma separated.
"""
from collections import OrderedDict

try:
    from accpac import *
    from form_client import (create_workflow_approval_form,
                             resolve_users,
                             render_title_and_content_for, )
except ImportError:
    pass

form_controls = [
                    {
                      'name': 'APPROVALCOMMENT',
                      'type': 'textarea',
                      'label': 'Comments',
                      'required': True,
                    }
                ]

def workflow(e):
    """Execute the workflow step.

    This function is invoked by the workflow engine.  It is called
    with ``accpac.WorkflowArgs`` and must return ``0`` on success and
    ``1`` on failed.

    :param e: the workflow arguments for this action.
    :type e: ``accpac.WorkflowArgs``
    :returns: 0/1
    :rtype: int
    """

    # Parse the actions from P4 into a { label: nextstep, } data structure
    actions = OrderedDict()
    try:
        steps = e.resolve(e.p4).split(',')
        for step in steps:
            label, next_step = step.split('=')
            actions[label] = next_step
    except (IndexError, ValueError) as s:
        showMessageBox("The actions (P4) must be a comma-separated list "
                       "of label=nextstep pairs, "
                       "eg. 'Approve=Approved+RTP,Reject=Rejected'" )
        return 1

    # Create the form
    try:
        title, content = render_title_and_content_for(e.resolve(e.p3), e)
        form = create_workflow_approval_form(
                            e.wi.viworkih.get("WIID"),
                            form_controls,
                            title,
                            content,
                            actions, )
    except Exception as err:
        showMessageBox("Failed to create approval form: {}".format(err))
        return 1

    url = form.get('url')
    if not url:
        error("Unable to get approval form URL.")
        return 1

    e.wi.setValue("FORMURL", url)

    # send an email
    users = resolve_users(e.resolve(e.p2))

    for (username, email_address) in users:
        email = Email()
        email.setTo(email_address)
        if email.load(e.resolve(e.p1)) == False:
            error("Unable to load message template '" + e.p1 + "'")
            return 1

        user_url = "{}?RUNUSER={}&".format(url, username)
        email.replace("FORMURL", user_url)
        email.replace("", e.wi.getView())
        email.setSubject(e.resolve(email.subject))
        if email.textBody != None:
            email.setText(e.resolve(email.textBody))
        if email.htmlBody != None:
            email.setHtml(e.resolve(email.htmlBody))
        email.send()
    return 0
<<< SCRIPT <<<