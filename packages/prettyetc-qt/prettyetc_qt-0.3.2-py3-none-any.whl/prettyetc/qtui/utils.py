#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Util functions for Qt.
"""

import multiprocessing
import os
import threading

from prettyetc.baseui import get_desktop_environment
from PySide2.QtCore import QPoint
from PySide2.QtWidgets import (QApplication, QMainWindow, QToolTip, QWidget,
                               QWidgetAction)

__all__ = ("init_qt_components", "load_qt_plugins", "tr", "get_main_window",
           "show_tooltip")

INIT_TEMPLATE = '''#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""Autogenerated module, any changes will be lost."""

from .{} import {}
__all__ = ({})
'''


def _spawn_command(command, *args):
    # os.execvp(command, args)
    os.system("{} {}".format(command, " ".join(args)))


def init_qt_components(  # pylint: disable=R0914
        component_path,
        design_path="design",
        locale_path="locale",
        widgets_path="widgets",
        resources_path="resources",
        project_file="project.pro",
        languages=None,
        generate_project=False,
        generate_init=False):
    """
    Initialize qt components create by exernal qt tools to be used by
    python.

    The given directory must contain 3 folder and 2 files:
        - a design path (specified by design_path parameter
            where is contained .ui files created by Qt Designer.
        - a locale path (specified by locale_path parameter)
            where is contained .ts files created by pyside2-lupdate command and
            used by qt linguist.
        - a widget path (specified by widgets_path parameter)
            where ui files will be converted by pyside2-uic to python modules.
        - a resouces path (specified by resources_path parameter)
            where is contained qrc files.
        - a compiled resouces path (specified by compiled_resource_path parameter)
            where qrc files is compiled to rcc files by pyside2-rcc
        - a qt project file (specified by project_file parameter)
            where is contained directives for pyside2-lupdate.
            It can be generated by this function if generate_project is True
        - an __init__.py file
            that import modules contained in widgets path.
            It can be generated by this function if generate_init is True
        """

    design_path = os.path.join(component_path, design_path)
    locale_path = os.path.join(component_path, locale_path)
    widgets_path = os.path.join(component_path, widgets_path)
    resources_path = os.path.join(component_path, resources_path)

    project_file = os.path.join(component_path, project_file)
    if not (os.path.exists(design_path) or os.path.exists(locale_path)
            or os.path.exists(widgets_path) or os.path.exists(resources_path)):
        raise FileNotFoundError(
            "Given design, locale, widgets and resources directory must exists."
        )

    if not hasattr(languages, "__iter__") and generate_project:
        raise ValueError(
            "Languages must be specified when you generate a project.")

    # ui processing
    if generate_project or generate_init:
        generated_widgets = []
    for file in os.listdir(design_path):
        abspath = os.path.join(design_path, file)
        if file.endswith(".ui"):
            module_path = os.path.join(widgets_path,
                                       os.path.splitext(file)[0] + ".py")

            multiprocessing.Process(
                target=_spawn_command,
                args=("pyside2-uic", "--from-imports", abspath, "-o",
                      module_path)).start()
            if generate_project or generate_init:
                generated_widgets.append(module_path)

    # resources processing
    for file in os.listdir(resources_path):
        abspath = os.path.join(resources_path, file)
        if file.endswith(".qrc"):
            compiled_path = os.path.join(widgets_path,
                                         os.path.splitext(file)[0] + "_rc.py")
            multiprocessing.Process(
                target=_spawn_command,
                args=("pyside2-rcc", abspath, "-o", compiled_path)).start()

    if generate_init:
        # generate __init__ files
        dirname = os.path.split(widgets_path)[1]
        module_names = ", ".join(
            os.path.splitext(os.path.split(file)[1])[0]
            for file in generated_widgets)
        module_names_all = ", ".join(
            repr(os.path.splitext(os.path.split(file)[1])[0])
            for file in generated_widgets)
        with open(os.path.join(component_path, "__init__.py"), "w") as stream:
            stream.write(
                INIT_TEMPLATE.format(dirname, module_names, module_names_all))
        # create empty file
        open(os.path.join(widgets_path, "__init__.py"), "w")

    if generate_project:
        with open(os.path.join(component_path, project_file), "w") as stream:
            stream.write(
                "# Autogenerated project file, any changes will be lost\n")
            stream.write("SOURCES = ")  # init sources
            for abspath in generated_widgets:
                relpath = os.path.relpath(abspath, component_path)
                stream.write("{} ".format(relpath))
            # end sources, start languages
            stream.write("\n\nTRANSLATIONS = ")
            relpath = os.path.relpath(locale_path, component_path)
            for language in languages:
                stream.write("{} ".format(
                    os.path.join(relpath, "{}.ts".format(language))))
            stream.write("\n")  # end languages

    multiprocessing.Process(
        target=_spawn_command,
        args=("pyside2-lupdate", "-noobsolete",
              os.path.join(component_path, project_file))).start()
    # os.execlp("pyside2-lupdate", "-noobsolete", os.path.join(component_path, project_file))


def load_qt_plugins():
    """
    Init system Qt plugins on linux.

    Pip version of PySide2 is shipped with its qt plugins, ignoring the system ones.

    .. error::
        This function doesn't work and can crash qt.
    """
    # Load system qt plugins
    # for activate this you must call main script with
    # PYSIDE_DISABLE_INTERNAL_QT_CONF=1
    if get_desktop_environment() == "kde":
        # self.logger.info("You are using KDE")
        try:
            # self.logger.debug("Try to load custom qt.conf resource")
            import qtui.components.widgets.qt_conf_rc as _  # pylint: disable=E0611
        except ImportError:
            pass
            # self.logger.debug("Failed to load custom qt.conf resource")
        else:
            pass
            # qfile = QFile(":/qt/etc/qt.conf")
            # qfile.open(QIODevice.OpenModeFlag(0x0011))
            # print(qfile.readAll())


def tr(*args):
    """Shortcut for QApplication.translate."""
    return QApplication.translate(*args)


def get_main_window() -> QMainWindow:
    """Get instance of QtWidgets.QMainWindow from QApplication instance."""
    app = QApplication.instance()
    for widget in app.topLevelWidgets():
        if isinstance(widget, QMainWindow):
            return widget
    return None


def to_action(widget: QWidget) -> QWidgetAction:
    """Wrap a QWidget in a QWidgetAction."""
    parent = widget.parent()
    action = QWidgetAction(parent)
    action.setDefaultWidget(widget)

    return action


def show_tooltip(widget: QWidget, text: str, timeout: int = 5):
    """
    Show a tooltip in given widget that shows given text.
    :param int timeout: unshow automatically the tooltip after seconds
                        If timeout is None, the tooltip never unshow.
    """
    QToolTip.showText(widget.mapToGlobal(QPoint()), text)
    if timeout is not None:
        threading.Timer(timeout, QToolTip.hideText)
