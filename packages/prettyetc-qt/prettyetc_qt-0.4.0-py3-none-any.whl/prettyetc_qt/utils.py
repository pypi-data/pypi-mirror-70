#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Util functions for Qt.
"""

import multiprocessing
import os
import threading

from PySide2.QtCore import QObject, QPluginLoader, QPoint, QRunnable, Slot
from PySide2.QtWidgets import (
    QApplication, QLayout, QMainWindow, QToolTip, QWidget, QWidgetAction)

from prettyetc.baseui import get_desktop_environment

__all__ = ("RunnableWrapper", "init_qt_components", "load_qt_plugins", "tr",
           "get_main_window", "show_tooltip", "replace_widget",
           "tranfer_properties")

INIT_TEMPLATE = '''#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""Autogenerated module, any changes will be lost."""

from .{} import {}
__all__ = ({})
'''


class RunnableWrapper(QRunnable):
    """Wrap a callable into a QRunnable."""

    def __init__(self, func: callable, *args, **kwargs):
        super(RunnableWrapper, self).__init__()
        self.func = func
        self.args = args
        self.kwargs = kwargs

    @Slot()
    def run(self):
        self.func(*self.args, **self.kwargs)


def _spawn_command(command, *args):
    # os.execvp(command, args)
    os.system("{} {}".format(command, " ".join(args)))


def init_qt_components(  # pylint: disable=R0914
        component_path,
        design_path="design",
        locale_path="locale",
        widgets_path="widgets",
        resources_path="resources",
        project_file="project.pro",
        languages=None,
        generate_project=False,
        generate_init=False):
    """
    Initialize qt components create by exernal qt tools to be used by
    python.

    The given directory must contain 3 folder and 2 files:
        - a design path (specified by design_path parameter
            where is contained .ui files created by Qt Designer.
        - a locale path (specified by locale_path parameter)
            where is contained .ts files created by pyside2-lupdate command and
            used by qt linguist.
        - a widget path (specified by widgets_path parameter)
            where ui files will be converted by pyside2-uic to python modules.
        - a resouces path (specified by resources_path parameter)
            where is contained qrc files.
        - a compiled resouces path (specified by compiled_resource_path parameter)
            where qrc files is compiled to rcc files by pyside2-rcc
        - a qt project file (specified by project_file parameter)
            where is contained directives for pyside2-lupdate.
            It can be generated by this function if generate_project is True
        - an __init__.py file
            that import modules contained in widgets path.
            It can be generated by this function if generate_init is True
        """

    design_path = os.path.join(component_path, design_path)
    locale_path = os.path.join(component_path, locale_path)
    widgets_path = os.path.join(component_path, widgets_path)
    resources_path = os.path.join(component_path, resources_path)

    project_file = os.path.join(component_path, project_file)
    if not any((
            os.path.exists(design_path),
            os.path.exists(locale_path),
            os.path.exists(widgets_path),
            os.path.exists(resources_path),
    )):
        raise FileNotFoundError(
            "Given design, locale, widgets and resources directory must exists."
        )

    if not hasattr(languages, "__iter__") and generate_project:
        raise ValueError(
            "Languages must be specified when you generate a project.")

    # ui processing
    if generate_project or generate_init:
        generated_widgets = []
    for file in os.listdir(design_path):
        abspath = os.path.join(design_path, file)
        if file.endswith(".ui"):
            module_path = os.path.join(
                widgets_path,
                os.path.splitext(file)[0] + ".py",
            )

            multiprocessing.Process(
                target=_spawn_command,
                args=(
                    "pyside2-uic",
                    "--from-imports",
                    "-a",
                    '"' + abspath + '"',
                    "-o",
                    '"' + module_path + '"',
                ),
            ).start()
            if generate_project or generate_init:
                generated_widgets.append(module_path)

    # resources processing
    for file in os.listdir(resources_path):
        abspath = os.path.join(resources_path, file)
        if file.endswith(".qrc"):
            compiled_path = os.path.join(
                widgets_path,
                os.path.splitext(file)[0] + "_rc.py",
            )
            multiprocessing.Process(
                target=_spawn_command,
                args=(
                    "pyside2-rcc",
                    '"' + abspath + '"',
                    "-o",
                    '"' + compiled_path + '"',
                ),
            ).start()

    if generate_init:
        # generate __init__ files
        dirname = os.path.split(widgets_path)[1]
        module_names = ", ".join(
            os.path.splitext(os.path.split(file)[1])[0]
            for file in generated_widgets)
        module_names_all = ", ".join(
            os.path.normpath(os.path.splitext(os.path.split(file)[1])[0])
            for file in generated_widgets)
        with open(os.path.join(component_path, "__init__.py"), "w") as stream:
            stream.write(
                INIT_TEMPLATE.format(
                    dirname,
                    module_names,
                    module_names_all,
                ))
        # create empty file
        open(os.path.join(widgets_path, "__init__.py"), "w")

    if generate_project:
        with open(os.path.join(component_path, project_file), "w") as stream:
            stream.write(
                "# Autogenerated project file, any changes will be lost\n")
            stream.write("SOURCES = ")  # init sources
            for abspath in generated_widgets:
                relpath = os.path.relpath(abspath, component_path)
                stream.write("{} ".format(relpath))
            # end sources, start languages
            stream.write("\n\nTRANSLATIONS = ")
            relpath = os.path.relpath(locale_path, component_path)
            for language in languages:
                stream.write("{} ".format(
                    os.path.join(
                        relpath,
                        "{}.ts".format(language),
                    )))
            stream.write("\n")  # end languages

    multiprocessing.Process(
        target=_spawn_command,
        args=(
            "pyside2-lupdate",
            "-noobsolete",
            '"' + os.path.join(component_path, project_file) + '"',
        ),
    ).start()
    # os.execlp("pyside2-lupdate", "-noobsolete", os.path.join(component_path, project_file))


def load_qt_plugins(way: str = "qtconf"):
    """
    Init system Qt plugins on linux.

    Pip version of PySide2 is shipped with its qt plugins, ignoring the system ones.

    .. error::
        This function doesn't work and can crash qt.
    """
    if way == "qtconf":
        # Load system qt plugins
        # for activate this you must call main script with
        # PYSIDE_DISABLE_INTERNAL_QT_CONF=1
        if get_desktop_environment() == "kde":
            # self.logger.info("You are using KDE")
            try:
                # self.logger.debug("Try to load custom qt.conf resource")
                import prettyetc_qt.components.widgets.qt_conf_rc as _  # pylint: disable=C0415
            except ImportError:
                pass
                # self.logger.debug("Failed to load custom qt.conf resource")
            else:
                pass
                # qfile = QFile(":/qt/etc/qt.conf")
                # qfile.open(QIODevice.OpenModeFlag(0x0011))
                # print(qfile.readAll())

    elif way == "qpluginloader":
        # from PySide2.QtWidgets import QStyleFactory
        if get_desktop_environment() == "kde":
            loader = QPluginLoader(
                "/usr/lib/x86_64-linux-gnu/qt5/plugins/styles/breeze.so")
            loader.load()


def tr(*args):
    """Shortcut for QApplication.translate."""
    return QApplication.translate(*args)


def get_main_window() -> QMainWindow:
    """Get instance of QtWidgets.QMainWindow from QApplication instance."""
    app = QApplication.instance()
    for widget in app.topLevelWidgets():
        if isinstance(widget, QMainWindow):
            return widget
    return None


def to_action(widget: QWidget) -> QWidgetAction:
    """Wrap a QWidget in a QWidgetAction."""
    parent = widget.parent()
    action = QWidgetAction(parent)
    action.setDefaultWidget(widget)

    return action


def show_tooltip(widget: QWidget, text: str, timeout: int = 5):
    """
    Show a tooltip in given widget that shows given text.
    :param int timeout: unshow automatically the tooltip after seconds
                        If timeout is None, the tooltip never unshow.
    """
    QToolTip.showText(
        widget.mapToGlobal(QPoint()),
        text,
    )
    if timeout is not None:
        threading.Timer(timeout, QToolTip.hideText)


def replace_widget(layout: QLayout, old: QWidget, new: QWidget) -> QWidget:
    """Replace old widget in layout with a new widget."""
    if old is not None:
        layout.replaceWidget(old, new)
        old.setParent(None)
    return new


def tranfer_properties(src: QObject,
                       dst: QObject,
                       exclude: tuple = (),
                       include: tuple = ()) -> list:
    """
    Try to tranfer all properties from source object to another.

    Due to static C++ nature of Qt, this function can broke the object,
    or segfault the program.

    Return the tranfered properties.
    """
    attrames = []
    if isinstance(dst, type(src)):

        attrs = dir(src)
        for name in attrs:
            if name.startswith("set"):
                attrname = name[3:]
                attrname = attrname[0].lower() + attrname[1:]
                if attrname in attrs and attrname not in exclude and (
                        not include or attrname in include):
                    getter = getattr(src, attrname, None)
                    if getter is None:
                        getter = getattr(
                            src, "is" + attrname[0].upper() + attrname[1:],
                            None)
                    setter = getattr(dst, name, None)
                    if callable(getter) and callable(setter):
                        try:
                            setter(getter())
                        except Exception as ex:  # pylint: disable=W0703
                            pass
                        else:
                            attrames.append(attrname)

    return attrames
