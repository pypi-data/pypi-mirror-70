# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['garnet',
 'garnet.callbacks',
 'garnet.events',
 'garnet.filters',
 'garnet.functions',
 'garnet.helpers',
 'garnet.router',
 'garnet.storages']

package_data = \
{'': ['*']}

install_requires = \
['Telethon>=1.10.8,<2.0.0']

extras_require = \
{'orjson': ['orjson>=2.6.3,<3.0.0'],
 'redis': ['aioredis>=1.3.1,<2.0.0'],
 'ujson': ['ujson>=2.0.3,<3.0.0']}

setup_kwargs = {
    'name': 'telegram-garnet',
    'version': '0.3.0',
    'description': 'Garnet - cool add-on for Telethon',
    'long_description': 'Garnet\n===========\n\nGarnet ‚Äî bot-friendly telethon\n********************************\n\n.. invisible-content-till-nel\n.. _aioredis: https://github.com/aio-libs/aioredis\n.. _cryptg: https://pypi.org/project/cryptg/\n.. _telethon: https://pypi.org/project/Telethon/\n.. _orjson: https://pypi.org/project/orjson/\n.. _ujson: https://pypi.org/project/ujson/\n.. _hachoir: https://pypi.org/project/hachoir/\n.. _aiohttp: https://pypi.org/project/aiohttp/\n.. _Alex: https://github.com/JrooTJunior\n\n.. image:: https://raw.githubusercontent.com/uwinx/garnet/master/static/pomegranate.jpg\n\n\n************\nInstallation\n************\n\n    pip install telegram-garnet\n\n\n^^^^^^^\nExtras\n^^^^^^^\n- ``aioredis`` - redis driver required if you\'re using RedisStorage* aioredis_\n- ``orjson`` or ``ujson`` - RedisStorage/JSONStorage not required at all (ser/deser)ialization orjson_ ujson_\n\n\n****************************\nüåö üåù FSM-Storage types\n****************************\n\n\n- File - json storage, the main idea behind JSON storage is a custom reload of file and usage of memory session for writing, so the data in json storage not always actual\n\n- Memory - powerful in-memory map<str> based storage, only thing - not persistent\n\n- Redis - (requires aioredis_) - redis is fast key-value storage, if you\'re using your data is durable and persistent\n\n\nPomegranate implements updates dispatching and checks callback\'s filters wrapping all callbacks into ``garnet::Callback`` object\n\n***********************\nüòã Filters\n***********************\n\n``Filter`` object is the essential part of Pomegranate, the do state checking and other stuff.\n\nBasically, it\'s ``func`` from ``MyEventBuilder(func=lambda self: <bool>)`` but a way more complicated and not stored in EventBuilder, it\'s stored in callback object\n\n\nFilters support bitwise operations ::\n\n    # & (conjunction), | (disjunction), ~ (inversion), ^ (exclusive disjunction)\n    # also: ==, != (idk why)\n    @bot.on(MessageText.exact(".") | MessageText.exact(".."))\n\n\n^^^^^^^^^^^^^^^^^^^^^^^\nüì® Messages\n^^^^^^^^^^^^^^^^^^^^^^^\n\n`Following examples will include pattern`\n\n\n.. code:: python\n\n    from garnet import MessageText, TelegramClient\n    bot = TelegramClient.from_env().start_as_bot()\n\n    # // our code here //\n\n    bot.run_until_disconnected()\n\n.. code:: python\n\n    # handling /start and /help\n    @bot.on(MessageText.commands("help", "start"))\n    async def cmd_handler(message: custom.Message):\n        await message.reply("Hey there!")\n\n    # handling exact words\n    my_secret = "abcxyz"\n    @bot.on(MessageText.exact(my_secret))\n    async def secret_handler(message: custom.Message):\n        await message.reply("Secret entered correctly! Welcome!")\n\nMessageText or text(``from garnet import text``) includes following comparisons all returning <bool>\n - ``.exact(x)`` -> ``event.raw_text == x``\n - ``.commands(*x)`` -> ``event.raw_text.split()[0][1:] in x``\n - ``.match(x)`` -> ``re.compile(x).match(event.raw_text)``\n - ``.between(*x)`` -> ``event.raw_text in x``\n - ``.isdigit()`` -> ``(event.raw_text or "").isdigit()``\n - ``.startswith(x)`` -> ``event.raw_text.startswith(x)``\n\n\n``Len`` attribute in ``MessageText`` which has cmp methods::\n\n\n    @bot.on((MessageText.Len <= 14) | (MessageText.Len >= 88))\n\n\n\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nüëÄ CurrentState class\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n``from garnet import CurrentState``\n\n\nOnce great minds decided that state checking will be in filters without adding ``state`` as handler decorator parameter and further storing state in ``callback.(arg)``\n``CurrentState`` class methods return ``Filter``. There are two problems that Filter object really solves, ``Filter``\'s function can be any kind of callable(async,sync), filters also have a flag ``requires_context``, FSMProxy is passed if true\n\nSee `FSM example <https://github.com/uwinx/garnet/blob/master/examples/fsm.py>`_ to understand how CurrentState works\n\nIncludes following methods all returning <bool>\n - ``.exact(x)`` or ``CurrentState == x`` -> ``await context.get_state() == x``\n - ``CurrentState == [x, y, z]`` -> ``await context.get_state() in [x, y, z]``\n - ``CurrentState == all`` or ``CurrentState == any`` -> ``await context.get_state() is not None``\n\n^^^^^^^^^^^^^^^^^^^^^^^^^^^\nü¶î Custom Filter\n^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf you want to write your own filter, do it.\n\n\n.. code:: python\n\n    from garnet import Filter, FSMProxy\n\n    async def myFunc(event): ...\n    async def myFuncContextRequires(event, context: FSMProxy): ...\n    def normal_func(event): ...\n\n    @bot.on(Filter(normal_func), Filter(myFunc), Filter(myFuncContextRequires, requires_context=True))\n    async def handler(event, context: FSMProxy): ...\n    # same as\n    @bot.on(normal_func, myFunc, Filter(myFuncContextRequires, requires_context=True))\n    async def handler(event): ...\n\nSo the handler can take strict ``context`` argument and also ignore it\n\n^^^^\nAlso\n^^^^\n\nThere\'re file extension filters in ``garnet.filters.file_ext::File``, import as ``from garnet.filters import File``\n\nSome of filters are ported from ``telethon.utils`` as ``File.is_gif``, ``Filter.is_audio``, ``Filter.is_image``, ``Filter.is_video``\n\nAnd bunch of file extensions such as ``File.png``, ``File.ogg`` which are filters.\n\n\n*****************************\nOn start|finish|background\n*****************************\n\n``garnet::TelegramClient`` contains three lists on_start on_background and on_finish, their instance is ``PseudoFrozenList`` which freezes at calling ``.run_until_disconnected``\n``PseudoFrozenList`` has three main methods::\n\n    .append(*items)\n    .remove(*items)\n    .freeze()\n    .__call__() => (func) => (wrapped_func)   # for shiny decorator\n\n``items`` in case of TelegramClient means unpacked container of async-defined functions taking on position arguments\n\n**Usage:**\n\n\n.. code-block:: python\n\n    # my_module.py\n    class MyPostgresDatabase:\n        ...\n        async def close_pool(self, bot): await self.pool.safe_close()\n        async def open_pool(self, bot): await self.pool.open_conn_pool()\n\n    # garnethon.py\n    from garnet import TelegramClient\n    from my_module import MyPostgresDatabase\n\n    db = MyPostgresDatabase()\n    bot = TelegramClient.from_env().start_as_bot()\n    bot.on_start.append(db.open_pool)\n    bot.on_finish.append(db.close_pool)\n    ...\n\n    @bot.on_background()\n    async def xyz(cl: TelegramClient):\n        while True:\n           ...\n\n    bot.run_until_connected()\n\n\n****************************************************\nüì¶ Router and Migrating to garnet using Router\n****************************************************\n\nThink of router as just a dummy container of handlers(callbacks)\n\n`garnet::router::Router` may be helpful if you have telethon\'s `event.register` registered handlers. One thing: Router, I believe, is correct and more obvious way of registering event handlers. Example:\n\n**Migrate from telethon to garnet, also use for bot.on cases(soon better example)**\n\n.. code-block:: python\n\n    # my_handlers.py\n\n    # telethon register(bad) will raise Warning in garnet\n    from telethon import events\n\n    @events.register(event_type)\n    async def handler(event): ...\n\n    # garnet\'s telethon-like router\n    from garnet.router import TelethonRouter\n\n    router = TelethonRouter()\n\n    @router(event_type)\n    async def handler(event): ...\n\n\n\nThe advantage of routers is evidence of registering handlers when you have module-separated handlers. `events.register` was doing well, but blindly importing modules to register handlers and don\'t use them(modules) doesn\'t seem like a good idea.\n\n**Example of registering router in bot application**\n\n.. code-block:: python\n\n    # handlers/messages.py\n    from garnet.router import Router\n\n    router = Router()\n\n    @router()\n    async def handler(event): ...\n\n    # handlers/cb_query.py\n    from garnet.events import CallbackQuery\n    from garnet.router import Router\n\n    router = Router()\n\n    @router(event=CallbackQuery())\n    async def handler(event): ...\n\n    # entry.py ()\n    from garnet import TelegramClient\n\n    from handlers import messages, cb_query\n\n    tg = TelegramClient.from_env().start_as_bot()\n    tg.bind_routers(messages, cb_query)\n    ...\n\n``TelethonRouter`` and ``Router`` both have following methods:\n\n::\n\n    .message_handler(*filters)\n    .callback_query_handler(*filters)\n    .chat_action_handler(*filters)\n    .message_edited_handler(*filters)\n    .album_handler(*filters)\n\n*********************\nüç¨ Context magic\n*********************\n\nOne of the sweetest parts of garnet. Using `contextvars` we reach incredibly beautiful code :D\n*this is not FSMContext don\'t confuse with context magic provided by contextvars*\n\nAs an example, bot that doesn\'t requires `TelegramClient` to answer messages directly.\n\n.. code-block:: python\n\n    from garnet.functions.messages import reply, message, respond\n\n    @bot.message_handler()\n    async def handler():\n        # message() - function to get current Message event\n        await message().respond("ok")\n        await message().reply("ok")\n        # the same result, but shortcuts\n        await respond("ok")\n        await reply("Ok")\n\n\n``garnet.functions.messages`` contains ``current`` class with handy shortcuts:\n\n.. code-block:: python\n\n    from garnet.functions.messages import current\n\n    current.text  # raw text\n    current.fmt_text  # formatted text according to default parse mode\n    current.chat  # current chat\n    current.chat_id  # current chat identifier\n\n\n******************\nWhat\'s more ‚ùì\n******************\n\n1. ``garner.client::TelegramClient.conf`` is an attribute for your stuff you should share "globally". Be careful using it.\n\n\n\n2. Garnet can patch ``TLRequest.__await__`` method. To do something like:\n\n.. code-block:: python\n\n    from garnet.patch_tl_methods import install\n    from telethon.tl.functions.users import GetUsersRequest\n\n    install()\n\n    for user in await GetUsersRequest(["martin_winks", "YOURUSERNAME"]):\n        print(user.username)\n\n\nJust to have fun with debugging something with raw API.\n\n*******************\nContacts/Community\n*******************\n\nYou can find me on telegram by `@martin_winks <https://telegram.me/martin_winks>`_\n\nOur small telegram `group <https://t.me/joinchat/B2cC_hknbKGm3_G8N9qifQ>`_\n\n**********************\nü§ó Credits\n**********************\n\nFinite-state machine was ported from cool BotAPI library \'aiogram\', special thanks to Alex_\n\nSupport lonamiwebs: `lonamiwebs <http://paypal.me/lonamiwebs>`_\n\nSupport aiogram project: `JRootJunior <https://opencollective.com/aiogram/organization/0/website>`_\n',
    'author': 'Martin Winks',
    'author_email': 'cat@snejugal.ru',
    'maintainer': None,
    'maintainer_email': None,
    'url': 'https://github.com/uwinx/garnet',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'extras_require': extras_require,
    'python_requires': '>=3.7,<4.0',
}


setup(**setup_kwargs)
