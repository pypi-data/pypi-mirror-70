# Version stamping package

A simple package for auto increasing version numbers of any application agnostic to language or architecture. This package comes with three utilities:

* `ver-stamp`
* `goto-version`
* `get-version`


`ver-stamp` is fully compliant with https://semver.org semantics

## Usage

<u>First thing first</u>

```sh
mkdir remote_versions
cd remote_versions
git init
cd ..
git clone ./remote_versions/ ./versions

export VER_STAMP_VERSIONS_PATH=${PWD}/versions
```

We've created a `versions` repository where all of `our_project` versioning history will be saved.

### ver-stamp

Say that we have our project stored at a `git` repository called `our_project` and it's path is `/path/to/our_repos/our_project`

* Run the following command:

```sh
export REPOS_PATH=/path/to/our_repos

ver-stamp --repos_path ${REPOS_PATH} \
--app_version_file ${VER_STAMP_VERSIONS_PATH}/some_path/version.py \
--release_mode patch \
--app_name our_project
```

The `ver-stamp` tool will create the `version.py` file inside the `versions` repository and make the necessary commits to the `versions` repository. 

`--release_mode` can be one of `micro`, `patch`, `minor` or `major`

**Illustration:**

![ver_stamp](https://user-images.githubusercontent.com/5350434/71528249-ab04db00-28e7-11ea-9226-c3c50aa49b62.jpg)


A typical contents of the `version.py` file would be:

```python
# Autogenerated by version stamper. Do not edit
name = "our_project"
_version = "0.0.1.0"
template = "{0}.{1}.{2}"
version = "0.0.1"
release_mode = "patch"
changesets = {"our_project": {"hash": "74c2c20aa5025e2ab3cf9ab046e67403df7cb124", "vcs_type": "git"}}
```

That's it! Enjoy stamping :)

### goto-version
This utility is made for going back to a specific version. Think of it as `git checkout <tag>` for more than one repository.
Sometimes, beside `our_project`'s repository, `our_project` can depend on other repositories as well. And this is where this utility can be handy.

```sh
goto-version --repos_path ${REPOS_PATH} --app_name our_project --app_version 2.0.3.4
```

This will pull or clone to ${REPOS_PATH} every repository that `our_project` depends on.


Now if you'd like to bring ${REPOS_PATH} back to the latest state, run `goto-version` with no arguments:

```sh
goto-version --repos_path ${REPOS_PATH}
```


### get-version

A Very simple tool for printing the latest version of any app to stdout. 

```sh
get-version --repos_path ${REPOS_PATH} --app_name our_project
```


## Advanced features

### version_info.py

By default, `ver-stamp` will assume that everything under `${REPOS_PATH}` is required by `our_project`. We may want to  specify a white list of the repositories `our_project` depends on. This is how:
Create a file named `version_info.py` under `${VER_STAMP_VERSIONS_PATH}/some_path/` (where our's version.py is)  with the following content:

```python
repos = ['our_project_repo', 'repo_a', 'repo_b']
```

Commit and push manualy to your `versions` repository

### Project of projects

`ver-stamp` supports stamping projects that are a collection of other multiple sub projects.

Assume we have a system called `our_system` that is a collection of `project_a` and `project_b`. `project_a` and `project_b` have both versions of their own. We want to be able to advance `our_system`'s version every time `project_a` or `project_b` version is advanced.

Run:

```sh
ver-stamp --repos_path ${REPOS_PATH} \
--app_version_file ${VERSIONS_PATH}/our_system/project_a/version.py \
--app_name project_a \
--root_app_path ${VERSIONS_PATH}/our_system/main_version.py \
--release_mode patch
```

Now a new file, `main_version.py`, will be generated, committed and pushed along with the `version.py` file.

A typical contents of the `main_version.py` file would be:

```python
# Autogenerated by version stamper. Do not edit
name = "our_system"
build_num = "1"
version = "19.03.1"
services = {
"project_a": {"path": "/our_system/project_a/version.py", "version": "0.0.1.0"}}
external_services = {
}
```



#### Couple of notes:

1. The `version` field is generated by the following format: `YY.MM.BUILD_NUM`

2. `external_services` can be specified manually by committing to `versions` repository.



### Concurrent builds

`ver-stamp`  supports simultaneous builds. You can safely run multiple instances of `ver-stamp`



## Installation

```sh
pip3 install version-stamp
```

## Why `ver-stamp` is agnostic to application language?
It is the application's reposibility to actualy set the version number that is in the `version.py` file to the application's code during its build phase. 


## Contributing

If you want to contribute to version-stamp development:

1. Make a fresh fork of `ver_stamp` repository

2. Test your work

4. Pull Request

This project is just a small side project that I've started, decided to share it. We'll see if it will ramp up.

We will thank you for every contribution :)
