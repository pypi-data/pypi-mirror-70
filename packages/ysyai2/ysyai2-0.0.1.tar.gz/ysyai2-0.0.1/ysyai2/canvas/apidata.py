# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/05_canvas.apidata.ipynb (unless otherwise specified).

__all__ = ['__all__', 'chunk', 'CanvasApiData', 'CanvasDataStore']

# Cell
import requests_async as requests
from ..cache import *
from .refresh import RefreshHandler
import asyncio
import itertools
import random

# Cell
__all__=['chunk','CanvasApiData','CanvasDataStore']

# Cell
def chunk(l, n):
    "split list `l` to `n` lists"
    n = max(1, n)
    return (l[i:i+n] for i in range(0, len(l), n))

# Cell
class CanvasApiData():
    "Base class to handle the query to Canvas endpoints. It also handles parrel query"
    def __init__(self, url, headers, num_workers, page_num=100)->'CanvasDataset':
        self.url,self.headers,self.num_workers,self.page_num=url,headers,num_workers,page_num

    @classmethod
    def from_token(cls, url, token, num_workers, page_num=100):
        "init the `CanvasApiData` object"
        headers={'Authorization': f'Bearer {token}'}
        return cls(url,headers,num_workers,page_num)


    async def parallel_query_data(self, api_url, type='noraw', ids1=[], pagination=True, payload=None):
        "perform parallel query by `num_workers` workers"
        if len(ids1)==0:
            ids1_parts=[[]]
        else:
            size=int(len(ids1)/(self.num_workers-1))
            ids1_parts=list(chunk(ids1,size))

        if payload is None:
            query_tasks=[asyncio.ensure_future(self.get_data_payload(api_url, single_ids,pagination,i)) for i, single_ids in enumerate(ids1_parts)]
        elif type=='noraw':
            query_tasks=[asyncio.ensure_future(self.get_data_payload(api_url,single_ids,pagination,payload,i)) for i, single_ids in enumerate(ids1_parts)]
        elif type=='raw':
            query_tasks=[asyncio.ensure_future(self.get_data_payload(api_url,single_ids,pagination,payload,i,resp_type='raw')) for i, single_ids in enumerate(ids1_parts)]

        res_aggr=await asyncio.gather(*query_tasks)
        res=list(itertools.chain.from_iterable(res_aggr))
        return res


    async def get_data_payload(self, api_url, ids1=[],pagination=True,payload=None,thread_num=0,resp_type='noraw'):
        "implement https get request to Canvas endpoints"
        if(len(ids1)!=0):
            print(f'Thread {thread_num} for {api_url} starts at id {ids1[0]}')
        else:
            print(f'Thread {thread_num} for {api_url} starts')

        rs=[]

        if(len(ids1)==0): urls=[self.url+api_url+'?per_page='+str(self.page_num)]
        else:
            urls=[(self.url+api_url+'?per_page='+str(self.page_num)).format(id) for id in ids1]
        for url in urls:
            #print(url)
            if(pagination==True):
                r=await requests.get(url,headers=self.headers,params=payload)
                if resp_type=='noraw':
                    r_raw=r.json()
                elif resp_type=='raw':
                    r_raw=r.text
                else:
                    r_raw=r.text
                rs+=r_raw
                i=0
                while(len(r_raw)!=0):
                    #reach the last page
                    if('next' not in r.links):
                        break
                    r=await requests.get(r.links['next']['url'],headers=self.headers,params=payload)
                    if resp_type=='noraw':
                        r_raw=r.json()
                    elif resp_type=='raw':
                        r_raw=r.text
                    else:
                        r_raw=r.text
                    rs+=r_raw
                    i=i+1
                    if(i%10==0):print(f'Thread {thread_num} API call {api_url} has returned {i*100} rows')
                    #if(i%2==0):print(f'Thread {thread_num} API call {api_url} has returned {i*100} rows')
            else:
                r=await requests.get(url,headers=self.headers,params=payload)
                #print(r.text)
                if resp_type=='noraw':
                    r_raw=r.json()
                elif resp_type=='raw':
                    r_raw=r.text
                else:
                    r_raw=r.text
                rs+=r_raw

        print(f'Thread {thread_num} for {api_url} finishes')
        #print(rs)
        return rs

    async def get_ids(self, api_url, cname, ids1=[], pagination=True):
        "implement https get request to retrieve ids only"
        r=await self.get_data_from_ids(api_url, ids1, pagination)
        return [row[cname] for row in r]

# Cell
class CanvasDataStore(CanvasApiData):
    "Class to retrieve data from Canvas endpoints and store locally as binary `json` files using `Pickle`"
    def __init__(self,cache,api_dict=None,**kwargs):
        super().__init__(**kwargs)
        self.api_dict=api_dict if api_dict else {}
        self.cache=cache

    @classmethod
    def from_token(cls,cache,token,api_dict=None,**kwargs):
        "init CanvasDataStore object"
        headers={'Authorization': f'Bearer {token}'}
        return cls(cache,api_dict,headers=headers,**kwargs)


    async def refresh_data(self):
        "perform https requests to Canvas endpoints"
        courseid_list=self.get_courseids()
        random.shuffle(courseid_list)
        refresh_handler=RefreshHandler(learn_data=self,cache=self.cache,courseid_list=courseid_list)

        for obj_name, obj_val in self.api_dict.items():
            api_string=obj_val['url']
            api_type=obj_val['type']
            r=await refresh_handler.handle(api_type,api_string,obj_name,obj_val)

    async def test_refresh_data(self):
        "process a small number of reqeusts, only for test purpose"
        courseid_list=self.get_courseids_sample()
        #random.seed(42)
        random.shuffle(courseid_list)
        refresh_handler=RefreshHandler(learn_data=self,cache=self.cache,courseid_list=courseid_list)

        for obj_name, obj_val in self.api_dict.items():
            api_string=obj_val['url']
            api_type=obj_val['type']
            r=await refresh_handler.handle(api_type,api_string,obj_name,obj_val)

    def load_obj(self,obj_name):
        "load the json object from cache to memory"
        obj=self.cache.load(obj_name)
        return obj

    def get_courseids(self):
        "return the list of course id"
        r=self.load_obj('courses')
        cids=[c['id'] for c in r]
        return cids

    def get_courseids_sample(self):
        "return the sample list of course id, only for test purpose"
        r=self.load_obj('courses')
        cids=[c['id'] for c in r]
        return cids[:50]

    def get_userids(self):
        "return the list of user id"
        r=self.load_obj('users')
        uids=[u['id'] for u in r]
        return uids

    def get_assignments(self):
        "return assignment json object"
        r=self.load_obj('assignments')
        return r

    def get_enrollments(self):
        "return enrollments json object"
        r=self.load_obj('enrollments')
        return r

    def get_quizzes(self):
        "return quizzes json object"
        r=self.load_obj('quizzes')
        return r